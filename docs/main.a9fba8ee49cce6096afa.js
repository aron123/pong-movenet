(self.webpackChunkpong_posenet=self.webpackChunkpong_posenet||[]).push([[179],{255:e=>{function t(e){return Promise.resolve().then(()=>{var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t})}t.keys=()=>[],t.resolve=t,t.id=255,e.exports=t},394:function(){(function(){"use strict";var e;function t(e){var t=0;return function(){return t<e.length?{done:!1,value:e[t++]}:{done:!0}}}var n,r="function"==typeof Object.defineProperties?Object.defineProperty:function(e,t,n){return e==Array.prototype||e==Object.prototype||(e[t]=n.value),e},s=function(e){e=["object"==typeof globalThis&&globalThis,e,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof global&&global];for(var t=0;t<e.length;++t){var n=e[t];if(n&&n.Math==Math)return n}throw Error("Cannot find global object")}(this);function o(e,t){if(t)e:{var n=s;e=e.split(".");for(var o=0;o<e.length-1;o++){var i=e[o];if(!(i in n))break e;n=n[i]}(t=t(o=n[e=e[e.length-1]]))!=o&&null!=t&&r(n,e,{configurable:!0,writable:!0,value:t})}}function i(e){return(e={next:e})[Symbol.iterator]=function(){return this},e}function a(e){var n="undefined"!=typeof Symbol&&Symbol.iterator&&e[Symbol.iterator];return n?n.call(e):{next:t(e)}}function u(e){if(!(e instanceof Array)){e=a(e);for(var t,n=[];!(t=e.next()).done;)n.push(t.value);e=n}return e}if(o("Symbol",function(e){function t(e,t){this.g=e,r(this,"description",{configurable:!0,writable:!0,value:t})}if(e)return e;t.prototype.toString=function(){return this.g};var n="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",s=0;return function e(r){if(this instanceof e)throw new TypeError("Symbol is not a constructor");return new t(n+(r||"")+"_"+s++,r)}}),o("Symbol.iterator",function(e){if(e)return e;e=Symbol("Symbol.iterator");for(var n="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),o=0;o<n.length;o++){var a=s[n[o]];"function"==typeof a&&"function"!=typeof a.prototype[e]&&r(a.prototype,e,{configurable:!0,writable:!0,value:function(){return i(t(this))}})}return e}),"function"==typeof Object.setPrototypeOf)n=Object.setPrototypeOf;else{var l;e:{var c={};try{c.__proto__={a:!0},l=c.a;break e}catch(V){}l=!1}n=l?function(e,t){if(e.__proto__=t,e.__proto__!==t)throw new TypeError(e+" is not extensible");return e}:null}var h=n;function d(){this.l=!1,this.i=null,this.h=void 0,this.g=1,this.s=this.m=0,this.j=null}function p(e){if(e.l)throw new TypeError("Generator is already running");e.l=!0}function f(e,t){e.j={S:t,T:!0},e.g=e.m||e.s}function m(e,t,n){return e.g=n,{value:t}}function g(e){this.g=new d,this.h=e}function y(e,t,n,r){try{var s=t.call(e.g.i,n);if(!(s instanceof Object))throw new TypeError("Iterator result "+s+" is not an object");if(!s.done)return e.g.l=!1,s;var o=s.value}catch(i){return e.g.i=null,f(e.g,i),x(e)}return e.g.i=null,r.call(e.g,o),x(e)}function x(e){for(;e.g.g;)try{var t=e.h(e.g);if(t)return e.g.l=!1,{value:t.value,done:!1}}catch(n){e.g.h=void 0,f(e.g,n)}if(e.g.l=!1,e.g.j){if(t=e.g.j,e.g.j=null,t.T)throw t.S;return{value:t.return,done:!0}}return{value:void 0,done:!0}}function b(e){this.next=function(t){return p(e.g),e.g.i?t=y(e,e.g.i.next,t,e.g.o):(e.g.o(t),t=x(e)),t},this.throw=function(t){return p(e.g),e.g.i?t=y(e,e.g.i.throw,t,e.g.o):(f(e.g,t),t=x(e)),t},this.return=function(t){return function(e,t){p(e.g);var n=e.g.i;return n?y(e,"return"in n?n.return:function(e){return{value:e,done:!0}},t,e.g.return):(e.g.return(t),x(e))}(e,t)},this[Symbol.iterator]=function(){return this}}function v(e,t){return t=new b(new g(t)),h&&e.prototype&&h(t,e.prototype),t}d.prototype.o=function(e){this.h=e},d.prototype.return=function(e){this.j={return:e},this.g=this.s};var w="function"==typeof Object.assign?Object.assign:function(e,t){for(var n=1;n<arguments.length;n++){var r=arguments[n];if(r)for(var s in r)Object.prototype.hasOwnProperty.call(r,s)&&(e[s]=r[s])}return e};o("Object.assign",function(e){return e||w}),o("Promise",function(e){function t(e){this.h=0,this.i=void 0,this.g=[],this.o=!1;var t=this.j();try{e(t.resolve,t.reject)}catch(n){t.reject(n)}}function n(){this.g=null}function r(e){return e instanceof t?e:new t(function(t){t(e)})}if(e)return e;n.prototype.h=function(e){if(null==this.g){this.g=[];var t=this;this.i(function(){t.l()})}this.g.push(e)};var o=s.setTimeout;n.prototype.i=function(e){o(e,0)},n.prototype.l=function(){for(;this.g&&this.g.length;){var e=this.g;this.g=[];for(var t=0;t<e.length;++t){var n=e[t];e[t]=null;try{n()}catch(r){this.j(r)}}}this.g=null},n.prototype.j=function(e){this.i(function(){throw e})},t.prototype.j=function(){function e(e){return function(r){n||(n=!0,e.call(t,r))}}var t=this,n=!1;return{resolve:e(this.B),reject:e(this.l)}},t.prototype.B=function(e){if(e===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(e instanceof t)this.D(e);else{e:switch(typeof e){case"object":var n=null!=e;break e;case"function":n=!0;break e;default:n=!1}n?this.A(e):this.m(e)}},t.prototype.A=function(e){var t=void 0;try{t=e.then}catch(n){return void this.l(n)}"function"==typeof t?this.F(t,e):this.m(e)},t.prototype.l=function(e){this.s(2,e)},t.prototype.m=function(e){this.s(1,e)},t.prototype.s=function(e,t){if(0!=this.h)throw Error("Cannot settle("+e+", "+t+"): Promise already settled in state"+this.h);this.h=e,this.i=t,2===this.h&&this.C(),this.u()},t.prototype.C=function(){var e=this;o(function(){if(e.v()){var t=s.console;void 0!==t&&t.error(e.i)}},1)},t.prototype.v=function(){if(this.o)return!1;var e=s.CustomEvent,t=s.Event,n=s.dispatchEvent;return void 0===n||("function"==typeof e?e=new e("unhandledrejection",{cancelable:!0}):"function"==typeof t?e=new t("unhandledrejection",{cancelable:!0}):(e=s.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection",!1,!0,e),e.promise=this,e.reason=this.i,n(e))},t.prototype.u=function(){if(null!=this.g){for(var e=0;e<this.g.length;++e)i.h(this.g[e]);this.g=null}};var i=new n;return t.prototype.D=function(e){var t=this.j();e.I(t.resolve,t.reject)},t.prototype.F=function(e,t){var n=this.j();try{e.call(t,n.resolve,n.reject)}catch(r){n.reject(r)}},t.prototype.then=function(e,n){function r(e,t){return"function"==typeof e?function(t){try{s(e(t))}catch(n){o(n)}}:t}var s,o,i=new t(function(e,t){s=e,o=t});return this.I(r(e,s),r(n,o)),i},t.prototype.catch=function(e){return this.then(void 0,e)},t.prototype.I=function(e,t){function n(){switch(r.h){case 1:e(r.i);break;case 2:t(r.i);break;default:throw Error("Unexpected state: "+r.h)}}var r=this;null==this.g?i.h(n):this.g.push(n),this.o=!0},t.resolve=r,t.reject=function(e){return new t(function(t,n){n(e)})},t.race=function(e){return new t(function(t,n){for(var s=a(e),o=s.next();!o.done;o=s.next())r(o.value).I(t,n)})},t.all=function(e){var n=a(e),s=n.next();return s.done?r([]):new t(function(e,t){function o(t){return function(n){i[t]=n,0==--a&&e(i)}}var i=[],a=0;do{i.push(void 0),a++,r(s.value).I(o(i.length-1),t),s=n.next()}while(!s.done)})},t}),o("Array.prototype.keys",function(e){return e||function(){return function(e,t){e instanceof String&&(e+="");var n=0,r=!1,s={next:function(){return!r&&n<e.length?{value:n++,done:!1}:(r=!0,{done:!0,value:void 0})}};return s[Symbol.iterator]=function(){return s},s}(this)}});var C=this||self;function _(e,t){e=e.split(".");var n,r=C;e[0]in r||void 0===r.execScript||r.execScript("var "+e[0]);for(;e.length&&(n=e.shift());)e.length||void 0===t?r=r[n]&&r[n]!==Object.prototype[n]?r[n]:r[n]={}:r[n]=t}function k(e,t){var n=void 0;return new(n||(n=Promise))(function(r,s){function o(e){try{a(t.next(e))}catch(n){s(n)}}function i(e){try{a(t.throw(e))}catch(n){s(n)}}function a(e){e.done?r(e.value):new n(function(t){t(e.value)}).then(o,i)}a((t=t.apply(e,void 0)).next())})}function E(e,t,n){if(n=e.createShader(0===n?e.VERTEX_SHADER:e.FRAGMENT_SHADER),e.shaderSource(n,t),e.compileShader(n),!e.getShaderParameter(n,e.COMPILE_STATUS))throw Error("Could not compile WebGL shader.\n\n"+e.getShaderInfoLog(n));return n}function S(e,t,n){this.h=e,this.g=t,this.u=n,this.l=0}function T(e){return"function"==typeof e.g.canvas.transferToImageBitmap?Promise.resolve(e.g.canvas.transferToImageBitmap()):e.u?Promise.resolve(e.g.canvas):"function"==typeof createImageBitmap?createImageBitmap(e.g.canvas):(void 0===e.j&&(e.j=document.createElement("img")),new Promise(function(t){e.j.onload=function(){requestAnimationFrame(function(){t(e.j)})},e.j.src=e.g.canvas.toDataURL()}))}function I(e,t){var n=e.g;if(void 0===e.m){var r=E(n,"\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }",0),s=E(n,"\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }",1),o=n.createProgram();if(n.attachShader(o,r),n.attachShader(o,s),n.linkProgram(o),!n.getProgramParameter(o,n.LINK_STATUS))throw Error("Could not compile WebGL program.\n\n"+n.getProgramInfoLog(o));r=e.m=o,n.useProgram(r),s=n.getUniformLocation(r,"sampler0"),e.i={H:n.getAttribLocation(r,"aVertex"),G:n.getAttribLocation(r,"aTex"),V:s},e.s=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,e.s),n.enableVertexAttribArray(e.i.H),n.vertexAttribPointer(e.i.H,2,n.FLOAT,!1,0,0),n.bufferData(n.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,null),e.o=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,e.o),n.enableVertexAttribArray(e.i.G),n.vertexAttribPointer(e.i.G,2,n.FLOAT,!1,0,0),n.bufferData(n.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,null),n.uniform1i(s,0)}r=e.i,n.useProgram(e.m),n.canvas.width=t.width,n.canvas.height=t.height,n.viewport(0,0,t.width,t.height),n.activeTexture(n.TEXTURE0),e.h.bindTexture2d(t.glName),n.enableVertexAttribArray(r.H),n.bindBuffer(n.ARRAY_BUFFER,e.s),n.vertexAttribPointer(r.H,2,n.FLOAT,!1,0,0),n.enableVertexAttribArray(r.G),n.bindBuffer(n.ARRAY_BUFFER,e.o),n.vertexAttribPointer(r.G,2,n.FLOAT,!1,0,0),n.bindFramebuffer(n.DRAW_FRAMEBUFFER?n.DRAW_FRAMEBUFFER:n.FRAMEBUFFER,null),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),n.colorMask(!0,!0,!0,!0),n.drawArrays(n.TRIANGLE_FAN,0,4),n.disableVertexAttribArray(r.H),n.disableVertexAttribArray(r.G),n.bindBuffer(n.ARRAY_BUFFER,null),e.h.bindTexture2d(0)}function N(e){this.g=e}var $=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function R(e,t){return t+e}function A(e,t){window[e]=t}function O(e){for(var t=[],n=e.size(),r=0;r<n;++r){var s=e.get(r);t.push({x:s.x,y:s.y,z:s.z,visibility:s.hasVisibility?s.visibility:void 0}),s.delete()}return t}function F(e){for(var t=[],n=e.size(),r=0;r<n;++r){var s=e.get(r);t.push({index:s.index,score:s.score,label:s.hasLabel?s.label:void 0,displayName:s.hasDisplayName?s.displayName:void 0})}return t}function D(e){if(this.g=e,this.listeners={},this.l={},this.B={},this.m={},this.s={},this.v=this.o=this.O=!0,this.F=Promise.resolve(),this.N="",this.u={},this.locateFile=e&&e.locateFile||R,"object"==typeof window)e=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else{if("undefined"==typeof location)throw Error("solutions can only be loaded on a web page or in a web worker");e=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/"}this.P=e}function P(e,t){return k(e,function e(){var n,r,s=this;return v(e,function(e){return t in s.B?e.return(s.B[t]):(n=s.locateFile(t,""),r=fetch(n).then(function(e){return e.arrayBuffer()}),s.B[t]=r,e.return(r))})})}function M(e,t){for(var n=t.name||"$",r=[].concat(u(t.wants)),s=new e.h.StringList,o=a(t.wants),i=o.next();!i.done;i=o.next())s.push_back(i.value);o=e.h.PacketListener.implement({onResults:function(s){return k(e,function e(){var o,i,u,l,c,h=this;return v(e,function(e){for(o=h,i={},u=0;u<t.wants.length;++u)i[r[u]]=s.get(u);if(l=function(e,t,n){return k(e,function e(){var r,s,o,i,u,l,c,h,d,p,f,g,y,x,b,w,C,_=this;return v(e,function(e){switch(e.g){case 1:if(!n)return e.return(t);for(r={},s=0,o=a(Object.keys(n)),i=o.next();!i.done;i=o.next())"string"!=typeof(u=n[i.value])&&"texture"===u.type&&++s;1<s&&(_.v=!1),l=a(Object.keys(n)),i=l.next();case 2:if(i.done){e.g=4;break}if("string"==typeof(h=n[c=i.value]))return w=r,C=c,m(e,function(e,t,n){return k(e,function e(){var r,s=this;return v(e,function(e){if(n.isNumber())return e.return(n.getNumber());if(n.isRect())return e.return(n.getRect());if(n.isLandmarks())return e.return(n.getLandmarks());if(n.isLandmarksList())return e.return(n.getLandmarksList());if(n.isClassificationsList())return e.return(n.getClassificationsList());if(n.isObjectDetectionList())return e.return(n.getObjectDetectionList());if(n.isTexture2d()){(r=s.s[t])||(r=new S(s.h,s.A,s.v),s.s[t]=r);var o=e.return,i=r;return I(i,n.getTexture2d()),i=T(i),o.call(e,i)}return e.return(void 0)})})}(_,c,t[h]),15);if(void 0===(d=t[h.stream])){e.g=3;break}if("detection_list"===h.type){var E=d.getRectList(),N=d.getLandmarksList(),$=d.getClassificationsList(),R=[];if(E)for(var A=0;A<E.size();++A){var D={R:E.get(A),M:O(N.get(A)),L:F($.get(A))};R.push(D)}r[c]=R,e.g=7;break}if("landmarks"===h.type){p=d.getLandmarks(),r[c]=p?O(p):void 0,e.g=7;break}if("landmarks_list"===h.type){if(f=d.getLandmarksList())for(E=[],N=f.size(),$=0;$<N;++$)R=f.get($),E.push(O(R)),R.delete();else E=void 0;r[c]=E,e.g=7;break}if("rect_list"===h.type){if(g=d.getRectList())for(E=[],N=g.size(),$=0;$<N;++$)R=g.get($),E.push(R);else E=void 0;r[c]=E,e.g=7;break}if("classifications_list"===h.type){if(y=d.getClassificationsList())for(E=[],N=y.size(),$=0;$<N;++$)R=y.get($),E.push(F(R));else E=void 0;r[c]=E,e.g=7;break}if("object_detection_list"===h.type){if(x=d.getObjectDetectionList())for(E=[],N=x.size(),$=0;$<N;++$){R=x.get($),D=(A=E).push;for(var P=R.id,M=R.keypoints,L=[],B=M.size(),V=0;V<B;++V){var U=M.get(V);L.push({id:U.id,point3d:{x:U.point3d.x,y:U.point3d.y,z:U.point3d.z},point2d:{x:U.point2d.x,y:U.point2d.y,depth:U.point2d.depth}})}D.call(A,{id:P,keypoints:L,visibility:R.visibility})}else E=void 0;r[c]=E,e.g=7;break}if("texture"!==h.type)throw Error("Unknown output config type: '"+h.type+"'");return(b=_.s[c])||(b=new S(_.h,_.A,_.v),_.s[c]=b),I(E=b,N=d.getTexture2d()),m(e,E=T(E),14);case 14:r[c]=e.h;case 7:h.transform&&r[c]&&(r[c]=h.transform(r[c])),e.g=3;break;case 15:w[C]=e.h;case 3:i=l.next(),e.g=2;break;case 4:return e.return(r)}})})}(h,i,t.outs),c=h.listeners[n])return e.return(h.F.then(function(){return l}).then(function(e){return k(o,function n(){var s,o,a=this;return v(n,function(n){for(s=c(e),o=0;o<t.wants.length;++o)i[r[o]].delete();if(s)return a.F=s,n.return(s);n.g=0})})}));e.g=0})})}}),e.i.attachMultiListener(s,o),s.delete()}function L(e){switch(void 0===e&&(e=0),e){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function B(e){var t=this;this.g=new D({locateFile:(e=e||{}).locateFile,files:function(e){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:L(e.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","image_transformed"],outs:{image:"image_transformed",poseLandmarks:{type:"landmarks",stream:"pose_landmarks"},poseWorldLandmarks:{type:"landmarks",stream:"world_landmarks"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{selfieMode:{type:1,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(e){return k(t,function t(){var n,r,s=this;return v(t,function(t){return 1==t.g?(n=L(e),r="third_party/mediapipe/modules/pose_landmark/"+n,m(t,P(s.g,n),2)):(s.g.overrideFile(r,t.h),t.return(!0))})})}},smoothLandmarks:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},minDetectionConfidence:{type:0,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:0,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__poselandmarkbyroipostprocessing__ThresholdingCalculator",fieldName:"threshold"}}}})}(e=D.prototype).close=function(){return this.i&&this.i.delete(),Promise.resolve()},e.reset=function(){return k(this,function e(){var t=this;return v(e,function(e){t.i&&(t.i.reset(),t.m={},t.s={}),e.g=0})})},e.setOptions=function(e){var t=this;if(this.g.options){for(var n=[],r=[],s={},o=a(Object.keys(e)),i=o.next();!i.done;s={J:s.J,K:s.K},i=o.next()){var u=i.value;(!(u in this.l)||this.l[u]!==e[u])&&(this.l[u]=e[u],i=this.g.options[u])&&(i.onChange&&(s.J=i.onChange,s.K=e[u],n.push(function(e){return function(){return k(t,function t(){var n=this;return v(t,function(t){if(1==t.g)return m(t,e.J(e.K),2);!0===t.h&&(n.o=!0),t.g=0})})}}(s))),i.graphOptionXref&&(u={valueNumber:0===i.type?e[u]:0,valueBoolean:1===i.type&&e[u]},i=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),i.graphOptionXref),u),r.push(i)))}0===n.length&&0===r.length||(this.o=!0,this.C=r,this.D=n)}},e.initialize=function(){return k(this,function e(){var t=this;return v(e,function(e){return 1==e.g?m(e,k(t,function e(){var t,n,r,s,o,i,a,l,c,h,d,p=this;return v(e,function(e){switch(e.g){case 1:return t=p,p.O?(n=function(e,t){return void 0===e.g.files?[]:"function"==typeof e.g.files?e.g.files(t):e.g.files}(p,p.l),m(e,function(){return k(this,function e(){return v(e,function(e){switch(e.g){case 1:return e.m=2,m(e,WebAssembly.instantiate($),4);case 4:e.g=3,e.m=0;break;case 2:return e.m=0,e.j=null,e.return(!1);case 3:return e.return(!0)}})})}(),2)):e.return();case 2:if(r=e.h,"object"==typeof window)return A("createMediapipeSolutionsWasm",{locateFile:p.locateFile}),A("createMediapipeSolutionsPackedAssets",{locateFile:p.locateFile}),i=n.filter(function(e){return void 0!==e.data}),a=n.filter(function(e){return void 0===e.data}),l=Promise.all(i.map(function(e){return P(t,e.url)})),c=Promise.all(a.map(function(e){return void 0===e.simd||e.simd&&r||!e.simd&&!r?function(e){var t=document.createElement("script");return t.setAttribute("src",e),t.setAttribute("crossorigin","anonymous"),document.body.appendChild(t),new Promise(function(e){t.addEventListener("load",function(){e()},!1)})}(t.locateFile(e.url,t.P)):Promise.resolve()})).then(function(){return k(t,function e(){var t,n,r=this;return v(e,function(e){if(1==e.g)return t=window.createMediapipeSolutionsWasm,n=window.createMediapipeSolutionsPackedAssets,m(e,t(n),2);r.h=e.h,e.g=0})})}),h=k(t,function e(){var t=this;return v(e,function(e){return t.g.graph&&t.g.graph.url?e=m(e,P(t,t.g.graph.url),0):(e.g=0,e=void 0),e})}),m(e,Promise.all([c,l,h]),7);if("function"!=typeof importScripts)throw Error("solutions can only be loaded on a web page or in a web worker");return s=n.filter(function(e){return void 0===e.simd||e.simd&&r||!e.simd&&!r}).map(function(e){return t.locateFile(e.url,t.P)}),importScripts.apply(null,u(s)),m(e,createMediapipeSolutionsWasm(Module),6);case 6:p.h=e.h,p.j=new OffscreenCanvas(1,1),p.h.canvas=p.j,o=p.h.GL.createContext(p.j,{antialias:!1,alpha:!1,U:"undefined"!=typeof WebGL2RenderingContext?2:1}),p.h.GL.makeContextCurrent(o),e.g=4;break;case 7:if(p.j=document.createElement("canvas"),!(d=p.j.getContext("webgl2",{}))&&!(d=p.j.getContext("webgl",{})))return alert("Failed to create WebGL canvas context when passing video frame."),e.return();p.A=d,p.h.canvas=p.j,p.h.createContext(p.j,!0,!0,{});case 4:p.i=new p.h.SolutionWasm,p.O=!1,e.g=0}})}),2):3!=e.g?m(e,k(t,function e(){var t,n,r,s,o,i,u=this;return v(e,function(e){if(1==e.g)return u.g.graph&&u.g.graph.url&&u.N===u.g.graph.url?e.return():(u.o=!0,u.g.graph&&u.g.graph.url?(u.N=u.g.graph.url,m(e,P(u,u.g.graph.url),3)):void(e.g=2));for(2!=e.g&&u.i.loadGraph(e.h),t=a(Object.keys(u.u)),n=t.next();!n.done;n=t.next())u.i.overrideFile(r=n.value,u.u[r]);if(u.u={},u.g.listeners)for(s=a(u.g.listeners),o=s.next();!o.done;o=s.next())M(u,o.value);i=u.l,u.l={},u.setOptions(i),e.g=0})}),3):m(e,k(t,function e(){var t,n,r,s,o,i=this;return v(e,function(e){switch(e.g){case 1:if(!i.o)return e.return();if(!i.D){e.g=2;break}t=a(i.D),n=t.next();case 3:if(n.done){e.g=5;break}return m(e,(0,n.value)(),4);case 4:n=t.next(),e.g=3;break;case 5:i.D=void 0;case 2:if(i.C){for(r=new i.h.GraphOptionChangeRequestList,s=a(i.C),o=s.next();!o.done;o=s.next())r.push_back(o.value);i.i.changeOptions(r),r.delete(),i.C=void 0}i.o=!1,e.g=0}})}),0)})})},e.overrideFile=function(e,t){this.i?this.i.overrideFile(e,t):this.u[e]=t},e.clearOverriddenFiles=function(){this.u={},this.i&&this.i.clearOverriddenFiles()},e.send=function(e,t){return k(this,function n(){var r,s,o,i,u,l,c,h,d,p=this;return v(n,function(n){if(1==n.g)return p.g.inputs?(r=1e3*(null==t?performance.now():t),m(n,p.F,2)):n.return();if(3!=n.g)return m(n,p.initialize(),3);for(s=new p.h.PacketDataList,o=a(Object.keys(e)),i=o.next();!i.done;i=o.next())if(l=p.g.inputs[u=i.value]){e:{var f=p,g=e[u];switch(l.type){case"video":var y=f.m[l.stream];if(y||(y=new S(f.h,f.A,f.v),f.m[l.stream]=y),0===(f=y).l&&(f.l=f.h.createTexture()),"undefined"!=typeof HTMLVideoElement&&g instanceof HTMLVideoElement){var x=g.videoWidth;y=g.videoHeight}else"undefined"!=typeof HTMLImageElement&&g instanceof HTMLImageElement?(x=g.naturalWidth,y=g.naturalHeight):(x=g.width,y=g.height);y={glName:f.l,width:x,height:y},(x=f.g).canvas.width=y.width,x.canvas.height=y.height,x.activeTexture(x.TEXTURE0),f.h.bindTexture2d(f.l),x.texImage2D(x.TEXTURE_2D,0,x.RGBA,x.RGBA,x.UNSIGNED_BYTE,g),f.h.bindTexture2d(0),f=y;break e;case"detections":for((y=f.m[l.stream])||(y=new N(f.h),f.m[l.stream]=y),(f=y).data||(f.data=new f.g.DetectionListData),f.data.reset(g.length),y=0;y<g.length;++y){if(f.data.setBoundingBox(y,(x=g[y]).R),x.M)for(var b=0;b<x.M.length;++b){var v=x.M[b],w=!!v.visibility;f.data.addNormalizedLandmark(y,Object.assign(Object.assign({},v),{hasVisibility:w,visibility:w?v.visibility:0}))}if(x.L)for(b=0;b<x.L.length;++b){var C=!!(v=x.L[b]).label,_=!!v.displayName;f.data.addClassification(y,{score:v.score,hasIndex:w=!!v.index,index:w?v.index:-1,hasLabel:C,label:C?v.label:"",hasDisplayName:_,displayName:_?v.displayName:""})}}f=f.data;break e;default:f={}}}switch(c=f,h=l.stream,l.type){case"video":s.pushTexture2d(Object.assign(Object.assign({},c),{stream:h,timestamp:r}));break;case"detections":(d=c).stream=h,d.timestamp=r,s.pushDetectionList(d);break;default:throw Error("Unknown input config type: '"+l.type+"'")}}p.i.send(s),s.delete(),n.g=0})})},e.onResults=function(e,t){this.listeners[t||"$"]=e},_("Solution",D),_("OptionType",{NUMBER:0,BOOL:1,0:"NUMBER",1:"BOOL"}),(e=B.prototype).reset=function(){this.g.reset()},e.close=function(){return this.g.close(),Promise.resolve()},e.onResults=function(e){this.g.onResults(e)},e.initialize=function(){return k(this,function e(){var t=this;return v(e,function(e){return m(e,t.g.initialize(),0)})})},e.send=function(e,t){return k(this,function n(){var r=this;return v(n,function(n){return m(n,r.g.send(e,t),0)})})},e.setOptions=function(e){this.g.setOptions(e)},_("Pose",B),_("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),_("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),_("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),_("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),_("POSE_LANDMARKS_NEUTRAL",{NOSE:0})}).call(this)},176:(e,t,n)=>{var r=n(367),s=n(171),o=n(777),i=n(887),a=n(843),u=n(709),l=n(269);l.alea=r,l.xor128=s,l.xorwow=o,l.xorshift7=i,l.xor4096=a,l.tychei=u,e.exports=l},367:function(e,t,n){var r;!function(e,s,o){function i(e){var t,n=this,r=(t=4022871197,function(e){e=e.toString();for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function a(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function u(e,t){var n=new i(e),r=t&&t.state,s=n.next;return s.int32=function(){return 4294967296*n.next()|0},s.double=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.quick=s,r&&("object"==typeof r&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=(function(){return u}).call(t,n,t,s))||(s.exports=r):this.alea=u}(0,e=n.nmd(e))},709:function(e,t,n){var r;!function(e,s,o){function i(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,s=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^s,s=s-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^s,t.a=s-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function u(e,t){var n=new i(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=(function(){return u}).call(t,n,t,s))||(s.exports=r):this.tychei=u}(0,e=n.nmd(e))},171:function(e,t,n){var r;!function(e,s,o){function i(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function u(e,t){var n=new i(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=(function(){return u}).call(t,n,t,s))||(s.exports=r):this.xor128=u}(0,e=n.nmd(e))},843:function(e,t,n){var r;!function(e,s,o){function i(e){var t=this;t.next=function(){var e,n,r=t.w,s=t.X,o=t.i;return t.w=r=r+1640531527|0,n=s[o+34&127],e=s[o=o+1&127],n^=n<<13,e^=e<<17,n=s[o]=(n^=n>>>15)^(e^=e>>>12),t.i=o,n+(r^r>>>16)|0},function(e,t){var n,r,s,o,i,a=[],u=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,u=Math.max(u,t.length)),s=0,o=-32;o<u;++o)t&&(r^=t.charCodeAt((o+32)%t.length)),0===o&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,o>=0&&(s=0==(n=a[127&o]^=r+(i=i+1640531527|0))?s+1:0);for(s>=128&&(a[127&(t&&t.length||0)]=-1),s=127,o=512;o>0;--o)r=a[s+34&127],n=a[s=s+1&127],r^=r<<13,n^=n<<17,a[s]=(r^=r>>>15)^(n^=n>>>12);e.w=i,e.X=a,e.i=s}(t,e)}function a(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function u(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.X&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=(function(){return u}).call(t,n,t,s))||(s.exports=r):this.xor4096=u}(0,e=n.nmd(e))},887:function(e,t,n){var r;!function(e,s,o){function i(e){var t=this;t.next=function(){var e,n,r=t.x,s=t.i;return e=r[s],n=(e^=e>>>7)^e<<24,n^=(e=r[s+1&7])^e>>>10,n^=(e=r[s+3&7])^e>>>3,n^=(e=r[s+4&7])^e<<7,e=r[s+7&7],r[s]=n^=(e^=e<<13)^e<<9,t.i=s+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n&&(r[7]=-1),e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function a(e,t){return t.x=e.x.slice(),t.i=e.i,t}function u(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.x&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=(function(){return u}).call(t,n,t,s))||(s.exports=r):this.xorshift7=u}(0,e=n.nmd(e))},777:function(e,t,n){var r;!function(e,s,o){function i(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function u(e,t){var n=new i(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=(function(){return u}).call(t,n,t,s))||(s.exports=r):this.xorwow=u}(0,e=n.nmd(e))},269:(e,t,n)=>{var r;!function(s,o){var i,a=this,u=256,l=o.pow(u,6),c=o.pow(2,52),h=2*c,d=255;function p(e,t,n){var r=[],d=y(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,x(s)]:null==e?function(){try{var e;return i&&(e=i.randomBytes)?e=e(u):(e=new Uint8Array(u),(a.crypto||a.msCrypto).getRandomValues(e)),x(e)}catch(r){var t=a.navigator,n=t&&t.plugins;return[+new Date,a,n,a.screen,x(s)]}}():e,3),r),p=new f(r),b=function(){for(var e=p.g(6),t=l,n=0;e<c;)e=(e+n)*u,t*=u,n=p.g(1);for(;e>=h;)e/=2,t/=2,n>>>=1;return(e+n)/t};return b.int32=function(){return 0|p.g(4)},b.quick=function(){return p.g(4)/4294967296},b.double=b,y(x(p.S),s),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,p),e.state=function(){return m(p,{})}),n?(o.random=e,t):e})(b,d,"global"in t?t.global:this==o,t.state)}function f(e){var t,n=e.length,r=this,s=0,o=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);s<u;)i[s]=s++;for(s=0;s<u;s++)i[s]=i[o=d&o+e[s%n]+(t=i[s])],i[o]=t;(r.g=function(e){for(var t,n=0,s=r.i,o=r.j,i=r.S;e--;)t=i[s=d&s+1],n=n*u+i[d&(i[s]=i[o=d&o+t])+(i[o]=t)];return r.i=s,r.j=o,n})(u)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,r=[],s=typeof e;if(t&&"object"==s)for(n in e)try{r.push(g(e[n],t-1))}catch(o){}return r.length?r:"string"==s?e:e+"\0"}function y(e,t){for(var n,r=e+"",s=0;s<r.length;)t[d&s]=d&(n^=19*t[d&s])+r.charCodeAt(s++);return x(t)}function x(e){return String.fromCharCode.apply(0,e)}if(o.seedrandom=p,y(o.random(),s),e.exports){e.exports=p;try{i=n(778)}catch(b){}}else void 0===(r=(function(){return p}).call(t,n,t,e))||(e.exports=r)}([],Math)},80:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(E){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var s={},o={};function i(e,t){var n,r,i;return t?(i=0<=(e>>>=0)&&e<256)&&(r=o[e])?r:(n=u(e,(0|e)<0?-1:0,!0),i&&(o[e]=n),n):(i=-128<=(e|=0)&&e<128)&&(r=s[e])?r:(n=u(e,e<0?-1:0,!1),i&&(s[e]=n),n)}function a(e,t){if(isNaN(e))return t?y:g;if(t){if(e<0)return y;if(e>=p)return C}else{if(e<=-f)return _;if(e+1>=f)return w}return e<0?a(-e,t).neg():u(e%d|0,e/d|0,t)}function u(e,t,r){return new n(e,t,r)}n.fromInt=i,n.fromNumber=a,n.fromBits=u;var l=Math.pow;function c(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(e.substring(1),t,n).neg();for(var s=a(l(n,8)),o=g,i=0;i<e.length;i+=8){var u=Math.min(8,e.length-i),h=parseInt(e.substring(i,i+u),n);if(u<8){var d=a(l(n,u));o=o.mul(d).add(a(h))}else o=(o=o.mul(s)).add(a(h))}return o.unsigned=t,o}function h(e,t){return"number"==typeof e?a(e,t):"string"==typeof e?c(e,t):u(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}n.fromString=c,n.fromValue=h;var d=4294967296,p=d*d,f=p/2,m=i(1<<24),g=i(0);n.ZERO=g;var y=i(0,!0);n.UZERO=y;var x=i(1);n.ONE=x;var b=i(1,!0);n.UONE=b;var v=i(-1);n.NEG_ONE=v;var w=u(-1,2147483647,!1);n.MAX_VALUE=w;var C=u(-1,-1,!0);n.MAX_UNSIGNED_VALUE=C;var _=u(0,-2147483648,!1);n.MIN_VALUE=_;var k=n.prototype;k.toInt=function(){return this.unsigned?this.low>>>0:this.low},k.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},k.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(_)){var t=a(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var s=a(l(e,6),this.unsigned),o=this,i="";;){var u=o.div(s),c=(o.sub(u.mul(s)).toInt()>>>0).toString(e);if((o=u).isZero())return c+i;for(;c.length<6;)c="0"+c;i=""+c+i}},k.getHighBits=function(){return this.high},k.getHighBitsUnsigned=function(){return this.high>>>0},k.getLowBits=function(){return this.low},k.getLowBitsUnsigned=function(){return this.low>>>0},k.getNumBitsAbs=function(){if(this.isNegative())return this.eq(_)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},k.isZero=function(){return 0===this.high&&0===this.low},k.eqz=k.isZero,k.isNegative=function(){return!this.unsigned&&this.high<0},k.isPositive=function(){return this.unsigned||this.high>=0},k.isOdd=function(){return 1==(1&this.low)},k.isEven=function(){return 0==(1&this.low)},k.equals=function(e){return r(e)||(e=h(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&this.high===e.high&&this.low===e.low},k.eq=k.equals,k.notEquals=function(e){return!this.eq(e)},k.neq=k.notEquals,k.ne=k.notEquals,k.lessThan=function(e){return this.comp(e)<0},k.lt=k.lessThan,k.lessThanOrEqual=function(e){return this.comp(e)<=0},k.lte=k.lessThanOrEqual,k.le=k.lessThanOrEqual,k.greaterThan=function(e){return this.comp(e)>0},k.gt=k.greaterThan,k.greaterThanOrEqual=function(e){return this.comp(e)>=0},k.gte=k.greaterThanOrEqual,k.ge=k.greaterThanOrEqual,k.compare=function(e){if(r(e)||(e=h(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},k.comp=k.compare,k.negate=function(){return!this.unsigned&&this.eq(_)?_:this.not().add(x)},k.neg=k.negate,k.add=function(e){r(e)||(e=h(e));var t=0,n=0,s=0,o=0;return s+=(o+=(65535&this.low)+(65535&e.low))>>>16,n+=(s+=(this.low>>>16)+(e.low>>>16))>>>16,t+=(n+=(65535&this.high)+(65535&e.high))>>>16,t+=(this.high>>>16)+(e.high>>>16),u((s&=65535)<<16|(o&=65535),(t&=65535)<<16|(n&=65535),this.unsigned)},k.subtract=function(e){return r(e)||(e=h(e)),this.add(e.neg())},k.sub=k.subtract,k.multiply=function(e){if(this.isZero())return g;if(r(e)||(e=h(e)),t)return u(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(_))return e.isOdd()?_:g;if(e.eq(_))return this.isOdd()?_:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return a(this.toNumber()*e.toNumber(),this.unsigned);var n=65535&this.high,s=this.low>>>16,o=65535&this.low,i=65535&e.high,l=e.low>>>16,c=65535&e.low,d=0,p=0,f=0,y=0;return f+=(y+=o*c)>>>16,p+=(f+=s*c)>>>16,f&=65535,p+=(f+=o*l)>>>16,d+=(p+=n*c)>>>16,p&=65535,d+=(p+=s*l)>>>16,p&=65535,d+=(p+=o*i)>>>16,d+=(this.high>>>16)*c+n*l+s*i+o*(e.high>>>16),u((f&=65535)<<16|(y&=65535),(d&=65535)<<16|(p&=65535),this.unsigned)},k.mul=k.multiply,k.divide=function(e){if(r(e)||(e=h(e)),e.isZero())throw Error("division by zero");var n,s,o;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?u((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return y;if(e.gt(this.shru(1)))return b;o=y}else{if(this.eq(_))return e.eq(x)||e.eq(v)?_:e.eq(_)?x:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?x:v:(s=this.sub(e.mul(n)),o=n.add(s.div(e)));if(e.eq(_))return this.unsigned?y:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();o=g}for(s=this;s.gte(e);){n=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),c=i<=48?1:l(2,i-48),d=a(n),p=d.mul(e);p.isNegative()||p.gt(s);)p=(d=a(n-=c,this.unsigned)).mul(e);d.isZero()&&(d=x),o=o.add(d),s=s.sub(p)}return o},k.div=k.divide,k.modulo=function(e){return r(e)||(e=h(e)),t?u((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},k.mod=k.modulo,k.rem=k.modulo,k.not=function(){return u(~this.low,~this.high,this.unsigned)},k.and=function(e){return r(e)||(e=h(e)),u(this.low&e.low,this.high&e.high,this.unsigned)},k.or=function(e){return r(e)||(e=h(e)),u(this.low|e.low,this.high|e.high,this.unsigned)},k.xor=function(e){return r(e)||(e=h(e)),u(this.low^e.low,this.high^e.high,this.unsigned)},k.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?u(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):u(0,this.low<<e-32,this.unsigned)},k.shl=k.shiftLeft,k.shiftRight=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?u(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):u(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},k.shr=k.shiftRight,k.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0==(e&=63))return this;var t=this.high;return e<32?u(this.low>>>e|t<<32-e,t>>>e,this.unsigned):u(32===e?t:t>>>e-32,0,this.unsigned)},k.shru=k.shiftRightUnsigned,k.shr_u=k.shiftRightUnsigned,k.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},k.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},k.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},k.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},k.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},339:(e,t,n)=>{"use strict";var r={};n.r(r),n.d(r,{assertParamsValid:()=>ux,computeFlatOffset:()=>wx,computeOutShape:()=>cx,getNormalizedAxes:()=>fx,isSliceContinous:()=>vx,maskToAxes:()=>lx,parseSliceParams:()=>Cx,sliceInfo:()=>_x,startForAxis:()=>xx,startIndicesWithElidedDims:()=>mx,stopForAxis:()=>bx,stopIndicesWithElidedDims:()=>gx,stridesForAxis:()=>yx,stridesWithElidedDims:()=>hx});var s={};n.r(s),n.d(s,{collectGatherOpShapeInfo:()=>Ww,computeOutShape:()=>zw,segOpComputeOptimalWindowSize:()=>Uw});var o={};n.r(o),n.d(o,{ERF_A1:()=>xw,ERF_A2:()=>bw,ERF_A3:()=>vw,ERF_A4:()=>ww,ERF_A5:()=>Cw,ERF_P:()=>yw,PARALLELIZE_THRESHOLD:()=>rw,SELU_SCALE:()=>gw,SELU_SCALEALPHA:()=>mw,applyActivation:()=>tw,assertAndGetBroadcastShape:()=>Tb,assertAxesAreInnerMostDims:()=>jb,assertParamsConsistent:()=>Ov,assignToTypedArray:()=>$w,axesAreInnerMostDims:()=>Vb,calculateShapes:()=>fw,checkEinsumDimSizes:()=>Pw,combineLocations:()=>Ub,complexWithEvenIndex:()=>Tw,complexWithOddIndex:()=>Iw,computeConv2DInfo:()=>Lv,computeConv3DInfo:()=>Bv,computeDefaultPad:()=>Vv,computeDilation2DInfo:()=>Dv,computeOptimalWindowSize:()=>sw,computeOutAndReduceShapes:()=>zb,computeOutShape:()=>Fv,computePool2DInfo:()=>Pv,computePool3DInfo:()=>Mv,convertConv2DDataFormat:()=>qv,decodeEinsumEquation:()=>Fw,eitherStridesOrDilationsAreOne:()=>Gv,expandShapeToKeepDim:()=>Wb,exponent:()=>Aw,exponents:()=>Rw,fromStringArrayToUint8:()=>Hw,fromUint8ToStringArray:()=>jw,getAxesPermutation:()=>Hb,getBroadcastDims:()=>Eb,getComplexWithIndex:()=>Nw,getEinsumComputePath:()=>Mw,getEinsumPermutation:()=>Dw,getFusedBiasGradient:()=>ew,getFusedDyActivation:()=>Jv,getImageCenter:()=>ow,getInnerMostAxes:()=>qb,getPermuted:()=>aw,getReductionAxes:()=>Sb,getReshaped:()=>iw,getReshapedPermuted:()=>uw,getSliceBeginCoords:()=>lw,getSliceSize:()=>cw,getUndoAxesPermutation:()=>Gb,isIdentityPermutation:()=>Lw,log:()=>kw,mergeRealAndImagArrays:()=>Ew,prepareAndValidate:()=>hw,prepareSplitSize:()=>Vw,segment_util:()=>s,shouldFuse:()=>nw,slice_util:()=>r,splitRealAndImagArrays:()=>Sw,tupleValuesAreOne:()=>Hv,upcastType:()=>Kg,validateInput:()=>pw,validateUpdateShape:()=>dw,warn:()=>_w});var i={};n.r(i),n.d(i,{json:()=>sC});var a={};n.r(a),n.d(a,{json:()=>oC});var u={};n.r(u),n.d(u,{json:()=>iC});var l={};n.r(l),n.d(l,{json:()=>aC});var c={};n.r(c),n.d(c,{json:()=>uC});var h={};n.r(h),n.d(h,{json:()=>lC});var d={};n.r(d),n.d(d,{json:()=>cC});var p={};n.r(p),n.d(p,{json:()=>hC});var f={};n.r(f),n.d(f,{json:()=>dC});var m={};n.r(m),n.d(m,{json:()=>pC});var g={};n.r(g),n.d(g,{json:()=>fC});var y={};n.r(y),n.d(y,{json:()=>mC});var x={};n.r(x),n.d(x,{json:()=>gC});var b={};n.r(b),n.d(b,{json:()=>yC});var v={};n.r(v),n.d(v,{json:()=>xC});var w={};n.r(w),n.d(w,{json:()=>bC});var C={};n.r(C),n.d(C,{json:()=>vC});var _={};n.r(_),n.d(_,{json:()=>wC});var k={};n.r(k),n.d(k,{json:()=>CC});var E={};function S(e){return"function"==typeof e}n.r(E),n.d(E,{addImpl:()=>XT,bincountImpl:()=>QT,bincountReduceImpl:()=>ZT,ceilImpl:()=>tI,concatImpl:()=>nI,equalImpl:()=>rI,expImpl:()=>sI,expm1Impl:()=>oI,floorImpl:()=>iI,gatherNdImpl:()=>aI,gatherV2Impl:()=>uI,greaterEqualImpl:()=>cI,greaterImpl:()=>lI,lessEqualImpl:()=>dI,lessImpl:()=>hI,linSpaceImpl:()=>pI,logImpl:()=>fI,maxImpl:()=>mI,maximumImpl:()=>gI,minimumImpl:()=>yI,multiplyImpl:()=>xI,negImpl:()=>vI,notEqualImpl:()=>wI,prodImpl:()=>_I,rangeImpl:()=>kI,rsqrtImpl:()=>EI,simpleAbsImpl:()=>UT,sliceImpl:()=>SI,sparseFillEmptyRowsImpl:()=>TI,sparseReshapeImpl:()=>II,sparseSegmentReductionImpl:()=>NI,squaredDifferenceImpl:()=>$I,stridedSliceImpl:()=>RI,stringNGramsImpl:()=>OI,stringSplitImpl:()=>DI,stringToHashBucketFastImpl:()=>PI,subImpl:()=>MI,tileImpl:()=>BI,topKImpl:()=>VI,transposeImpl:()=>CI,uniqueImpl:()=>UI});let T=!1;const I={Promise:void 0,set useDeprecatedSynchronousErrorHandling(e){if(e){const e=new Error;console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n"+e.stack)}else T&&console.log("RxJS: Back to a better error behavior. Thank you. <3");T=e},get useDeprecatedSynchronousErrorHandling(){return T}};function N(e){setTimeout(()=>{throw e},0)}const $={closed:!0,next(e){},error(e){if(I.useDeprecatedSynchronousErrorHandling)throw e;N(e)},complete(){}},R=Array.isArray||(e=>e&&"number"==typeof e.length);function A(e){return null!==e&&"object"==typeof e}const O=(()=>{function e(e){return Error.call(this),this.message=e?`${e.length} errors occurred during unsubscription:\n${e.map((e,t)=>`${t+1}) ${e.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=e,this}return e.prototype=Object.create(Error.prototype),e})();class F{constructor(e){this.closed=!1,this._parentOrParents=null,this._subscriptions=null,e&&(this._ctorUnsubscribe=!0,this._unsubscribe=e)}unsubscribe(){let e;if(this.closed)return;let{_parentOrParents:t,_ctorUnsubscribe:n,_unsubscribe:r,_subscriptions:s}=this;if(this.closed=!0,this._parentOrParents=null,this._subscriptions=null,t instanceof F)t.remove(this);else if(null!==t)for(let i=0;i<t.length;++i)t[i].remove(this);if(S(r)){n&&(this._unsubscribe=void 0);try{r.call(this)}catch(o){e=o instanceof O?D(o.errors):[o]}}if(R(s)){let t=-1,n=s.length;for(;++t<n;){const n=s[t];if(A(n))try{n.unsubscribe()}catch(o){e=e||[],o instanceof O?e=e.concat(D(o.errors)):e.push(o)}}}if(e)throw new O(e)}add(e){let t=e;if(!e)return F.EMPTY;switch(typeof e){case"function":t=new F(e);case"object":if(t===this||t.closed||"function"!=typeof t.unsubscribe)return t;if(this.closed)return t.unsubscribe(),t;if(!(t instanceof F)){const e=t;t=new F,t._subscriptions=[e]}break;default:throw new Error("unrecognized teardown "+e+" added to Subscription.")}let{_parentOrParents:n}=t;if(null===n)t._parentOrParents=this;else if(n instanceof F){if(n===this)return t;t._parentOrParents=[n,this]}else{if(-1!==n.indexOf(this))return t;n.push(this)}const r=this._subscriptions;return null===r?this._subscriptions=[t]:r.push(t),t}remove(e){const t=this._subscriptions;if(t){const n=t.indexOf(e);-1!==n&&t.splice(n,1)}}}function D(e){return e.reduce((e,t)=>e.concat(t instanceof O?t.errors:t),[])}F.EMPTY=function(e){return e.closed=!0,e}(new F);const P="function"==typeof Symbol?Symbol("rxSubscriber"):"@@rxSubscriber_"+Math.random();class M extends F{constructor(e,t,n){switch(super(),this.syncErrorValue=null,this.syncErrorThrown=!1,this.syncErrorThrowable=!1,this.isStopped=!1,arguments.length){case 0:this.destination=$;break;case 1:if(!e){this.destination=$;break}if("object"==typeof e){e instanceof M?(this.syncErrorThrowable=e.syncErrorThrowable,this.destination=e,e.add(this)):(this.syncErrorThrowable=!0,this.destination=new L(this,e));break}default:this.syncErrorThrowable=!0,this.destination=new L(this,e,t,n)}}[P](){return this}static create(e,t,n){const r=new M(e,t,n);return r.syncErrorThrowable=!1,r}next(e){this.isStopped||this._next(e)}error(e){this.isStopped||(this.isStopped=!0,this._error(e))}complete(){this.isStopped||(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe())}_next(e){this.destination.next(e)}_error(e){this.destination.error(e),this.unsubscribe()}_complete(){this.destination.complete(),this.unsubscribe()}_unsubscribeAndRecycle(){const{_parentOrParents:e}=this;return this._parentOrParents=null,this.unsubscribe(),this.closed=!1,this.isStopped=!1,this._parentOrParents=e,this}}class L extends M{constructor(e,t,n,r){let s;super(),this._parentSubscriber=e;let o=this;S(t)?s=t:t&&(s=t.next,n=t.error,r=t.complete,t!==$&&(o=Object.create(t),S(o.unsubscribe)&&this.add(o.unsubscribe.bind(o)),o.unsubscribe=this.unsubscribe.bind(this))),this._context=o,this._next=s,this._error=n,this._complete=r}next(e){if(!this.isStopped&&this._next){const{_parentSubscriber:t}=this;I.useDeprecatedSynchronousErrorHandling&&t.syncErrorThrowable?this.__tryOrSetError(t,this._next,e)&&this.unsubscribe():this.__tryOrUnsub(this._next,e)}}error(e){if(!this.isStopped){const{_parentSubscriber:t}=this,{useDeprecatedSynchronousErrorHandling:n}=I;if(this._error)n&&t.syncErrorThrowable?(this.__tryOrSetError(t,this._error,e),this.unsubscribe()):(this.__tryOrUnsub(this._error,e),this.unsubscribe());else if(t.syncErrorThrowable)n?(t.syncErrorValue=e,t.syncErrorThrown=!0):N(e),this.unsubscribe();else{if(this.unsubscribe(),n)throw e;N(e)}}}complete(){if(!this.isStopped){const{_parentSubscriber:e}=this;if(this._complete){const t=()=>this._complete.call(this._context);I.useDeprecatedSynchronousErrorHandling&&e.syncErrorThrowable?(this.__tryOrSetError(e,t),this.unsubscribe()):(this.__tryOrUnsub(t),this.unsubscribe())}else this.unsubscribe()}}__tryOrUnsub(e,t){try{e.call(this._context,t)}catch(n){if(this.unsubscribe(),I.useDeprecatedSynchronousErrorHandling)throw n;N(n)}}__tryOrSetError(e,t,n){if(!I.useDeprecatedSynchronousErrorHandling)throw new Error("bad call");try{t.call(this._context,n)}catch(r){return I.useDeprecatedSynchronousErrorHandling?(e.syncErrorValue=r,e.syncErrorThrown=!0,!0):(N(r),!0)}return!1}_unsubscribe(){const{_parentSubscriber:e}=this;this._context=null,this._parentSubscriber=null,e.unsubscribe()}}const B="function"==typeof Symbol&&Symbol.observable||"@@observable";function V(e){return e}let U=(()=>{class e{constructor(e){this._isScalar=!1,e&&(this._subscribe=e)}lift(t){const n=new e;return n.source=this,n.operator=t,n}subscribe(e,t,n){const{operator:r}=this,s=function(e,t,n){if(e){if(e instanceof M)return e;if(e[P])return e[P]()}return e||t||n?new M(e,t,n):new M($)}(e,t,n);if(s.add(r?r.call(s,this.source):this.source||I.useDeprecatedSynchronousErrorHandling&&!s.syncErrorThrowable?this._subscribe(s):this._trySubscribe(s)),I.useDeprecatedSynchronousErrorHandling&&s.syncErrorThrowable&&(s.syncErrorThrowable=!1,s.syncErrorThrown))throw s.syncErrorValue;return s}_trySubscribe(e){try{return this._subscribe(e)}catch(t){I.useDeprecatedSynchronousErrorHandling&&(e.syncErrorThrown=!0,e.syncErrorValue=t),function(e){for(;e;){const{closed:t,destination:n,isStopped:r}=e;if(t||r)return!1;e=n&&n instanceof M?n:null}return!0}(e)?e.error(t):console.warn(t)}}forEach(e,t){return new(t=z(t))((t,n)=>{let r;r=this.subscribe(t=>{try{e(t)}catch(s){n(s),r&&r.unsubscribe()}},n,t)})}_subscribe(e){const{source:t}=this;return t&&t.subscribe(e)}[B](){return this}pipe(...e){return 0===e.length?this:(0===(t=e).length?V:1===t.length?t[0]:function(e){return t.reduce((e,t)=>t(e),e)})(this);var t}toPromise(e){return new(e=z(e))((e,t)=>{let n;this.subscribe(e=>n=e,e=>t(e),()=>e(n))})}}return e.create=t=>new e(t),e})();function z(e){if(e||(e=I.Promise||Promise),!e)throw new Error("no Promise impl found");return e}const W=(()=>{function e(){return Error.call(this),this.message="object unsubscribed",this.name="ObjectUnsubscribedError",this}return e.prototype=Object.create(Error.prototype),e})();class j extends F{constructor(e,t){super(),this.subject=e,this.subscriber=t,this.closed=!1}unsubscribe(){if(this.closed)return;this.closed=!0;const e=this.subject,t=e.observers;if(this.subject=null,!t||0===t.length||e.isStopped||e.closed)return;const n=t.indexOf(this.subscriber);-1!==n&&t.splice(n,1)}}class H extends M{constructor(e){super(e),this.destination=e}}let G=(()=>{class e extends U{constructor(){super(),this.observers=[],this.closed=!1,this.isStopped=!1,this.hasError=!1,this.thrownError=null}[P](){return new H(this)}lift(e){const t=new q(this,this);return t.operator=e,t}next(e){if(this.closed)throw new W;if(!this.isStopped){const{observers:t}=this,n=t.length,r=t.slice();for(let s=0;s<n;s++)r[s].next(e)}}error(e){if(this.closed)throw new W;this.hasError=!0,this.thrownError=e,this.isStopped=!0;const{observers:t}=this,n=t.length,r=t.slice();for(let s=0;s<n;s++)r[s].error(e);this.observers.length=0}complete(){if(this.closed)throw new W;this.isStopped=!0;const{observers:e}=this,t=e.length,n=e.slice();for(let r=0;r<t;r++)n[r].complete();this.observers.length=0}unsubscribe(){this.isStopped=!0,this.closed=!0,this.observers=null}_trySubscribe(e){if(this.closed)throw new W;return super._trySubscribe(e)}_subscribe(e){if(this.closed)throw new W;return this.hasError?(e.error(this.thrownError),F.EMPTY):this.isStopped?(e.complete(),F.EMPTY):(this.observers.push(e),new j(this,e))}asObservable(){const e=new U;return e.source=this,e}}return e.create=(e,t)=>new q(e,t),e})();class q extends G{constructor(e,t){super(),this.destination=e,this.source=t}next(e){const{destination:t}=this;t&&t.next&&t.next(e)}error(e){const{destination:t}=this;t&&t.error&&this.destination.error(e)}complete(){const{destination:e}=this;e&&e.complete&&this.destination.complete()}_subscribe(e){const{source:t}=this;return t?this.source.subscribe(e):F.EMPTY}}function K(e){return e&&"function"==typeof e.schedule}function X(e,t){return function(n){if("function"!=typeof e)throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");return n.lift(new Y(e,t))}}class Y{constructor(e,t){this.project=e,this.thisArg=t}call(e,t){return t.subscribe(new Q(e,this.project,this.thisArg))}}class Q extends M{constructor(e,t,n){super(e),this.project=t,this.count=0,this.thisArg=n||this}_next(e){let t;try{t=this.project.call(this.thisArg,e,this.count++)}catch(n){return void this.destination.error(n)}this.destination.next(t)}}const Z=e=>t=>{for(let n=0,r=e.length;n<r&&!t.closed;n++)t.next(e[n]);t.complete()},J="function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator",ee=e=>e&&"number"==typeof e.length&&"function"!=typeof e;function te(e){return!!e&&"function"!=typeof e.subscribe&&"function"==typeof e.then}const ne=e=>{if(e&&"function"==typeof e[B])return n=e,e=>{const t=n[B]();if("function"!=typeof t.subscribe)throw new TypeError("Provided object does not correctly implement Symbol.observable");return t.subscribe(e)};if(ee(e))return Z(e);if(te(e))return(e=>t=>(e.then(e=>{t.closed||(t.next(e),t.complete())},e=>t.error(e)).then(null,N),t))(e);if(e&&"function"==typeof e[J])return t=e,e=>{const n=t[J]();for(;;){let t;try{t=n.next()}catch(r){return e.error(r),e}if(t.done){e.complete();break}if(e.next(t.value),e.closed)break}return"function"==typeof n.return&&e.add(()=>{n.return&&n.return()}),e};{const t=A(e)?"an invalid object":`'${e}'`;throw new TypeError(`You provided ${t} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`)}var t,n};function re(e,t){return new U(n=>{const r=new F;let s=0;return r.add(t.schedule(function(){s!==e.length?(n.next(e[s++]),n.closed||r.add(this.schedule())):n.complete()})),r})}function se(e,t){return t?function(e,t){if(null!=e){if(function(e){return e&&"function"==typeof e[B]}(e))return function(e,t){return new U(n=>{const r=new F;return r.add(t.schedule(()=>{const s=e[B]();r.add(s.subscribe({next(e){r.add(t.schedule(()=>n.next(e)))},error(e){r.add(t.schedule(()=>n.error(e)))},complete(){r.add(t.schedule(()=>n.complete()))}}))})),r})}(e,t);if(te(e))return function(e,t){return new U(n=>{const r=new F;return r.add(t.schedule(()=>e.then(e=>{r.add(t.schedule(()=>{n.next(e),r.add(t.schedule(()=>n.complete()))}))},e=>{r.add(t.schedule(()=>n.error(e)))}))),r})}(e,t);if(ee(e))return re(e,t);if(function(e){return e&&"function"==typeof e[J]}(e)||"string"==typeof e)return function(e,t){if(!e)throw new Error("Iterable cannot be null");return new U(n=>{const r=new F;let s;return r.add(()=>{s&&"function"==typeof s.return&&s.return()}),r.add(t.schedule(()=>{s=e[J](),r.add(t.schedule(function(){if(n.closed)return;let e,t;try{const n=s.next();e=n.value,t=n.done}catch(r){return void n.error(r)}t?n.complete():(n.next(e),this.schedule())}))})),r})}(e,t)}throw new TypeError((null!==e&&typeof e||e)+" is not observable")}(e,t):e instanceof U?e:new U(ne(e))}class oe extends M{constructor(e){super(),this.parent=e}_next(e){this.parent.notifyNext(e)}_error(e){this.parent.notifyError(e),this.unsubscribe()}_complete(){this.parent.notifyComplete(),this.unsubscribe()}}class ie extends M{notifyNext(e){this.destination.next(e)}notifyError(e){this.destination.error(e)}notifyComplete(){this.destination.complete()}}function ae(e,t){if(t.closed)return;if(e instanceof U)return e.subscribe(t);let n;try{n=ne(e)(t)}catch(r){t.error(r)}return n}function ue(e,t,n=Number.POSITIVE_INFINITY){return"function"==typeof t?r=>r.pipe(ue((n,r)=>se(e(n,r)).pipe(X((e,s)=>t(n,e,r,s))),n)):("number"==typeof t&&(n=t),t=>t.lift(new le(e,n)))}class le{constructor(e,t=Number.POSITIVE_INFINITY){this.project=e,this.concurrent=t}call(e,t){return t.subscribe(new ce(e,this.project,this.concurrent))}}class ce extends ie{constructor(e,t,n=Number.POSITIVE_INFINITY){super(e),this.project=t,this.concurrent=n,this.hasCompleted=!1,this.buffer=[],this.active=0,this.index=0}_next(e){this.active<this.concurrent?this._tryNext(e):this.buffer.push(e)}_tryNext(e){let t;const n=this.index++;try{t=this.project(e,n)}catch(r){return void this.destination.error(r)}this.active++,this._innerSub(t)}_innerSub(e){const t=new oe(this),n=this.destination;n.add(t);const r=ae(e,t);r!==t&&n.add(r)}_complete(){this.hasCompleted=!0,0===this.active&&0===this.buffer.length&&this.destination.complete(),this.unsubscribe()}notifyNext(e){this.destination.next(e)}notifyComplete(){const e=this.buffer;this.active--,e.length>0?this._next(e.shift()):0===this.active&&this.hasCompleted&&this.destination.complete()}}const he=ue;function de(e=Number.POSITIVE_INFINITY){return ue(V,e)}function pe(e,t){return t?re(e,t):new U(Z(e))}function fe(){return function(e){return e.lift(new me(e))}}class me{constructor(e){this.connectable=e}call(e,t){const{connectable:n}=this;n._refCount++;const r=new ge(e,n),s=t.subscribe(r);return r.closed||(r.connection=n.connect()),s}}class ge extends M{constructor(e,t){super(e),this.connectable=t}_unsubscribe(){const{connectable:e}=this;if(!e)return void(this.connection=null);this.connectable=null;const t=e._refCount;if(t<=0)return void(this.connection=null);if(e._refCount=t-1,t>1)return void(this.connection=null);const{connection:n}=this,r=e._connection;this.connection=null,!r||n&&r!==n||r.unsubscribe()}}class ye extends U{constructor(e,t){super(),this.source=e,this.subjectFactory=t,this._refCount=0,this._isComplete=!1}_subscribe(e){return this.getSubject().subscribe(e)}getSubject(){const e=this._subject;return e&&!e.isStopped||(this._subject=this.subjectFactory()),this._subject}connect(){let e=this._connection;return e||(this._isComplete=!1,e=this._connection=new F,e.add(this.source.subscribe(new be(this.getSubject(),this))),e.closed&&(this._connection=null,e=F.EMPTY)),e}refCount(){return fe()(this)}}const xe=(()=>{const e=ye.prototype;return{operator:{value:null},_refCount:{value:0,writable:!0},_subject:{value:null,writable:!0},_connection:{value:null,writable:!0},_subscribe:{value:e._subscribe},_isComplete:{value:e._isComplete,writable:!0},getSubject:{value:e.getSubject},connect:{value:e.connect},refCount:{value:e.refCount}}})();class be extends H{constructor(e,t){super(e),this.connectable=t}_error(e){this._unsubscribe(),super._error(e)}_complete(){this.connectable._isComplete=!0,this._unsubscribe(),super._complete()}_unsubscribe(){const e=this.connectable;if(e){this.connectable=null;const t=e._connection;e._refCount=0,e._subject=null,e._connection=null,t&&t.unsubscribe()}}}function ve(){return new G}function we(e){for(let t in e)if(e[t]===we)return t;throw Error("Could not find renamed property on target object.")}function Ce(e){if("string"==typeof e)return e;if(Array.isArray(e))return"["+e.map(Ce).join(", ")+"]";if(null==e)return""+e;if(e.overriddenName)return`${e.overriddenName}`;if(e.name)return`${e.name}`;const t=e.toString();if(null==t)return""+t;const n=t.indexOf("\n");return-1===n?t:t.substring(0,n)}function _e(e,t){return null==e||""===e?null===t?"":t:null==t||""===t?e:e+" "+t}const ke=we({__forward_ref__:we});function Ee(e){return e.__forward_ref__=Ee,e.toString=function(){return Ce(this())},e}function Se(e){return"function"==typeof(t=e)&&t.hasOwnProperty(ke)&&t.__forward_ref__===Ee?e():e;var t}class Te extends Error{constructor(e,t){super(function(e,t){return`${e?`NG0${e}: `:""}${t}`}(e,t)),this.code=e}}function Ie(e){return"string"==typeof e?e:null==e?"":String(e)}function Ne(e){return"function"==typeof e?e.name||e.toString():"object"==typeof e&&null!=e&&"function"==typeof e.type?e.type.name||e.type.toString():Ie(e)}function $e(e,t){const n=t?` in ${t}`:"";throw new Te("201",`No provider for ${Ne(e)} found${n}`)}function Re(e){return{token:e.token,providedIn:e.providedIn||null,factory:e.factory,value:void 0}}function Ae(e){return{providers:e.providers||[],imports:e.imports||[]}}function Oe(e){return Fe(e,Pe)||Fe(e,Le)}function Fe(e,t){return e.hasOwnProperty(t)?e[t]:null}function De(e){return e&&(e.hasOwnProperty(Me)||e.hasOwnProperty(Be))?e[Me]:null}const Pe=we({"\u0275prov":we}),Me=we({"\u0275inj":we}),Le=we({ngInjectableDef:we}),Be=we({ngInjectorDef:we});var Ve=(()=>((Ve=Ve||{})[Ve.Default=0]="Default",Ve[Ve.Host=1]="Host",Ve[Ve.Self=2]="Self",Ve[Ve.SkipSelf=4]="SkipSelf",Ve[Ve.Optional=8]="Optional",Ve))();let Ue;function ze(e){const t=Ue;return Ue=e,t}function We(e,t,n){const r=Oe(e);return r&&"root"==r.providedIn?void 0===r.value?r.value=r.factory():r.value:n&Ve.Optional?null:void 0!==t?t:void $e(Ce(e),"Injector")}function je(e){return{toString:e}.toString()}var He=(()=>((He=He||{})[He.OnPush=0]="OnPush",He[He.Default=1]="Default",He))(),Ge=(()=>((Ge=Ge||{})[Ge.Emulated=0]="Emulated",Ge[Ge.None=2]="None",Ge[Ge.ShadowDom=3]="ShadowDom",Ge))();const qe="undefined"!=typeof globalThis&&globalThis,Ke="undefined"!=typeof window&&window,Xe="undefined"!=typeof self&&"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&self,Ye="undefined"!=typeof global&&global,Qe=qe||Ye||Ke||Xe,Ze={},Je=[],et=we({"\u0275cmp":we}),tt=we({"\u0275dir":we}),nt=we({"\u0275pipe":we}),rt=we({"\u0275mod":we}),st=we({"\u0275loc":we}),ot=we({"\u0275fac":we}),it=we({__NG_ELEMENT_ID__:we});let at=0;function ut(e){return je(()=>{const t={},n={type:e.type,providersResolver:null,decls:e.decls,vars:e.vars,factory:null,template:e.template||null,consts:e.consts||null,ngContentSelectors:e.ngContentSelectors,hostBindings:e.hostBindings||null,hostVars:e.hostVars||0,hostAttrs:e.hostAttrs||null,contentQueries:e.contentQueries||null,declaredInputs:t,inputs:null,outputs:null,exportAs:e.exportAs||null,onPush:e.changeDetection===He.OnPush,directiveDefs:null,pipeDefs:null,selectors:e.selectors||Je,viewQuery:e.viewQuery||null,features:e.features||null,data:e.data||{},encapsulation:e.encapsulation||Ge.Emulated,id:"c",styles:e.styles||Je,_:null,setInput:null,schemas:e.schemas||null,tView:null},r=e.directives,s=e.features,o=e.pipes;return n.id+=at++,n.inputs=pt(e.inputs,t),n.outputs=pt(e.outputs),s&&s.forEach(e=>e(n)),n.directiveDefs=r?()=>("function"==typeof r?r():r).map(lt):null,n.pipeDefs=o?()=>("function"==typeof o?o():o).map(ct):null,n})}function lt(e){return mt(e)||function(e){return e[tt]||null}(e)}function ct(e){return function(e){return e[nt]||null}(e)}const ht={};function dt(e){return je(()=>{const t={type:e.type,bootstrap:e.bootstrap||Je,declarations:e.declarations||Je,imports:e.imports||Je,exports:e.exports||Je,transitiveCompileScopes:null,schemas:e.schemas||null,id:e.id||null};return null!=e.id&&(ht[e.id]=e.type),t})}function pt(e,t){if(null==e)return Ze;const n={};for(const r in e)if(e.hasOwnProperty(r)){let s=e[r],o=s;Array.isArray(s)&&(o=s[1],s=s[0]),n[s]=r,t&&(t[s]=o)}return n}const ft=ut;function mt(e){return e[et]||null}function gt(e,t){const n=e[rt]||null;if(!n&&!0===t)throw new Error(`Type ${Ce(e)} does not have '\u0275mod' property.`);return n}const yt=20,xt=10;function bt(e){return Array.isArray(e)&&"object"==typeof e[1]}function vt(e){return Array.isArray(e)&&!0===e[1]}function wt(e){return 0!=(8&e.flags)}function Ct(e){return 2==(2&e.flags)}function _t(e){return 1==(1&e.flags)}function kt(e){return null!==e.template}function Et(e,t){return e.hasOwnProperty(ot)?e[ot]:null}class St{constructor(e,t,n){this.previousValue=e,this.currentValue=t,this.firstChange=n}isFirstChange(){return this.firstChange}}function Tt(){const e=Nt(this),t=null==e?void 0:e.current;if(t){const n=e.previous;if(n===Ze)e.previous=t;else for(let e in t)n[e]=t[e];e.current=null,this.ngOnChanges(t)}}function It(e,t,n,r){const s=Nt(e)||function(e,t){return e.__ngSimpleChanges__=t}(e,{previous:Ze,current:null}),o=s.current||(s.current={}),i=s.previous,a=this.declaredInputs[n],u=i[a];o[a]=new St(u&&u.currentValue,t,i===Ze),e[r]=t}function Nt(e){return e.__ngSimpleChanges__||null}let $t;function Rt(e){return!!e.listen}const At={createRenderer:(e,t)=>void 0!==$t?$t:"undefined"!=typeof document?document:void 0};function Ot(e){for(;Array.isArray(e);)e=e[0];return e}function Ft(e,t){return Ot(t[e.index])}function Dt(e,t){return e.data[t]}function Pt(e,t){const n=t[e];return bt(n)?n:n[0]}function Mt(e){return 4==(4&e[2])}function Lt(e){return 128==(128&e[2])}function Bt(e,t){return null==t?null:e[t]}function Vt(e){e[18]=0}function Ut(e,t){e[5]+=t;let n=e,r=e[3];for(;null!==r&&(1===t&&1===n[5]||-1===t&&0===n[5]);)r[5]+=t,n=r,r=r[3]}const zt={lFrame:an(null),bindingsEnabled:!0,isInCheckNoChangesMode:!1};function Wt(){return zt.bindingsEnabled}function jt(){return zt.lFrame.lView}function Ht(){return zt.lFrame.tView}function Gt(){let e=qt();for(;null!==e&&64===e.type;)e=e.parent;return e}function qt(){return zt.lFrame.currentTNode}function Kt(e,t){const n=zt.lFrame;n.currentTNode=e,n.isParent=t}function Xt(){return zt.lFrame.isParent}function Yt(){return zt.isInCheckNoChangesMode}function Qt(e){zt.isInCheckNoChangesMode=e}function Zt(e,t){const n=zt.lFrame;n.bindingIndex=n.bindingRootIndex=e,Jt(t)}function Jt(e){zt.lFrame.currentDirectiveIndex=e}function en(){return zt.lFrame.currentQueryIndex}function tn(e){zt.lFrame.currentQueryIndex=e}function nn(e){const t=e[1];return 2===t.type?t.declTNode:1===t.type?e[6]:null}function rn(e,t,n){if(n&Ve.SkipSelf){let r=t,s=e;for(;r=r.parent,!(null!==r||n&Ve.Host||(r=nn(s),null===r)||(s=s[15],10&r.type)););if(null===r)return!1;t=r,e=s}const r=zt.lFrame=on();return r.currentTNode=t,r.lView=e,!0}function sn(e){const t=on(),n=e[1];zt.lFrame=t,t.currentTNode=n.firstChild,t.lView=e,t.tView=n,t.contextLView=e,t.bindingIndex=n.bindingStartIndex,t.inI18n=!1}function on(){const e=zt.lFrame,t=null===e?null:e.child;return null===t?an(e):t}function an(e){const t={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:e,child:null,inI18n:!1};return null!==e&&(e.child=t),t}function un(){const e=zt.lFrame;return zt.lFrame=e.parent,e.currentTNode=null,e.lView=null,e}const ln=un;function cn(){const e=un();e.isParent=!0,e.tView=null,e.selectedIndex=-1,e.contextLView=null,e.elementDepthCount=0,e.currentDirectiveIndex=-1,e.currentNamespace=null,e.bindingRootIndex=-1,e.bindingIndex=-1,e.currentQueryIndex=0}function hn(){return zt.lFrame.selectedIndex}function dn(e){zt.lFrame.selectedIndex=e}function pn(e,t){for(let n=t.directiveStart,r=t.directiveEnd;n<r;n++){const t=e.data[n].type.prototype,{ngAfterContentInit:r,ngAfterContentChecked:s,ngAfterViewInit:o,ngAfterViewChecked:i,ngOnDestroy:a}=t;r&&(e.contentHooks||(e.contentHooks=[])).push(-n,r),s&&((e.contentHooks||(e.contentHooks=[])).push(n,s),(e.contentCheckHooks||(e.contentCheckHooks=[])).push(n,s)),o&&(e.viewHooks||(e.viewHooks=[])).push(-n,o),i&&((e.viewHooks||(e.viewHooks=[])).push(n,i),(e.viewCheckHooks||(e.viewCheckHooks=[])).push(n,i)),null!=a&&(e.destroyHooks||(e.destroyHooks=[])).push(n,a)}}function fn(e,t,n){yn(e,t,3,n)}function mn(e,t,n,r){(3&e[2])===n&&yn(e,t,n,r)}function gn(e,t){let n=e[2];(3&n)===t&&(n&=2047,n+=1,e[2]=n)}function yn(e,t,n,r){const s=null!=r?r:-1,o=t.length-1;let i=0;for(let a=void 0!==r?65535&e[18]:0;a<o;a++)if("number"==typeof t[a+1]){if(i=t[a],null!=r&&i>=r)break}else t[a]<0&&(e[18]+=65536),(i<s||-1==s)&&(xn(e,n,t,a),e[18]=(4294901760&e[18])+a+2),a++}function xn(e,t,n,r){const s=n[r]<0,o=n[r+1],i=e[s?-n[r]:n[r]];if(s){if(e[2]>>11<e[18]>>16&&(3&e[2])===t){e[2]+=2048;try{o.call(i)}finally{}}}else try{o.call(i)}finally{}}const bn=-1;class vn{constructor(e,t,n){this.factory=e,this.resolving=!1,this.canSeeViewProviders=t,this.injectImpl=n}}function wn(e,t,n){const r=Rt(e);let s=0;for(;s<n.length;){const o=n[s];if("number"==typeof o){if(0!==o)break;s++;const i=n[s++],a=n[s++],u=n[s++];r?e.setAttribute(t,a,u,i):t.setAttributeNS(i,a,u)}else{const i=o,a=n[++s];_n(i)?r&&e.setProperty(t,i,a):r?e.setAttribute(t,i,a):t.setAttribute(i,a),s++}}return s}function Cn(e){return 3===e||4===e||6===e}function _n(e){return 64===e.charCodeAt(0)}function kn(e,t){if(null===t||0===t.length);else if(null===e||0===e.length)e=t.slice();else{let n=-1;for(let r=0;r<t.length;r++){const s=t[r];"number"==typeof s?n=s:0===n||En(e,n,s,null,-1===n||2===n?t[++r]:null)}}return e}function En(e,t,n,r,s){let o=0,i=e.length;if(-1===t)i=-1;else for(;o<e.length;){const n=e[o++];if("number"==typeof n){if(n===t){i=-1;break}if(n>t){i=o-1;break}}}for(;o<e.length;){const t=e[o];if("number"==typeof t)break;if(t===n){if(null===r)return void(null!==s&&(e[o+1]=s));if(r===e[o+1])return void(e[o+2]=s)}o++,null!==r&&o++,null!==s&&o++}-1!==i&&(e.splice(i,0,t),o=i+1),e.splice(o++,0,n),null!==r&&e.splice(o++,0,r),null!==s&&e.splice(o++,0,s)}function Sn(e){return e!==bn}function Tn(e){return 32767&e}function In(e,t){let n=e>>16,r=t;for(;n>0;)r=r[15],n--;return r}let Nn=!0;function $n(e){const t=Nn;return Nn=e,t}let Rn=0;function An(e,t){const n=Fn(e,t);if(-1!==n)return n;const r=t[1];r.firstCreatePass&&(e.injectorIndex=t.length,On(r.data,e),On(t,null),On(r.blueprint,null));const s=Dn(e,t),o=e.injectorIndex;if(Sn(s)){const e=Tn(s),n=In(s,t),r=n[1].data;for(let s=0;s<8;s++)t[o+s]=n[e+s]|r[e+s]}return t[o+8]=s,o}function On(e,t){e.push(0,0,0,0,0,0,0,0,t)}function Fn(e,t){return-1===e.injectorIndex||e.parent&&e.parent.injectorIndex===e.injectorIndex||null===t[e.injectorIndex+8]?-1:e.injectorIndex}function Dn(e,t){if(e.parent&&-1!==e.parent.injectorIndex)return e.parent.injectorIndex;let n=0,r=null,s=t;for(;null!==s;){const e=s[1],t=e.type;if(r=2===t?e.declTNode:1===t?s[6]:null,null===r)return bn;if(n++,s=s[15],-1!==r.injectorIndex)return r.injectorIndex|n<<16}return bn}function Pn(e,t,n){!function(e,t,n){let r;"string"==typeof n?r=n.charCodeAt(0)||0:n.hasOwnProperty(it)&&(r=n[it]),null==r&&(r=n[it]=Rn++);const s=255&r;t.data[e+(s>>5)]|=1<<s}(e,t,n)}function Mn(e,t,n){if(n&Ve.Optional)return e;$e(t,"NodeInjector")}function Ln(e,t,n,r){if(n&Ve.Optional&&void 0===r&&(r=null),0==(n&(Ve.Self|Ve.Host))){const s=e[9],o=ze(void 0);try{return s?s.get(t,r,n&Ve.Optional):We(t,r,n&Ve.Optional)}finally{ze(o)}}return Mn(r,t,n)}function Bn(e,t,n,r=Ve.Default,s){if(null!==e){const o=function(e){if("string"==typeof e)return e.charCodeAt(0)||0;const t=e.hasOwnProperty(it)?e[it]:void 0;return"number"==typeof t?t>=0?255&t:Un:t}(n);if("function"==typeof o){if(!rn(t,e,r))return r&Ve.Host?Mn(s,n,r):Ln(t,n,r,s);try{const e=o(r);if(null!=e||r&Ve.Optional)return e;$e(n)}finally{ln()}}else if("number"==typeof o){let s=null,i=Fn(e,t),a=bn,u=r&Ve.Host?t[16][6]:null;for((-1===i||r&Ve.SkipSelf)&&(a=-1===i?Dn(e,t):t[i+8],a!==bn&&Gn(r,!1)?(s=t[1],i=Tn(a),t=In(a,t)):i=-1);-1!==i;){const e=t[1];if(Hn(o,i,e.data)){const e=zn(i,t,n,s,r,u);if(e!==Vn)return e}a=t[i+8],a!==bn&&Gn(r,t[1].data[i+8]===u)&&Hn(o,i,t)?(s=e,i=Tn(a),t=In(a,t)):i=-1}}}return Ln(t,n,r,s)}const Vn={};function Un(){return new qn(Gt(),jt())}function zn(e,t,n,r,s,o){const i=t[1],a=i.data[e+8],u=Wn(a,i,n,null==r?Ct(a)&&Nn:r!=i&&0!=(3&a.type),s&Ve.Host&&o===a);return null!==u?jn(t,i,u,a):Vn}function Wn(e,t,n,r,s){const o=e.providerIndexes,i=t.data,a=1048575&o,u=e.directiveStart,l=o>>20,c=s?a+l:e.directiveEnd;for(let h=r?a:a+l;h<c;h++){const e=i[h];if(h<u&&n===e||h>=u&&e.type===n)return h}if(s){const e=i[u];if(e&&kt(e)&&e.type===n)return u}return null}function jn(e,t,n,r){let s=e[n];const o=t.data;if(s instanceof vn){const i=s;i.resolving&&function(e,t){throw new Te("200",`Circular dependency in DI detected for ${e}`)}(Ne(o[n]));const a=$n(i.canSeeViewProviders);i.resolving=!0;const u=i.injectImpl?ze(i.injectImpl):null;rn(e,r,Ve.Default);try{s=e[n]=i.factory(void 0,o,e,r),t.firstCreatePass&&n>=r.directiveStart&&function(e,t,n){const{ngOnChanges:r,ngOnInit:s,ngDoCheck:o}=t.type.prototype;if(r){const r=((i=t).type.prototype.ngOnChanges&&(i.setInput=It),Tt);(n.preOrderHooks||(n.preOrderHooks=[])).push(e,r),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(e,r)}var i;s&&(n.preOrderHooks||(n.preOrderHooks=[])).push(0-e,s),o&&((n.preOrderHooks||(n.preOrderHooks=[])).push(e,o),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(e,o))}(n,o[n],t)}finally{null!==u&&ze(u),$n(a),i.resolving=!1,ln()}}return s}function Hn(e,t,n){return!!(n[t+(e>>5)]&1<<e)}function Gn(e,t){return!(e&Ve.Self||e&Ve.Host&&t)}class qn{constructor(e,t){this._tNode=e,this._lView=t}get(e,t){return Bn(this._tNode,this._lView,e,void 0,t)}}const Kn="__parameters__";function Xn(e,t,n){return je(()=>{const r=function(e){return function(...t){if(e){const n=e(...t);for(const e in n)this[e]=n[e]}}}(t);function s(...e){if(this instanceof s)return r.apply(this,e),this;const t=new s(...e);return n.annotation=t,n;function n(e,n,r){const s=e.hasOwnProperty(Kn)?e[Kn]:Object.defineProperty(e,Kn,{value:[]})[Kn];for(;s.length<=r;)s.push(null);return(s[r]=s[r]||[]).push(t),e}}return n&&(s.prototype=Object.create(n.prototype)),s.prototype.ngMetadataName=e,s.annotationCls=s,s})}class Yn{constructor(e,t){this._desc=e,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof t?this.__NG_ELEMENT_ID__=t:void 0!==t&&(this.\u0275prov=Re({token:this,providedIn:t.providedIn||"root",factory:t.factory}))}toString(){return`InjectionToken ${this._desc}`}}const Qn=new Yn("AnalyzeForEntryComponents"),Zn=Function;function Jn(e,t){void 0===t&&(t=e);for(let n=0;n<e.length;n++){let r=e[n];Array.isArray(r)?(t===e&&(t=e.slice(0,n)),Jn(r,t)):t!==e&&t.push(r)}return t}function er(e,t){e.forEach(e=>Array.isArray(e)?er(e,t):t(e))}function tr(e,t,n){t>=e.length?e.push(n):e.splice(t,0,n)}function nr(e,t){return t>=e.length-1?e.pop():e.splice(t,1)[0]}const rr={},sr=/\n/gm,or="__source",ir=we({provide:String,useValue:we});let ar;function ur(e){const t=ar;return ar=e,t}function lr(e,t=Ve.Default){if(void 0===ar)throw new Error("inject() must be called from an injection context");return null===ar?We(e,void 0,t):ar.get(e,t&Ve.Optional?null:void 0,t)}function cr(e,t=Ve.Default){return(Ue||lr)(Se(e),t)}function hr(e){const t=[];for(let n=0;n<e.length;n++){const r=Se(e[n]);if(Array.isArray(r)){if(0===r.length)throw new Error("Arguments array must have arguments.");let e,n=Ve.Default;for(let t=0;t<r.length;t++){const s=r[t],o=s.__NG_DI_FLAG__;"number"==typeof o?-1===o?e=s.token:n|=o:e=s}t.push(cr(e,n))}else t.push(cr(r))}return t}function dr(e,t){return e.__NG_DI_FLAG__=t,e.prototype.__NG_DI_FLAG__=t,e}const pr=dr(Xn("Inject",e=>({token:e})),-1),fr=dr(Xn("Optional"),8),mr=dr(Xn("SkipSelf"),4);function gr(e,t){e.__ngContext__=t}function yr(e){const t=function(e){return e.__ngContext__||null}(e);return t?Array.isArray(t)?t:t.lView:null}function xr(e){return e.ngDebugContext}function br(e){return e.ngOriginalError}function vr(e,...t){e.error(...t)}class wr{constructor(){this._console=console}handleError(e){const t=this._findOriginalError(e),n=this._findContext(e),r=function(e){return e.ngErrorLogger||vr}(e);r(this._console,"ERROR",e),t&&r(this._console,"ORIGINAL ERROR",t),n&&r(this._console,"ERROR CONTEXT",n)}_findContext(e){return e?xr(e)?xr(e):this._findContext(br(e)):null}_findOriginalError(e){let t=br(e);for(;t&&br(t);)t=br(t);return t}}const Cr=(()=>("undefined"!=typeof requestAnimationFrame&&requestAnimationFrame||setTimeout).bind(Qe))();function _r(e){return e instanceof Function?e():e}var kr=(()=>((kr=kr||{})[kr.Important=1]="Important",kr[kr.DashCase=2]="DashCase",kr))();function Er(e,t){return(void 0)(e,t)}function Sr(e){const t=e[3];return vt(t)?t[3]:t}function Tr(e){return Nr(e[13])}function Ir(e){return Nr(e[4])}function Nr(e){for(;null!==e&&!vt(e);)e=e[4];return e}function $r(e,t,n,r,s){if(null!=r){let o,i=!1;vt(r)?o=r:bt(r)&&(i=!0,r=r[0]);const a=Ot(r);0===e&&null!==n?null==s?Mr(t,n,a):Pr(t,n,a,s||null,!0):1===e&&null!==n?Pr(t,n,a,s||null,!0):2===e?function(e,t,n){const r=Br(e,t);r&&function(e,t,n,r){Rt(e)?e.removeChild(t,n,r):t.removeChild(n)}(e,r,t,n)}(t,a,i):3===e&&t.destroyNode(a),null!=o&&function(e,t,n,r,s){const o=n[7];o!==Ot(n)&&$r(t,e,r,o,s);for(let i=xt;i<n.length;i++){const s=n[i];Hr(s[1],s,e,t,r,o)}}(t,e,o,n,s)}}function Rr(e,t,n){return Rt(e)?e.createElement(t,n):null===n?e.createElement(t):e.createElementNS(n,t)}function Ar(e,t){const n=e[9],r=n.indexOf(t),s=t[3];1024&t[2]&&(t[2]&=-1025,Ut(s,-1)),n.splice(r,1)}function Or(e,t){if(e.length<=xt)return;const n=xt+t,r=e[n];if(r){const o=r[17];null!==o&&o!==e&&Ar(o,r),t>0&&(e[n-1][4]=r[4]);const i=nr(e,xt+t);Hr(r[1],s=r,s[11],2,null,null),s[0]=null,s[6]=null;const a=i[19];null!==a&&a.detachView(i[1]),r[3]=null,r[4]=null,r[2]&=-129}var s;return r}function Fr(e,t){if(!(256&t[2])){const n=t[11];Rt(n)&&n.destroyNode&&Hr(e,t,n,3,null,null),function(e){let t=e[13];if(!t)return Dr(e[1],e);for(;t;){let n=null;if(bt(t))n=t[13];else{const e=t[10];e&&(n=e)}if(!n){for(;t&&!t[4]&&t!==e;)bt(t)&&Dr(t[1],t),t=t[3];null===t&&(t=e),bt(t)&&Dr(t[1],t),n=t&&t[4]}t=n}}(t)}}function Dr(e,t){if(!(256&t[2])){t[2]&=-129,t[2]|=256,function(e,t){let n;if(null!=e&&null!=(n=e.destroyHooks))for(let r=0;r<n.length;r+=2){const e=t[n[r]];if(!(e instanceof vn)){const t=n[r+1];if(Array.isArray(t))for(let n=0;n<t.length;n+=2){const r=e[t[n]],s=t[n+1];try{s.call(r)}finally{}}else try{t.call(e)}finally{}}}}(e,t),function(e,t){const n=e.cleanup,r=t[7];let s=-1;if(null!==n)for(let o=0;o<n.length-1;o+=2)if("string"==typeof n[o]){const e=n[o+1],i="function"==typeof e?e(t):Ot(t[e]),a=r[s=n[o+2]],u=n[o+3];"boolean"==typeof u?i.removeEventListener(n[o],a,u):u>=0?r[s=u]():r[s=-u].unsubscribe(),o+=2}else{const e=r[s=n[o+1]];n[o].call(e)}if(null!==r){for(let e=s+1;e<r.length;e++)(0,r[e])();t[7]=null}}(e,t),1===t[1].type&&Rt(t[11])&&t[11].destroy();const n=t[17];if(null!==n&&vt(t[3])){n!==t[3]&&Ar(n,t);const r=t[19];null!==r&&r.detachView(e)}}}function Pr(e,t,n,r,s){Rt(e)?e.insertBefore(t,n,r,s):t.insertBefore(n,r,s)}function Mr(e,t,n){Rt(e)?e.appendChild(t,n):t.appendChild(n)}function Lr(e,t,n,r,s){null!==r?Pr(e,t,n,r,s):Mr(e,t,n)}function Br(e,t){return Rt(e)?e.parentNode(t):t.parentNode}function Vr(e,t,n,r){const s=function(e,t,n){return function(e,t,n){let r=t;for(;null!==r&&40&r.type;)r=(t=r).parent;if(null===r)return n[0];if(2&r.flags){const t=e.data[r.directiveStart].encapsulation;if(t===Ge.None||t===Ge.Emulated)return null}return Ft(r,n)}(e,t.parent,n)}(e,r,t),o=t[11],i=function(e,t,n){return function(e,t,n){return 40&e.type?Ft(e,n):null}(e,0,n)}(r.parent||t[6],0,t);if(null!=s)if(Array.isArray(n))for(let a=0;a<n.length;a++)Lr(o,s,n[a],i,!1);else Lr(o,s,n,i,!1)}function Ur(e,t){if(null!==t){const n=t.type;if(3&n)return Ft(t,e);if(4&n)return Wr(-1,e[t.index]);if(8&n){const n=t.child;if(null!==n)return Ur(e,n);{const n=e[t.index];return vt(n)?Wr(-1,n):Ot(n)}}if(32&n)return Er(t,e)()||Ot(e[t.index]);{const n=zr(e,t);return null!==n?Array.isArray(n)?n[0]:Ur(Sr(e[16]),n):Ur(e,t.next)}}return null}function zr(e,t){return null!==t?e[16][6].projection[t.projection]:null}function Wr(e,t){const n=xt+e+1;if(n<t.length){const e=t[n],r=e[1].firstChild;if(null!==r)return Ur(e,r)}return t[7]}function jr(e,t,n,r,s,o,i){for(;null!=n;){const a=r[n.index],u=n.type;if(i&&0===t&&(a&&gr(Ot(a),r),n.flags|=4),64!=(64&n.flags))if(8&u)jr(e,t,n.child,r,s,o,!1),$r(t,e,s,a,o);else if(32&u){const i=Er(n,r);let u;for(;u=i();)$r(t,e,s,u,o);$r(t,e,s,a,o)}else 16&u?Gr(e,t,r,n,s,o):$r(t,e,s,a,o);n=i?n.projectionNext:n.next}}function Hr(e,t,n,r,s,o){jr(n,r,e.firstChild,t,s,o,!1)}function Gr(e,t,n,r,s,o){const i=n[16],a=i[6].projection[r.projection];if(Array.isArray(a))for(let u=0;u<a.length;u++)$r(t,e,s,a[u],o);else jr(e,t,a,i[3],s,o,!0)}function qr(e,t,n){Rt(e)?e.setAttribute(t,"style",n):t.style.cssText=n}function Kr(e,t,n){Rt(e)?""===n?e.removeAttribute(t,"class"):e.setAttribute(t,"class",n):t.className=n}function Xr(e,t,n){let r=e.length;for(;;){const s=e.indexOf(t,n);if(-1===s)return s;if(0===s||e.charCodeAt(s-1)<=32){const n=t.length;if(s+n===r||e.charCodeAt(s+n)<=32)return s}n=s+1}}const Yr="ng-template";function Qr(e,t,n){let r=0;for(;r<e.length;){let s=e[r++];if(n&&"class"===s){if(s=e[r],-1!==Xr(s.toLowerCase(),t,0))return!0}else if(1===s){for(;r<e.length&&"string"==typeof(s=e[r++]);)if(s.toLowerCase()===t)return!0;return!1}}return!1}function Zr(e){return 4===e.type&&e.value!==Yr}function Jr(e,t,n){return t===(4!==e.type||n?e.value:Yr)}function es(e,t,n){let r=4;const s=e.attrs||[],o=function(e){for(let t=0;t<e.length;t++)if(Cn(e[t]))return t;return e.length}(s);let i=!1;for(let a=0;a<t.length;a++){const u=t[a];if("number"!=typeof u){if(!i)if(4&r){if(r=2|1&r,""!==u&&!Jr(e,u,n)||""===u&&1===t.length){if(ts(r))return!1;i=!0}}else{const l=8&r?u:t[++a];if(8&r&&null!==e.attrs){if(!Qr(e.attrs,l,n)){if(ts(r))return!1;i=!0}continue}const c=ns(8&r?"class":u,s,Zr(e),n);if(-1===c){if(ts(r))return!1;i=!0;continue}if(""!==l){let e;e=c>o?"":s[c+1].toLowerCase();const t=8&r?e:null;if(t&&-1!==Xr(t,l,0)||2&r&&l!==e){if(ts(r))return!1;i=!0}}}}else{if(!i&&!ts(r)&&!ts(u))return!1;if(i&&ts(u))continue;i=!1,r=u|1&r}}return ts(r)||i}function ts(e){return 0==(1&e)}function ns(e,t,n,r){if(null===t)return-1;let s=0;if(r||!n){let n=!1;for(;s<t.length;){const r=t[s];if(r===e)return s;if(3===r||6===r)n=!0;else{if(1===r||2===r){let e=t[++s];for(;"string"==typeof e;)e=t[++s];continue}if(4===r)break;if(0===r){s+=4;continue}}s+=n?1:2}return-1}return function(e,t){let n=e.indexOf(4);if(n>-1)for(n++;n<e.length;){const r=e[n];if("number"==typeof r)return-1;if(r===t)return n;n++}return-1}(t,e)}function rs(e,t,n=!1){for(let r=0;r<t.length;r++)if(es(e,t[r],n))return!0;return!1}function ss(e,t){return e?":not("+t.trim()+")":t}function os(e){let t=e[0],n=1,r=2,s="",o=!1;for(;n<e.length;){let i=e[n];if("string"==typeof i)if(2&r){const t=e[++n];s+="["+i+(t.length>0?'="'+t+'"':"")+"]"}else 8&r?s+="."+i:4&r&&(s+=" "+i);else""===s||ts(i)||(t+=ss(o,s),s=""),r=i,o=o||!ts(r);n++}return""!==s&&(t+=ss(o,s)),t}const is={};function as(e){us(Ht(),jt(),hn()+e,Yt())}function us(e,t,n,r){if(!r)if(3==(3&t[2])){const r=e.preOrderCheckHooks;null!==r&&fn(t,r,n)}else{const r=e.preOrderHooks;null!==r&&mn(t,r,0,n)}dn(n)}function ls(e,t){const n=e.contentQueries;if(null!==n)for(let r=0;r<n.length;r+=2){const s=n[r],o=n[r+1];if(-1!==o){const n=e.data[o];tn(s),n.contentQueries(2,t[o],o)}}}function cs(e,t,n,r,s,o,i,a,u,l){const c=t.blueprint.slice();return c[0]=s,c[2]=140|r,Vt(c),c[3]=c[15]=e,c[8]=n,c[10]=i||e&&e[10],c[11]=a||e&&e[11],c[12]=u||e&&e[12]||null,c[9]=l||e&&e[9]||null,c[6]=o,c[16]=2==t.type?e[16]:c,c}function hs(e,t,n,r,s){let o=e.data[t];if(null===o)o=function(e,t,n,r,s){const o=qt(),i=Xt(),a=e.data[t]=function(e,t,n,r,s,o){return{type:n,index:r,insertBeforeIndex:null,injectorIndex:t?t.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,propertyBindings:null,flags:0,providerIndexes:0,value:s,attrs:o,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,i?o:o&&o.parent,n,t,r,s);return null===e.firstChild&&(e.firstChild=a),null!==o&&(i?null==o.child&&null!==a.parent&&(o.child=a):null===o.next&&(o.next=a)),a}(e,t,n,r,s),zt.lFrame.inI18n&&(o.flags|=64);else if(64&o.type){o.type=n,o.value=r,o.attrs=s;const e=function(){const e=zt.lFrame,t=e.currentTNode;return e.isParent?t:t.parent}();o.injectorIndex=null===e?-1:e.injectorIndex}return Kt(o,!0),o}function ds(e,t,n,r){if(0===n)return-1;const s=t.length;for(let o=0;o<n;o++)t.push(r),e.blueprint.push(r),e.data.push(null);return s}function ps(e,t,n){sn(t);try{const r=e.viewQuery;null!==r&&Vs(1,r,n);const s=e.template;null!==s&&gs(e,t,s,1,n),e.firstCreatePass&&(e.firstCreatePass=!1),e.staticContentQueries&&ls(e,t),e.staticViewQueries&&Vs(2,e.viewQuery,n);const o=e.components;null!==o&&function(e,t){for(let n=0;n<t.length;n++)Ps(e,t[n])}(t,o)}catch(r){throw e.firstCreatePass&&(e.incompleteFirstPass=!0),r}finally{t[2]&=-5,cn()}}function fs(e,t,n,r){const s=t[2];if(256==(256&s))return;sn(t);const o=Yt();try{Vt(t),zt.lFrame.bindingIndex=e.bindingStartIndex,null!==n&&gs(e,t,n,2,r);const i=3==(3&s);if(!o)if(i){const n=e.preOrderCheckHooks;null!==n&&fn(t,n,null)}else{const n=e.preOrderHooks;null!==n&&mn(t,n,0,null),gn(t,0)}if(function(e){for(let t=Tr(e);null!==t;t=Ir(t)){if(!t[2])continue;const e=t[9];for(let t=0;t<e.length;t++){const n=e[t],r=n[3];0==(1024&n[2])&&Ut(r,1),n[2]|=1024}}}(t),function(e){for(let t=Tr(e);null!==t;t=Ir(t))for(let e=xt;e<t.length;e++){const n=t[e],r=n[1];Lt(n)&&fs(r,n,r.template,n[8])}}(t),null!==e.contentQueries&&ls(e,t),!o)if(i){const n=e.contentCheckHooks;null!==n&&fn(t,n)}else{const n=e.contentHooks;null!==n&&mn(t,n,1),gn(t,1)}!function(e,t){const n=e.hostBindingOpCodes;if(null!==n)try{for(let e=0;e<n.length;e++){const r=n[e];if(r<0)dn(~r);else{const s=r,o=n[++e],i=n[++e];Zt(o,s),i(2,t[s])}}}finally{dn(-1)}}(e,t);const a=e.components;null!==a&&function(e,t){for(let n=0;n<t.length;n++)Fs(e,t[n])}(t,a);const u=e.viewQuery;if(null!==u&&Vs(2,u,r),!o)if(i){const n=e.viewCheckHooks;null!==n&&fn(t,n)}else{const n=e.viewHooks;null!==n&&mn(t,n,2),gn(t,2)}!0===e.firstUpdatePass&&(e.firstUpdatePass=!1),o||(t[2]&=-73),1024&t[2]&&(t[2]&=-1025,Ut(t[3],-1))}finally{cn()}}function ms(e,t,n,r){const s=t[10],o=!Yt(),i=Mt(t);try{o&&!i&&s.begin&&s.begin(),i&&ps(e,t,r),fs(e,t,n,r)}finally{o&&!i&&s.end&&s.end()}}function gs(e,t,n,r,s){const o=hn(),i=2&r;try{dn(-1),i&&t.length>yt&&us(e,t,yt,Yt()),n(r,s)}finally{dn(o)}}function ys(e,t,n){Wt()&&(function(e,t,n,r){const s=n.directiveStart,o=n.directiveEnd;e.firstCreatePass||An(n,t),gr(r,t);const i=n.initialInputs;for(let a=s;a<o;a++){const r=e.data[a],o=kt(r);o&&$s(t,n,r);const u=jn(t,e,a,n);gr(u,t),null!==i&&Rs(0,a-s,u,r,0,i),o&&(Pt(n.index,t)[8]=u)}}(e,t,n,Ft(n,t)),128==(128&n.flags)&&function(e,t,n){const r=n.directiveStart,s=n.directiveEnd,o=n.index,i=zt.lFrame.currentDirectiveIndex;try{dn(o);for(let n=r;n<s;n++){const r=e.data[n],s=t[n];Jt(n),null===r.hostBindings&&0===r.hostVars&&null===r.hostAttrs||Es(r,s)}}finally{dn(-1),Jt(i)}}(e,t,n))}function xs(e,t,n=Ft){const r=t.localNames;if(null!==r){let s=t.index+1;for(let o=0;o<r.length;o+=2){const i=r[o+1],a=-1===i?n(t,e):e[i];e[s++]=a}}}function bs(e){const t=e.tView;return null===t||t.incompleteFirstPass?e.tView=vs(1,null,e.template,e.decls,e.vars,e.directiveDefs,e.pipeDefs,e.viewQuery,e.schemas,e.consts):t}function vs(e,t,n,r,s,o,i,a,u,l){const c=yt+r,h=c+s,d=function(e,t){const n=[];for(let r=0;r<t;r++)n.push(r<e?null:is);return n}(c,h),p="function"==typeof l?l():l;return d[1]={type:e,blueprint:d,template:n,queries:null,viewQuery:a,declTNode:t,data:d.slice().fill(null,c),bindingStartIndex:c,expandoStartIndex:h,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof o?o():o,pipeRegistry:"function"==typeof i?i():i,firstChild:null,schemas:u,consts:p,incompleteFirstPass:!1}}function ws(e,t,n,r){const s=(o=t)[7]||(o[7]=[]);var o;null===n?s.push(r):(s.push(n),e.firstCreatePass&&function(e){return e.cleanup||(e.cleanup=[])}(e).push(r,s.length-1))}function Cs(e,t,n){for(let r in e)if(e.hasOwnProperty(r)){const s=e[r];(n=null===n?{}:n).hasOwnProperty(r)?n[r].push(t,s):n[r]=[t,s]}return n}function _s(e,t,n,r){let s=!1;if(Wt()){const o=function(e,t,n){const r=e.directiveRegistry;let s=null;if(r)for(let o=0;o<r.length;o++){const i=r[o];rs(n,i.selectors,!1)&&(s||(s=[]),Pn(An(n,t),e,i.type),kt(i)?(Ss(e,n),s.unshift(i)):s.push(i))}return s}(e,t,n),i=null===r?null:{"":-1};if(null!==o){s=!0,Is(n,e.data.length,o.length);for(let e=0;e<o.length;e++){const t=o[e];t.providersResolver&&t.providersResolver(t)}let r=!1,a=!1,u=ds(e,t,o.length,null);for(let s=0;s<o.length;s++){const l=o[s];n.mergedAttrs=kn(n.mergedAttrs,l.hostAttrs),Ns(e,n,t,u,l),Ts(u,l,i),null!==l.contentQueries&&(n.flags|=8),null===l.hostBindings&&null===l.hostAttrs&&0===l.hostVars||(n.flags|=128);const c=l.type.prototype;!r&&(c.ngOnChanges||c.ngOnInit||c.ngDoCheck)&&((e.preOrderHooks||(e.preOrderHooks=[])).push(n.index),r=!0),a||!c.ngOnChanges&&!c.ngDoCheck||((e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(n.index),a=!0),u++}!function(e,t){const n=t.directiveEnd,r=e.data,s=t.attrs,o=[];let i=null,a=null;for(let u=t.directiveStart;u<n;u++){const e=r[u],n=e.inputs,l=null===s||Zr(t)?null:As(n,s);o.push(l),i=Cs(n,u,i),a=Cs(e.outputs,u,a)}null!==i&&(i.hasOwnProperty("class")&&(t.flags|=16),i.hasOwnProperty("style")&&(t.flags|=32)),t.initialInputs=o,t.inputs=i,t.outputs=a}(e,n)}i&&function(e,t,n){if(t){const r=e.localNames=[];for(let e=0;e<t.length;e+=2){const s=n[t[e+1]];if(null==s)throw new Te("301",`Export of name '${t[e+1]}' not found!`);r.push(t[e],s)}}}(n,r,i)}return n.mergedAttrs=kn(n.mergedAttrs,n.attrs),s}function ks(e,t,n,r,s,o){const i=o.hostBindings;if(i){let n=e.hostBindingOpCodes;null===n&&(n=e.hostBindingOpCodes=[]);const o=~t.index;(function(e){let t=e.length;for(;t>0;){const n=e[--t];if("number"==typeof n&&n<0)return n}return 0})(n)!=o&&n.push(o),n.push(r,s,i)}}function Es(e,t){null!==e.hostBindings&&e.hostBindings(1,t)}function Ss(e,t){t.flags|=2,(e.components||(e.components=[])).push(t.index)}function Ts(e,t,n){if(n){if(t.exportAs)for(let r=0;r<t.exportAs.length;r++)n[t.exportAs[r]]=e;kt(t)&&(n[""]=e)}}function Is(e,t,n){e.flags|=1,e.directiveStart=t,e.directiveEnd=t+n,e.providerIndexes=t}function Ns(e,t,n,r,s){e.data[r]=s;const o=s.factory||(s.factory=Et(s.type)),i=new vn(o,kt(s),null);e.blueprint[r]=i,n[r]=i,ks(e,t,0,r,ds(e,n,s.hostVars,is),s)}function $s(e,t,n){const r=Ft(t,e),s=bs(n),o=e[10],i=Ms(e,cs(e,s,null,n.onPush?64:16,r,t,o,o.createRenderer(r,n),null,null));e[t.index]=i}function Rs(e,t,n,r,s,o){const i=o[t];if(null!==i){const e=r.setInput;for(let t=0;t<i.length;){const s=i[t++],o=i[t++],a=i[t++];null!==e?r.setInput(n,a,s,o):n[o]=a}}}function As(e,t){let n=null,r=0;for(;r<t.length;){const s=t[r];if(0!==s)if(5!==s){if("number"==typeof s)break;e.hasOwnProperty(s)&&(null===n&&(n=[]),n.push(s,e[s],t[r+1])),r+=2}else r+=2;else r+=4}return n}function Os(e,t,n,r){return new Array(e,!0,!1,t,null,0,r,n,null,null)}function Fs(e,t){const n=Pt(t,e);if(Lt(n)){const e=n[1];80&n[2]?fs(e,n,e.template,n[8]):n[5]>0&&Ds(n)}}function Ds(e){for(let n=Tr(e);null!==n;n=Ir(n))for(let e=xt;e<n.length;e++){const t=n[e];if(1024&t[2]){const e=t[1];fs(e,t,e.template,t[8])}else t[5]>0&&Ds(t)}const t=e[1].components;if(null!==t)for(let n=0;n<t.length;n++){const r=Pt(t[n],e);Lt(r)&&r[5]>0&&Ds(r)}}function Ps(e,t){const n=Pt(t,e),r=n[1];!function(e,t){for(let n=t.length;n<e.blueprint.length;n++)t.push(e.blueprint[n])}(r,n),ps(r,n,n[8])}function Ms(e,t){return e[13]?e[14][4]=t:e[13]=t,e[14]=t,t}function Ls(e,t,n){const r=t[10];r.begin&&r.begin();try{fs(e,t,e.template,n)}catch(s){throw function(e,t){const n=e[9],r=n?n.get(wr,null):null;r&&r.handleError(t)}(t,s),s}finally{r.end&&r.end()}}function Bs(e){!function(e){for(let t=0;t<e.components.length;t++){const n=e.components[t],r=yr(n),s=r[1];ms(s,r,s.template,n)}}(e[8])}function Vs(e,t,n){tn(0),t(e,n)}const Us=(()=>Promise.resolve(null))();function zs(e,t,n,r,s){for(let o=0;o<n.length;){const i=n[o++],a=n[o++],u=t[i],l=e.data[i];null!==l.setInput?l.setInput(u,s,r,a):u[a]=s}}function Ws(e,t,n){let r=n?e.styles:null,s=n?e.classes:null,o=0;if(null!==t)for(let i=0;i<t.length;i++){const e=t[i];"number"==typeof e?o=e:1==o?s=_e(s,e):2==o&&(r=_e(r,e+": "+t[++i]+";"))}n?e.styles=r:e.stylesWithoutHost=r,n?e.classes=s:e.classesWithoutHost=s}const js=new Yn("INJECTOR",-1);class Hs{get(e,t=rr){if(t===rr){const t=new Error(`NullInjectorError: No provider for ${Ce(e)}!`);throw t.name="NullInjectorError",t}return t}}const Gs=new Yn("Set Injector scope."),qs={},Ks={};let Xs;function Ys(){return void 0===Xs&&(Xs=new Hs),Xs}function Qs(e,t=null,n=null,r){return new Zs(e,n,t||Ys(),r)}class Zs{constructor(e,t,n,r=null){this.parent=n,this.records=new Map,this.injectorDefTypes=new Set,this.onDestroy=new Set,this._destroyed=!1;const s=[];t&&er(t,n=>this.processProvider(n,e,t)),er([e],e=>this.processInjectorType(e,[],s)),this.records.set(js,eo(void 0,this));const o=this.records.get(Gs);this.scope=null!=o?o.value:null,this.source=r||("object"==typeof e?null:Ce(e))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{this.onDestroy.forEach(e=>e.ngOnDestroy())}finally{this.records.clear(),this.onDestroy.clear(),this.injectorDefTypes.clear()}}get(e,t=rr,n=Ve.Default){this.assertNotDestroyed();const r=ur(this);try{if(!(n&Ve.SkipSelf)){let t=this.records.get(e);if(void 0===t){const n=("function"==typeof(s=e)||"object"==typeof s&&s instanceof Yn)&&Oe(e);t=n&&this.injectableDefInScope(n)?eo(Js(e),qs):null,this.records.set(e,t)}if(null!=t)return this.hydrate(e,t)}return(n&Ve.Self?Ys():this.parent).get(e,t=n&Ve.Optional&&t===rr?null:t)}catch(o){if("NullInjectorError"===o.name){if((o.ngTempTokenPath=o.ngTempTokenPath||[]).unshift(Ce(e)),r)throw o;return function(e,t,n,r){const s=e.ngTempTokenPath;throw t[or]&&s.unshift(t[or]),e.message=function(e,t,n,r=null){e=e&&"\n"===e.charAt(0)&&"\u0275"==e.charAt(1)?e.substr(2):e;let s=Ce(t);if(Array.isArray(t))s=t.map(Ce).join(" -> ");else if("object"==typeof t){let e=[];for(let n in t)if(t.hasOwnProperty(n)){let r=t[n];e.push(n+":"+("string"==typeof r?JSON.stringify(r):Ce(r)))}s=`{${e.join(", ")}}`}return`${n}${r?"("+r+")":""}[${s}]: ${e.replace(sr,"\n  ")}`}("\n"+e.message,s,n,r),e.ngTokenPath=s,e.ngTempTokenPath=null,e}(o,e,"R3InjectorError",this.source)}throw o}finally{ur(r)}var s}_resolveInjectorDefTypes(){this.injectorDefTypes.forEach(e=>this.get(e))}toString(){const e=[];return this.records.forEach((t,n)=>e.push(Ce(n))),`R3Injector[${e.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new Error("Injector has already been destroyed.")}processInjectorType(e,t,n){if(!(e=Se(e)))return!1;let r=De(e);const s=null==r&&e.ngModule||void 0,o=void 0===s?e:s,i=-1!==n.indexOf(o);if(void 0!==s&&(r=De(s)),null==r)return!1;if(null!=r.imports&&!i){let e;n.push(o);try{er(r.imports,r=>{this.processInjectorType(r,t,n)&&(void 0===e&&(e=[]),e.push(r))})}finally{}if(void 0!==e)for(let t=0;t<e.length;t++){const{ngModule:n,providers:r}=e[t];er(r,e=>this.processProvider(e,n,r||Je))}}this.injectorDefTypes.add(o);const a=Et(o)||(()=>new o);this.records.set(o,eo(a,qs));const u=r.providers;if(null!=u&&!i){const t=e;er(u,e=>this.processProvider(e,t,u))}return void 0!==s&&void 0!==e.providers}processProvider(e,t,n){let r=no(e=Se(e))?e:Se(e&&e.provide);const s=function(e,t,n){return to(e)?eo(void 0,e.useValue):eo(function(e,t,n){let r;if(no(e)){const t=Se(e);return Et(t)||Js(t)}if(to(e))r=()=>Se(e.useValue);else if((s=e)&&s.useFactory)r=()=>e.useFactory(...hr(e.deps||[]));else if(function(e){return!(!e||!e.useExisting)}(e))r=()=>cr(Se(e.useExisting));else{const t=Se(e&&(e.useClass||e.provide));if(!function(e){return!!e.deps}(e))return Et(t)||Js(t);r=()=>new t(...hr(e.deps))}var s;return r}(e),qs)}(e);if(no(e)||!0!==e.multi)this.records.get(r);else{let t=this.records.get(r);t||(t=eo(void 0,qs,!0),t.factory=()=>hr(t.multi),this.records.set(r,t)),r=e,t.multi.push(e)}this.records.set(r,s)}hydrate(e,t){var n;return t.value===qs&&(t.value=Ks,t.value=t.factory()),"object"==typeof t.value&&t.value&&null!==(n=t.value)&&"object"==typeof n&&"function"==typeof n.ngOnDestroy&&this.onDestroy.add(t.value),t.value}injectableDefInScope(e){if(!e.providedIn)return!1;const t=Se(e.providedIn);return"string"==typeof t?"any"===t||t===this.scope:this.injectorDefTypes.has(t)}}function Js(e){const t=Oe(e),n=null!==t?t.factory:Et(e);if(null!==n)return n;if(e instanceof Yn)throw new Error(`Token ${Ce(e)} is missing a \u0275prov definition.`);if(e instanceof Function)return function(e){const t=e.length;if(t>0){const n=function(e,t){const n=[];for(let r=0;r<e;r++)n.push("?");return n}(t);throw new Error(`Can't resolve all parameters for ${Ce(e)}: (${n.join(", ")}).`)}const n=function(e){const t=e&&(e[Pe]||e[Le]);if(t){const n=function(e){if(e.hasOwnProperty("name"))return e.name;const t=(""+e).match(/^function\s*([^\s(]+)/);return null===t?"":t[1]}(e);return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`),t}return null}(e);return null!==n?()=>n.factory(e):()=>new e}(e);throw new Error("unreachable")}function eo(e,t,n=!1){return{factory:e,value:t,multi:n?[]:void 0}}function to(e){return null!==e&&"object"==typeof e&&ir in e}function no(e){return"function"==typeof e}const ro=function(e,t,n){return function(e,t=null,n=null,r){const s=Qs(e,t,n,r);return s._resolveInjectorDefTypes(),s}({name:n},t,e,n)};class so{static create(e,t){return Array.isArray(e)?ro(e,t,""):ro(e.providers,e.parent,e.name||"")}}function oo(e,t){pn(yr(e)[1],Gt())}so.THROW_IF_NOT_FOUND=rr,so.NULL=new Hs,so.\u0275prov=Re({token:so,providedIn:"any",factory:()=>cr(js)}),so.__NG_ELEMENT_ID__=-1;let io=null;function ao(){if(!io){const e=Qe.Symbol;if(e&&e.iterator)io=e.iterator;else{const e=Object.getOwnPropertyNames(Map.prototype);for(let t=0;t<e.length;++t){const n=e[t];"entries"!==n&&"size"!==n&&Map.prototype[n]===Map.prototype.entries&&(io=n)}}}return io}function uo(e){return!!lo(e)&&(Array.isArray(e)||!(e instanceof Map)&&ao()in e)}function lo(e){return null!==e&&("function"==typeof e||"object"==typeof e)}function co(e,t,n){return!Object.is(e[t],n)&&(e[t]=n,!0)}function ho(e,t,n,r,s,o,i,a){const u=function(e,t,n,r,s){const o=function(e,t,n,r){const s=co(e,t,n);return co(e,t+1,r)||s}(e,t,n,r);return co(e,t+2,s)||o}(e,zt.lFrame.bindingIndex,n,s,i);return function(e){const t=zt.lFrame;t.bindingIndex=t.bindingIndex+3}(),u?t+Ie(n)+r+Ie(s)+o+Ie(i)+a:is}function po(e,t,n,r,s,o,i,a){const u=jt(),l=Ht(),c=e+yt,h=l.firstCreatePass?function(e,t,n,r,s,o,i,a,u){const l=t.consts,c=hs(t,e,4,i||null,Bt(l,a));_s(t,n,c,Bt(l,u)),pn(t,c);const h=c.tViews=vs(2,c,r,s,o,t.directiveRegistry,t.pipeRegistry,null,t.schemas,l);return null!==t.queries&&(t.queries.template(t,c),h.queries=t.queries.embeddedTView(c)),c}(c,l,u,t,n,r,s,o,i):l.data[c];Kt(h,!1);const d=u[11].createComment("");Vr(l,u,d,h),gr(d,u),Ms(u,u[c]=Os(d,u,d,h)),_t(h)&&ys(l,u,h),null!=i&&xs(u,h,a)}function fo(e,t=Ve.Default){const n=jt();return null===n?cr(e,t):Bn(Gt(),n,Se(e),t)}function mo(e,t,n){const r=jt();return co(r,zt.lFrame.bindingIndex++,t)&&function(e,t,n,r,s,o,i,a){const u=Ft(t,n);let l,c=t.inputs;var h;null!=c&&(l=c[r])?(zs(e,n,l,r,s),Ct(t)&&function(e,t){const n=Pt(t,e);16&n[2]||(n[2]|=64)}(n,t.index)):3&t.type&&(r="class"===(h=r)?"className":"for"===h?"htmlFor":"formaction"===h?"formAction":"innerHtml"===h?"innerHTML":"readonly"===h?"readOnly":"tabindex"===h?"tabIndex":h,s=null!=i?i(s,t.value||"",r):s,Rt(o)?o.setProperty(u,r,s):_n(r)||(u.setProperty?u.setProperty(r,s):u[r]=s))}(Ht(),function(){const e=zt.lFrame;return Dt(e.tView,e.selectedIndex)}(),r,e,t,r[11],n),mo}function go(e,t,n,r,s){const o=s?"class":"style";zs(e,n,t.inputs[o],o,r)}function yo(e,t,n,r){const s=jt(),o=Ht(),i=yt+e,a=s[11],u=s[i]=Rr(a,t,zt.lFrame.currentNamespace),l=o.firstCreatePass?function(e,t,n,r,s,o,i){const a=t.consts,u=hs(t,e,2,s,Bt(a,o));return _s(t,n,u,Bt(a,i)),null!==u.attrs&&Ws(u,u.attrs,!1),null!==u.mergedAttrs&&Ws(u,u.mergedAttrs,!0),null!==t.queries&&t.queries.elementStart(t,u),u}(i,o,s,0,t,n,r):o.data[i];Kt(l,!0);const c=l.mergedAttrs;null!==c&&wn(a,u,c);const h=l.classes;null!==h&&Kr(a,u,h);const d=l.styles;null!==d&&qr(a,u,d),64!=(64&l.flags)&&Vr(o,s,u,l),0===zt.lFrame.elementDepthCount&&gr(u,s),zt.lFrame.elementDepthCount++,_t(l)&&(ys(o,s,l),function(e,t,n){if(wt(t)){const r=t.directiveEnd;for(let s=t.directiveStart;s<r;s++){const t=e.data[s];t.contentQueries&&t.contentQueries(1,n[s],s)}}}(o,l,s)),null!==r&&xs(s,l)}function xo(){let e=Gt();Xt()?zt.lFrame.isParent=!1:(e=e.parent,Kt(e,!1));const t=e;zt.lFrame.elementDepthCount--;const n=Ht();n.firstCreatePass&&(pn(n,e),wt(e)&&n.queries.elementEnd(e)),null!=t.classesWithoutHost&&function(e){return 0!=(16&e.flags)}(t)&&go(n,t,jt(),t.classesWithoutHost,!0),null!=t.stylesWithoutHost&&function(e){return 0!=(32&e.flags)}(t)&&go(n,t,jt(),t.stylesWithoutHost,!1)}function bo(e,t,n,r){yo(e,t,n,r),xo()}function vo(e){return!!e&&"function"==typeof e.then}const wo=function(e){return!!e&&"function"==typeof e.subscribe};function Co(e,t=""){const n=jt(),r=Ht(),s=e+yt,o=r.firstCreatePass?hs(r,s,1,t,null):r.data[s],i=n[s]=function(e,t){return Rt(e)?e.createText(t):e.createTextNode(t)}(n[11],t);Vr(r,n,i,o),Kt(o,!1)}function _o(e,t,n,r,s,o,i){const a=jt(),u=ho(a,e,t,n,r,s,o,i);return u!==is&&function(e,t,n){const r=function(e,t){return Ot(t[e])}(t,e);!function(e,t,n){Rt(e)?e.setValue(t,n):t.textContent=n}(e[11],r,n)}(a,hn(),u),_o}const ko=void 0;var Eo=["en",[["a","p"],["AM","PM"],ko],[["AM","PM"],ko,ko],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],ko,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],ko,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",ko,"{1} 'at' {0}",ko],[".",",",";","%","+","-","E","\xd7","\u2030","\u221e","NaN",":"],["#,##0.###","#,##0%","\xa4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function(e){let t=Math.floor(Math.abs(e)),n=e.toString().replace(/^[^.]*\.?/,"").length;return 1===t&&0===n?1:5}];let So={};function To(e){return e in So||(So[e]=Qe.ng&&Qe.ng.common&&Qe.ng.common.locales&&Qe.ng.common.locales[e]),So[e]}var Io=(()=>((Io=Io||{})[Io.LocaleId=0]="LocaleId",Io[Io.DayPeriodsFormat=1]="DayPeriodsFormat",Io[Io.DayPeriodsStandalone=2]="DayPeriodsStandalone",Io[Io.DaysFormat=3]="DaysFormat",Io[Io.DaysStandalone=4]="DaysStandalone",Io[Io.MonthsFormat=5]="MonthsFormat",Io[Io.MonthsStandalone=6]="MonthsStandalone",Io[Io.Eras=7]="Eras",Io[Io.FirstDayOfWeek=8]="FirstDayOfWeek",Io[Io.WeekendRange=9]="WeekendRange",Io[Io.DateFormat=10]="DateFormat",Io[Io.TimeFormat=11]="TimeFormat",Io[Io.DateTimeFormat=12]="DateTimeFormat",Io[Io.NumberSymbols=13]="NumberSymbols",Io[Io.NumberFormats=14]="NumberFormats",Io[Io.CurrencyCode=15]="CurrencyCode",Io[Io.CurrencySymbol=16]="CurrencySymbol",Io[Io.CurrencyName=17]="CurrencyName",Io[Io.Currencies=18]="Currencies",Io[Io.Directionality=19]="Directionality",Io[Io.PluralCase=20]="PluralCase",Io[Io.ExtraData=21]="ExtraData",Io))();const No="en-US";let $o=No;function Ro(e){var t,n;n="Expected localeId to be defined",null==(t=e)&&function(e,t,n,r){throw new Error(`ASSERTION ERROR: ${e} [Expected=> null != ${t} <=Actual]`)}(n,t),"string"==typeof e&&($o=e.toLowerCase().replace(/_/g,"-"))}class Ao{}class Oo{resolveComponentFactory(e){throw function(e){const t=Error(`No component factory found for ${Ce(e)}. Did you add it to @NgModule.entryComponents?`);return t.ngComponent=e,t}(e)}}class Fo{}function Do(...e){}function Po(e,t){return new Lo(Ft(e,t))}Fo.NULL=new Oo;const Mo=function(){return Po(Gt(),jt())};let Lo=(()=>{class e{constructor(e){this.nativeElement=e}}return e.__NG_ELEMENT_ID__=Mo,e})();function Bo(e){return e instanceof Lo?e.nativeElement:e}class Vo{}let Uo=(()=>{class e{}return e.\u0275prov=Re({token:e,providedIn:"root",factory:()=>null}),e})();class zo{constructor(e){this.full=e,this.major=e.split(".")[0],this.minor=e.split(".")[1],this.patch=e.split(".").slice(2).join(".")}}const Wo=new zo("12.1.1");class jo{constructor(){}supports(e){return uo(e)}create(e){return new Go(e)}}const Ho=(e,t)=>t;class Go{constructor(e){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=e||Ho}forEachItem(e){let t;for(t=this._itHead;null!==t;t=t._next)e(t)}forEachOperation(e){let t=this._itHead,n=this._removalsHead,r=0,s=null;for(;t||n;){const o=!n||t&&t.currentIndex<Yo(n,r,s)?t:n,i=Yo(o,r,s),a=o.currentIndex;if(o===n)r--,n=n._nextRemoved;else if(t=t._next,null==o.previousIndex)r++;else{s||(s=[]);const e=i-r,t=a-r;if(e!=t){for(let n=0;n<e;n++){const r=n<s.length?s[n]:s[n]=0,o=r+n;t<=o&&o<e&&(s[n]=r+1)}s[o.previousIndex]=t-e}}i!==a&&e(o,i,a)}}forEachPreviousItem(e){let t;for(t=this._previousItHead;null!==t;t=t._nextPrevious)e(t)}forEachAddedItem(e){let t;for(t=this._additionsHead;null!==t;t=t._nextAdded)e(t)}forEachMovedItem(e){let t;for(t=this._movesHead;null!==t;t=t._nextMoved)e(t)}forEachRemovedItem(e){let t;for(t=this._removalsHead;null!==t;t=t._nextRemoved)e(t)}forEachIdentityChange(e){let t;for(t=this._identityChangesHead;null!==t;t=t._nextIdentityChange)e(t)}diff(e){if(null==e&&(e=[]),!uo(e))throw new Error(`Error trying to diff '${Ce(e)}'. Only arrays and iterables are allowed`);return this.check(e)?this:null}onDestroy(){}check(e){this._reset();let t,n,r,s=this._itHead,o=!1;if(Array.isArray(e)){this.length=e.length;for(let t=0;t<this.length;t++)n=e[t],r=this._trackByFn(t,n),null!==s&&Object.is(s.trackById,r)?(o&&(s=this._verifyReinsertion(s,n,r,t)),Object.is(s.item,n)||this._addIdentityChange(s,n)):(s=this._mismatch(s,n,r,t),o=!0),s=s._next}else t=0,function(e,t){if(Array.isArray(e))for(let n=0;n<e.length;n++)t(e[n]);else{const n=e[ao()]();let r;for(;!(r=n.next()).done;)t(r.value)}}(e,e=>{r=this._trackByFn(t,e),null!==s&&Object.is(s.trackById,r)?(o&&(s=this._verifyReinsertion(s,e,r,t)),Object.is(s.item,e)||this._addIdentityChange(s,e)):(s=this._mismatch(s,e,r,t),o=!0),s=s._next,t++}),this.length=t;return this._truncate(s),this.collection=e,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let e;for(e=this._previousItHead=this._itHead;null!==e;e=e._next)e._nextPrevious=e._next;for(e=this._additionsHead;null!==e;e=e._nextAdded)e.previousIndex=e.currentIndex;for(this._additionsHead=this._additionsTail=null,e=this._movesHead;null!==e;e=e._nextMoved)e.previousIndex=e.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(e,t,n,r){let s;return null===e?s=this._itTail:(s=e._prev,this._remove(e)),null!==(e=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null))?(Object.is(e.item,t)||this._addIdentityChange(e,t),this._reinsertAfter(e,s,r)):null!==(e=null===this._linkedRecords?null:this._linkedRecords.get(n,r))?(Object.is(e.item,t)||this._addIdentityChange(e,t),this._moveAfter(e,s,r)):e=this._addAfter(new qo(t,n),s,r),e}_verifyReinsertion(e,t,n,r){let s=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null);return null!==s?e=this._reinsertAfter(s,e._prev,r):e.currentIndex!=r&&(e.currentIndex=r,this._addToMoves(e,r)),e}_truncate(e){for(;null!==e;){const t=e._next;this._addToRemovals(this._unlink(e)),e=t}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(e,t,n){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(e);const r=e._prevRemoved,s=e._nextRemoved;return null===r?this._removalsHead=s:r._nextRemoved=s,null===s?this._removalsTail=r:s._prevRemoved=r,this._insertAfter(e,t,n),this._addToMoves(e,n),e}_moveAfter(e,t,n){return this._unlink(e),this._insertAfter(e,t,n),this._addToMoves(e,n),e}_addAfter(e,t,n){return this._insertAfter(e,t,n),this._additionsTail=null===this._additionsTail?this._additionsHead=e:this._additionsTail._nextAdded=e,e}_insertAfter(e,t,n){const r=null===t?this._itHead:t._next;return e._next=r,e._prev=t,null===r?this._itTail=e:r._prev=e,null===t?this._itHead=e:t._next=e,null===this._linkedRecords&&(this._linkedRecords=new Xo),this._linkedRecords.put(e),e.currentIndex=n,e}_remove(e){return this._addToRemovals(this._unlink(e))}_unlink(e){null!==this._linkedRecords&&this._linkedRecords.remove(e);const t=e._prev,n=e._next;return null===t?this._itHead=n:t._next=n,null===n?this._itTail=t:n._prev=t,e}_addToMoves(e,t){return e.previousIndex===t||(this._movesTail=null===this._movesTail?this._movesHead=e:this._movesTail._nextMoved=e),e}_addToRemovals(e){return null===this._unlinkedRecords&&(this._unlinkedRecords=new Xo),this._unlinkedRecords.put(e),e.currentIndex=null,e._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=e,e._prevRemoved=null):(e._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=e),e}_addIdentityChange(e,t){return e.item=t,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=e:this._identityChangesTail._nextIdentityChange=e,e}}class qo{constructor(e,t){this.item=e,this.trackById=t,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class Ko{constructor(){this._head=null,this._tail=null}add(e){null===this._head?(this._head=this._tail=e,e._nextDup=null,e._prevDup=null):(this._tail._nextDup=e,e._prevDup=this._tail,e._nextDup=null,this._tail=e)}get(e,t){let n;for(n=this._head;null!==n;n=n._nextDup)if((null===t||t<=n.currentIndex)&&Object.is(n.trackById,e))return n;return null}remove(e){const t=e._prevDup,n=e._nextDup;return null===t?this._head=n:t._nextDup=n,null===n?this._tail=t:n._prevDup=t,null===this._head}}class Xo{constructor(){this.map=new Map}put(e){const t=e.trackById;let n=this.map.get(t);n||(n=new Ko,this.map.set(t,n)),n.add(e)}get(e,t){const n=this.map.get(e);return n?n.get(e,t):null}remove(e){const t=e.trackById;return this.map.get(t).remove(e)&&this.map.delete(t),e}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function Yo(e,t,n){const r=e.previousIndex;if(null===r)return r;let s=0;return n&&r<n.length&&(s=n[r]),r+t+s}class Qo{constructor(){}supports(e){return e instanceof Map||lo(e)}create(){return new Zo}}class Zo{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(e){let t;for(t=this._mapHead;null!==t;t=t._next)e(t)}forEachPreviousItem(e){let t;for(t=this._previousMapHead;null!==t;t=t._nextPrevious)e(t)}forEachChangedItem(e){let t;for(t=this._changesHead;null!==t;t=t._nextChanged)e(t)}forEachAddedItem(e){let t;for(t=this._additionsHead;null!==t;t=t._nextAdded)e(t)}forEachRemovedItem(e){let t;for(t=this._removalsHead;null!==t;t=t._nextRemoved)e(t)}diff(e){if(e){if(!(e instanceof Map||lo(e)))throw new Error(`Error trying to diff '${Ce(e)}'. Only maps and objects are allowed`)}else e=new Map;return this.check(e)?this:null}onDestroy(){}check(e){this._reset();let t=this._mapHead;if(this._appendAfter=null,this._forEach(e,(e,n)=>{if(t&&t.key===n)this._maybeAddToChanges(t,e),this._appendAfter=t,t=t._next;else{const r=this._getOrCreateRecordForKey(n,e);t=this._insertBeforeOrAppend(t,r)}}),t){t._prev&&(t._prev._next=null),this._removalsHead=t;for(let e=t;null!==e;e=e._nextRemoved)e===this._mapHead&&(this._mapHead=null),this._records.delete(e.key),e._nextRemoved=e._next,e.previousValue=e.currentValue,e.currentValue=null,e._prev=null,e._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(e,t){if(e){const n=e._prev;return t._next=e,t._prev=n,e._prev=t,n&&(n._next=t),e===this._mapHead&&(this._mapHead=t),this._appendAfter=e,e}return this._appendAfter?(this._appendAfter._next=t,t._prev=this._appendAfter):this._mapHead=t,this._appendAfter=t,null}_getOrCreateRecordForKey(e,t){if(this._records.has(e)){const n=this._records.get(e);this._maybeAddToChanges(n,t);const r=n._prev,s=n._next;return r&&(r._next=s),s&&(s._prev=r),n._next=null,n._prev=null,n}const n=new Jo(e);return this._records.set(e,n),n.currentValue=t,this._addToAdditions(n),n}_reset(){if(this.isDirty){let e;for(this._previousMapHead=this._mapHead,e=this._previousMapHead;null!==e;e=e._next)e._nextPrevious=e._next;for(e=this._changesHead;null!==e;e=e._nextChanged)e.previousValue=e.currentValue;for(e=this._additionsHead;null!=e;e=e._nextAdded)e.previousValue=e.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(e,t){Object.is(t,e.currentValue)||(e.previousValue=e.currentValue,e.currentValue=t,this._addToChanges(e))}_addToAdditions(e){null===this._additionsHead?this._additionsHead=this._additionsTail=e:(this._additionsTail._nextAdded=e,this._additionsTail=e)}_addToChanges(e){null===this._changesHead?this._changesHead=this._changesTail=e:(this._changesTail._nextChanged=e,this._changesTail=e)}_forEach(e,t){e instanceof Map?e.forEach(t):Object.keys(e).forEach(n=>t(e[n],n))}}class Jo{constructor(e){this.key=e,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function ei(){return new ti([new jo])}let ti=(()=>{class e{constructor(e){this.factories=e}static create(t,n){if(null!=n){const e=n.factories.slice();t=t.concat(e)}return new e(t)}static extend(t){return{provide:e,useFactory:n=>e.create(t,n||ei()),deps:[[e,new mr,new fr]]}}find(e){const t=this.factories.find(t=>t.supports(e));if(null!=t)return t;throw new Error(`Cannot find a differ supporting object '${e}' of type '${n=e,n.name||typeof n}'`);var n}}return e.\u0275prov=Re({token:e,providedIn:"root",factory:ei}),e})();function ni(){return new ri([new Qo])}let ri=(()=>{class e{constructor(e){this.factories=e}static create(t,n){if(n){const e=n.factories.slice();t=t.concat(e)}return new e(t)}static extend(t){return{provide:e,useFactory:n=>e.create(t,n||ni()),deps:[[e,new mr,new fr]]}}find(e){const t=this.factories.find(t=>t.supports(e));if(t)return t;throw new Error(`Cannot find a differ supporting object '${e}'`)}}return e.\u0275prov=Re({token:e,providedIn:"root",factory:ni}),e})();function si(e,t,n,r,s=!1){for(;null!==n;){const o=t[n.index];if(null!==o&&r.push(Ot(o)),vt(o))for(let e=xt;e<o.length;e++){const t=o[e],n=t[1].firstChild;null!==n&&si(t[1],t,n,r)}const i=n.type;if(8&i)si(e,t,n.child,r);else if(32&i){const e=Er(n,t);let s;for(;s=e();)r.push(s)}else if(16&i){const e=zr(t,n);if(Array.isArray(e))r.push(...e);else{const n=Sr(t[16]);si(n[1],n,e,r,!0)}}n=s?n.projectionNext:n.next}return r}class oi{constructor(e,t){this._lView=e,this._cdRefInjectingView=t,this._appRef=null,this._attachedToViewContainer=!1}get rootNodes(){const e=this._lView,t=e[1];return si(t,e,t.firstChild,[])}get context(){return this._lView[8]}set context(e){this._lView[8]=e}get destroyed(){return 256==(256&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const e=this._lView[3];if(vt(e)){const t=e[8],n=t?t.indexOf(this):-1;n>-1&&(Or(e,n),nr(t,n))}this._attachedToViewContainer=!1}Fr(this._lView[1],this._lView)}onDestroy(e){ws(this._lView[1],this._lView,null,e)}markForCheck(){!function(e){for(;e;){e[2]|=64;const t=Sr(e);if(0!=(512&e[2])&&!t)return e;e=t}}(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-129}reattach(){this._lView[2]|=128}detectChanges(){Ls(this._lView[1],this._lView,this.context)}checkNoChanges(){!function(e,t,n){Qt(!0);try{Ls(e,t,n)}finally{Qt(!1)}}(this._lView[1],this._lView,this.context)}attachToViewContainerRef(){if(this._appRef)throw new Error("This view is already attached directly to the ApplicationRef!");this._attachedToViewContainer=!0}detachFromAppRef(){var e;this._appRef=null,Hr(this._lView[1],e=this._lView,e[11],2,null,null)}attachToAppRef(e){if(this._attachedToViewContainer)throw new Error("This view is already attached to a ViewContainer!");this._appRef=e}}class ii extends oi{constructor(e){super(e),this._view=e}detectChanges(){Bs(this._view)}checkNoChanges(){!function(e){Qt(!0);try{Bs(e)}finally{Qt(!1)}}(this._view)}get context(){return null}}const ai=function(e){return function(e,t,n){if(Ct(e)&&!n){const n=Pt(e.index,t);return new oi(n,n)}return 47&e.type?new oi(t[16],t):null}(Gt(),jt(),16==(16&e))};let ui=(()=>{class e{}return e.__NG_ELEMENT_ID__=ai,e})();const li=[new Qo],ci=new ti([new jo]),hi=new ri(li),di=function(){return gi(Gt(),jt())};let pi=(()=>{class e{}return e.__NG_ELEMENT_ID__=di,e})();const fi=pi,mi=class extends fi{constructor(e,t,n){super(),this._declarationLView=e,this._declarationTContainer=t,this.elementRef=n}createEmbeddedView(e){const t=this._declarationTContainer.tViews,n=cs(this._declarationLView,t,e,16,null,t.declTNode,null,null,null,null);n[17]=this._declarationLView[this._declarationTContainer.index];const r=this._declarationLView[19];return null!==r&&(n[19]=r.createEmbeddedView(t)),ps(t,n,e),new oi(n)}};function gi(e,t){return 4&e.type?new mi(t,e,Po(e,t)):null}class yi{}class xi{}const bi=function(){return Ei(Gt(),jt())};let vi=(()=>{class e{}return e.__NG_ELEMENT_ID__=bi,e})();const wi=vi,Ci=class extends wi{constructor(e,t,n){super(),this._lContainer=e,this._hostTNode=t,this._hostLView=n}get element(){return Po(this._hostTNode,this._hostLView)}get injector(){return new qn(this._hostTNode,this._hostLView)}get parentInjector(){const e=Dn(this._hostTNode,this._hostLView);if(Sn(e)){const t=In(e,this._hostLView),n=Tn(e);return new qn(t[1].data[n+8],t)}return new qn(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(e){const t=_i(this._lContainer);return null!==t&&t[e]||null}get length(){return this._lContainer.length-xt}createEmbeddedView(e,t,n){const r=e.createEmbeddedView(t||{});return this.insert(r,n),r}createComponent(e,t,n,r,s){const o=n||this.parentInjector;if(!s&&null==e.ngModule&&o){const e=o.get(yi,null);e&&(s=e)}const i=e.create(o,r,void 0,s);return this.insert(i.hostView,t),i}insert(e,t){const n=e._lView,r=n[1];if(vt(n[3])){const t=this.indexOf(e);if(-1!==t)this.detach(t);else{const t=n[3],r=new Ci(t,t[6],t[3]);r.detach(r.indexOf(e))}}const s=this._adjustIndex(t),o=this._lContainer;!function(e,t,n,r){const s=xt+r,o=n.length;r>0&&(n[s-1][4]=t),r<o-xt?(t[4]=n[s],tr(n,xt+r,t)):(n.push(t),t[4]=null),t[3]=n;const i=t[17];null!==i&&n!==i&&function(e,t){const n=e[9];t[16]!==t[3][3][16]&&(e[2]=!0),null===n?e[9]=[t]:n.push(t)}(i,t);const a=t[19];null!==a&&a.insertView(e),t[2]|=128}(r,n,o,s);const i=Wr(s,o),a=n[11],u=Br(a,o[7]);return null!==u&&function(e,t,n,r,s,o){r[0]=s,r[6]=t,Hr(e,r,n,1,s,o)}(r,o[6],a,n,u,i),e.attachToViewContainerRef(),tr(ki(o),s,e),e}move(e,t){return this.insert(e,t)}indexOf(e){const t=_i(this._lContainer);return null!==t?t.indexOf(e):-1}remove(e){const t=this._adjustIndex(e,-1),n=Or(this._lContainer,t);n&&(nr(ki(this._lContainer),t),Fr(n[1],n))}detach(e){const t=this._adjustIndex(e,-1),n=Or(this._lContainer,t);return n&&null!=nr(ki(this._lContainer),t)?new oi(n):null}_adjustIndex(e,t=0){return null==e?this.length+t:e}};function _i(e){return e[8]}function ki(e){return e[8]||(e[8]=[])}function Ei(e,t){let n;const r=t[e.index];if(vt(r))n=r;else{let s;if(8&e.type)s=Ot(r);else{const n=t[11];s=n.createComment("");const r=Ft(e,t);Pr(n,Br(n,r),s,function(e,t){return Rt(e)?e.nextSibling(t):t.nextSibling}(n,r),!1)}t[e.index]=n=Os(r,t,s,e),Ms(t,n)}return new Ci(n,e,t)}const Si={};class Ti extends Fo{constructor(e){super(),this.ngModule=e}resolveComponentFactory(e){const t=mt(e);return new $i(t,this.ngModule)}}function Ii(e){const t=[];for(let n in e)e.hasOwnProperty(n)&&t.push({propName:e[n],templateName:n});return t}const Ni=new Yn("SCHEDULER_TOKEN",{providedIn:"root",factory:()=>Cr});class $i extends Ao{constructor(e,t){super(),this.componentDef=e,this.ngModule=t,this.componentType=e.type,this.selector=e.selectors.map(os).join(","),this.ngContentSelectors=e.ngContentSelectors?e.ngContentSelectors:[],this.isBoundToModule=!!t}get inputs(){return Ii(this.componentDef.inputs)}get outputs(){return Ii(this.componentDef.outputs)}create(e,t,n,r){const s=(r=r||this.ngModule)?function(e,t){return{get:(n,r,s)=>{const o=e.get(n,Si,s);return o!==Si||r===Si?o:t.get(n,r,s)}}}(e,r.injector):e,o=s.get(Vo,At),i=s.get(Uo,null),a=o.createRenderer(null,this.componentDef),u=this.componentDef.selectors[0][0]||"div",l=n?function(e,t,n){if(Rt(e))return e.selectRootElement(t,n===Ge.ShadowDom);let r="string"==typeof t?e.querySelector(t):t;return r.textContent="",r}(a,n,this.componentDef.encapsulation):Rr(o.createRenderer(null,this.componentDef),u,function(e){const t=e.toLowerCase();return"svg"===t?"http://www.w3.org/2000/svg":"math"===t?"http://www.w3.org/1998/MathML/":null}(u)),c=this.componentDef.onPush?576:528,h={components:[],scheduler:Cr,clean:Us,playerHandler:null,flags:0},d=vs(0,null,null,1,0,null,null,null,null,null),p=cs(null,d,h,c,null,null,o,a,i,s);let f,m;sn(p);try{const e=function(e,t,n,r,s,o){const i=n[1];n[20]=e;const a=hs(i,20,2,"#host",null),u=a.mergedAttrs=t.hostAttrs;null!==u&&(Ws(a,u,!0),null!==e&&(wn(s,e,u),null!==a.classes&&Kr(s,e,a.classes),null!==a.styles&&qr(s,e,a.styles)));const l=r.createRenderer(e,t),c=cs(n,bs(t),null,t.onPush?64:16,n[20],a,r,l,null,null);return i.firstCreatePass&&(Pn(An(a,n),i,t.type),Ss(i,a),Is(a,n.length,1)),Ms(n,c),n[20]=c}(l,this.componentDef,p,o,a);if(l)if(n)wn(a,l,["ng-version",Wo.full]);else{const{attrs:e,classes:t}=function(e){const t=[],n=[];let r=1,s=2;for(;r<e.length;){let o=e[r];if("string"==typeof o)2===s?""!==o&&t.push(o,e[++r]):8===s&&n.push(o);else{if(!ts(s))break;s=o}r++}return{attrs:t,classes:n}}(this.componentDef.selectors[0]);e&&wn(a,l,e),t&&t.length>0&&Kr(a,l,t.join(" "))}if(m=Dt(d,yt),void 0!==t){const e=m.projection=[];for(let n=0;n<this.ngContentSelectors.length;n++){const r=t[n];e.push(null!=r?Array.from(r):null)}}f=function(e,t,n,r,s){const o=n[1],i=function(e,t,n){const r=Gt();e.firstCreatePass&&(n.providersResolver&&n.providersResolver(n),Ns(e,r,t,ds(e,t,1,null),n));const s=jn(t,e,r.directiveStart,r);gr(s,t);const o=Ft(r,t);return o&&gr(o,t),s}(o,n,t);if(r.components.push(i),e[8]=i,s&&s.forEach(e=>e(i,t)),t.contentQueries){const e=Gt();t.contentQueries(1,i,e.directiveStart)}const a=Gt();return!o.firstCreatePass||null===t.hostBindings&&null===t.hostAttrs||(dn(a.index),ks(n[1],a,0,a.directiveStart,a.directiveEnd,t),Es(t,i)),i}(e,this.componentDef,p,h,[oo]),ps(d,p,null)}finally{cn()}return new Ri(this.componentType,f,Po(m,p),p,m)}}class Ri extends class{}{constructor(e,t,n,r,s){super(),this.location=n,this._rootLView=r,this._tNode=s,this.instance=t,this.hostView=this.changeDetectorRef=new ii(r),this.componentType=e}get injector(){return new qn(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(e){this.hostView.onDestroy(e)}}const Ai=new Map;class Oi extends yi{constructor(e,t){super(),this._parent=t,this._bootstrapComponents=[],this.injector=this,this.destroyCbs=[],this.componentFactoryResolver=new Ti(this);const n=gt(e),r=e[st]||null;r&&Ro(r),this._bootstrapComponents=_r(n.bootstrap),this._r3Injector=Qs(e,t,[{provide:yi,useValue:this},{provide:Fo,useValue:this.componentFactoryResolver}],Ce(e)),this._r3Injector._resolveInjectorDefTypes(),this.instance=this.get(e)}get(e,t=so.THROW_IF_NOT_FOUND,n=Ve.Default){return e===so||e===yi||e===js?this:this._r3Injector.get(e,t,n)}destroy(){const e=this._r3Injector;!e.destroyed&&e.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(e){this.destroyCbs.push(e)}}class Fi extends xi{constructor(e){super(),this.moduleType=e,null!==gt(e)&&function(e){const t=new Set;!function e(n){const r=gt(n,!0),s=r.id;null!==s&&(function(e,t,n){if(t&&t!==n)throw new Error(`Duplicate module registered for ${e} - ${Ce(t)} vs ${Ce(t.name)}`)}(s,Ai.get(s),n),Ai.set(s,n));const o=_r(r.imports);for(const i of o)t.has(i)||(t.add(i),e(i))}(e)}(e)}create(e){return new Oi(this.moduleType,e)}}function Di(e){return t=>{setTimeout(e,void 0,t)}}const Pi=class extends G{constructor(e=!1){super(),this.__isAsync=e}emit(e){super.next(e)}subscribe(e,t,n){var r,s,o;let i=e,a=t||(()=>null),u=n;if(e&&"object"==typeof e){const t=e;i=null===(r=t.next)||void 0===r?void 0:r.bind(t),a=null===(s=t.error)||void 0===s?void 0:s.bind(t),u=null===(o=t.complete)||void 0===o?void 0:o.bind(t)}this.__isAsync&&(a=Di(a),i&&(i=Di(i)),u&&(u=Di(u)));const l=super.subscribe({next:i,error:a,complete:u});return e instanceof F&&e.add(l),l}};function Mi(){return this._results[ao()]()}class Li{constructor(e=!1){this._emitDistinctChangesOnly=e,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const t=ao(),n=Li.prototype;n[t]||(n[t]=Mi)}get changes(){return this._changes||(this._changes=new Pi)}get(e){return this._results[e]}map(e){return this._results.map(e)}filter(e){return this._results.filter(e)}find(e){return this._results.find(e)}reduce(e,t){return this._results.reduce(e,t)}forEach(e){this._results.forEach(e)}some(e){return this._results.some(e)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(e,t){const n=this;n.dirty=!1;const r=Jn(e);(this._changesDetected=!function(e,t,n){if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++){let s=e[r],o=t[r];if(n&&(s=n(s),o=n(o)),o!==s)return!1}return!0}(n._results,r,t))&&(n._results=r,n.length=r.length,n.last=r[this.length-1],n.first=r[0])}notifyOnChanges(){!this._changes||!this._changesDetected&&this._emitDistinctChangesOnly||this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}Symbol;class Bi{constructor(e){this.queryList=e,this.matches=null}clone(){return new Bi(this.queryList)}setDirty(){this.queryList.setDirty()}}class Vi{constructor(e=[]){this.queries=e}createEmbeddedView(e){const t=e.queries;if(null!==t){const n=null!==e.contentQueries?e.contentQueries[0]:t.length,r=[];for(let e=0;e<n;e++){const n=t.getByIndex(e);r.push(this.queries[n.indexInDeclarationView].clone())}return new Vi(r)}return null}insertView(e){this.dirtyQueriesWithMatches(e)}detachView(e){this.dirtyQueriesWithMatches(e)}dirtyQueriesWithMatches(e){for(let t=0;t<this.queries.length;t++)null!==Qi(e,t).matches&&this.queries[t].setDirty()}}class Ui{constructor(e,t,n=null){this.predicate=e,this.flags=t,this.read=n}}class zi{constructor(e=[]){this.queries=e}elementStart(e,t){for(let n=0;n<this.queries.length;n++)this.queries[n].elementStart(e,t)}elementEnd(e){for(let t=0;t<this.queries.length;t++)this.queries[t].elementEnd(e)}embeddedTView(e){let t=null;for(let n=0;n<this.length;n++){const r=null!==t?t.length:0,s=this.getByIndex(n).embeddedTView(e,r);s&&(s.indexInDeclarationView=n,null!==t?t.push(s):t=[s])}return null!==t?new zi(t):null}template(e,t){for(let n=0;n<this.queries.length;n++)this.queries[n].template(e,t)}getByIndex(e){return this.queries[e]}get length(){return this.queries.length}track(e){this.queries.push(e)}}class Wi{constructor(e,t=-1){this.metadata=e,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=t}elementStart(e,t){this.isApplyingToNode(t)&&this.matchTNode(e,t)}elementEnd(e){this._declarationNodeIndex===e.index&&(this._appliesToNextNode=!1)}template(e,t){this.elementStart(e,t)}embeddedTView(e,t){return this.isApplyingToNode(e)?(this.crossesNgTemplate=!0,this.addMatch(-e.index,t),new Wi(this.metadata)):null}isApplyingToNode(e){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const t=this._declarationNodeIndex;let n=e.parent;for(;null!==n&&8&n.type&&n.index!==t;)n=n.parent;return t===(null!==n?n.index:-1)}return this._appliesToNextNode}matchTNode(e,t){const n=this.metadata.predicate;if(Array.isArray(n))for(let r=0;r<n.length;r++){const s=n[r];this.matchTNodeWithReadOption(e,t,ji(t,s)),this.matchTNodeWithReadOption(e,t,Wn(t,e,s,!1,!1))}else n===pi?4&t.type&&this.matchTNodeWithReadOption(e,t,-1):this.matchTNodeWithReadOption(e,t,Wn(t,e,n,!1,!1))}matchTNodeWithReadOption(e,t,n){if(null!==n){const r=this.metadata.read;if(null!==r)if(r===Lo||r===vi||r===pi&&4&t.type)this.addMatch(t.index,-2);else{const n=Wn(t,e,r,!1,!1);null!==n&&this.addMatch(t.index,n)}else this.addMatch(t.index,n)}}addMatch(e,t){null===this.matches?this.matches=[e,t]:this.matches.push(e,t)}}function ji(e,t){const n=e.localNames;if(null!==n)for(let r=0;r<n.length;r+=2)if(n[r]===t)return n[r+1];return null}function Hi(e,t,n,r){return-1===n?function(e,t){return 11&e.type?Po(e,t):4&e.type?gi(e,t):null}(t,e):-2===n?function(e,t,n){return n===Lo?Po(t,e):n===pi?gi(t,e):n===vi?Ei(t,e):void 0}(e,t,r):jn(e,e[1],n,t)}function Gi(e,t,n,r){const s=t[19].queries[r];if(null===s.matches){const r=e.data,o=n.matches,i=[];for(let e=0;e<o.length;e+=2){const s=o[e];i.push(s<0?null:Hi(t,r[s],o[e+1],n.metadata.read))}s.matches=i}return s.matches}function qi(e,t,n,r){const s=e.queries.getByIndex(n),o=s.matches;if(null!==o){const i=Gi(e,t,s,n);for(let e=0;e<o.length;e+=2){const n=o[e];if(n>0)r.push(i[e/2]);else{const s=o[e+1],i=t[-n];for(let e=xt;e<i.length;e++){const t=i[e];t[17]===t[3]&&qi(t[1],t,s,r)}if(null!==i[9]){const e=i[9];for(let t=0;t<e.length;t++){const n=e[t];qi(n[1],n,s,r)}}}}}return r}function Ki(e){const t=jt(),n=Ht(),r=en();tn(r+1);const s=Qi(n,r);if(e.dirty&&Mt(t)===(2==(2&s.metadata.flags))){if(null===s.matches)e.reset([]);else{const o=s.crossesNgTemplate?qi(n,t,r,[]):Gi(n,t,s,r);e.reset(o,Bo),e.notifyOnChanges()}return!0}return!1}function Xi(e,t,n){const r=Ht();r.firstCreatePass&&(function(e,t,n){null===e.queries&&(e.queries=new zi),e.queries.track(new Wi(t,-1))}(r,new Ui(e,t,n)),2==(2&t)&&(r.staticViewQueries=!0)),function(e,t,n){const r=new Li(4==(4&n));ws(e,t,r,r.destroy),null===t[19]&&(t[19]=new Vi),t[19].queries.push(new Bi(r))}(r,jt(),t)}function Yi(){return e=jt(),t=en(),e[19].queries[t].queryList;var e,t}function Qi(e,t){return e.queries.getByIndex(t)}const Zi=new Yn("Application Initializer");let Ji=(()=>{class e{constructor(e){this.appInits=e,this.resolve=Do,this.reject=Do,this.initialized=!1,this.done=!1,this.donePromise=new Promise((e,t)=>{this.resolve=e,this.reject=t})}runInitializers(){if(this.initialized)return;const e=[],t=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let n=0;n<this.appInits.length;n++){const t=this.appInits[n]();if(vo(t))e.push(t);else if(wo(t)){const n=new Promise((e,n)=>{t.subscribe({complete:e,error:n})});e.push(n)}}Promise.all(e).then(()=>{t()}).catch(e=>{this.reject(e)}),0===e.length&&t(),this.initialized=!0}}return e.\u0275fac=function(t){return new(t||e)(cr(Zi,8))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();const ea=new Yn("AppId"),ta={provide:ea,useFactory:function(){return`${na()}${na()}${na()}`},deps:[]};function na(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const ra=new Yn("Platform Initializer"),sa=new Yn("Platform ID"),oa=new Yn("appBootstrapListener");let ia=(()=>{class e{log(e){console.log(e)}warn(e){console.warn(e)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();const aa=new Yn("LocaleId"),ua=new Yn("DefaultCurrencyCode");class la{constructor(e,t){this.ngModuleFactory=e,this.componentFactories=t}}const ca=function(e){return new Fi(e)},ha=ca,da=function(e){return Promise.resolve(ca(e))},pa=function(e){const t=ca(e),n=_r(gt(e).declarations).reduce((e,t)=>{const n=mt(t);return n&&e.push(new $i(n)),e},[]);return new la(t,n)},fa=pa,ma=function(e){return Promise.resolve(pa(e))};let ga=(()=>{class e{constructor(){this.compileModuleSync=ha,this.compileModuleAsync=da,this.compileModuleAndAllComponentsSync=fa,this.compileModuleAndAllComponentsAsync=ma}clearCache(){}clearCacheFor(e){}getModuleId(e){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();const ya=(()=>Promise.resolve(0))();function xa(e){"undefined"==typeof Zone?ya.then(()=>{e&&e.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",e)}class ba{constructor({enableLongStackTrace:e=!1,shouldCoalesceEventChangeDetection:t=!1,shouldCoalesceRunChangeDetection:n=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new Pi(!1),this.onMicrotaskEmpty=new Pi(!1),this.onStable=new Pi(!1),this.onError=new Pi(!1),"undefined"==typeof Zone)throw new Error("In this configuration Angular requires Zone.js");Zone.assertZonePatched();const r=this;r._nesting=0,r._outer=r._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(r._inner=r._inner.fork(new Zone.TaskTrackingZoneSpec)),e&&Zone.longStackTraceZoneSpec&&(r._inner=r._inner.fork(Zone.longStackTraceZoneSpec)),r.shouldCoalesceEventChangeDetection=!n&&t,r.shouldCoalesceRunChangeDetection=n,r.lastRequestAnimationFrameId=-1,r.nativeRequestAnimationFrame=function(){let e=Qe.requestAnimationFrame,t=Qe.cancelAnimationFrame;if("undefined"!=typeof Zone&&e&&t){const n=e[Zone.__symbol__("OriginalDelegate")];n&&(e=n);const r=t[Zone.__symbol__("OriginalDelegate")];r&&(t=r)}return{nativeRequestAnimationFrame:e,nativeCancelAnimationFrame:t}}().nativeRequestAnimationFrame,function(e){const t=()=>{!function(e){e.isCheckStableRunning||-1!==e.lastRequestAnimationFrameId||(e.lastRequestAnimationFrameId=e.nativeRequestAnimationFrame.call(Qe,()=>{e.fakeTopEventTask||(e.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{e.lastRequestAnimationFrameId=-1,Ca(e),e.isCheckStableRunning=!0,wa(e),e.isCheckStableRunning=!1},void 0,()=>{},()=>{})),e.fakeTopEventTask.invoke()}),Ca(e))}(e)};e._inner=e._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(n,r,s,o,i,a)=>{try{return _a(e),n.invokeTask(s,o,i,a)}finally{(e.shouldCoalesceEventChangeDetection&&"eventTask"===o.type||e.shouldCoalesceRunChangeDetection)&&t(),ka(e)}},onInvoke:(n,r,s,o,i,a,u)=>{try{return _a(e),n.invoke(s,o,i,a,u)}finally{e.shouldCoalesceRunChangeDetection&&t(),ka(e)}},onHasTask:(t,n,r,s)=>{t.hasTask(r,s),n===r&&("microTask"==s.change?(e._hasPendingMicrotasks=s.microTask,Ca(e),wa(e)):"macroTask"==s.change&&(e.hasPendingMacrotasks=s.macroTask))},onHandleError:(t,n,r,s)=>(t.handleError(r,s),e.runOutsideAngular(()=>e.onError.emit(s)),!1)})}(r)}static isInAngularZone(){return!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!ba.isInAngularZone())throw new Error("Expected to be in Angular Zone, but it is not!")}static assertNotInAngularZone(){if(ba.isInAngularZone())throw new Error("Expected to not be in Angular Zone, but it is!")}run(e,t,n){return this._inner.run(e,t,n)}runTask(e,t,n,r){const s=this._inner,o=s.scheduleEventTask("NgZoneEvent: "+r,e,va,Do,Do);try{return s.runTask(o,t,n)}finally{s.cancelTask(o)}}runGuarded(e,t,n){return this._inner.runGuarded(e,t,n)}runOutsideAngular(e){return this._outer.run(e)}}const va={};function wa(e){if(0==e._nesting&&!e.hasPendingMicrotasks&&!e.isStable)try{e._nesting++,e.onMicrotaskEmpty.emit(null)}finally{if(e._nesting--,!e.hasPendingMicrotasks)try{e.runOutsideAngular(()=>e.onStable.emit(null))}finally{e.isStable=!0}}}function Ca(e){e.hasPendingMicrotasks=!!(e._hasPendingMicrotasks||(e.shouldCoalesceEventChangeDetection||e.shouldCoalesceRunChangeDetection)&&-1!==e.lastRequestAnimationFrameId)}function _a(e){e._nesting++,e.isStable&&(e.isStable=!1,e.onUnstable.emit(null))}function ka(e){e._nesting--,wa(e)}class Ea{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new Pi,this.onMicrotaskEmpty=new Pi,this.onStable=new Pi,this.onError=new Pi}run(e,t,n){return e.apply(t,n)}runGuarded(e,t,n){return e.apply(t,n)}runOutsideAngular(e){return e()}runTask(e,t,n,r){return e.apply(t,n)}}let Sa=(()=>{class e{constructor(e){this._ngZone=e,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone="undefined"==typeof Zone?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{ba.assertNotInAngularZone(),xa(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())xa(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(t=>!t.updateCb||!t.updateCb(e)||(clearTimeout(t.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,t,n){let r=-1;t&&t>0&&(r=setTimeout(()=>{this._callbacks=this._callbacks.filter(e=>e.timeoutId!==r),e(this._didWork,this.getPendingTasks())},t)),this._callbacks.push({doneCb:e,timeoutId:r,updateCb:n})}whenStable(e,t,n){if(n&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(e,t,n),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}findProviders(e,t,n){return[]}}return e.\u0275fac=function(t){return new(t||e)(cr(ba))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})(),Ta=(()=>{class e{constructor(){this._applications=new Map,$a.addToWindow(this)}registerApplication(e,t){this._applications.set(e,t)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,t=!0){return $a.findTestabilityInTree(this,e,t)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();class Ia{addToWindow(e){}findTestabilityInTree(e,t,n){return null}}let Na,$a=new Ia,Ra=!0,Aa=!1;const Oa=new Yn("AllowMultipleToken");class Fa{constructor(e,t){this.name=e,this.token=t}}function Da(e,t,n=[]){const r=`Platform: ${t}`,s=new Yn(r);return(t=[])=>{let o=Pa();if(!o||o.injector.get(Oa,!1))if(e)e(n.concat(t).concat({provide:s,useValue:!0}));else{const e=n.concat(t).concat({provide:s,useValue:!0},{provide:Gs,useValue:"platform"});!function(e){if(Na&&!Na.destroyed&&!Na.injector.get(Oa,!1))throw new Error("There can be only one platform. Destroy the previous one to create a new one.");Na=e.get(Ma);const t=e.get(ra,null);t&&t.forEach(e=>e())}(so.create({providers:e,name:r}))}return function(e){const t=Pa();if(!t)throw new Error("No platform exists!");if(!t.injector.get(e,null))throw new Error("A platform with a different configuration has been created. Please destroy it first.");return t}(s)}}function Pa(){return Na&&!Na.destroyed?Na:null}let Ma=(()=>{class e{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,t){const n=function(e,t){let n;return n="noop"===e?new Ea:("zone.js"===e?void 0:e)||new ba({enableLongStackTrace:(Aa=!0,Ra),shouldCoalesceEventChangeDetection:!!(null==t?void 0:t.ngZoneEventCoalescing),shouldCoalesceRunChangeDetection:!!(null==t?void 0:t.ngZoneRunCoalescing)}),n}(t?t.ngZone:void 0,{ngZoneEventCoalescing:t&&t.ngZoneEventCoalescing||!1,ngZoneRunCoalescing:t&&t.ngZoneRunCoalescing||!1}),r=[{provide:ba,useValue:n}];return n.run(()=>{const t=so.create({providers:r,parent:this.injector,name:e.moduleType.name}),s=e.create(t),o=s.injector.get(wr,null);if(!o)throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?");return n.runOutsideAngular(()=>{const e=n.onError.subscribe({next:e=>{o.handleError(e)}});s.onDestroy(()=>{Va(this._modules,s),e.unsubscribe()})}),function(e,t,n){try{const r=n();return vo(r)?r.catch(n=>{throw t.runOutsideAngular(()=>e.handleError(n)),n}):r}catch(r){throw t.runOutsideAngular(()=>e.handleError(r)),r}}(o,n,()=>{const e=s.injector.get(Ji);return e.runInitializers(),e.donePromise.then(()=>(Ro(s.injector.get(aa,No)||No),this._moduleDoBootstrap(s),s))})})}bootstrapModule(e,t=[]){const n=La({},t);return function(e,t,n){const r=new Fi(n);return Promise.resolve(r)}(0,0,e).then(e=>this.bootstrapModuleFactory(e,n))}_moduleDoBootstrap(e){const t=e.injector.get(Ba);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(e=>t.bootstrap(e));else{if(!e.instance.ngDoBootstrap)throw new Error(`The module ${Ce(e.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);e.instance.ngDoBootstrap(t)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new Error("The platform has already been destroyed!");this._modules.slice().forEach(e=>e.destroy()),this._destroyListeners.forEach(e=>e()),this._destroyed=!0}get destroyed(){return this._destroyed}}return e.\u0275fac=function(t){return new(t||e)(cr(so))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();function La(e,t){return Array.isArray(t)?t.reduce(La,e):Object.assign(Object.assign({},e),t)}let Ba=(()=>{class e{constructor(e,t,n,r,s){this._zone=e,this._injector=t,this._exceptionHandler=n,this._componentFactoryResolver=r,this._initStatus=s,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const o=new U(e=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{e.next(this._stable),e.complete()})}),i=new U(e=>{let t;this._zone.runOutsideAngular(()=>{t=this._zone.onStable.subscribe(()=>{ba.assertNotInAngularZone(),xa(()=>{this._stable||this._zone.hasPendingMacrotasks||this._zone.hasPendingMicrotasks||(this._stable=!0,e.next(!0))})})});const n=this._zone.onUnstable.subscribe(()=>{ba.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{e.next(!1)}))});return()=>{t.unsubscribe(),n.unsubscribe()}});this.isStable=function(...e){let t=Number.POSITIVE_INFINITY,n=null,r=e[e.length-1];return K(r)?(n=e.pop(),e.length>1&&"number"==typeof e[e.length-1]&&(t=e.pop())):"number"==typeof r&&(t=e.pop()),null===n&&1===e.length&&e[0]instanceof U?e[0]:de(t)(pe(e,n))}(o,i.pipe(e=>{return fe()((t=ve,function(e){let n;n="function"==typeof t?t:function(){return t};const r=Object.create(e,xe);return r.source=e,r.subjectFactory=n,r})(e));var t}))}bootstrap(e,t){if(!this._initStatus.done)throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.");let n;n=e instanceof Ao?e:this._componentFactoryResolver.resolveComponentFactory(e),this.componentTypes.push(n.componentType);const r=n.isBoundToModule?void 0:this._injector.get(yi),s=n.create(so.NULL,[],t||n.selector,r),o=s.location.nativeElement,i=s.injector.get(Sa,null),a=i&&s.injector.get(Ta);return i&&a&&a.registerApplication(o,i),s.onDestroy(()=>{this.detachView(s.hostView),Va(this.components,s),a&&a.unregisterApplication(o)}),this._loadComponent(s),s}tick(){if(this._runningTick)throw new Error("ApplicationRef.tick is called recursively");try{this._runningTick=!0;for(let e of this._views)e.detectChanges()}catch(e){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(e))}finally{this._runningTick=!1}}attachView(e){const t=e;this._views.push(t),t.attachToAppRef(this)}detachView(e){const t=e;Va(this._views,t),t.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e),this._injector.get(oa,[]).concat(this._bootstrapListeners).forEach(t=>t(e))}ngOnDestroy(){this._views.slice().forEach(e=>e.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}get viewCount(){return this._views.length}}return e.\u0275fac=function(t){return new(t||e)(cr(ba),cr(so),cr(wr),cr(Fo),cr(Ji))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();function Va(e,t){const n=e.indexOf(t);n>-1&&e.splice(n,1)}class Ua{}class za{}const Wa={factoryPathPrefix:"",factoryPathSuffix:".ngfactory"};let ja=(()=>{class e{constructor(e,t){this._compiler=e,this._config=t||Wa}load(e){return this.loadAndCompile(e)}loadAndCompile(e){let[t,r]=e.split("#");return void 0===r&&(r="default"),n(255)(t).then(e=>e[r]).then(e=>Ha(e,t,r)).then(e=>this._compiler.compileModuleAsync(e))}loadFactory(e){let[t,r]=e.split("#"),s="NgFactory";return void 0===r&&(r="default",s=""),n(255)(this._config.factoryPathPrefix+t+this._config.factoryPathSuffix).then(e=>e[r+s]).then(e=>Ha(e,t,r))}}return e.\u0275fac=function(t){return new(t||e)(cr(ga),cr(za,8))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();function Ha(e,t,n){if(!e)throw new Error(`Cannot find '${n}' in '${t}'`);return e}const Ga=Da(null,"core",[{provide:sa,useValue:"unknown"},{provide:Ma,deps:[so]},{provide:Ta,deps:[]},{provide:ia,deps:[]}]),qa=[{provide:Ba,useClass:Ba,deps:[ba,so,wr,Fo,Ji]},{provide:Ni,deps:[ba],useFactory:function(e){let t=[];return e.onStable.subscribe(()=>{for(;t.length;)t.pop()()}),function(e){t.push(e)}}},{provide:Ji,useClass:Ji,deps:[[new fr,Zi]]},{provide:ga,useClass:ga,deps:[]},ta,{provide:ti,useFactory:function(){return ci},deps:[]},{provide:ri,useFactory:function(){return hi},deps:[]},{provide:aa,useFactory:function(e){return Ro(e=e||"undefined"!=typeof $localize&&$localize.locale||No),e},deps:[[new pr(aa),new fr,new mr]]},{provide:ua,useValue:"USD"}];let Ka=(()=>{class e{constructor(e){}}return e.\u0275fac=function(t){return new(t||e)(cr(Ba))},e.\u0275mod=dt({type:e}),e.\u0275inj=Ae({providers:qa}),e})(),Xa=null;function Ya(){return Xa}const Qa=new Yn("DocumentToken");let Za=(()=>{class e{historyGo(e){throw new Error("Not implemented")}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=Re({factory:Ja,token:e,providedIn:"platform"}),e})();function Ja(){return cr(tu)}const eu=new Yn("Location Initialized");let tu=(()=>{class e extends Za{constructor(e){super(),this._doc=e,this._init()}_init(){this.location=window.location,this._history=window.history}getBaseHrefFromDOM(){return Ya().getBaseHref(this._doc)}onPopState(e){const t=Ya().getGlobalEventTarget(this._doc,"window");return t.addEventListener("popstate",e,!1),()=>t.removeEventListener("popstate",e)}onHashChange(e){const t=Ya().getGlobalEventTarget(this._doc,"window");return t.addEventListener("hashchange",e,!1),()=>t.removeEventListener("hashchange",e)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(e){this.location.pathname=e}pushState(e,t,n){nu()?this._history.pushState(e,t,n):this.location.hash=n}replaceState(e,t,n){nu()?this._history.replaceState(e,t,n):this.location.hash=n}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}}return e.\u0275fac=function(t){return new(t||e)(cr(Qa))},e.\u0275prov=Re({factory:ru,token:e,providedIn:"platform"}),e})();function nu(){return!!window.history.pushState}function ru(){return new tu(cr(Qa))}function su(e,t){if(0==e.length)return t;if(0==t.length)return e;let n=0;return e.endsWith("/")&&n++,t.startsWith("/")&&n++,2==n?e+t.substring(1):1==n?e+t:e+"/"+t}function ou(e){const t=e.match(/#|\?|$/),n=t&&t.index||e.length;return e.slice(0,n-("/"===e[n-1]?1:0))+e.slice(n)}function iu(e){return e&&"?"!==e[0]?"?"+e:e}let au=(()=>{class e{historyGo(e){throw new Error("Not implemented")}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=Re({factory:uu,token:e,providedIn:"root"}),e})();function uu(e){const t=cr(Qa).location;return new cu(cr(Za),t&&t.origin||"")}const lu=new Yn("appBaseHref");let cu=(()=>{class e extends au{constructor(e,t){if(super(),this._platformLocation=e,this._removeListenerFns=[],null==t&&(t=this._platformLocation.getBaseHrefFromDOM()),null==t)throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");this._baseHref=t}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return su(this._baseHref,e)}path(e=!1){const t=this._platformLocation.pathname+iu(this._platformLocation.search),n=this._platformLocation.hash;return n&&e?`${t}${n}`:t}pushState(e,t,n,r){const s=this.prepareExternalUrl(n+iu(r));this._platformLocation.pushState(e,t,s)}replaceState(e,t,n,r){const s=this.prepareExternalUrl(n+iu(r));this._platformLocation.replaceState(e,t,s)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}historyGo(e=0){var t,n;null===(n=(t=this._platformLocation).historyGo)||void 0===n||n.call(t,e)}}return e.\u0275fac=function(t){return new(t||e)(cr(Za),cr(lu,8))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})(),hu=(()=>{class e extends au{constructor(e,t){super(),this._platformLocation=e,this._baseHref="",this._removeListenerFns=[],null!=t&&(this._baseHref=t)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}path(e=!1){let t=this._platformLocation.hash;return null==t&&(t="#"),t.length>0?t.substring(1):t}prepareExternalUrl(e){const t=su(this._baseHref,e);return t.length>0?"#"+t:t}pushState(e,t,n,r){let s=this.prepareExternalUrl(n+iu(r));0==s.length&&(s=this._platformLocation.pathname),this._platformLocation.pushState(e,t,s)}replaceState(e,t,n,r){let s=this.prepareExternalUrl(n+iu(r));0==s.length&&(s=this._platformLocation.pathname),this._platformLocation.replaceState(e,t,s)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}historyGo(e=0){var t,n;null===(n=(t=this._platformLocation).historyGo)||void 0===n||n.call(t,e)}}return e.\u0275fac=function(t){return new(t||e)(cr(Za),cr(lu,8))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})(),du=(()=>{class e{constructor(e,t){this._subject=new Pi,this._urlChangeListeners=[],this._platformStrategy=e;const n=this._platformStrategy.getBaseHref();this._platformLocation=t,this._baseHref=ou(fu(n)),this._platformStrategy.onPopState(e=>{this._subject.emit({url:this.path(!0),pop:!0,state:e.state,type:e.type})})}path(e=!1){return this.normalize(this._platformStrategy.path(e))}getState(){return this._platformLocation.getState()}isCurrentPathEqualTo(e,t=""){return this.path()==this.normalize(e+iu(t))}normalize(t){return e.stripTrailingSlash(function(e,t){return e&&t.startsWith(e)?t.substring(e.length):t}(this._baseHref,fu(t)))}prepareExternalUrl(e){return e&&"/"!==e[0]&&(e="/"+e),this._platformStrategy.prepareExternalUrl(e)}go(e,t="",n=null){this._platformStrategy.pushState(n,"",e,t),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+iu(t)),n)}replaceState(e,t="",n=null){this._platformStrategy.replaceState(n,"",e,t),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+iu(t)),n)}forward(){this._platformStrategy.forward()}back(){this._platformStrategy.back()}historyGo(e=0){var t,n;null===(n=(t=this._platformStrategy).historyGo)||void 0===n||n.call(t,e)}onUrlChange(e){this._urlChangeListeners.push(e),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(e=>{this._notifyUrlChangeListeners(e.url,e.state)}))}_notifyUrlChangeListeners(e="",t){this._urlChangeListeners.forEach(n=>n(e,t))}subscribe(e,t,n){return this._subject.subscribe({next:e,error:t,complete:n})}}return e.\u0275fac=function(t){return new(t||e)(cr(au),cr(Za))},e.normalizeQueryParams=iu,e.joinWithSlash=su,e.stripTrailingSlash=ou,e.\u0275prov=Re({factory:pu,token:e,providedIn:"root"}),e})();function pu(){return new du(cr(au),cr(Za))}function fu(e){return e.replace(/\/index.html$/,"")}var mu=(()=>((mu=mu||{})[mu.Zero=0]="Zero",mu[mu.One=1]="One",mu[mu.Two=2]="Two",mu[mu.Few=3]="Few",mu[mu.Many=4]="Many",mu[mu.Other=5]="Other",mu))();class gu{}let yu=(()=>{class e extends gu{constructor(e){super(),this.locale=e}getPluralCategory(e,t){switch(function(e){return function(e){const t=function(e){return e.toLowerCase().replace(/_/g,"-")}(e);let n=To(t);if(n)return n;const r=t.split("-")[0];if(n=To(r),n)return n;if("en"===r)return Eo;throw new Error(`Missing locale data for the locale "${e}".`)}(e)[Io.PluralCase]}(t||this.locale)(e)){case mu.Zero:return"zero";case mu.One:return"one";case mu.Two:return"two";case mu.Few:return"few";case mu.Many:return"many";default:return"other"}}}return e.\u0275fac=function(t){return new(t||e)(cr(aa))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})(),xu=(()=>{class e{constructor(e,t){this._viewContainer=e,this._context=new bu,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=t}set ngIf(e){this._context.$implicit=this._context.ngIf=e,this._updateView()}set ngIfThen(e){vu("ngIfThen",e),this._thenTemplateRef=e,this._thenViewRef=null,this._updateView()}set ngIfElse(e){vu("ngIfElse",e),this._elseTemplateRef=e,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(e,t){return!0}}return e.\u0275fac=function(t){return new(t||e)(fo(vi),fo(pi))},e.\u0275dir=ft({type:e,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"}}),e})();class bu{constructor(){this.$implicit=null,this.ngIf=null}}function vu(e,t){if(t&&!t.createEmbeddedView)throw new Error(`${e} must be a TemplateRef, but received '${Ce(t)}'.`)}let wu=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=dt({type:e}),e.\u0275inj=Ae({providers:[{provide:gu,useClass:yu}]}),e})(),Cu=(()=>{class e{}return e.\u0275prov=Re({token:e,providedIn:"root",factory:()=>new _u(cr(Qa),window)}),e})();class _u{constructor(e,t){this.document=e,this.window=t,this.offset=()=>[0,0]}setOffset(e){this.offset=Array.isArray(e)?()=>e:e}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(e){this.supportsScrolling()&&this.window.scrollTo(e[0],e[1])}scrollToAnchor(e){if(!this.supportsScrolling())return;const t=function(e,t){const n=e.getElementById(t)||e.getElementsByName(t)[0];if(n)return n;if("function"==typeof e.createTreeWalker&&e.body&&(e.body.createShadowRoot||e.body.attachShadow)){const n=e.createTreeWalker(e.body,NodeFilter.SHOW_ELEMENT);let r=n.currentNode;for(;r;){const e=r.shadowRoot;if(e){const n=e.getElementById(t)||e.querySelector(`[name="${t}"]`);if(n)return n}r=n.nextNode()}}return null}(this.document,e);t&&(this.scrollToElement(t),this.attemptFocus(t))}setHistoryScrollRestoration(e){if(this.supportScrollRestoration()){const t=this.window.history;t&&t.scrollRestoration&&(t.scrollRestoration=e)}}scrollToElement(e){const t=e.getBoundingClientRect(),n=t.left+this.window.pageXOffset,r=t.top+this.window.pageYOffset,s=this.offset();this.window.scrollTo(n-s[0],r-s[1])}attemptFocus(e){return e.focus(),this.document.activeElement===e}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const e=ku(this.window.history)||ku(Object.getPrototypeOf(this.window.history));return!(!e||!e.writable&&!e.set)}catch(e){return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch(e){return!1}}}function ku(e){return Object.getOwnPropertyDescriptor(e,"scrollRestoration")}class Eu extends class extends class{}{constructor(){super(...arguments),this.supportsDOMEvents=!0}}{static makeCurrent(){var e;e=new Eu,Xa||(Xa=e)}onAndCancel(e,t,n){return e.addEventListener(t,n,!1),()=>{e.removeEventListener(t,n,!1)}}dispatchEvent(e,t){e.dispatchEvent(t)}remove(e){e.parentNode&&e.parentNode.removeChild(e)}createElement(e,t){return(t=t||this.getDefaultDocument()).createElement(e)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(e){return e.nodeType===Node.ELEMENT_NODE}isShadowRoot(e){return e instanceof DocumentFragment}getGlobalEventTarget(e,t){return"window"===t?window:"document"===t?e:"body"===t?e.body:null}getBaseHref(e){const t=(Tu=Tu||document.querySelector("base"),Tu?Tu.getAttribute("href"):null);return null==t?null:function(e){Su=Su||document.createElement("a"),Su.setAttribute("href",e);const t=Su.pathname;return"/"===t.charAt(0)?t:`/${t}`}(t)}resetBaseElement(){Tu=null}getUserAgent(){return window.navigator.userAgent}getCookie(e){return function(e,t){t=encodeURIComponent(t);for(const n of e.split(";")){const e=n.indexOf("="),[r,s]=-1==e?[n,""]:[n.slice(0,e),n.slice(e+1)];if(r.trim()===t)return decodeURIComponent(s)}return null}(document.cookie,e)}}let Su,Tu=null;const Iu=new Yn("TRANSITION_ID"),Nu=[{provide:Zi,useFactory:function(e,t,n){return()=>{n.get(Ji).donePromise.then(()=>{const n=Ya();Array.prototype.slice.apply(t.querySelectorAll("style[ng-transition]")).filter(t=>t.getAttribute("ng-transition")===e).forEach(e=>n.remove(e))})}},deps:[Iu,Qa,so],multi:!0}];class $u{static init(){var e;e=new $u,$a=e}addToWindow(e){Qe.getAngularTestability=(t,n=!0)=>{const r=e.findTestabilityInTree(t,n);if(null==r)throw new Error("Could not find testability for element.");return r},Qe.getAllAngularTestabilities=()=>e.getAllTestabilities(),Qe.getAllAngularRootElements=()=>e.getAllRootElements(),Qe.frameworkStabilizers||(Qe.frameworkStabilizers=[]),Qe.frameworkStabilizers.push(e=>{const t=Qe.getAllAngularTestabilities();let n=t.length,r=!1;const s=function(t){r=r||t,n--,0==n&&e(r)};t.forEach(function(e){e.whenStable(s)})})}findTestabilityInTree(e,t,n){if(null==t)return null;const r=e.getTestability(t);return null!=r?r:n?Ya().isShadowRoot(t)?this.findTestabilityInTree(e,t.host,!0):this.findTestabilityInTree(e,t.parentElement,!0):null}}let Ru=(()=>{class e{build(){return new XMLHttpRequest}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();const Au=new Yn("EventManagerPlugins");let Ou=(()=>{class e{constructor(e,t){this._zone=t,this._eventNameToPlugin=new Map,e.forEach(e=>e.manager=this),this._plugins=e.slice().reverse()}addEventListener(e,t,n){return this._findPluginFor(t).addEventListener(e,t,n)}addGlobalEventListener(e,t,n){return this._findPluginFor(t).addGlobalEventListener(e,t,n)}getZone(){return this._zone}_findPluginFor(e){const t=this._eventNameToPlugin.get(e);if(t)return t;const n=this._plugins;for(let r=0;r<n.length;r++){const t=n[r];if(t.supports(e))return this._eventNameToPlugin.set(e,t),t}throw new Error(`No event manager plugin found for event ${e}`)}}return e.\u0275fac=function(t){return new(t||e)(cr(Au),cr(ba))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();class Fu{constructor(e){this._doc=e}addGlobalEventListener(e,t,n){const r=Ya().getGlobalEventTarget(this._doc,e);if(!r)throw new Error(`Unsupported event target ${r} for event ${t}`);return this.addEventListener(r,t,n)}}let Du=(()=>{class e{constructor(){this._stylesSet=new Set}addStyles(e){const t=new Set;e.forEach(e=>{this._stylesSet.has(e)||(this._stylesSet.add(e),t.add(e))}),this.onStylesAdded(t)}onStylesAdded(e){}getAllStyles(){return Array.from(this._stylesSet)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})(),Pu=(()=>{class e extends Du{constructor(e){super(),this._doc=e,this._hostNodes=new Map,this._hostNodes.set(e.head,[])}_addStylesToHost(e,t,n){e.forEach(e=>{const r=this._doc.createElement("style");r.textContent=e,n.push(t.appendChild(r))})}addHost(e){const t=[];this._addStylesToHost(this._stylesSet,e,t),this._hostNodes.set(e,t)}removeHost(e){const t=this._hostNodes.get(e);t&&t.forEach(Mu),this._hostNodes.delete(e)}onStylesAdded(e){this._hostNodes.forEach((t,n)=>{this._addStylesToHost(e,n,t)})}ngOnDestroy(){this._hostNodes.forEach(e=>e.forEach(Mu))}}return e.\u0275fac=function(t){return new(t||e)(cr(Qa))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();function Mu(e){Ya().remove(e)}const Lu={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"},Bu=/%COMP%/g;function Vu(e,t,n){for(let r=0;r<t.length;r++){let s=t[r];Array.isArray(s)?Vu(e,s,n):(s=s.replace(Bu,e),n.push(s))}return n}function Uu(e){return t=>{if("__ngUnwrap__"===t)return e;!1===e(t)&&(t.preventDefault(),t.returnValue=!1)}}let zu=(()=>{class e{constructor(e,t,n){this.eventManager=e,this.sharedStylesHost=t,this.appId=n,this.rendererByCompId=new Map,this.defaultRenderer=new Wu(e)}createRenderer(e,t){if(!e||!t)return this.defaultRenderer;switch(t.encapsulation){case Ge.Emulated:{let n=this.rendererByCompId.get(t.id);return n||(n=new ju(this.eventManager,this.sharedStylesHost,t,this.appId),this.rendererByCompId.set(t.id,n)),n.applyToHost(e),n}case 1:case Ge.ShadowDom:return new Hu(this.eventManager,this.sharedStylesHost,e,t);default:if(!this.rendererByCompId.has(t.id)){const e=Vu(t.id,t.styles,[]);this.sharedStylesHost.addStyles(e),this.rendererByCompId.set(t.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return e.\u0275fac=function(t){return new(t||e)(cr(Ou),cr(Pu),cr(ea))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();class Wu{constructor(e){this.eventManager=e,this.data=Object.create(null)}destroy(){}createElement(e,t){return t?document.createElementNS(Lu[t]||t,e):document.createElement(e)}createComment(e){return document.createComment(e)}createText(e){return document.createTextNode(e)}appendChild(e,t){e.appendChild(t)}insertBefore(e,t,n){e&&e.insertBefore(t,n)}removeChild(e,t){e&&e.removeChild(t)}selectRootElement(e,t){let n="string"==typeof e?document.querySelector(e):e;if(!n)throw new Error(`The selector "${e}" did not match any elements`);return t||(n.textContent=""),n}parentNode(e){return e.parentNode}nextSibling(e){return e.nextSibling}setAttribute(e,t,n,r){if(r){t=r+":"+t;const s=Lu[r];s?e.setAttributeNS(s,t,n):e.setAttribute(t,n)}else e.setAttribute(t,n)}removeAttribute(e,t,n){if(n){const r=Lu[n];r?e.removeAttributeNS(r,t):e.removeAttribute(`${n}:${t}`)}else e.removeAttribute(t)}addClass(e,t){e.classList.add(t)}removeClass(e,t){e.classList.remove(t)}setStyle(e,t,n,r){r&(kr.DashCase|kr.Important)?e.style.setProperty(t,n,r&kr.Important?"important":""):e.style[t]=n}removeStyle(e,t,n){n&kr.DashCase?e.style.removeProperty(t):e.style[t]=""}setProperty(e,t,n){e[t]=n}setValue(e,t){e.nodeValue=t}listen(e,t,n){return"string"==typeof e?this.eventManager.addGlobalEventListener(e,t,Uu(n)):this.eventManager.addEventListener(e,t,Uu(n))}}class ju extends Wu{constructor(e,t,n,r){super(e),this.component=n;const s=Vu(r+"-"+n.id,n.styles,[]);t.addStyles(s),this.contentAttr="_ngcontent-%COMP%".replace(Bu,r+"-"+n.id),this.hostAttr="_nghost-%COMP%".replace(Bu,r+"-"+n.id)}applyToHost(e){super.setAttribute(e,this.hostAttr,"")}createElement(e,t){const n=super.createElement(e,t);return super.setAttribute(n,this.contentAttr,""),n}}class Hu extends Wu{constructor(e,t,n,r){super(e),this.sharedStylesHost=t,this.hostEl=n,this.shadowRoot=n.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const s=Vu(r.id,r.styles,[]);for(let o=0;o<s.length;o++){const e=document.createElement("style");e.textContent=s[o],this.shadowRoot.appendChild(e)}}nodeOrShadowRoot(e){return e===this.hostEl?this.shadowRoot:e}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(e,t){return super.appendChild(this.nodeOrShadowRoot(e),t)}insertBefore(e,t,n){return super.insertBefore(this.nodeOrShadowRoot(e),t,n)}removeChild(e,t){return super.removeChild(this.nodeOrShadowRoot(e),t)}parentNode(e){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(e)))}}let Gu=(()=>{class e extends Fu{constructor(e){super(e)}supports(e){return!0}addEventListener(e,t,n){return e.addEventListener(t,n,!1),()=>this.removeEventListener(e,t,n)}removeEventListener(e,t,n){return e.removeEventListener(t,n)}}return e.\u0275fac=function(t){return new(t||e)(cr(Qa))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();const qu=["alt","control","meta","shift"],Ku={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},Xu={A:"1",B:"2",C:"3",D:"4",E:"5",F:"6",G:"7",H:"8",I:"9",J:"*",K:"+",M:"-",N:".",O:"/","`":"0","\x90":"NumLock"},Yu={alt:e=>e.altKey,control:e=>e.ctrlKey,meta:e=>e.metaKey,shift:e=>e.shiftKey};let Qu=(()=>{class e extends Fu{constructor(e){super(e)}supports(t){return null!=e.parseEventName(t)}addEventListener(t,n,r){const s=e.parseEventName(n),o=e.eventCallback(s.fullKey,r,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>Ya().onAndCancel(t,s.domEventName,o))}static parseEventName(t){const n=t.toLowerCase().split("."),r=n.shift();if(0===n.length||"keydown"!==r&&"keyup"!==r)return null;const s=e._normalizeKey(n.pop());let o="";if(qu.forEach(e=>{const t=n.indexOf(e);t>-1&&(n.splice(t,1),o+=e+".")}),o+=s,0!=n.length||0===s.length)return null;const i={};return i.domEventName=r,i.fullKey=o,i}static getEventFullKey(e){let t="",n=function(e){let t=e.key;if(null==t){if(t=e.keyIdentifier,null==t)return"Unidentified";t.startsWith("U+")&&(t=String.fromCharCode(parseInt(t.substring(2),16)),3===e.location&&Xu.hasOwnProperty(t)&&(t=Xu[t]))}return Ku[t]||t}(e);return n=n.toLowerCase()," "===n?n="space":"."===n&&(n="dot"),qu.forEach(r=>{r!=n&&(0,Yu[r])(e)&&(t+=r+".")}),t+=n,t}static eventCallback(t,n,r){return s=>{e.getEventFullKey(s)===t&&r.runGuarded(()=>n(s))}}static _normalizeKey(e){switch(e){case"esc":return"escape";default:return e}}}return e.\u0275fac=function(t){return new(t||e)(cr(Qa))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();const Zu=Da(Ga,"browser",[{provide:sa,useValue:"browser"},{provide:ra,useValue:function(){Eu.makeCurrent(),$u.init()},multi:!0},{provide:Qa,useFactory:function(){return function(e){$t=e}(document),document},deps:[]}]),Ju=[[],{provide:Gs,useValue:"root"},{provide:wr,useFactory:function(){return new wr},deps:[]},{provide:Au,useClass:Gu,multi:!0,deps:[Qa,ba,sa]},{provide:Au,useClass:Qu,multi:!0,deps:[Qa]},[],{provide:zu,useClass:zu,deps:[Ou,Pu,ea]},{provide:Vo,useExisting:zu},{provide:Du,useExisting:Pu},{provide:Pu,useClass:Pu,deps:[Qa]},{provide:Sa,useClass:Sa,deps:[ba]},{provide:Ou,useClass:Ou,deps:[Au,ba]},{provide:class{},useClass:Ru,deps:[]},[]];let el=(()=>{class e{constructor(e){if(e)throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.")}static withServerTransition(t){return{ngModule:e,providers:[{provide:ea,useValue:t.appId},{provide:Iu,useExisting:ea},Nu]}}}return e.\u0275fac=function(t){return new(t||e)(cr(e,12))},e.\u0275mod=dt({type:e}),e.\u0275inj=Ae({providers:Ju,imports:[wu,Ka]}),e})();function tl(...e){let t=e[e.length-1];return K(t)?(e.pop(),re(e,t)):pe(e)}"undefined"!=typeof window&&window;class nl extends G{constructor(e){super(),this._value=e}get value(){return this.getValue()}_subscribe(e){const t=super._subscribe(e);return t&&!t.closed&&e.next(this._value),t}getValue(){if(this.hasError)throw this.thrownError;if(this.closed)throw new W;return this._value}next(e){super.next(this._value=e)}}class rl extends M{notifyNext(e,t,n,r,s){this.destination.next(t)}notifyError(e,t){this.destination.error(e)}notifyComplete(e){this.destination.complete()}}class sl extends M{constructor(e,t,n){super(),this.parent=e,this.outerValue=t,this.outerIndex=n,this.index=0}_next(e){this.parent.notifyNext(this.outerValue,e,this.outerIndex,this.index++,this)}_error(e){this.parent.notifyError(e,this),this.unsubscribe()}_complete(){this.parent.notifyComplete(this),this.unsubscribe()}}function ol(e,t,n,r,s=new sl(e,n,r)){if(!s.closed)return t instanceof U?t.subscribe(s):ne(t)(s)}const il={};class al{constructor(e){this.resultSelector=e}call(e,t){return t.subscribe(new ul(e,this.resultSelector))}}class ul extends rl{constructor(e,t){super(e),this.resultSelector=t,this.active=0,this.values=[],this.observables=[]}_next(e){this.values.push(il),this.observables.push(e)}_complete(){const e=this.observables,t=e.length;if(0===t)this.destination.complete();else{this.active=t,this.toRespond=t;for(let n=0;n<t;n++)this.add(ol(this,e[n],void 0,n))}}notifyComplete(e){0==(this.active-=1)&&this.destination.complete()}notifyNext(e,t,n){const r=this.values,s=this.toRespond?r[n]===il?--this.toRespond:this.toRespond:0;r[n]=t,0===s&&(this.resultSelector?this._tryResultSelector(r):this.destination.next(r.slice()))}_tryResultSelector(e){let t;try{t=this.resultSelector.apply(this,e)}catch(n){return void this.destination.error(n)}this.destination.next(t)}}const ll=(()=>{function e(){return Error.call(this),this.message="no elements in sequence",this.name="EmptyError",this}return e.prototype=Object.create(Error.prototype),e})();function cl(...e){return de(1)(tl(...e))}const hl=new U(e=>e.complete());function dl(e){return e?function(e){return new U(t=>e.schedule(()=>t.complete()))}(e):hl}function pl(e){return new U(t=>{let n;try{n=e()}catch(r){return void t.error(r)}return(n?se(n):dl()).subscribe(t)})}function fl(e,t){return"function"==typeof t?n=>n.pipe(fl((n,r)=>se(e(n,r)).pipe(X((e,s)=>t(n,e,r,s))))):t=>t.lift(new ml(e))}class ml{constructor(e){this.project=e}call(e,t){return t.subscribe(new gl(e,this.project))}}class gl extends ie{constructor(e,t){super(e),this.project=t,this.index=0}_next(e){let t;const n=this.index++;try{t=this.project(e,n)}catch(r){return void this.destination.error(r)}this._innerSub(t)}_innerSub(e){const t=this.innerSubscription;t&&t.unsubscribe();const n=new oe(this),r=this.destination;r.add(n),this.innerSubscription=ae(e,n),this.innerSubscription!==n&&r.add(this.innerSubscription)}_complete(){const{innerSubscription:e}=this;e&&!e.closed||super._complete(),this.unsubscribe()}_unsubscribe(){this.innerSubscription=void 0}notifyComplete(){this.innerSubscription=void 0,this.isStopped&&super._complete()}notifyNext(e){this.destination.next(e)}}const yl=(()=>{function e(){return Error.call(this),this.message="argument out of range",this.name="ArgumentOutOfRangeError",this}return e.prototype=Object.create(Error.prototype),e})();function xl(e){return t=>0===e?dl():t.lift(new bl(e))}class bl{constructor(e){if(this.total=e,this.total<0)throw new yl}call(e,t){return t.subscribe(new vl(e,this.total))}}class vl extends M{constructor(e,t){super(e),this.total=t,this.count=0}_next(e){const t=this.total,n=++this.count;n<=t&&(this.destination.next(e),n===t&&(this.destination.complete(),this.unsubscribe()))}}function wl(e,t){let n=!1;return arguments.length>=2&&(n=!0),function(r){return r.lift(new Cl(e,t,n))}}class Cl{constructor(e,t,n=!1){this.accumulator=e,this.seed=t,this.hasSeed=n}call(e,t){return t.subscribe(new _l(e,this.accumulator,this.seed,this.hasSeed))}}class _l extends M{constructor(e,t,n,r){super(e),this.accumulator=t,this._seed=n,this.hasSeed=r,this.index=0}get seed(){return this._seed}set seed(e){this.hasSeed=!0,this._seed=e}_next(e){if(this.hasSeed)return this._tryNext(e);this.seed=e,this.destination.next(e)}_tryNext(e){const t=this.index++;let n;try{n=this.accumulator(this.seed,e,t)}catch(r){this.destination.error(r)}this.seed=n,this.destination.next(n)}}function kl(e,t){return function(n){return n.lift(new El(e,t))}}class El{constructor(e,t){this.predicate=e,this.thisArg=t}call(e,t){return t.subscribe(new Sl(e,this.predicate,this.thisArg))}}class Sl extends M{constructor(e,t,n){super(e),this.predicate=t,this.thisArg=n,this.count=0}_next(e){let t;try{t=this.predicate.call(this.thisArg,e,this.count++)}catch(n){return void this.destination.error(n)}t&&this.destination.next(e)}}function Tl(e){return function(t){const n=new Il(e),r=t.lift(n);return n.caught=r}}class Il{constructor(e){this.selector=e}call(e,t){return t.subscribe(new Nl(e,this.selector,this.caught))}}class Nl extends ie{constructor(e,t,n){super(e),this.selector=t,this.caught=n}error(e){if(!this.isStopped){let n;try{n=this.selector(e,this.caught)}catch(t){return void super.error(t)}this._unsubscribeAndRecycle();const r=new oe(this);this.add(r);const s=ae(n,r);s!==r&&this.add(s)}}}function $l(e,t){return ue(e,t,1)}function Rl(e){return function(t){return 0===e?dl():t.lift(new Al(e))}}class Al{constructor(e){if(this.total=e,this.total<0)throw new yl}call(e,t){return t.subscribe(new Ol(e,this.total))}}class Ol extends M{constructor(e,t){super(e),this.total=t,this.ring=new Array,this.count=0}_next(e){const t=this.ring,n=this.total,r=this.count++;t.length<n?t.push(e):t[r%n]=e}_complete(){const e=this.destination;let t=this.count;if(t>0){const n=this.count>=this.total?this.total:this.count,r=this.ring;for(let s=0;s<n;s++){const s=t++%n;e.next(r[s])}}e.complete()}}function Fl(e=Ml){return t=>t.lift(new Dl(e))}class Dl{constructor(e){this.errorFactory=e}call(e,t){return t.subscribe(new Pl(e,this.errorFactory))}}class Pl extends M{constructor(e,t){super(e),this.errorFactory=t,this.hasValue=!1}_next(e){this.hasValue=!0,this.destination.next(e)}_complete(){if(this.hasValue)return this.destination.complete();{let t;try{t=this.errorFactory()}catch(e){t=e}this.destination.error(t)}}}function Ml(){return new ll}function Ll(e=null){return t=>t.lift(new Bl(e))}class Bl{constructor(e){this.defaultValue=e}call(e,t){return t.subscribe(new Vl(e,this.defaultValue))}}class Vl extends M{constructor(e,t){super(e),this.defaultValue=t,this.isEmpty=!0}_next(e){this.isEmpty=!1,this.destination.next(e)}_complete(){this.isEmpty&&this.destination.next(this.defaultValue),this.destination.complete()}}function Ul(e,t){const n=arguments.length>=2;return r=>r.pipe(e?kl((t,n)=>e(t,n,r)):V,xl(1),n?Ll(t):Fl(()=>new ll))}function zl(){}function Wl(e,t,n){return function(r){return r.lift(new jl(e,t,n))}}class jl{constructor(e,t,n){this.nextOrObserver=e,this.error=t,this.complete=n}call(e,t){return t.subscribe(new Hl(e,this.nextOrObserver,this.error,this.complete))}}class Hl extends M{constructor(e,t,n,r){super(e),this._tapNext=zl,this._tapError=zl,this._tapComplete=zl,this._tapError=n||zl,this._tapComplete=r||zl,S(t)?(this._context=this,this._tapNext=t):t&&(this._context=t,this._tapNext=t.next||zl,this._tapError=t.error||zl,this._tapComplete=t.complete||zl)}_next(e){try{this._tapNext.call(this._context,e)}catch(t){return void this.destination.error(t)}this.destination.next(e)}_error(e){try{this._tapError.call(this._context,e)}catch(e){return void this.destination.error(e)}this.destination.error(e)}_complete(){try{this._tapComplete.call(this._context)}catch(e){return void this.destination.error(e)}return this.destination.complete()}}class Gl{constructor(e){this.callback=e}call(e,t){return t.subscribe(new ql(e,this.callback))}}class ql extends M{constructor(e,t){super(e),this.add(new F(t))}}class Kl{constructor(e,t){this.id=e,this.url=t}}class Xl extends Kl{constructor(e,t,n="imperative",r=null){super(e,t),this.navigationTrigger=n,this.restoredState=r}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class Yl extends Kl{constructor(e,t,n){super(e,t),this.urlAfterRedirects=n}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class Ql extends Kl{constructor(e,t,n){super(e,t),this.reason=n}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class Zl extends Kl{constructor(e,t,n){super(e,t),this.error=n}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class Jl extends Kl{constructor(e,t,n,r){super(e,t),this.urlAfterRedirects=n,this.state=r}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class ec extends Kl{constructor(e,t,n,r){super(e,t),this.urlAfterRedirects=n,this.state=r}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class tc extends Kl{constructor(e,t,n,r,s){super(e,t),this.urlAfterRedirects=n,this.state=r,this.shouldActivate=s}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class nc extends Kl{constructor(e,t,n,r){super(e,t),this.urlAfterRedirects=n,this.state=r}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class rc extends Kl{constructor(e,t,n,r){super(e,t),this.urlAfterRedirects=n,this.state=r}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class sc{constructor(e){this.route=e}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class oc{constructor(e){this.route=e}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class ic{constructor(e){this.snapshot=e}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class ac{constructor(e){this.snapshot=e}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class uc{constructor(e){this.snapshot=e}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class lc{constructor(e){this.snapshot=e}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class cc{constructor(e,t,n){this.routerEvent=e,this.position=t,this.anchor=n}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}const hc="primary";class dc{constructor(e){this.params=e||{}}has(e){return Object.prototype.hasOwnProperty.call(this.params,e)}get(e){if(this.has(e)){const t=this.params[e];return Array.isArray(t)?t[0]:t}return null}getAll(e){if(this.has(e)){const t=this.params[e];return Array.isArray(t)?t:[t]}return[]}get keys(){return Object.keys(this.params)}}function pc(e){return new dc(e)}function fc(e){const t=Error("NavigationCancelingError: "+e);return t.ngNavigationCancelingError=!0,t}function mc(e,t,n){const r=n.path.split("/");if(r.length>e.length)return null;if("full"===n.pathMatch&&(t.hasChildren()||r.length<e.length))return null;const s={};for(let o=0;o<r.length;o++){const t=r[o],n=e[o];if(t.startsWith(":"))s[t.substring(1)]=n;else if(t!==n.path)return null}return{consumed:e.slice(0,r.length),posParams:s}}function gc(e,t){const n=e?Object.keys(e):void 0,r=t?Object.keys(t):void 0;if(!n||!r||n.length!=r.length)return!1;let s;for(let o=0;o<n.length;o++)if(s=n[o],!yc(e[s],t[s]))return!1;return!0}function yc(e,t){if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;const n=[...e].sort(),r=[...t].sort();return n.every((e,t)=>r[t]===e)}return e===t}function xc(e){return Array.prototype.concat.apply([],e)}function bc(e){return e.length>0?e[e.length-1]:null}function vc(e,t){for(const n in e)e.hasOwnProperty(n)&&t(e[n],n)}function wc(e){return wo(e)?e:vo(e)?se(Promise.resolve(e)):tl(e)}const Cc={exact:function e(t,n,r){if(!Rc(t.segments,n.segments))return!1;if(!Tc(t.segments,n.segments,r))return!1;if(t.numberOfChildren!==n.numberOfChildren)return!1;for(const s in n.children){if(!t.children[s])return!1;if(!e(t.children[s],n.children[s],r))return!1}return!0},subset:Ec},_c={exact:function(e,t){return gc(e,t)},subset:function(e,t){return Object.keys(t).length<=Object.keys(e).length&&Object.keys(t).every(n=>yc(e[n],t[n]))},ignored:()=>!0};function kc(e,t,n){return Cc[n.paths](e.root,t.root,n.matrixParams)&&_c[n.queryParams](e.queryParams,t.queryParams)&&!("exact"===n.fragment&&e.fragment!==t.fragment)}function Ec(e,t,n){return Sc(e,t,t.segments,n)}function Sc(e,t,n,r){if(e.segments.length>n.length){const s=e.segments.slice(0,n.length);return!!Rc(s,n)&&!t.hasChildren()&&!!Tc(s,n,r)}if(e.segments.length===n.length){if(!Rc(e.segments,n))return!1;if(!Tc(e.segments,n,r))return!1;for(const n in t.children){if(!e.children[n])return!1;if(!Ec(e.children[n],t.children[n],r))return!1}return!0}{const s=n.slice(0,e.segments.length),o=n.slice(e.segments.length);return!!Rc(e.segments,s)&&!!Tc(e.segments,s,r)&&!!e.children.primary&&Sc(e.children.primary,t,o,r)}}function Tc(e,t,n){return t.every((t,r)=>_c[n](e[r].parameters,t.parameters))}class Ic{constructor(e,t,n){this.root=e,this.queryParams=t,this.fragment=n}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=pc(this.queryParams)),this._queryParamMap}toString(){return Fc.serialize(this)}}class Nc{constructor(e,t){this.segments=e,this.children=t,this.parent=null,vc(t,(e,t)=>e.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return Dc(this)}}class $c{constructor(e,t){this.path=e,this.parameters=t}get parameterMap(){return this._parameterMap||(this._parameterMap=pc(this.parameters)),this._parameterMap}toString(){return zc(this)}}function Rc(e,t){return e.length===t.length&&e.every((e,n)=>e.path===t[n].path)}class Ac{}class Oc{parse(e){const t=new qc(e);return new Ic(t.parseRootSegment(),t.parseQueryParams(),t.parseFragment())}serialize(e){var t;return`/${Pc(e.root,!0)}${function(e){const t=Object.keys(e).map(t=>{const n=e[t];return Array.isArray(n)?n.map(e=>`${Lc(t)}=${Lc(e)}`).join("&"):`${Lc(t)}=${Lc(n)}`}).filter(e=>!!e);return t.length?`?${t.join("&")}`:""}(e.queryParams)}${"string"==typeof e.fragment?`#${t=e.fragment,encodeURI(t)}`:""}`}}const Fc=new Oc;function Dc(e){return e.segments.map(e=>zc(e)).join("/")}function Pc(e,t){if(!e.hasChildren())return Dc(e);if(t){const t=e.children.primary?Pc(e.children.primary,!1):"",n=[];return vc(e.children,(e,t)=>{t!==hc&&n.push(`${t}:${Pc(e,!1)}`)}),n.length>0?`${t}(${n.join("//")})`:t}{const t=function(e,t){let n=[];return vc(e.children,(e,r)=>{r===hc&&(n=n.concat(t(e,r)))}),vc(e.children,(e,r)=>{r!==hc&&(n=n.concat(t(e,r)))}),n}(e,(t,n)=>n===hc?[Pc(e.children.primary,!1)]:[`${n}:${Pc(t,!1)}`]);return 1===Object.keys(e.children).length&&null!=e.children.primary?`${Dc(e)}/${t[0]}`:`${Dc(e)}/(${t.join("//")})`}}function Mc(e){return encodeURIComponent(e).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function Lc(e){return Mc(e).replace(/%3B/gi,";")}function Bc(e){return Mc(e).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function Vc(e){return decodeURIComponent(e)}function Uc(e){return Vc(e.replace(/\+/g,"%20"))}function zc(e){return`${Bc(e.path)}${t=e.parameters,Object.keys(t).map(e=>`;${Bc(e)}=${Bc(t[e])}`).join("")}`;var t}const Wc=/^[^\/()?;=#]+/;function jc(e){const t=e.match(Wc);return t?t[0]:""}const Hc=/^[^=?&#]+/,Gc=/^[^?&#]+/;class qc{constructor(e){this.url=e,this.remaining=e}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new Nc([],{}):new Nc([],this.parseChildren())}parseQueryParams(){const e={};if(this.consumeOptional("?"))do{this.parseQueryParam(e)}while(this.consumeOptional("&"));return e}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const e=[];for(this.peekStartsWith("(")||e.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),e.push(this.parseSegment());let t={};this.peekStartsWith("/(")&&(this.capture("/"),t=this.parseParens(!0));let n={};return this.peekStartsWith("(")&&(n=this.parseParens(!1)),(e.length>0||Object.keys(t).length>0)&&(n.primary=new Nc(e,t)),n}parseSegment(){const e=jc(this.remaining);if(""===e&&this.peekStartsWith(";"))throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`);return this.capture(e),new $c(Vc(e),this.parseMatrixParams())}parseMatrixParams(){const e={};for(;this.consumeOptional(";");)this.parseParam(e);return e}parseParam(e){const t=jc(this.remaining);if(!t)return;this.capture(t);let n="";if(this.consumeOptional("=")){const e=jc(this.remaining);e&&(n=e,this.capture(n))}e[Vc(t)]=Vc(n)}parseQueryParam(e){const t=function(e){const t=e.match(Hc);return t?t[0]:""}(this.remaining);if(!t)return;this.capture(t);let n="";if(this.consumeOptional("=")){const e=function(e){const t=e.match(Gc);return t?t[0]:""}(this.remaining);e&&(n=e,this.capture(n))}const r=Uc(t),s=Uc(n);if(e.hasOwnProperty(r)){let t=e[r];Array.isArray(t)||(t=[t],e[r]=t),t.push(s)}else e[r]=s}parseParens(e){const t={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const n=jc(this.remaining),r=this.remaining[n.length];if("/"!==r&&")"!==r&&";"!==r)throw new Error(`Cannot parse url '${this.url}'`);let s;n.indexOf(":")>-1?(s=n.substr(0,n.indexOf(":")),this.capture(s),this.capture(":")):e&&(s=hc);const o=this.parseChildren();t[s]=1===Object.keys(o).length?o.primary:new Nc([],o),this.consumeOptional("//")}return t}peekStartsWith(e){return this.remaining.startsWith(e)}consumeOptional(e){return!!this.peekStartsWith(e)&&(this.remaining=this.remaining.substring(e.length),!0)}capture(e){if(!this.consumeOptional(e))throw new Error(`Expected "${e}".`)}}class Kc{constructor(e){this._root=e}get root(){return this._root.value}parent(e){const t=this.pathFromRoot(e);return t.length>1?t[t.length-2]:null}children(e){const t=Xc(e,this._root);return t?t.children.map(e=>e.value):[]}firstChild(e){const t=Xc(e,this._root);return t&&t.children.length>0?t.children[0].value:null}siblings(e){const t=Yc(e,this._root);return t.length<2?[]:t[t.length-2].children.map(e=>e.value).filter(t=>t!==e)}pathFromRoot(e){return Yc(e,this._root).map(e=>e.value)}}function Xc(e,t){if(e===t.value)return t;for(const n of t.children){const t=Xc(e,n);if(t)return t}return null}function Yc(e,t){if(e===t.value)return[t];for(const n of t.children){const r=Yc(e,n);if(r.length)return r.unshift(t),r}return[]}class Qc{constructor(e,t){this.value=e,this.children=t}toString(){return`TreeNode(${this.value})`}}function Zc(e){const t={};return e&&e.children.forEach(e=>t[e.value.outlet]=e),t}class Jc extends Kc{constructor(e,t){super(e),this.snapshot=t,oh(this,e)}toString(){return this.snapshot.toString()}}function eh(e,t){const n=function(e,t){const n=new rh([],{},{},"",{},hc,t,null,e.root,-1,{});return new sh("",new Qc(n,[]))}(e,t),r=new nl([new $c("",{})]),s=new nl({}),o=new nl({}),i=new nl({}),a=new nl(""),u=new th(r,s,i,a,o,hc,t,n.root);return u.snapshot=n.root,new Jc(new Qc(u,[]),n)}class th{constructor(e,t,n,r,s,o,i,a){this.url=e,this.params=t,this.queryParams=n,this.fragment=r,this.data=s,this.outlet=o,this.component=i,this._futureSnapshot=a}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(X(e=>pc(e)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(X(e=>pc(e)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function nh(e,t="emptyOnly"){const n=e.pathFromRoot;let r=0;if("always"!==t)for(r=n.length-1;r>=1;){const e=n[r],t=n[r-1];if(e.routeConfig&&""===e.routeConfig.path)r--;else{if(t.component)break;r--}}return function(e){return e.reduce((e,t)=>({params:Object.assign(Object.assign({},e.params),t.params),data:Object.assign(Object.assign({},e.data),t.data),resolve:Object.assign(Object.assign({},e.resolve),t._resolvedData)}),{params:{},data:{},resolve:{}})}(n.slice(r))}class rh{constructor(e,t,n,r,s,o,i,a,u,l,c){this.url=e,this.params=t,this.queryParams=n,this.fragment=r,this.data=s,this.outlet=o,this.component=i,this.routeConfig=a,this._urlSegment=u,this._lastPathIndex=l,this._resolve=c}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=pc(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=pc(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(e=>e.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class sh extends Kc{constructor(e,t){super(t),this.url=e,oh(this,t)}toString(){return ih(this._root)}}function oh(e,t){t.value._routerState=e,t.children.forEach(t=>oh(e,t))}function ih(e){const t=e.children.length>0?` { ${e.children.map(ih).join(", ")} } `:"";return`${e.value}${t}`}function ah(e){if(e.snapshot){const t=e.snapshot,n=e._futureSnapshot;e.snapshot=n,gc(t.queryParams,n.queryParams)||e.queryParams.next(n.queryParams),t.fragment!==n.fragment&&e.fragment.next(n.fragment),gc(t.params,n.params)||e.params.next(n.params),function(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!gc(e[n],t[n]))return!1;return!0}(t.url,n.url)||e.url.next(n.url),gc(t.data,n.data)||e.data.next(n.data)}else e.snapshot=e._futureSnapshot,e.data.next(e._futureSnapshot.data)}function uh(e,t){var n,r;return gc(e.params,t.params)&&Rc(n=e.url,r=t.url)&&n.every((e,t)=>gc(e.parameters,r[t].parameters))&&!(!e.parent!=!t.parent)&&(!e.parent||uh(e.parent,t.parent))}function lh(e,t,n){if(n&&e.shouldReuseRoute(t.value,n.value.snapshot)){const r=n.value;r._futureSnapshot=t.value;const s=function(e,t,n){return t.children.map(t=>{for(const r of n.children)if(e.shouldReuseRoute(t.value,r.value.snapshot))return lh(e,t,r);return lh(e,t)})}(e,t,n);return new Qc(r,s)}{if(e.shouldAttach(t.value)){const n=e.retrieve(t.value);if(null!==n){const e=n.route;return ch(t,e),e}}const n=new th(new nl((r=t.value).url),new nl(r.params),new nl(r.queryParams),new nl(r.fragment),new nl(r.data),r.outlet,r.component,r),s=t.children.map(t=>lh(e,t));return new Qc(n,s)}var r}function ch(e,t){if(e.value.routeConfig!==t.value.routeConfig)throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route");if(e.children.length!==t.children.length)throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children");t.value._futureSnapshot=e.value;for(let n=0;n<e.children.length;++n)ch(e.children[n],t.children[n])}function hh(e){return"object"==typeof e&&null!=e&&!e.outlets&&!e.segmentPath}function dh(e){return"object"==typeof e&&null!=e&&e.outlets}function ph(e,t,n,r,s){let o={};return r&&vc(r,(e,t)=>{o[t]=Array.isArray(e)?e.map(e=>`${e}`):`${e}`}),new Ic(n.root===e?t:fh(n.root,e,t),o,s)}function fh(e,t,n){const r={};return vc(e.children,(e,s)=>{r[s]=e===t?n:fh(e,t,n)}),new Nc(e.segments,r)}class mh{constructor(e,t,n){if(this.isAbsolute=e,this.numberOfDoubleDots=t,this.commands=n,e&&n.length>0&&hh(n[0]))throw new Error("Root segment cannot have matrix parameters");const r=n.find(dh);if(r&&r!==bc(n))throw new Error("{outlets:{}} has to be the last command")}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class gh{constructor(e,t,n){this.segmentGroup=e,this.processChildren=t,this.index=n}}function yh(e,t,n){if(e||(e=new Nc([],{})),0===e.segments.length&&e.hasChildren())return xh(e,t,n);const r=function(e,t,n){let r=0,s=t;const o={match:!1,pathIndex:0,commandIndex:0};for(;s<e.segments.length;){if(r>=n.length)return o;const t=e.segments[s],i=n[r];if(dh(i))break;const a=`${i}`,u=r<n.length-1?n[r+1]:null;if(s>0&&void 0===a)break;if(a&&u&&"object"==typeof u&&void 0===u.outlets){if(!Ch(a,u,t))return o;r+=2}else{if(!Ch(a,{},t))return o;r++}s++}return{match:!0,pathIndex:s,commandIndex:r}}(e,t,n),s=n.slice(r.commandIndex);if(r.match&&r.pathIndex<e.segments.length){const t=new Nc(e.segments.slice(0,r.pathIndex),{});return t.children.primary=new Nc(e.segments.slice(r.pathIndex),e.children),xh(t,0,s)}return r.match&&0===s.length?new Nc(e.segments,{}):r.match&&!e.hasChildren()?bh(e,t,n):r.match?xh(e,0,s):bh(e,t,n)}function xh(e,t,n){if(0===n.length)return new Nc(e.segments,{});{const r=function(e){return dh(e[0])?e[0].outlets:{[hc]:e}}(n),s={};return vc(r,(n,r)=>{"string"==typeof n&&(n=[n]),null!==n&&(s[r]=yh(e.children[r],t,n))}),vc(e.children,(e,t)=>{void 0===r[t]&&(s[t]=e)}),new Nc(e.segments,s)}}function bh(e,t,n){const r=e.segments.slice(0,t);let s=0;for(;s<n.length;){const o=n[s];if(dh(o)){const e=vh(o.outlets);return new Nc(r,e)}if(0===s&&hh(n[0])){r.push(new $c(e.segments[t].path,wh(n[0]))),s++;continue}const i=dh(o)?o.outlets.primary:`${o}`,a=s<n.length-1?n[s+1]:null;i&&a&&hh(a)?(r.push(new $c(i,wh(a))),s+=2):(r.push(new $c(i,{})),s++)}return new Nc(r,{})}function vh(e){const t={};return vc(e,(e,n)=>{"string"==typeof e&&(e=[e]),null!==e&&(t[n]=bh(new Nc([],{}),0,e))}),t}function wh(e){const t={};return vc(e,(e,n)=>t[n]=`${e}`),t}function Ch(e,t,n){return e==n.path&&gc(t,n.parameters)}class _h{constructor(e,t,n,r){this.routeReuseStrategy=e,this.futureState=t,this.currState=n,this.forwardEvent=r}activate(e){const t=this.futureState._root,n=this.currState?this.currState._root:null;this.deactivateChildRoutes(t,n,e),ah(this.futureState.root),this.activateChildRoutes(t,n,e)}deactivateChildRoutes(e,t,n){const r=Zc(t);e.children.forEach(e=>{const t=e.value.outlet;this.deactivateRoutes(e,r[t],n),delete r[t]}),vc(r,(e,t)=>{this.deactivateRouteAndItsChildren(e,n)})}deactivateRoutes(e,t,n){const r=e.value,s=t?t.value:null;if(r===s)if(r.component){const s=n.getContext(r.outlet);s&&this.deactivateChildRoutes(e,t,s.children)}else this.deactivateChildRoutes(e,t,n);else s&&this.deactivateRouteAndItsChildren(t,n)}deactivateRouteAndItsChildren(e,t){this.routeReuseStrategy.shouldDetach(e.value.snapshot)?this.detachAndStoreRouteSubtree(e,t):this.deactivateRouteAndOutlet(e,t)}detachAndStoreRouteSubtree(e,t){const n=t.getContext(e.value.outlet);if(n&&n.outlet){const t=n.outlet.detach(),r=n.children.onOutletDeactivated();this.routeReuseStrategy.store(e.value.snapshot,{componentRef:t,route:e,contexts:r})}}deactivateRouteAndOutlet(e,t){const n=t.getContext(e.value.outlet),r=n&&e.value.component?n.children:t,s=Zc(e);for(const o of Object.keys(s))this.deactivateRouteAndItsChildren(s[o],r);n&&n.outlet&&(n.outlet.deactivate(),n.children.onOutletDeactivated(),n.attachRef=null,n.resolver=null,n.route=null)}activateChildRoutes(e,t,n){const r=Zc(t);e.children.forEach(e=>{this.activateRoutes(e,r[e.value.outlet],n),this.forwardEvent(new lc(e.value.snapshot))}),e.children.length&&this.forwardEvent(new ac(e.value.snapshot))}activateRoutes(e,t,n){const r=e.value,s=t?t.value:null;if(ah(r),r===s)if(r.component){const s=n.getOrCreateContext(r.outlet);this.activateChildRoutes(e,t,s.children)}else this.activateChildRoutes(e,t,n);else if(r.component){const t=n.getOrCreateContext(r.outlet);if(this.routeReuseStrategy.shouldAttach(r.snapshot)){const e=this.routeReuseStrategy.retrieve(r.snapshot);this.routeReuseStrategy.store(r.snapshot,null),t.children.onOutletReAttached(e.contexts),t.attachRef=e.componentRef,t.route=e.route.value,t.outlet&&t.outlet.attach(e.componentRef,e.route.value),kh(e.route)}else{const n=function(e){for(let t=e.parent;t;t=t.parent){const e=t.routeConfig;if(e&&e._loadedConfig)return e._loadedConfig;if(e&&e.component)return null}return null}(r.snapshot),s=n?n.module.componentFactoryResolver:null;t.attachRef=null,t.route=r,t.resolver=s,t.outlet&&t.outlet.activateWith(r,s),this.activateChildRoutes(e,null,t.children)}}else this.activateChildRoutes(e,null,n)}}function kh(e){ah(e.value),e.children.forEach(kh)}class Eh{constructor(e,t){this.routes=e,this.module=t}}function Sh(e){return"function"==typeof e}function Th(e){return e instanceof Ic}const Ih=Symbol("INITIAL_VALUE");function Nh(){return fl(e=>function(...e){let t,n;return K(e[e.length-1])&&(n=e.pop()),"function"==typeof e[e.length-1]&&(t=e.pop()),1===e.length&&R(e[0])&&(e=e[0]),pe(e,n).lift(new al(t))}(e.map(e=>e.pipe(xl(1),function(...e){const t=e[e.length-1];return K(t)?(e.pop(),n=>cl(e,n,t)):t=>cl(e,t)}(Ih)))).pipe(wl((e,t)=>{let n=!1;return t.reduce((e,r,s)=>{if(e!==Ih)return e;if(r===Ih&&(n=!0),!n){if(!1===r)return r;if(s===t.length-1||Th(r))return r}return e},e)},Ih),kl(e=>e!==Ih),X(e=>Th(e)?e:!0===e),xl(1)))}let $h=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=ut({type:e,selectors:[["ng-component"]],decls:1,vars:0,template:function(e,t){1&e&&bo(0,"router-outlet")},directives:function(){return[kd]},encapsulation:2}),e})();function Rh(e,t=""){for(let n=0;n<e.length;n++){const r=e[n];Ah(r,Oh(t,r))}}function Ah(e,t){e.children&&Rh(e.children,t)}function Oh(e,t){return t?e||t.path?e&&!t.path?`${e}/`:!e&&t.path?t.path:`${e}/${t.path}`:"":e}function Fh(e){const t=e.children&&e.children.map(Fh),n=t?Object.assign(Object.assign({},e),{children:t}):Object.assign({},e);return!n.component&&(t||n.loadChildren)&&n.outlet&&n.outlet!==hc&&(n.component=$h),n}function Dh(e){return e.outlet||hc}function Ph(e,t){const n=e.filter(e=>Dh(e)===t);return n.push(...e.filter(e=>Dh(e)!==t)),n}const Mh={matched:!1,consumedSegments:[],lastChild:0,parameters:{},positionalParamSegments:{}};function Lh(e,t,n){var r;if(""===t.path)return"full"===t.pathMatch&&(e.hasChildren()||n.length>0)?Object.assign({},Mh):{matched:!0,consumedSegments:[],lastChild:0,parameters:{},positionalParamSegments:{}};const s=(t.matcher||mc)(n,e,t);if(!s)return Object.assign({},Mh);const o={};vc(s.posParams,(e,t)=>{o[t]=e.path});const i=s.consumed.length>0?Object.assign(Object.assign({},o),s.consumed[s.consumed.length-1].parameters):o;return{matched:!0,consumedSegments:s.consumed,lastChild:s.consumed.length,parameters:i,positionalParamSegments:null!==(r=s.posParams)&&void 0!==r?r:{}}}function Bh(e,t,n,r,s="corrected"){if(n.length>0&&function(e,t,n){return n.some(n=>Vh(e,t,n)&&Dh(n)!==hc)}(e,n,r)){const s=new Nc(t,function(e,t,n,r){const s={};s.primary=r,r._sourceSegment=e,r._segmentIndexShift=t.length;for(const o of n)if(""===o.path&&Dh(o)!==hc){const n=new Nc([],{});n._sourceSegment=e,n._segmentIndexShift=t.length,s[Dh(o)]=n}return s}(e,t,r,new Nc(n,e.children)));return s._sourceSegment=e,s._segmentIndexShift=t.length,{segmentGroup:s,slicedSegments:[]}}if(0===n.length&&function(e,t,n){return n.some(n=>Vh(e,t,n))}(e,n,r)){const o=new Nc(e.segments,function(e,t,n,r,s,o){const i={};for(const a of r)if(Vh(e,n,a)&&!s[Dh(a)]){const n=new Nc([],{});n._sourceSegment=e,n._segmentIndexShift="legacy"===o?e.segments.length:t.length,i[Dh(a)]=n}return Object.assign(Object.assign({},s),i)}(e,t,n,r,e.children,s));return o._sourceSegment=e,o._segmentIndexShift=t.length,{segmentGroup:o,slicedSegments:n}}const o=new Nc(e.segments,e.children);return o._sourceSegment=e,o._segmentIndexShift=t.length,{segmentGroup:o,slicedSegments:n}}function Vh(e,t,n){return(!(e.hasChildren()||t.length>0)||"full"!==n.pathMatch)&&""===n.path}function Uh(e,t,n,r){return!!(Dh(e)===r||r!==hc&&Vh(t,n,e))&&("**"===e.path||Lh(t,e,n).matched)}function zh(e,t,n){return 0===t.length&&!e.children[n]}class Wh{constructor(e){this.segmentGroup=e||null}}class jh{constructor(e){this.urlTree=e}}function Hh(e){return new U(t=>t.error(new Wh(e)))}function Gh(e){return new U(t=>t.error(new jh(e)))}function qh(e){return new U(t=>t.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${e}'`)))}class Kh{constructor(e,t,n,r,s){this.configLoader=t,this.urlSerializer=n,this.urlTree=r,this.config=s,this.allowRedirects=!0,this.ngModule=e.get(yi)}apply(){const e=Bh(this.urlTree.root,[],[],this.config).segmentGroup,t=new Nc(e.segments,e.children);return this.expandSegmentGroup(this.ngModule,this.config,t,hc).pipe(X(e=>this.createUrlTree(Xh(e),this.urlTree.queryParams,this.urlTree.fragment))).pipe(Tl(e=>{if(e instanceof jh)return this.allowRedirects=!1,this.match(e.urlTree);if(e instanceof Wh)throw this.noMatchError(e);throw e}))}match(e){return this.expandSegmentGroup(this.ngModule,this.config,e.root,hc).pipe(X(t=>this.createUrlTree(Xh(t),e.queryParams,e.fragment))).pipe(Tl(e=>{if(e instanceof Wh)throw this.noMatchError(e);throw e}))}noMatchError(e){return new Error(`Cannot match any routes. URL Segment: '${e.segmentGroup}'`)}createUrlTree(e,t,n){const r=e.segments.length>0?new Nc([],{[hc]:e}):e;return new Ic(r,t,n)}expandSegmentGroup(e,t,n,r){return 0===n.segments.length&&n.hasChildren()?this.expandChildren(e,t,n).pipe(X(e=>new Nc([],e))):this.expandSegment(e,n,t,n.segments,r,!0)}expandChildren(e,t,n){const r=[];for(const s of Object.keys(n.children))"primary"===s?r.unshift(s):r.push(s);return se(r).pipe($l(r=>{const s=n.children[r],o=Ph(t,r);return this.expandSegmentGroup(e,o,s,r).pipe(X(e=>({segment:e,outlet:r})))}),wl((e,t)=>(e[t.outlet]=t.segment,e),{}),function(e,t){const n=arguments.length>=2;return r=>r.pipe(e?kl((t,n)=>e(t,n,r)):V,Rl(1),n?Ll(t):Fl(()=>new ll))}())}expandSegment(e,t,n,r,s,o){return se(n).pipe($l(i=>this.expandSegmentAgainstRoute(e,t,n,i,r,s,o).pipe(Tl(e=>{if(e instanceof Wh)return tl(null);throw e}))),Ul(e=>!!e),Tl((e,n)=>{if(e instanceof ll||"EmptyError"===e.name){if(zh(t,r,s))return tl(new Nc([],{}));throw new Wh(t)}throw e}))}expandSegmentAgainstRoute(e,t,n,r,s,o,i){return Uh(r,t,s,o)?void 0===r.redirectTo?this.matchSegmentAgainstRoute(e,t,r,s,o):i&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(e,t,n,r,s,o):Hh(t):Hh(t)}expandSegmentAgainstRouteUsingRedirect(e,t,n,r,s,o){return"**"===r.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(e,n,r,o):this.expandRegularSegmentAgainstRouteUsingRedirect(e,t,n,r,s,o)}expandWildCardWithParamsAgainstRouteUsingRedirect(e,t,n,r){const s=this.applyRedirectCommands([],n.redirectTo,{});return n.redirectTo.startsWith("/")?Gh(s):this.lineralizeSegments(n,s).pipe(ue(n=>{const s=new Nc(n,{});return this.expandSegment(e,s,t,n,r,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(e,t,n,r,s,o){const{matched:i,consumedSegments:a,lastChild:u,positionalParamSegments:l}=Lh(t,r,s);if(!i)return Hh(t);const c=this.applyRedirectCommands(a,r.redirectTo,l);return r.redirectTo.startsWith("/")?Gh(c):this.lineralizeSegments(r,c).pipe(ue(r=>this.expandSegment(e,t,n,r.concat(s.slice(u)),o,!1)))}matchSegmentAgainstRoute(e,t,n,r,s){if("**"===n.path)return n.loadChildren?(n._loadedConfig?tl(n._loadedConfig):this.configLoader.load(e.injector,n)).pipe(X(e=>(n._loadedConfig=e,new Nc(r,{})))):tl(new Nc(r,{}));const{matched:o,consumedSegments:i,lastChild:a}=Lh(t,n,r);if(!o)return Hh(t);const u=r.slice(a);return this.getChildConfig(e,n,r).pipe(ue(e=>{const r=e.module,o=e.routes,{segmentGroup:a,slicedSegments:l}=Bh(t,i,u,o),c=new Nc(a.segments,a.children);if(0===l.length&&c.hasChildren())return this.expandChildren(r,o,c).pipe(X(e=>new Nc(i,e)));if(0===o.length&&0===l.length)return tl(new Nc(i,{}));const h=Dh(n)===s;return this.expandSegment(r,c,o,l,h?hc:s,!0).pipe(X(e=>new Nc(i.concat(e.segments),e.children)))}))}getChildConfig(e,t,n){return t.children?tl(new Eh(t.children,e)):t.loadChildren?void 0!==t._loadedConfig?tl(t._loadedConfig):this.runCanLoadGuards(e.injector,t,n).pipe(ue(n=>n?this.configLoader.load(e.injector,t).pipe(X(e=>(t._loadedConfig=e,e))):function(e){return new U(t=>t.error(fc(`Cannot load children because the guard of the route "path: '${e.path}'" returned false`)))}(t))):tl(new Eh([],e))}runCanLoadGuards(e,t,n){const r=t.canLoad;return r&&0!==r.length?tl(r.map(r=>{const s=e.get(r);let o;if(function(e){return e&&Sh(e.canLoad)}(s))o=s.canLoad(t,n);else{if(!Sh(s))throw new Error("Invalid CanLoad guard");o=s(t,n)}return wc(o)})).pipe(Nh(),Wl(e=>{if(!Th(e))return;const t=fc(`Redirecting to "${this.urlSerializer.serialize(e)}"`);throw t.url=e,t}),X(e=>!0===e)):tl(!0)}lineralizeSegments(e,t){let n=[],r=t.root;for(;;){if(n=n.concat(r.segments),0===r.numberOfChildren)return tl(n);if(r.numberOfChildren>1||!r.children.primary)return qh(e.redirectTo);r=r.children.primary}}applyRedirectCommands(e,t,n){return this.applyRedirectCreatreUrlTree(t,this.urlSerializer.parse(t),e,n)}applyRedirectCreatreUrlTree(e,t,n,r){const s=this.createSegmentGroup(e,t.root,n,r);return new Ic(s,this.createQueryParams(t.queryParams,this.urlTree.queryParams),t.fragment)}createQueryParams(e,t){const n={};return vc(e,(e,r)=>{if("string"==typeof e&&e.startsWith(":")){const s=e.substring(1);n[r]=t[s]}else n[r]=e}),n}createSegmentGroup(e,t,n,r){const s=this.createSegments(e,t.segments,n,r);let o={};return vc(t.children,(t,s)=>{o[s]=this.createSegmentGroup(e,t,n,r)}),new Nc(s,o)}createSegments(e,t,n,r){return t.map(t=>t.path.startsWith(":")?this.findPosParam(e,t,r):this.findOrReturn(t,n))}findPosParam(e,t,n){const r=n[t.path.substring(1)];if(!r)throw new Error(`Cannot redirect to '${e}'. Cannot find '${t.path}'.`);return r}findOrReturn(e,t){let n=0;for(const r of t){if(r.path===e.path)return t.splice(n),r;n++}return e}}function Xh(e){const t={};for(const n of Object.keys(e.children)){const r=Xh(e.children[n]);(r.segments.length>0||r.hasChildren())&&(t[n]=r)}return function(e){if(1===e.numberOfChildren&&e.children.primary){const t=e.children.primary;return new Nc(e.segments.concat(t.segments),t.children)}return e}(new Nc(e.segments,t))}class Yh{constructor(e){this.path=e,this.route=this.path[this.path.length-1]}}class Qh{constructor(e,t){this.component=e,this.route=t}}function Zh(e,t,n){const r=e._root;return ed(r,t?t._root:null,n,[r.value])}function Jh(e,t,n){const r=function(e){if(!e)return null;for(let t=e.parent;t;t=t.parent){const e=t.routeConfig;if(e&&e._loadedConfig)return e._loadedConfig}return null}(t);return(r?r.module.injector:n).get(e)}function ed(e,t,n,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const o=Zc(t);return e.children.forEach(e=>{!function(e,t,n,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const o=e.value,i=t?t.value:null,a=n?n.getContext(e.value.outlet):null;if(i&&o.routeConfig===i.routeConfig){const u=function(e,t,n){if("function"==typeof n)return n(e,t);switch(n){case"pathParamsChange":return!Rc(e.url,t.url);case"pathParamsOrQueryParamsChange":return!Rc(e.url,t.url)||!gc(e.queryParams,t.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!uh(e,t)||!gc(e.queryParams,t.queryParams);case"paramsChange":default:return!uh(e,t)}}(i,o,o.routeConfig.runGuardsAndResolvers);u?s.canActivateChecks.push(new Yh(r)):(o.data=i.data,o._resolvedData=i._resolvedData),ed(e,t,o.component?a?a.children:null:n,r,s),u&&a&&a.outlet&&a.outlet.isActivated&&s.canDeactivateChecks.push(new Qh(a.outlet.component,i))}else i&&td(t,a,s),s.canActivateChecks.push(new Yh(r)),ed(e,null,o.component?a?a.children:null:n,r,s)}(e,o[e.value.outlet],n,r.concat([e.value]),s),delete o[e.value.outlet]}),vc(o,(e,t)=>td(e,n.getContext(t),s)),s}function td(e,t,n){const r=Zc(e),s=e.value;vc(r,(e,r)=>{td(e,s.component?t?t.children.getContext(r):null:t,n)}),n.canDeactivateChecks.push(new Qh(s.component&&t&&t.outlet&&t.outlet.isActivated?t.outlet.component:null,s))}class nd{}function rd(e){return new U(t=>t.error(e))}class sd{constructor(e,t,n,r,s,o){this.rootComponentType=e,this.config=t,this.urlTree=n,this.url=r,this.paramsInheritanceStrategy=s,this.relativeLinkResolution=o}recognize(){const e=Bh(this.urlTree.root,[],[],this.config.filter(e=>void 0===e.redirectTo),this.relativeLinkResolution).segmentGroup,t=this.processSegmentGroup(this.config,e,hc);if(null===t)return null;const n=new rh([],Object.freeze({}),Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,{},hc,this.rootComponentType,null,this.urlTree.root,-1,{}),r=new Qc(n,t),s=new sh(this.url,r);return this.inheritParamsAndData(s._root),s}inheritParamsAndData(e){const t=e.value,n=nh(t,this.paramsInheritanceStrategy);t.params=Object.freeze(n.params),t.data=Object.freeze(n.data),e.children.forEach(e=>this.inheritParamsAndData(e))}processSegmentGroup(e,t,n){return 0===t.segments.length&&t.hasChildren()?this.processChildren(e,t):this.processSegment(e,t,t.segments,n)}processChildren(e,t){const n=[];for(const s of Object.keys(t.children)){const r=t.children[s],o=Ph(e,s),i=this.processSegmentGroup(o,r,s);if(null===i)return null;n.push(...i)}const r=id(n);return r.sort((e,t)=>e.value.outlet===hc?-1:t.value.outlet===hc?1:e.value.outlet.localeCompare(t.value.outlet)),r}processSegment(e,t,n,r){for(const s of e){const e=this.processSegmentAgainstRoute(s,t,n,r);if(null!==e)return e}return zh(t,n,r)?[]:null}processSegmentAgainstRoute(e,t,n,r){if(e.redirectTo||!Uh(e,t,n,r))return null;let s,o=[],i=[];if("**"===e.path){const r=n.length>0?bc(n).parameters:{};s=new rh(n,r,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,ld(e),Dh(e),e.component,e,ad(t),ud(t)+n.length,cd(e))}else{const r=Lh(t,e,n);if(!r.matched)return null;o=r.consumedSegments,i=n.slice(r.lastChild),s=new rh(o,r.parameters,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,ld(e),Dh(e),e.component,e,ad(t),ud(t)+o.length,cd(e))}const a=function(e){return e.children?e.children:e.loadChildren?e._loadedConfig.routes:[]}(e),{segmentGroup:u,slicedSegments:l}=Bh(t,o,i,a.filter(e=>void 0===e.redirectTo),this.relativeLinkResolution);if(0===l.length&&u.hasChildren()){const e=this.processChildren(a,u);return null===e?null:[new Qc(s,e)]}if(0===a.length&&0===l.length)return[new Qc(s,[])];const c=Dh(e)===r,h=this.processSegment(a,u,l,c?hc:r);return null===h?null:[new Qc(s,h)]}}function od(e){const t=e.value.routeConfig;return t&&""===t.path&&void 0===t.redirectTo}function id(e){const t=[],n=new Set;for(const r of e){if(!od(r)){t.push(r);continue}const e=t.find(e=>r.value.routeConfig===e.value.routeConfig);void 0!==e?(e.children.push(...r.children),n.add(e)):t.push(r)}for(const r of n){const e=id(r.children);t.push(new Qc(r.value,e))}return t.filter(e=>!n.has(e))}function ad(e){let t=e;for(;t._sourceSegment;)t=t._sourceSegment;return t}function ud(e){let t=e,n=t._segmentIndexShift?t._segmentIndexShift:0;for(;t._sourceSegment;)t=t._sourceSegment,n+=t._segmentIndexShift?t._segmentIndexShift:0;return n-1}function ld(e){return e.data||{}}function cd(e){return e.resolve||{}}function hd(e){return fl(t=>{const n=e(t);return n?se(n).pipe(X(()=>t)):tl(t)})}class dd extends class{shouldDetach(e){return!1}store(e,t){}shouldAttach(e){return!1}retrieve(e){return null}shouldReuseRoute(e,t){return e.routeConfig===t.routeConfig}}{}const pd=new Yn("ROUTES");class fd{constructor(e,t,n,r){this.loader=e,this.compiler=t,this.onLoadStartListener=n,this.onLoadEndListener=r}load(e,t){if(t._loader$)return t._loader$;this.onLoadStartListener&&this.onLoadStartListener(t);const n=this.loadModuleFactory(t.loadChildren).pipe(X(n=>{this.onLoadEndListener&&this.onLoadEndListener(t);const r=n.create(e);return new Eh(xc(r.injector.get(pd,void 0,Ve.Self|Ve.Optional)).map(Fh),r)}),Tl(e=>{throw t._loader$=void 0,e}));return t._loader$=new ye(n,()=>new G).pipe(fe()),t._loader$}loadModuleFactory(e){return"string"==typeof e?se(this.loader.load(e)):wc(e()).pipe(ue(e=>e instanceof xi?tl(e):se(this.compiler.compileModuleAsync(e))))}}class md{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.children=new gd,this.attachRef=null}}class gd{constructor(){this.contexts=new Map}onChildOutletCreated(e,t){const n=this.getOrCreateContext(e);n.outlet=t,this.contexts.set(e,n)}onChildOutletDestroyed(e){const t=this.getContext(e);t&&(t.outlet=null)}onOutletDeactivated(){const e=this.contexts;return this.contexts=new Map,e}onOutletReAttached(e){this.contexts=e}getOrCreateContext(e){let t=this.getContext(e);return t||(t=new md,this.contexts.set(e,t)),t}getContext(e){return this.contexts.get(e)||null}}class yd{shouldProcessUrl(e){return!0}extract(e){return e}merge(e,t){return e}}function xd(e){throw e}function bd(e,t,n){return t.parse("/")}function vd(e,t){return tl(null)}const wd={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},Cd={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};let _d=(()=>{class e{constructor(e,t,n,r,s,o,i,a){this.rootComponentType=e,this.urlSerializer=t,this.rootContexts=n,this.location=r,this.config=a,this.lastSuccessfulNavigation=null,this.currentNavigation=null,this.disposed=!1,this.lastLocationChangeInfo=null,this.navigationId=0,this.currentPageId=0,this.isNgZoneEnabled=!1,this.events=new G,this.errorHandler=xd,this.malformedUriErrorHandler=bd,this.navigated=!1,this.lastSuccessfulId=-1,this.hooks={beforePreactivation:vd,afterPreactivation:vd},this.urlHandlingStrategy=new yd,this.routeReuseStrategy=new dd,this.onSameUrlNavigation="ignore",this.paramsInheritanceStrategy="emptyOnly",this.urlUpdateStrategy="deferred",this.relativeLinkResolution="corrected",this.canceledNavigationResolution="replace",this.ngModule=s.get(yi),this.console=s.get(ia);const u=s.get(ba);this.isNgZoneEnabled=u instanceof ba&&ba.isInAngularZone(),this.resetConfig(a),this.currentUrlTree=new Ic(new Nc([],{}),{},null),this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.configLoader=new fd(o,i,e=>this.triggerEvent(new sc(e)),e=>this.triggerEvent(new oc(e))),this.routerState=eh(this.currentUrlTree,this.rootComponentType),this.transitions=new nl({id:0,targetPageId:0,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,extractedUrl:this.urlHandlingStrategy.extract(this.currentUrlTree),urlAfterRedirects:this.urlHandlingStrategy.extract(this.currentUrlTree),rawUrl:this.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:"imperative",restoredState:null,currentSnapshot:this.routerState.snapshot,targetSnapshot:null,currentRouterState:this.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.navigations=this.setupNavigations(this.transitions),this.processNavigations()}setupNavigations(e){const t=this.events;return e.pipe(kl(e=>0!==e.id),X(e=>Object.assign(Object.assign({},e),{extractedUrl:this.urlHandlingStrategy.extract(e.rawUrl)})),fl(e=>{let n=!1,r=!1;return tl(e).pipe(Wl(e=>{this.currentNavigation={id:e.id,initialUrl:e.currentRawUrl,extractedUrl:e.extractedUrl,trigger:e.source,extras:e.extras,previousNavigation:this.lastSuccessfulNavigation?Object.assign(Object.assign({},this.lastSuccessfulNavigation),{previousNavigation:null}):null}}),fl(e=>{const n=!this.navigated||e.extractedUrl.toString()!==this.browserUrlTree.toString();if(("reload"===this.onSameUrlNavigation||n)&&this.urlHandlingStrategy.shouldProcessUrl(e.rawUrl))return tl(e).pipe(fl(e=>{const n=this.transitions.getValue();return t.next(new Xl(e.id,this.serializeUrl(e.extractedUrl),e.source,e.restoredState)),n!==this.transitions.getValue()?hl:Promise.resolve(e)}),function(e,t,n,r){return fl(s=>function(e,t,n,r,s){return new Kh(e,t,n,r,s).apply()}(e,t,n,s.extractedUrl,r).pipe(X(e=>Object.assign(Object.assign({},s),{urlAfterRedirects:e}))))}(this.ngModule.injector,this.configLoader,this.urlSerializer,this.config),Wl(e=>{this.currentNavigation=Object.assign(Object.assign({},this.currentNavigation),{finalUrl:e.urlAfterRedirects})}),function(e,t,n,r,s){return ue(o=>function(e,t,n,r,s="emptyOnly",o="legacy"){try{const i=new sd(e,t,n,r,s,o).recognize();return null===i?rd(new nd):tl(i)}catch(i){return rd(i)}}(e,t,o.urlAfterRedirects,n(o.urlAfterRedirects),r,s).pipe(X(e=>Object.assign(Object.assign({},o),{targetSnapshot:e}))))}(this.rootComponentType,this.config,e=>this.serializeUrl(e),this.paramsInheritanceStrategy,this.relativeLinkResolution),Wl(e=>{"eager"===this.urlUpdateStrategy&&(e.extras.skipLocationChange||this.setBrowserUrl(e.urlAfterRedirects,e),this.browserUrlTree=e.urlAfterRedirects);const n=new Jl(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);t.next(n)}));if(n&&this.rawUrlTree&&this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)){const{id:n,extractedUrl:r,source:s,restoredState:o,extras:i}=e,a=new Xl(n,this.serializeUrl(r),s,o);t.next(a);const u=eh(r,this.rootComponentType).snapshot;return tl(Object.assign(Object.assign({},e),{targetSnapshot:u,urlAfterRedirects:r,extras:Object.assign(Object.assign({},i),{skipLocationChange:!1,replaceUrl:!1})}))}return this.rawUrlTree=e.rawUrl,this.browserUrlTree=e.urlAfterRedirects,e.resolve(null),hl}),hd(e=>{const{targetSnapshot:t,id:n,extractedUrl:r,rawUrl:s,extras:{skipLocationChange:o,replaceUrl:i}}=e;return this.hooks.beforePreactivation(t,{navigationId:n,appliedUrlTree:r,rawUrlTree:s,skipLocationChange:!!o,replaceUrl:!!i})}),Wl(e=>{const t=new ec(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);this.triggerEvent(t)}),X(e=>Object.assign(Object.assign({},e),{guards:Zh(e.targetSnapshot,e.currentSnapshot,this.rootContexts)})),function(e,t){return ue(n=>{const{targetSnapshot:r,currentSnapshot:s,guards:{canActivateChecks:o,canDeactivateChecks:i}}=n;return 0===i.length&&0===o.length?tl(Object.assign(Object.assign({},n),{guardsResult:!0})):function(e,t,n,r){return se(e).pipe(ue(e=>function(e,t,n,r,s){const o=t&&t.routeConfig?t.routeConfig.canDeactivate:null;return o&&0!==o.length?tl(o.map(o=>{const i=Jh(o,t,s);let a;if(function(e){return e&&Sh(e.canDeactivate)}(i))a=wc(i.canDeactivate(e,t,n,r));else{if(!Sh(i))throw new Error("Invalid CanDeactivate guard");a=wc(i(e,t,n,r))}return a.pipe(Ul())})).pipe(Nh()):tl(!0)}(e.component,e.route,n,t,r)),Ul(e=>!0!==e,!0))}(i,r,s,e).pipe(ue(n=>n&&"boolean"==typeof n?function(e,t,n,r){return se(t).pipe($l(t=>cl(function(e,t){return null!==e&&t&&t(new ic(e)),tl(!0)}(t.route.parent,r),function(e,t){return null!==e&&t&&t(new uc(e)),tl(!0)}(t.route,r),function(e,t,n){const r=t[t.length-1],s=t.slice(0,t.length-1).reverse().map(e=>function(e){const t=e.routeConfig?e.routeConfig.canActivateChild:null;return t&&0!==t.length?{node:e,guards:t}:null}(e)).filter(e=>null!==e).map(t=>pl(()=>tl(t.guards.map(s=>{const o=Jh(s,t.node,n);let i;if(function(e){return e&&Sh(e.canActivateChild)}(o))i=wc(o.canActivateChild(r,e));else{if(!Sh(o))throw new Error("Invalid CanActivateChild guard");i=wc(o(r,e))}return i.pipe(Ul())})).pipe(Nh())));return tl(s).pipe(Nh())}(e,t.path,n),function(e,t,n){const r=t.routeConfig?t.routeConfig.canActivate:null;return r&&0!==r.length?tl(r.map(r=>pl(()=>{const s=Jh(r,t,n);let o;if(function(e){return e&&Sh(e.canActivate)}(s))o=wc(s.canActivate(t,e));else{if(!Sh(s))throw new Error("Invalid CanActivate guard");o=wc(s(t,e))}return o.pipe(Ul())}))).pipe(Nh()):tl(!0)}(e,t.route,n))),Ul(e=>!0!==e,!0))}(r,o,e,t):tl(n)),X(e=>Object.assign(Object.assign({},n),{guardsResult:e})))})}(this.ngModule.injector,e=>this.triggerEvent(e)),Wl(e=>{if(Th(e.guardsResult)){const t=fc(`Redirecting to "${this.serializeUrl(e.guardsResult)}"`);throw t.url=e.guardsResult,t}const t=new tc(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot,!!e.guardsResult);this.triggerEvent(t)}),kl(e=>!!e.guardsResult||(this.cancelNavigationTransition(e,""),!1)),hd(e=>{if(e.guards.canActivateChecks.length)return tl(e).pipe(Wl(e=>{const t=new nc(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);this.triggerEvent(t)}),fl(e=>{let t=!1;return tl(e).pipe((n=this.paramsInheritanceStrategy,r=this.ngModule.injector,ue(e=>{const{targetSnapshot:t,guards:{canActivateChecks:s}}=e;if(!s.length)return tl(e);let o=0;return se(s).pipe($l(e=>function(e,t,n,r){return function(e,t,n,r){const s=Object.keys(e);if(0===s.length)return tl({});const o={};return se(s).pipe(ue(s=>function(e,t,n,r){const s=Jh(e,t,r);return wc(s.resolve?s.resolve(t,n):s(t,n))}(e[s],t,n,r).pipe(Wl(e=>{o[s]=e}))),Rl(1),ue(()=>Object.keys(o).length===s.length?tl(o):hl))}(e._resolve,e,t,r).pipe(X(t=>(e._resolvedData=t,e.data=Object.assign(Object.assign({},e.data),nh(e,n).resolve),null)))}(e.route,t,n,r)),Wl(()=>o++),Rl(1),ue(t=>o===s.length?tl(e):hl))})),Wl({next:()=>t=!0,complete:()=>{t||this.cancelNavigationTransition(e,"At least one route resolver didn't emit any value.")}}));var n,r}),Wl(e=>{const t=new rc(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);this.triggerEvent(t)}))}),hd(e=>{const{targetSnapshot:t,id:n,extractedUrl:r,rawUrl:s,extras:{skipLocationChange:o,replaceUrl:i}}=e;return this.hooks.afterPreactivation(t,{navigationId:n,appliedUrlTree:r,rawUrlTree:s,skipLocationChange:!!o,replaceUrl:!!i})}),X(e=>{const t=function(e,t,n){const r=lh(e,t._root,n?n._root:void 0);return new Jc(r,t)}(this.routeReuseStrategy,e.targetSnapshot,e.currentRouterState);return Object.assign(Object.assign({},e),{targetRouterState:t})}),Wl(e=>{this.currentUrlTree=e.urlAfterRedirects,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl),this.routerState=e.targetRouterState,"deferred"===this.urlUpdateStrategy&&(e.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,e),this.browserUrlTree=e.urlAfterRedirects)}),(o=this.rootContexts,i=this.routeReuseStrategy,a=e=>this.triggerEvent(e),X(e=>(new _h(i,e.targetRouterState,e.currentRouterState,a).activate(o),e))),Wl({next(){n=!0},complete(){n=!0}}),(s=()=>{n||r||this.cancelNavigationTransition(e,`Navigation ID ${e.id} is not equal to the current navigation id ${this.navigationId}`),this.currentNavigation=null},e=>e.lift(new Gl(s))),Tl(n=>{if(r=!0,(s=n)&&s.ngNavigationCancelingError){const r=Th(n.url);r||(this.navigated=!0,this.resetStateAndUrl(e.currentRouterState,e.currentUrlTree,e.rawUrl));const s=new Ql(e.id,this.serializeUrl(e.extractedUrl),n.message);t.next(s),r?setTimeout(()=>{const t=this.urlHandlingStrategy.merge(n.url,this.rawUrlTree);this.scheduleNavigation(t,"imperative",null,{skipLocationChange:e.extras.skipLocationChange,replaceUrl:"eager"===this.urlUpdateStrategy},{resolve:e.resolve,reject:e.reject,promise:e.promise})},0):e.resolve(!1)}else{this.resetStateAndUrl(e.currentRouterState,e.currentUrlTree,e.rawUrl);const r=new Zl(e.id,this.serializeUrl(e.extractedUrl),n);t.next(r);try{e.resolve(this.errorHandler(n))}catch(dS){e.reject(dS)}}var s;return hl}));var s,o,i,a}))}resetRootComponentType(e){this.rootComponentType=e,this.routerState.root.component=this.rootComponentType}getTransition(){const e=this.transitions.value;return e.urlAfterRedirects=this.browserUrlTree,e}setTransition(e){this.transitions.next(Object.assign(Object.assign({},this.getTransition()),e))}initialNavigation(){this.setUpLocationChangeListener(),0===this.navigationId&&this.navigateByUrl(this.location.path(!0),{replaceUrl:!0})}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=>{const t=this.extractLocationChangeInfoFromEvent(e);this.shouldScheduleNavigation(this.lastLocationChangeInfo,t)&&setTimeout(()=>{const{source:e,state:n,urlTree:r}=t,s={replaceUrl:!0};if(n){const e=Object.assign({},n);delete e.navigationId,delete e.\u0275routerPageId,0!==Object.keys(e).length&&(s.state=e)}this.scheduleNavigation(r,e,n,s)},0),this.lastLocationChangeInfo=t}))}extractLocationChangeInfoFromEvent(e){var t;return{source:"popstate"===e.type?"popstate":"hashchange",urlTree:this.parseUrl(e.url),state:(null===(t=e.state)||void 0===t?void 0:t.navigationId)?e.state:null,transitionId:this.getTransition().id}}shouldScheduleNavigation(e,t){if(!e)return!0;const n=t.urlTree.toString()===e.urlTree.toString();return!(t.transitionId===e.transitionId&&n&&("hashchange"===t.source&&"popstate"===e.source||"popstate"===t.source&&"hashchange"===e.source))}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.currentNavigation}triggerEvent(e){this.events.next(e)}resetConfig(e){Rh(e),this.config=e.map(Fh),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.transitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(e,t={}){const{relativeTo:n,queryParams:r,fragment:s,queryParamsHandling:o,preserveFragment:i}=t,a=n||this.routerState.root,u=i?this.currentUrlTree.fragment:s;let l=null;switch(o){case"merge":l=Object.assign(Object.assign({},this.currentUrlTree.queryParams),r);break;case"preserve":l=this.currentUrlTree.queryParams;break;default:l=r||null}return null!==l&&(l=this.removeEmptyProps(l)),function(e,t,n,r,s){if(0===n.length)return ph(t.root,t.root,t,r,s);const o=function(e){if("string"==typeof e[0]&&1===e.length&&"/"===e[0])return new mh(!0,0,e);let t=0,n=!1;const r=e.reduce((e,r,s)=>{if("object"==typeof r&&null!=r){if(r.outlets){const t={};return vc(r.outlets,(e,n)=>{t[n]="string"==typeof e?e.split("/"):e}),[...e,{outlets:t}]}if(r.segmentPath)return[...e,r.segmentPath]}return"string"!=typeof r?[...e,r]:0===s?(r.split("/").forEach((r,s)=>{0==s&&"."===r||(0==s&&""===r?n=!0:".."===r?t++:""!=r&&e.push(r))}),e):[...e,r]},[]);return new mh(n,t,r)}(n);if(o.toRoot())return ph(t.root,new Nc([],{}),t,r,s);const i=function(e,t,n){if(e.isAbsolute)return new gh(t.root,!0,0);if(-1===n.snapshot._lastPathIndex){const e=n.snapshot._urlSegment;return new gh(e,e===t.root,0)}const r=hh(e.commands[0])?0:1;return function(e,t,n){let r=e,s=t,o=n;for(;o>s;){if(o-=s,r=r.parent,!r)throw new Error("Invalid number of '../'");s=r.segments.length}return new gh(r,!1,s-o)}(n.snapshot._urlSegment,n.snapshot._lastPathIndex+r,e.numberOfDoubleDots)}(o,t,e),a=i.processChildren?xh(i.segmentGroup,i.index,o.commands):yh(i.segmentGroup,i.index,o.commands);return ph(i.segmentGroup,a,t,r,s)}(a,this.currentUrlTree,e,l,null!=u?u:null)}navigateByUrl(e,t={skipLocationChange:!1}){const n=Th(e)?e:this.parseUrl(e),r=this.urlHandlingStrategy.merge(n,this.rawUrlTree);let s=null;return"computed"===this.canceledNavigationResolution&&(0===this.currentPageId||t.skipLocationChange||t.replaceUrl)&&(s=this.location.getState()),this.scheduleNavigation(r,"imperative",s,t)}navigate(e,t={skipLocationChange:!1}){return function(e){for(let t=0;t<e.length;t++){const n=e[t];if(null==n)throw new Error(`The requested path contains ${n} segment at index ${t}`)}}(e),this.navigateByUrl(this.createUrlTree(e,t),t)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let t;try{t=this.urlSerializer.parse(e)}catch(n){t=this.malformedUriErrorHandler(n,this.urlSerializer,e)}return t}isActive(e,t){let n;if(n=!0===t?Object.assign({},wd):!1===t?Object.assign({},Cd):t,Th(e))return kc(this.currentUrlTree,e,n);const r=this.parseUrl(e);return kc(this.currentUrlTree,r,n)}removeEmptyProps(e){return Object.keys(e).reduce((t,n)=>{const r=e[n];return null!=r&&(t[n]=r),t},{})}processNavigations(){this.navigations.subscribe(e=>{this.navigated=!0,this.lastSuccessfulId=e.id,this.currentPageId=e.targetPageId,this.events.next(new Yl(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(this.currentUrlTree))),this.lastSuccessfulNavigation=this.currentNavigation,e.resolve(!0)},e=>{this.console.warn("Unhandled Navigation Error: ")})}scheduleNavigation(e,t,n,r,s){if(this.disposed)return Promise.resolve(!1);const o=this.getTransition(),i="imperative"!==t&&"imperative"===(null==o?void 0:o.source),a=(this.lastSuccessfulId===o.id||this.currentNavigation?o.rawUrl:o.urlAfterRedirects).toString()===e.toString();if(i&&a)return Promise.resolve(!0);let u,l,c;s?(u=s.resolve,l=s.reject,c=s.promise):c=new Promise((e,t)=>{u=e,l=t});const h=++this.navigationId;let d;return d="computed"===this.canceledNavigationResolution?n&&n.\u0275routerPageId?n.\u0275routerPageId:this.currentPageId+1:0,this.setTransition({id:h,targetPageId:d,source:t,restoredState:n,currentUrlTree:this.currentUrlTree,currentRawUrl:this.rawUrlTree,rawUrl:e,extras:r,resolve:u,reject:l,promise:c,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),c.catch(e=>Promise.reject(e))}setBrowserUrl(e,t){const n=this.urlSerializer.serialize(e),r=Object.assign(Object.assign({},t.extras.state),this.generateNgRouterState(t.id,t.targetPageId));this.location.isCurrentPathEqualTo(n)||t.extras.replaceUrl?this.location.replaceState(n,"",r):this.location.go(n,"",r)}resetStateAndUrl(e,t,n){this.routerState=e,this.currentUrlTree=t,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,n),this.resetUrlToCurrentUrlTree()}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}cancelNavigationTransition(e,t){"computed"===this.canceledNavigationResolution?"popstate"!==e.source&&"eager"!==this.urlUpdateStrategy||this.location.historyGo(this.currentPageId-e.targetPageId):this.resetUrlToCurrentUrlTree();const n=new Ql(e.id,this.serializeUrl(e.extractedUrl),t);this.triggerEvent(n),e.resolve(!1)}generateNgRouterState(e,t){return"computed"===this.canceledNavigationResolution?{navigationId:e,"\u0275routerPageId":t}:{navigationId:e}}}return e.\u0275fac=function(t){return new(t||e)(cr(Zn),cr(Ac),cr(gd),cr(du),cr(so),cr(Ua),cr(ga),cr(void 0))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})(),kd=(()=>{class e{constructor(e,t,n,r,s){this.parentContexts=e,this.location=t,this.resolver=n,this.changeDetector=s,this.activated=null,this._activatedRoute=null,this.activateEvents=new Pi,this.deactivateEvents=new Pi,this.name=r||hc,e.onChildOutletCreated(this.name,this)}ngOnDestroy(){this.parentContexts.onChildOutletDestroyed(this.name)}ngOnInit(){if(!this.activated){const e=this.parentContexts.getContext(this.name);e&&e.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.resolver||null))}}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new Error("Outlet is not activated");return this.activated.instance}get activatedRoute(){if(!this.activated)throw new Error("Outlet is not activated");return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new Error("Outlet is not activated");this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,e}attach(e,t){this.activated=e,this._activatedRoute=t,this.location.insert(e.hostView)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,t){if(this.isActivated)throw new Error("Cannot activate an already activated outlet");this._activatedRoute=e;const n=(t=t||this.resolver).resolveComponentFactory(e._futureSnapshot.routeConfig.component),r=this.parentContexts.getOrCreateContext(this.name).children,s=new Ed(e,r,this.location.injector);this.activated=this.location.createComponent(n,this.location.length,s),this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return e.\u0275fac=function(t){return new(t||e)(fo(gd),fo(vi),fo(Fo),("name",function(e,t){const n=e.attrs;if(n){const e=n.length;let r=0;for(;r<e;){const s=n[r];if(Cn(s))break;if(0===s)r+=2;else if("number"==typeof s)for(r++;r<e&&"string"==typeof n[r];)r++;else{if(s===t)return n[r+1];r+=2}}}return null}(Gt(),"name")),fo(ui))},e.\u0275dir=ft({type:e,selectors:[["router-outlet"]],outputs:{activateEvents:"activate",deactivateEvents:"deactivate"},exportAs:["outlet"]}),e})();class Ed{constructor(e,t,n){this.route=e,this.childContexts=t,this.parent=n}get(e,t){return e===th?this.route:e===gd?this.childContexts:this.parent.get(e,t)}}class Sd{}class Td{preload(e,t){return tl(null)}}let Id=(()=>{class e{constructor(e,t,n,r,s){this.router=e,this.injector=r,this.preloadingStrategy=s,this.loader=new fd(t,n,t=>e.triggerEvent(new sc(t)),t=>e.triggerEvent(new oc(t)))}setUpPreloading(){this.subscription=this.router.events.pipe(kl(e=>e instanceof Yl),$l(()=>this.preload())).subscribe(()=>{})}preload(){const e=this.injector.get(yi);return this.processRoutes(e,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(e,t){const n=[];for(const r of t)if(r.loadChildren&&!r.canLoad&&r._loadedConfig){const e=r._loadedConfig;n.push(this.processRoutes(e.module,e.routes))}else r.loadChildren&&!r.canLoad?n.push(this.preloadConfig(e,r)):r.children&&n.push(this.processRoutes(e,r.children));return se(n).pipe(de(),X(e=>{}))}preloadConfig(e,t){return this.preloadingStrategy.preload(t,()=>(t._loadedConfig?tl(t._loadedConfig):this.loader.load(e.injector,t)).pipe(ue(e=>(t._loadedConfig=e,this.processRoutes(e.module,e.routes)))))}}return e.\u0275fac=function(t){return new(t||e)(cr(_d),cr(Ua),cr(ga),cr(so),cr(Sd))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})(),Nd=(()=>{class e{constructor(e,t,n={}){this.router=e,this.viewportScroller=t,this.options=n,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},n.scrollPositionRestoration=n.scrollPositionRestoration||"disabled",n.anchorScrolling=n.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.router.events.subscribe(e=>{e instanceof Xl?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof Yl&&(this.lastId=e.id,this.scheduleScrollEvent(e,this.router.parseUrl(e.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.router.events.subscribe(e=>{e instanceof cc&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,t){this.router.triggerEvent(new cc(e,"popstate"===this.lastSource?this.store[this.restoredId]:null,t))}ngOnDestroy(){this.routerEventsSubscription&&this.routerEventsSubscription.unsubscribe(),this.scrollEventsSubscription&&this.scrollEventsSubscription.unsubscribe()}}return e.\u0275fac=function(t){return new(t||e)(cr(_d),cr(Cu),cr(void 0))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();const $d=new Yn("ROUTER_CONFIGURATION"),Rd=new Yn("ROUTER_FORROOT_GUARD"),Ad=[du,{provide:Ac,useClass:Oc},{provide:_d,useFactory:function(e,t,n,r,s,o,i,a={},u,l){const c=new _d(null,e,t,n,r,s,o,xc(i));return u&&(c.urlHandlingStrategy=u),l&&(c.routeReuseStrategy=l),function(e,t){e.errorHandler&&(t.errorHandler=e.errorHandler),e.malformedUriErrorHandler&&(t.malformedUriErrorHandler=e.malformedUriErrorHandler),e.onSameUrlNavigation&&(t.onSameUrlNavigation=e.onSameUrlNavigation),e.paramsInheritanceStrategy&&(t.paramsInheritanceStrategy=e.paramsInheritanceStrategy),e.relativeLinkResolution&&(t.relativeLinkResolution=e.relativeLinkResolution),e.urlUpdateStrategy&&(t.urlUpdateStrategy=e.urlUpdateStrategy)}(a,c),a.enableTracing&&c.events.subscribe(e=>{var t,n;null===(t=console.group)||void 0===t||t.call(console,`Router Event: ${e.constructor.name}`),console.log(e.toString()),console.log(e),null===(n=console.groupEnd)||void 0===n||n.call(console)}),c},deps:[Ac,gd,du,so,Ua,ga,pd,$d,[class{},new fr],[class{},new fr]]},gd,{provide:th,useFactory:function(e){return e.routerState.root},deps:[_d]},{provide:Ua,useClass:ja},Id,Td,class{preload(e,t){return t().pipe(Tl(()=>tl(null)))}},{provide:$d,useValue:{enableTracing:!1}}];function Od(){return new Fa("Router",_d)}let Fd=(()=>{class e{constructor(e,t){}static forRoot(t,n){return{ngModule:e,providers:[Ad,Ld(t),{provide:Rd,useFactory:Md,deps:[[_d,new fr,new mr]]},{provide:$d,useValue:n||{}},{provide:au,useFactory:Pd,deps:[Za,[new pr(lu),new fr],$d]},{provide:Nd,useFactory:Dd,deps:[_d,Cu,$d]},{provide:Sd,useExisting:n&&n.preloadingStrategy?n.preloadingStrategy:Td},{provide:Fa,multi:!0,useFactory:Od},[Bd,{provide:Zi,multi:!0,useFactory:Vd,deps:[Bd]},{provide:zd,useFactory:Ud,deps:[Bd]},{provide:oa,multi:!0,useExisting:zd}]]}}static forChild(t){return{ngModule:e,providers:[Ld(t)]}}}return e.\u0275fac=function(t){return new(t||e)(cr(Rd,8),cr(_d,8))},e.\u0275mod=dt({type:e}),e.\u0275inj=Ae({}),e})();function Dd(e,t,n){return n.scrollOffset&&t.setOffset(n.scrollOffset),new Nd(e,t,n)}function Pd(e,t,n={}){return n.useHash?new hu(e,t):new cu(e,t)}function Md(e){return"guarded"}function Ld(e){return[{provide:Qn,multi:!0,useValue:e},{provide:pd,multi:!0,useValue:e}]}let Bd=(()=>{class e{constructor(e){this.injector=e,this.initNavigation=!1,this.destroyed=!1,this.resultOfPreactivationDone=new G}appInitializer(){return this.injector.get(eu,Promise.resolve(null)).then(()=>{if(this.destroyed)return Promise.resolve(!0);let e=null;const t=new Promise(t=>e=t),n=this.injector.get(_d),r=this.injector.get($d);return"disabled"===r.initialNavigation?(n.setUpLocationChangeListener(),e(!0)):"enabled"===r.initialNavigation||"enabledBlocking"===r.initialNavigation?(n.hooks.afterPreactivation=()=>this.initNavigation?tl(null):(this.initNavigation=!0,e(!0),this.resultOfPreactivationDone),n.initialNavigation()):e(!0),t})}bootstrapListener(e){const t=this.injector.get($d),n=this.injector.get(Id),r=this.injector.get(Nd),s=this.injector.get(_d),o=this.injector.get(Ba);e===o.components[0]&&("enabledNonBlocking"!==t.initialNavigation&&void 0!==t.initialNavigation||s.initialNavigation(),n.setUpPreloading(),r.init(),s.resetRootComponentType(o.componentTypes[0]),this.resultOfPreactivationDone.next(null),this.resultOfPreactivationDone.complete())}ngOnDestroy(){this.destroyed=!0}}return e.\u0275fac=function(t){return new(t||e)(cr(so))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();function Vd(e){return e.appInitializer.bind(e)}function Ud(e){return e.bootstrapListener.bind(e)}const zd=new Yn("Router Initializer");function Wd(e,t,n,r,s,o,i){try{var a=e[o](i),u=a.value}catch(l){return void n(l)}a.done?t(u):Promise.resolve(u).then(r,s)}function jd(e){return function(){var t=this,n=arguments;return new Promise(function(r,s){var o=e.apply(t,n);function i(e){Wd(o,r,s,i,a,"next",e)}function a(e){Wd(o,r,s,i,a,"throw",e)}i(void 0)})}}var Hd=n(394);class Gd{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class qd{refCount(e){return Kd("refCount")}incRef(e){return Kd("incRef")}timerAvailable(){return!0}time(e){return Kd("time")}read(e){return Kd("read")}readSync(e){return Kd("readSync")}numDataIds(){return Kd("numDataIds")}disposeData(e,t){return Kd("disposeData")}write(e,t,n){return Kd("write")}move(e,t,n,r,s){return Kd("move")}memory(){return Kd("memory")}floatPrecision(){return Kd("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Kd("dispose")}}function Kd(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Xd(e,t,n){return Math.max(e,Math.min(t,n))}function Yd(e){return e%2==0?e:e+1}function Qd(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function Zd(e,t,n=""){Qd(np(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function Jd(e){Qd(null!=e,()=>"The input to the tensor constructor must be a non-null value.")}function ep(e,t=[],n=!1){if(null==t&&(t=[]),Array.isArray(e)||dp(e)&&!n)for(let r=0;r<e.length;++r)ep(e[r],t,n);else t.push(e);return t}function tp(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function np(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function rp(e){return e%1==0}function sp(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function op(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function ip(e,t=(e=>0),n){return new Promise((r,s)=>{let o=0;const i=()=>{if(e())return void r();o++;const a=t(o);null!=n&&o>=n?s():setTimeout(i,a)};i()})}function ap(e,t){const n=t.length;return Qd((e=null==e?t.map((e,t)=>t):[].concat(e)).every(e=>e>=-n&&e<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),Qd(e.every(e=>rp(e)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(e=>e<0?n+e:e)}function up(e,t){const n=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,o=null==t||s?null:ap(t,e).sort();let i=0;for(let a=0;a<e.length;++a){if(null!=o){if(o[i]===a&&1!==e[a])throw new Error(`Can't squeeze axis ${a} since its dim '${e[a]}' is not 1`);(null==o[i]||o[i]>a)&&1===e[a]&&(n.push(e[a]),r.push(a)),o[i]<=a&&i++}1!==e[a]&&(n.push(e[a]),r.push(a))}return{newShape:n,keptDims:r}}function lp(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);n=new Uint8Array(t)}return n}function cp(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function hp(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function dp(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array}function pp(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function fp(e){return"string"==typeof e||e instanceof String}function mp(e){return Array.isArray(e)?mp(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array?"int32":"number"==typeof e?"float32":fp(e)?"string":"boolean"==typeof e?"bool":"float32"}function gp(e){return!!(e&&e.constructor&&e.call&&e.apply)}function yp(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function xp(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function bp(e,t,n,r=!1){const s=new Array;if(1===t.length){const o=t[0]*(r?2:1);for(let t=0;t<o;t++)s[t]=n[e+t]}else{const o=t[0],i=t.slice(1),a=i.reduce((e,t)=>e*t)*(r?2:1);for(let t=0;t<o;t++)s[t]=bp(e+t*a,i,n,r)}return s}function vp(e,t,n=!1){if(0===e.length)return t[0];const r=e.reduce((e,t)=>e*t)*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return bp(0,e,t,n)}function wp(e,t){const n=Cp(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function Cp(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function _p(e){e.forEach(t=>{Qd(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function kp(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=n[s]*e[s];return r}function Ep(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(e/n[s]),e-=r[s]*n[s];return r[r.length-1]=e,r}function Sp(e){return e&&e.then&&"function"==typeof e.then}class Tp{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Ip,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}getAsync(e){var t=this;return jd(function*(){return e in t.flags||(t.flags[e]=yield t.evaluateFlag(e)),t.flags[e]})()}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Sp(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);"tfjsflags"in e&&e.tfjsflags.split(",").forEach(e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}(t,n)})}}function Ip(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...n)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,n[0],n[1]),n.join("="))),t}function Np(){return Rp}let $p,Rp=null;function Ap(){if(null==$p){let e;if("undefined"!=typeof window)e=window;else if("undefined"!=typeof global)e=global;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}$p=e}return $p}function Op(e,t){const n=function(){const e=Ap();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const Fp="Acos",Dp="Acosh",Pp="Add",Mp="AddN",Lp="ArgMax",Bp="ArgMin",Vp="Asin",Up="Asinh",zp="Atan",Wp="Atanh",jp="Atan2",Hp="AvgPool",Gp="AvgPool3D",qp="BatchMatMul",Kp="BatchToSpaceND",Xp="Bincount",Yp="Cast",Qp="Ceil",Zp="ClipByValue",Jp="Complex",ef="ComplexAbs",tf="Concat",nf="Conv2D",rf="Conv2DBackpropFilter",sf="Conv2DBackpropInput",of="Conv3D",af="Cosh",uf="Cumsum",lf="CropAndResize",cf="DenseBincount",hf="DepthToSpace",df="DepthwiseConv2dNative",pf="DepthwiseConv2dNativeBackpropFilter",ff="DepthwiseConv2dNativeBackpropInput",mf="Dilation2D",gf="RealDiv",yf="Einsum",xf="Equal",bf="Exp",vf="ExpandDims",wf="Expm1",Cf="Fill",_f="FlipLeftRight",kf="Floor",Ef="FloorDiv",Sf="FusedBatchNorm",Tf="GatherV2",If="GatherNd",Nf="Greater",$f="GreaterEqual",Rf="Identity",Af="IFFT",Of="Imag",Ff="IsNan",Df="LeakyRelu",Pf="Less",Mf="LessEqual",Lf="LinSpace",Bf="Log",Vf="Log1p",Uf="LogicalAnd",zf="LogicalNot",Wf="LogicalOr",jf="Maximum",Hf="MaxPool",Gf="MaxPool3D",qf="MaxPoolWithArgmax",Kf="Mean",Xf="Minimum",Yf="MirrorPad",Qf="Multinomial",Zf="Multiply",Jf="NotEqual",em="NonMaxSuppressionV3",tm="NonMaxSuppressionV4",nm="NonMaxSuppressionV5",rm="OnesLike",sm="OneHot",om="Pack",im="PadV2",am="Prelu",um="Prod",lm="Range",cm="Real",hm="Reciprocal",dm="Relu",pm="Reshape",fm="ResizeNearestNeighbor",mm="ResizeBilinear",gm="Relu6",ym="Reverse",xm="Round",bm="Rsqrt",vm="ScatterNd",wm="Select",Cm="Selu",_m="Slice",km="Sinh",Em="Sign",Sm="Sigmoid",Tm="Softplus",Im="Sqrt",Nm="SpaceToBatchND",$m="SplitV",Rm="Softmax",Am="SparseFillEmptyRows",Om="SparseReshape",Fm="SparseSegmentMean",Dm="SparseSegmentSum",Pm="SparseToDense",Mm="SquaredDifference",Lm="StridedSlice",Bm="StringNGrams",Vm="StringSplit",Um="StringToHashBucketFast",zm="Sub",Wm="Tanh",jm="Tile",Hm="TopK",Gm="Transform",qm="Transpose",Km="Unique",Xm="Unpack",Ym="ZerosLike",Qm="Step",Zm="FromPixels",Jm="RotateWithOffset",eg="_FusedMatMul",tg="FusedConv2D",ng="FusedDepthwiseConv2D",rg=Op("kernelRegistry",()=>new Map),sg=Op("gradRegistry",()=>new Map);function og(e,t){const n=lg(e,t);return rg.get(n)}function ig(e){return sg.get(e)}function ag(e){const t=rg.entries(),n=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[o,i]=s,[a]=o.split("_");a===e&&n.push(i)}return n}function ug(e){const{kernelName:t,backendName:n}=e,r=lg(t,n);rg.has(r)&&console.warn(`The kernel '${t}' for backend '${n}' is already registered`),rg.set(r,e)}function lg(e,t){return`${t}_${e}`}var cg=n(80);const hg=n.n(cg)()||cg;function dg(e){return hg.fromString(e,!0,16)}const pg=dg("c3a5c85c97cb3127"),fg=dg("b492b66fbe98f273"),mg=dg("9ae16a3b2f90404f");function gg(e){return e.xor(e.shru(47))}function yg(e,t,n){const r=e.slice(t,t+n);return hg.fromBytes(Array.from(r),!0,!0)}function xg(e,t){return yg(e,t,8)}function bg(e,t){return yg(e,t,4)}function vg(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function wg(e,t,n=dg("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let s=t.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function Cg(e,t,n,r){return function(e,t,n,r,s,o){s=s.add(e),o=vg(o.add(s).add(r),21);const i=s;return s=(s=s.add(t)).add(n),o=o.add(vg(s,44)),[s.add(r),o.add(i)]}(xg(e,t),xg(e,t+8),xg(e,t+16),xg(e,t+24),n,r)}function _g(e,t=e.length){const n=hg.fromNumber(81,!0);if(t<=32)return t<=16?function(e,t=e.length){if(t>=8){const n=mg.add(2*t),r=xg(e,0).add(mg),s=xg(e,t-8);return wg(vg(s,37).mul(n).add(r),vg(r,25).add(s).mul(n),n)}if(t>=4){const n=mg.add(2*t);return wg(bg(e,0).shl(3).add(t),bg(e,t-4),n)}if(t>0){const n=t+(e[t-1]<<2);return gg(mg.mul(e[0]+(e[t>>1]<<8)).xor(pg.mul(n))).mul(mg)}return mg}(e,t):function(e,t=e.length){const n=mg.add(2*t),r=xg(e,0).mul(fg),s=xg(e,8),o=xg(e,t-8).mul(n),i=xg(e,t-16).mul(mg);return wg(vg(r.add(s),43).add(vg(o,30)).add(i),r.add(vg(s.add(mg),18)).add(o),n)}(e,t);if(t<=64)return function(e,t=e.length){const n=mg.add(2*t),r=xg(e,0).mul(mg),s=xg(e,8),o=xg(e,t-8).mul(n),i=xg(e,t-16).mul(mg),a=vg(r.add(s),43).add(vg(o,30)).add(i),u=wg(a,r.add(vg(s.add(mg),18)).add(o),n),l=xg(e,16).mul(n),c=xg(e,24),h=a.add(xg(e,t-32)).mul(n),d=u.add(xg(e,t-24)).mul(n);return wg(vg(l.add(c),43).add(vg(h,30)).add(d),l.add(vg(c.add(r),18)).add(h),n)}(e,t);let r=n,s=n.mul(fg).add(113),o=gg(s.mul(mg).add(113)).mul(mg),i=[hg.UZERO,hg.UZERO],a=[hg.UZERO,hg.UZERO];r=r.mul(mg).add(xg(e,0));let u=0;const l=64*(t-1>>6),c=l+(t-1&63)-63;do{r=vg(r.add(s).add(i[0]).add(xg(e,u+8)),37).mul(fg),s=vg(s.add(i[1]).add(xg(e,u+48)),42).mul(fg),r=r.xor(a[1]),s=s.add(i[0]).add(xg(e,u+40)),o=vg(o.add(a[0]),33).mul(fg),i=Cg(e,u,i[1].mul(fg),r.add(a[0])),a=Cg(e,u+32,o.add(a[1]),s.add(xg(e,u+16))),[o,r]=[r,o],u+=64}while(u!==l);const h=fg.add(o.and(255).shl(1));return u=c,a[0]=a[0].add(t-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),r=vg(r.add(s).add(i[0]).add(xg(e,u+8)),37).mul(h),s=vg(s.add(i[1]).add(xg(e,u+48)),42).mul(h),r=r.xor(a[1].mul(9)),s=s.add(i[0].mul(9).add(xg(e,u+40))),o=vg(o.add(a[0]),33).mul(h),i=Cg(e,u,i[1].mul(h),r.add(a[0])),a=Cg(e,u+32,o.add(a[1]),s.add(xg(e,u+16))),[o,r]=[r,o],wg(wg(i[0],a[0],h).add(gg(s).mul(pg)).add(o),wg(i[1],a[1],h).add(r),h)}function kg(e,t){return"string"===t?Tg(e):Eg([e],t)}function Eg(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=ep(e)),Np().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function Sg(){return Np().platform.now()}function Tg(e,t="utf-8"){return t=t||"utf-8",Np().platform.encode(e,t)}function Ig(e,t="utf-8"){return t=t||"utf-8",Np().platform.decode(e,t)}class Ng{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new Rg)}profileKernel(e,t,n){let r;const s=()=>{r=n()};let o;const i=Sg();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(s);else{s();for(const e of r)e.dataSync();o=Promise.resolve({kernelMs:Sg()-i})}if(Np().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let a=0;a<r.length;a++){const t=r[a];t.data().then(n=>{$g(n,t.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:o.then(e=>e.kernelMs),extraInfo:o.then(e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:o}=e;n.forEach(e=>{Promise.all([e.data(),r,o]).then(n=>{this.logger.logKernelProfile(t,e,n[0],n[1],s,n[2])})})}}function $g(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){const t=e[r];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}class Rg{logKernelProfile(e,t,n,r,s,o){const i="number"==typeof r?op(`${r}ms`,9):r.error,a=op(e,25),u=t.rank,l=t.size,c=op(t.shape.toString(),14);let h="";for(const d in s){const e=s[d];if(null!=e){const n=e.shape||t.shape,r=n.length;h+=`${d}: ${r}D ${r>0?n:""} `}}console.log(`%c${a}\t%c${i}\t%c${u}D ${c}\t%c${l}\t%c${h}\t%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Ag(e,t,n,r){const s=xp(t),o=function(e,t,n,r){const s=tp(t),o=r[r.length-1],i=new Array(o).fill(0),a=t.length,u="complex64"===n?Pg(e):e;if(a>1)for(let l=0;l<s/o;l++){const e=l*o;for(let t=0;t<o;t++)i[t]=Math.max(i[t],Og(u[e+t],0,n).length)}return i}(e,t,n,s),i=t.length,a=Dg(e,t,n,s,o),u=["Tensor"];return r&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${i}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(a.map(e=>"    "+e).join("\n")),u.join("\n")}function Og(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:fp(e)?`'${e}'`:"bool"===n?Fg(e):parseFloat(e.toFixed(7)).toString(),op(r,t)}function Fg(e){return 0===e?"false":"true"}function Dg(e,t,n,r,s,o=!0){const i="complex64"===n?2:1,a=t[0],u=t.length;if(0===u)return"complex64"===n?[Og(Pg(e)[0],0,n)]:"bool"===n?[Fg(e[0])]:[e[0].toString()];if(1===u){if(a>20){let t=Array.from(e.slice(0,3*i)),r=Array.from(e.slice((a-3)*i,a*i));return"complex64"===n&&(t=Pg(t),r=Pg(r)),["["+t.map((e,t)=>Og(e,s[t],n)).join(", ")+", ..., "+r.map((e,t)=>Og(e,s[a-3+t],n)).join(", ")+"]"]}return["["+("complex64"===n?Pg(e):Array.from(e)).map((e,t)=>Og(e,s[t],n)).join(", ")+"]"]}const l=t.slice(1),c=r.slice(1),h=r[0]*i,d=[];if(a>20){for(let t=0;t<3;t++){const r=t*h;d.push(...Dg(e.slice(r,r+h),l,n,c,s,!1))}d.push("...");for(let t=a-3;t<a;t++){const r=t*h;d.push(...Dg(e.slice(r,r+h),l,n,c,s,t===a-1))}}else for(let m=0;m<a;m++){const t=m*h;d.push(...Dg(e.slice(t,t+h),l,n,c,s,m===a-1))}const p=2===u?",":"";d[0]="["+d[0]+p;for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=",\n";for(let m=2;m<u;m++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(o?"":f),d}function Pg(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class Mg{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=tp(e),null!=n){const e=n.length;Qd(e===this.size,()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||cp(t,this.size),this.strides=xp(e)}set(e,...t){0===t.length&&(t=[0]),Qd(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t])throw new Error(`Requested out of range element at ${e}.   Buffer shape=${this.shape}`);t++}let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Lg().makeTensor(this.values,this.shape,this.dtype)}}let Lg=null,Bg=null,Vg=null;class Ug{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=tp(e),this.strides=xp(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var e=this;return jd(function*(){const t=yield e.data();return Bg.buffer(e.shape,e.dtype,t)})()}bufferSync(){return Bg.buffer(this.shape,this.dtype,this.dataSync())}array(){var e=this;return jd(function*(){const t=yield e.data();return vp(e.shape,t,"complex64"===e.dtype)})()}arraySync(){return vp(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var e=this;return jd(function*(){e.throwIfDisposed();const t=Lg().read(e.dataId);if("string"===e.dtype){const e=yield t;try{return e.map(e=>Ig(e))}catch(n){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t})()}dataSync(){this.throwIfDisposed();const e=Lg().readSync(this.dataId);if("string"===this.dtype)try{return e.map(e=>Ig(e))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}bytes(){var e=this;return jd(function*(){e.throwIfDisposed();const t=yield Lg().read(e.dataId);return"string"===e.dtype?t:new Uint8Array(t.buffer)})()}dispose(){this.isDisposed||(Lg().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Bg.print(this,e)}clone(){return this.throwIfDisposed(),Bg.clone(this)}toString(e=!1){return Ag(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Bg.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Lg().makeVariable(this,e,t,n)}}Object.defineProperty(Ug,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),Op("Tensor",()=>Ug);class zg extends Ug{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!np(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Lg().disposeTensor(this),this.dataId=e.dataId,Lg().incRef(this,null)}dispose(){Lg().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(zg,Symbol.hasInstance,{value:e=>e instanceof Ug&&null!=e.assign&&e.assign instanceof Function});var Wg=(()=>(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(Wg||(Wg={})),Wg))(),jg=(()=>(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(jg||(jg={})),jg))(),Hg=(()=>(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(Hg||(Hg={})),Hg))(),Gg=(()=>(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(Gg||(Gg={})),Gg))();const qg={float32:Hg,int32:Wg,bool:jg,complex64:Gg};function Kg(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return qg[e][t]}function Xg(e){return Kg(e,"int32")}function Yg(e,t){if(e.dtype===t.dtype)return[e,t];const n=Kg(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function Qg(e){const t=[];return Zg(e,t,new Set),t}function Zg(e,t,n){if(null==e)return;if(e instanceof Ug)return void t.push(e);if(r=e,!Array.isArray(r)&&"object"!=typeof r)return;var r;const s=e;for(const o in s){const e=s[o];n.has(e)||(n.add(e),Zg(e,t,n))}}function Jg(e){return null!=e.kernelName}class ey{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}let ty=(()=>{class e{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new ey}ready(){var e=this;return jd(function*(){if(null!=e.pendingBackendInit)return e.pendingBackendInit.then(()=>{});if(null!=e.backendInstance)return;const t=e.getSortedBackends();for(let n=0;n<t.length;n++){const r=t[n];if(yield e.initializeBackend(r).success)return void(yield e.setBackend(r))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(console.warn(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}setBackend(e){var t=this;return jd(function*(){if(null==t.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(t.backendName=e,null==t.registry[e]){t.backendInstance=null;const{success:n,asyncInit:r}=t.initializeBackend(e);if(!(r?yield n:n))return!1}return t.backendInstance=t.registry[e],t.setupRegisteredKernels(),t.profiler=new Ng(t.backendInstance),!0})()}setupRegisteredKernels(){ag(this.backendName).forEach(e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){ag(e).forEach(t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof qd||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then(n=>!(t<this.pendingBackendInitId||(this.registry[e]=n,this.pendingBackendInit=null,0))).catch(n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${e} failed`),console.warn(n.stack||n.message)),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return console.warn(`Initialization of backend ${e} failed`),console.warn(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,s=this.readSync(t),o=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun(()=>this.startScope(r),()=>this.endScope(n),()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(r){throw t(),r}}nextTensorId(){return e.nextTensorId++}nextVariableId(){return e.nextVariableId++}clone(e){const t=ry.runKernel(Rf,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[t],e=>({x:()=>ry.runKernel(Yp,{x:e},{dtype:"float32"})}),[],{}),t}runKernel(e,t,n){if(null==og(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let s=0;n.forEach(e=>{s+="complex64"===e.dtype?3:1});const o=r-t-s-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),s=this.state.numBytes,o=this.state.numTensors;let i,a;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const u=Jg(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Jg(e)){const{kernelName:t,inputs:s,attrs:o}=e,u=og(t,this.backendName);Qd(null!=u,()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`),i=()=>{const e=this.backend.numDataIds();a=u.kernelFunc({inputs:s,attrs:o,backend:this.backend});const i=Array.isArray(a)?a:[a];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,i);const l=i.map(e=>{if(null!=e.rank)return e;const{dataId:t,shape:n,dtype:r}=e;return this.makeTensorFromDataId(t,n,r)});if(r){const e=this.getTensorsForGradient(t,s,l);n=this.saveTensorsForBackwardMode(e)}return l}}else{const{forwardFunc:t}=e,s=e=>{r&&(n=e.map(e=>this.keep(this.clone(e))))};i=()=>{const e=this.backend.numDataIds();a=this.tidy(()=>t(this.backend,s));const n=Array.isArray(a)?a:[a];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,e,n),n}}const{inputs:l,attrs:c}=e,h=Jg(e)?null:e.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(u,l,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs):t=i()}),r&&this.addTapeNode(u,l,t,h,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map(e=>null!=l[e]?l[e].shape:null),outputShapes:t.map(e=>e.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(a)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(e=>this.keep(this.clone(e)))}getTensorsForGradient(e,t,n){const r=ig(e);if(null!=r){const e=r.inputsToSave||[],s=r.outputsToSave||[];let o;r.saveAllInputs?(Qd(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(t).map(e=>t[e])):o=e.map(e=>t[e]);const i=n.filter((e,t)=>s[t]);return o.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");r=r||this.backend;let s=e;"string"===(n=n||"float32")&&fp(e[0])&&(s=e.map(e=>Tg(e)));const o=r.write(s,t,n),i=new Ug(t,n,o,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){const e=this.state.tensorInfo.get(o),t=function(e){if(null==e)return 0;let t=0;return e.forEach(e=>t+=e.length),t}(s);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){const s=new Ug(t,n=n||"float32",e,this.nextTensorId());return this.trackTensor(s,r),s}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const s=new zg(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*pp(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof zg||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*pp(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[e])}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){var t=this;return jd(function*(){t.state.profiling=!0;const n=t.state.numBytes,r=t.state.numTensors;t.state.activeProfile.kernels=[],t.state.activeProfile.result=yield e(),t.state.profiling=!1,t.state.activeProfile.peakBytes=Math.max(...t.state.activeProfile.kernels.map(e=>e.totalBytesSnapshot)),t.state.activeProfile.newBytes=t.state.numBytes-n,t.state.activeProfile.newTensors=t.state.numTensors-r;for(const e of t.state.activeProfile.kernels)e.kernelTimeMs=yield e.kernelTimeMs,e.extraInfo=yield e.extraInfo;return t.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,s,o){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},a=ig(e);null!=a&&(r=a.gradFunc),null!=r&&(i.gradient=e=>(e=e.map((e,t)=>{if(null==e){const e=n[t],r=Cp(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e}),r(e.length>1?e:e[0],s,o))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Qg(e),n=new Set(t.map(e=>e.id));for(let s=0;s<this.state.activeScope.track.length;s++){const e=this.state.activeScope.track[s];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(e=>{e.kept||e.scopeId!==r.id||this.track(e)})}gradients(e,t,n,r=!1){if(Qd(t.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));Qd(s instanceof Ug,()=>"The result y returned by f() must be a tensor.");const o=function(e,t,n){const r={},s={};for(let u=0;u<t.length;u++)r[t[u].id]=!0;for(let u=0;u<e.length;u++){const n=e[u],o=n.inputs;for(const e in o){const i=o[e];let a=!1;for(let e=0;e<t.length;e++)if(r[i.id]){n.outputs.forEach(e=>r[e.id]=!0),a=!0,s[n.id]=!0;break}if(a)break}}const o={};o[n.id]=!0;const i={};for(let u=e.length-1;u>=0;u--){const t=e[u],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(o[t.outputs[e].id]){for(const e in n)o[n[e].id]=!0,i[t.id]=!0;break}}const a=[];for(let u=0;u<e.length;u++){const t=e[u];if(s[t.id]&&i[t.id]){const e={};for(const s in t.inputs){const n=t.inputs[s];r[n.id]&&(e[s]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,a.push(n)}}return a}(this.state.activeTape,t,s);if(!r&&0===o.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const e={};e[s.id]=null==n?function(e){const t=wp(tp(e),"float32");return ry.makeTensor(t,e,"float32")}(s.shape):n,function(e,t,n,r){for(let s=t.length-1;s>=0;s--){const o=t[s],i=[];if(o.outputs.forEach(t=>{const n=e[t.id];i.push(null!=n?n:null)}),null==o.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const a=o.gradient(i);for(const t in o.inputs){if(!(t in a))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(a)}.`);const s=n(()=>a[t]());if("float32"!==s.dtype)throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${s.dtype}'`);const i=o.inputs[t];if(!np(s.shape,i.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${t}' has shape '${s.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=s;else{const t=e[i.id];e[i.id]=r(t,s),t.dispose()}}}}(e,o,e=>this.tidy(e),sy);const r=t.map(t=>e[t.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(e=>{for(const t of e.saved)t.dispose()}),this.state.activeTape=null),{value:s,grads:r}})}customGrad(e){return Qd(gp(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{let n;Qd(t.every(e=>e instanceof Ug),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const r={};return t.forEach((e,t)=>{r[t]=e}),this.runKernelFunc({forwardFunc:(r,s)=>(n=e(...t,s),Qd(n.value instanceof Ug,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),Qd(gp(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),backwardsFunc:(e,r)=>{const s=n.gradFunc(e,r),o=Array.isArray(s)?s:[s];Qd(o.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),Qd(o.every(e=>e instanceof Ug),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const i={};return o.forEach((e,t)=>{i[t]=()=>e}),i},inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}time(e){var t=this;return jd(function*(){const n=Sg(),r=yield t.backend.time(e);return r.wallMs=Sg()-n,r})()}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new ey;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return e.nextTensorId=0,e.nextVariableId=0,e})();function ny(){const e=Ap();if(null==e._tfengine){const t=new Tp(e);e._tfengine=new ty(t)}return Rp=e._tfengine.ENV,Lg=()=>e._tfengine,e._tfengine}const ry=ny();function sy(e,t){return ry.runKernel(Pp,{a:e,b:t})}function oy(e){if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function iy(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const ay=Np();function uy(e,t){let n=e;if(dp(e))return"string"===t?[]:[e.length];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||dp(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&Np().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&ly(e,r,[]),r}function ly(e,t,n){if(n=n||[],!Array.isArray(e)&&!dp(e))return void Qd(0===t.length,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);Qd(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),Qd(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);const r=t.slice(1);for(let s=0;s<e.length;++s)ly(e[s],r,n.concat(s))}function cy(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function hy(e,t,n,r="numeric"){if(e instanceof Ug)return cy(r,e.dtype,t,n),e;let s=mp(e);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),cy(r,s,t,n),null==e||!dp(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${null==e?"null":e.constructor.name}'`);const o=uy(e,s);dp(e)||Array.isArray(e)||(e=[e]);const i="string"!==s?Eg(e,s):ep(e,[],!0);return ry.makeTensor(i,o,s)}function dy(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((e,s)=>hy(e,`${t}[${s}]`,n,r))}function py(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const s=(...e)=>{ry.startScope(n);try{const t=r(...e);return Sp(t)&&console.error("Cannot return a Promise inside of tidy."),ry.endScope(t),t}catch(t){throw ry.endScope(null),t}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}ay.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),ay.registerFlag("IS_BROWSER",()=>iy()),ay.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),ay.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),ay.registerFlag("PROD",()=>!1),ay.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ay.getBool("DEBUG")),ay.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),ay.registerFlag("IS_TEST",()=>!1),ay.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),ay.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);const fy=py({complex_:function(e,t){const n=hy(e,"real","complex"),r=hy(t,"imag","complex");return Zd(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`),ry.runKernel(Jp,{real:n,imag:r})}});function my(e,t,n,r){if(null==r&&(r=mp(e)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!dp(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){_p(t);const e=tp(t),r=tp(n);Qd(e===r,()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`);for(let s=0;s<n.length;++s){const e=n[s],r=s!==n.length-1||e!==tp(t.slice(s));Qd(n[s]===t[s]||!r,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return dp(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?Eg(e,r):ep(e,[],!0),ry.makeTensor(e,t,r)}function gy(e,t,n){return my(e,t,uy(e,n),n)}const yy={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},xy="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function by(e){return xy?Buffer.byteLength(e):new Blob([e]).size}function vy(e){if(1===e.length)return e[0];let t=0;e.forEach(e=>{t+=e.byteLength});const n=new Uint8Array(t);let r=0;return e.forEach(e=>{n.set(new Uint8Array(e),r),r+=e.byteLength}),n.buffer}function wy(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:by(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:by(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}function Cy(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0==(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{const s=new ArrayBuffer(4*r.length),o=new Uint32Array(s);for(let i=0;i<r.length;i++){const s=r[i];o[i]=e[n[s>>10]+(1023&s)]+t[s>>10]}return new Float32Array(s)}}class _y{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==_y.instance&&(_y.instance=new _y),_y.instance}static registerSaveRouter(e){_y.getInstance().saveRouters.push(e)}static registerLoadRouter(e){_y.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return _y.getHandlers(e,"save")}static getLoadHandlers(e,t){return _y.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?_y.getInstance().loadRouters:_y.getInstance().saveRouters).forEach(t=>{const s=t(e,n);null!==s&&r.push(s)}),r}}const ky="tensorflowjs",Ey="models_store",Sy="model_info_store";function Ty(){if(!Np().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Iy(e){const t=e.result;t.createObjectStore(Ey,{keyPath:"modelPath"}),t.createObjectStore(Sy,{keyPath:"modelPath"})}let Ny=(()=>{class e{constructor(e){if(this.indexedDB=Ty(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){var t=this;return jd(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return t.databaseAction(t.modelPath,e)})()}load(){var e=this;return jd(function*(){return e.databaseAction(e.modelPath)})()}databaseAction(e,t){return new Promise((e,n)=>{const r=this.indexedDB.open(ky,1);r.onupgradeneeded=()=>Iy(r),r.onsuccess=()=>{const s=r.result;if(null==t){const t=s.transaction(Ey,"readonly"),r=t.objectStore(Ey).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return s.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(s.close(),n(r.error)),t.oncomplete=()=>s.close()}else{const r=wy(t),o=s.transaction(Sy,"readwrite");let i=o.objectStore(Sy);const a=i.put({modelPath:this.modelPath,modelArtifactsInfo:r});let u;a.onsuccess=()=>{u=s.transaction(Ey,"readwrite");const a=u.objectStore(Ey).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r});a.onsuccess=()=>e({modelArtifactsInfo:r}),a.onerror=e=>{i=o.objectStore(Sy);const t=i.delete(this.modelPath);t.onsuccess=()=>(s.close(),n(a.error)),t.onerror=e=>(s.close(),n(a.error))}},a.onerror=e=>(s.close(),n(a.error)),o.oncomplete=()=>{null==u?s.close():u.oncomplete=()=>s.close()}}},r.onerror=e=>n(r.error)})}}return e.URL_SCHEME="indexeddb://",e})();const $y=e=>{return Np().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ny.URL_SCHEME)?(t=e.slice(Ny.URL_SCHEME.length),new Ny(t)):null;var t};_y.registerSaveRouter($y),_y.registerLoadRouter($y);class Ry{constructor(){this.indexedDB=Ty()}listModels(){var e=this;return jd(function*(){return new Promise((t,n)=>{const r=e.indexedDB.open(ky,1);r.onupgradeneeded=()=>Iy(r),r.onsuccess=()=>{const e=r.result,s=e.transaction(Sy,"readonly"),o=s.objectStore(Sy).getAll();o.onsuccess=()=>{const e={};for(const t of o.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},o.onerror=t=>(e.close(),n(o.error)),s.oncomplete=()=>e.close()},r.onerror=e=>n(r.error)})})()}removeModel(e){var t=this;return jd(function*(){var n;return e=(n=e).startsWith(Ny.URL_SCHEME)?n.slice(Ny.URL_SCHEME.length):n,new Promise((n,r)=>{const s=t.indexedDB.open(ky,1);s.onupgradeneeded=()=>Iy(s),s.onsuccess=()=>{const t=s.result,o=t.transaction(Sy,"readwrite"),i=o.objectStore(Sy),a=i.get(e);let u;a.onsuccess=()=>{if(null==a.result)return t.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const s=i.delete(e),o=()=>{u=t.transaction(Ey,"readwrite");const s=u.objectStore(Ey).delete(e);s.onsuccess=()=>n(a.result.modelArtifactsInfo),s.onerror=e=>r(a.error)};s.onsuccess=o,s.onerror=e=>(o(),t.close(),r(a.error))}},a.onerror=e=>(t.close(),r(a.error)),o.oncomplete=()=>{null==u?t.close():u.oncomplete=()=>t.close()}},s.onerror=e=>r(s.error)})})()}}const Ay="/",Oy="tensorflowjs_models",Fy="info",Dy="model_topology",Py="weight_specs",My="weight_data",Ly="model_metadata";function By(e){return{info:[Oy,e,Fy].join(Ay),topology:[Oy,e,Dy].join(Ay),weightSpecs:[Oy,e,Py].join(Ay),weightData:[Oy,e,My].join(Ay),modelMetadata:[Oy,e,Ly].join(Ay)}}function Vy(e){const t=e.split(Ay);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Ay)}let Uy=(()=>{class e{constructor(e){if(!Np().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=By(this.modelPath)}save(e){var t=this;return jd(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const r=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),o=wy(e);try{t.LS.setItem(t.keys.info,JSON.stringify(o)),t.LS.setItem(t.keys.topology,r),t.LS.setItem(t.keys.weightSpecs,s),t.LS.setItem(t.keys.weightData,function(e){if(xy)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let r=0,s=t.length;r<s;r++)n+=String.fromCharCode(t[r]);return btoa(n)}(e.weightData));const n={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),t.LS.setItem(t.keys.modelMetadata,JSON.stringify(n)),{modelArtifactsInfo:o}}catch(n){throw t.LS.removeItem(t.keys.info),t.LS.removeItem(t.keys.topology),t.LS.removeItem(t.keys.weightSpecs),t.LS.removeItem(t.keys.weightData),t.LS.removeItem(t.keys.modelMetadata),new Error(`Failed to save model '${t.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}})()}load(){var e=this;return jd(function*(){const t=JSON.parse(e.LS.getItem(e.keys.info));if(null==t)throw new Error(`In local storage, there is no model with name '${e.modelPath}'`);if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},r=JSON.parse(e.LS.getItem(e.keys.topology));if(null==r)throw new Error(`In local storage, the topology of model '${e.modelPath}' is missing.`);n.modelTopology=r;const s=JSON.parse(e.LS.getItem(e.keys.weightSpecs));if(null==s)throw new Error(`In local storage, the weight specs of model '${e.modelPath}' are missing.`);n.weightSpecs=s;const o=e.LS.getItem(e.keys.modelMetadata);if(null!=o){const e=JSON.parse(o);n.format=e.format,n.generatedBy=e.generatedBy,n.convertedBy=e.convertedBy,null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer)}const i=e.LS.getItem(e.keys.weightData);if(null==i)throw new Error(`In local storage, the binary weight values of model '${e.modelPath}' are missing.`);return n.weightData=function(e){if(xy){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}(i),n})()}}return e.URL_SCHEME="localstorage://",e})();const zy=e=>{return Np().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Uy.URL_SCHEME)?(t=e.slice(Uy.URL_SCHEME.length),new Uy(t)):null;var t};_y.registerSaveRouter(zy),_y.registerLoadRouter(zy);class Wy{constructor(){Qd(Np().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),Qd("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var e=this;return jd(function*(){const t={},n=Oy+Ay,r=Ay+Fy;for(let s=0;s<e.LS.length;++s){const o=e.LS.key(s);o.startsWith(n)&&o.endsWith(r)&&(t[Vy(o)]=JSON.parse(e.LS.getItem(o)))}return t})()}removeModel(e){var t=this;return jd(function*(){var n;const r=By(e=(n=e).startsWith(Uy.URL_SCHEME)?n.slice(Uy.URL_SCHEME.length):n);if(null==t.LS.getItem(r.info))throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(t.LS.getItem(r.info));return t.LS.removeItem(r.info),t.LS.removeItem(r.topology),t.LS.removeItem(r.weightSpecs),t.LS.removeItem(r.weightData),s})()}}class jy{constructor(){this.managers={}}static getInstance(){return null==jy.instance&&(jy.instance=new jy),jy.instance}static registerManager(e,t){Qd(null!=e,()=>"scheme must not be undefined or null."),e.endsWith("://")&&(e=e.slice(0,e.indexOf("://"))),Qd(e.length>0,()=>"scheme must not be an empty string.");const n=jy.getInstance();Qd(null==n.managers[e],()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){const t=this.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}}class Hy{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}}if(Np().get("IS_BROWSER")){Np().setPlatform("browser",new Hy);try{jy.registerManager(Uy.URL_SCHEME,new Wy)}catch(CP){}try{jy.registerManager(Ny.URL_SCHEME,new Ry)}catch(CP){}}let Gy;function qy(e,t="float32",n){return t=t||"float32",_p(e),new Mg(e,t,n)}Np().get("IS_NODE")&&Np().setPlatform("node",new class{constructor(){this.util=n(628),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=Np().global.fetch?Np().global.fetch(e,t):(null==Gy&&(Gy=n(410)),Gy(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}});const Ky=py({cast_:function(e,t){const n=hy(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");return ry.runKernel(Yp,{x:n},{dtype:t})}}),Xy=py({clone_:function(e){const t=hy(e,"x","clone","string_or_numeric");return ry.runKernel(Rf,{x:t})}});function Yy(e){return new Promise(e=>setTimeout(e)).then(e)}ny(),Bg={buffer:qy,cast:Ky,clone:Xy,print:function(e,t=!1){console.log(e.toString(t))}};let Qy=(()=>{class e{constructor(t){if(!Np().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(e.URL_SCHEME)&&(t=t.slice(e.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelTopologyFileName=t+".json",this.weightDataFileName=t+".weights.bin"}save(e){var t=this;return jd(function*(){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:[{paths:["./"+t.weightDataFileName],weights:e.weightSpecs}]};null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer);const s=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),o=null==t.jsonAnchor?document.createElement("a"):t.jsonAnchor;if(o.download=t.modelTopologyFileName,o.href=s,yield Yy(()=>o.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const e=null==t.weightDataAnchor?document.createElement("a"):t.weightDataAnchor;e.download=t.weightDataFileName,e.href=n,yield Yy(()=>e.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:wy(e)}}})()}}return e.URL_SCHEME="downloads://",e})();function Zy(e,t,n,r){!function(e){Qd(null!=e&&Array.isArray(e)&&e.length>0,()=>"promises must be a none empty array")}(e),function(e,t){Qd(e>=0&&e<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`),Qd(t>=0&&t<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`),Qd(t>=e,()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`)}(n=null==n?0:n,r=null==r?1:r);let s=0;return Promise.all(e.map(o=>(o.then(o=>{const i=n+ ++s/e.length*(r-n);return t(i),o}),o)))}function Jy(e,t){return ex.apply(this,arguments)}function ex(){return(ex=jd(function*(e,t){null==t&&(t={});const n=null==t.fetchFunc?Np().platform.fetch:t.fetchFunc,r=e.map(e=>n(e,t.requestInit,{isBinary:!0})),s=(null==t.onProgress?yield Promise.all(r):yield Zy(r,t.onProgress,0,.5)).map(e=>e.arrayBuffer());return null==t.onProgress?yield Promise.all(s):yield Zy(s,t.onProgress,.5,1)})).apply(this,arguments)}_y.registerSaveRouter(e=>Np().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Qy.URL_SCHEME)?function(e="model"){return new Qy(e)}(e.slice(Qy.URL_SCHEME.length)):null);let tx=(()=>{class e{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Qd("function"==typeof t.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=Np().platform.fetch,Qd(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&Qd(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}save(e){var t=this;return jd(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:t.DEFAULT_METHOD},t.requestInit);n.body=new FormData;const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:[{paths:["./model.weights.bin"],weights:e.weightSpecs}]};null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),n.body.append("model.json",new Blob([JSON.stringify(r)],{type:"application/json"}),"model.json"),null!=e.weightData&&n.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const s=yield t.fetch(t.path,n);if(s.ok)return{modelArtifactsInfo:wy(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)})()}load(){var e=this;return jd(function*(){const t=yield e.fetch(e.path,e.requestInit);if(!t.ok)throw new Error(`Request to ${e.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=yield t.json()}catch(f){let t=`Failed to parse model JSON of response from ${e.path}.`;throw e.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const r=n.modelTopology,s=n.weightsManifest,o=n.generatedBy,i=n.convertedBy,a=n.format,u=n.signature,l=n.userDefinedMetadata;if(null==r&&null==s)throw new Error(`The JSON from HTTP path ${e.path} contains neither model topology or manifest for weights.`);let c,h;if(null!=s){const t=yield e.loadWeights(s);[c,h]=t}const d={modelTopology:r,weightSpecs:c,weightData:h,generatedBy:o,convertedBy:i,format:a};null!=u&&(d.signature=u),null!=l&&(d.userDefinedMetadata=l);const p=n.modelInitializer;return p&&(d.modelInitializer=p),d})()}loadWeights(e){var t=this;return jd(function*(){const n=Array.isArray(t.path)?t.path[1]:t.path,[r,s]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?");return[e.substring(0,t)+"/",n>t?e.substring(n):""]}(n),o=t.weightPathPrefix||r,i=[];for(const t of e)i.push(...t.weights);const a=[],u=[];for(const l of e)for(const e of l.paths)null!=t.weightUrlConverter?u.push(t.weightUrlConverter(e)):a.push(o+e+s);return t.weightUrlConverter&&a.push(...yield Promise.all(u)),[i,vy(yield Jy(a,{requestInit:t.requestInit,fetchFunc:t.fetch,onProgress:t.onProgress}))]})()}}return e.URL_SCHEME_REGEX=/^https?:\/\//,e})();function nx(e){return null!=e.match(tx.URL_SCHEME_REGEX)}const rx=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every(e=>nx(e)):nx(e),n)return sx(e,t)}return null};function sx(e,t){return new tx(e,t)}function ox(e,t){return sx(e,t)}let ix;_y.registerSaveRouter(rx),_y.registerLoadRouter(rx);const ax=py({fromPixels_:function(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,o=!1,i=!1,a=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)s=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)o=!0;else if(null!=e.getContext)i=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);a=!0}if(s){const t=2;if(s&&e.readyState<t)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=og(Zm,ry.backendName))return ry.runKernel(Zm,{pixels:e},{numChannels:t});const[u,l]=s?[e.videoWidth,e.videoHeight]:[e.width,e.height];let c,h;if(i?c=e.getContext("2d").getImageData(0,0,u,l).data:r||n?c=e.data:(o||s||a)&&(null==ix&&(ix=document.createElement("canvas").getContext("2d")),ix.canvas.width=u,ix.canvas.height=l,ix.drawImage(e,0,0,u,l),c=ix.getImageData(0,0,u,l).data),4===t)h=new Int32Array(c);else{const e=u*l;h=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)h[n*t+e]=c[4*n+e]}return function(e,t,n){if(Jd(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=uy(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return my(e,t,r,n)}(h,[l,u,t],"int32")}});function ux(e,t,n){const r=e.shape.length;Qd(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),Qd(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)Qd(t[s]+n[s]<=e.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`)}function lx(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function cx(e,t,n){const r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function hx(e,t,n,r){const s=[...e];for(let o=s.length;o<r.length;o++)s.push(1);for(let o=0;o<n;o++)0===o?s[t]=1:(s.splice(t,0,1),s.pop());return s}function dx(e,t,n){return n<=e?n:n-(t-1)}function px(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function fx(e,t,n,r,s,o,i,a,u){const l=e.length;let c=new Array(l),h=new Array(l),d=new Array(l);if(t.length&&n>0){const u=t[0],l=n+1;c=mx(i,u,l,r,e),h=gx(a,u,l,s,e),d=hx(o,u,l,e)}else for(let p=0;p<l;p++)c[p]=xx(i,r,o,e,p,u),h[p]=bx(a,s,o,e,p,u),d[p]=yx(o,p,u);return{begin:c,end:h,strides:d}}function mx(e,t,n,r,s){const o=[...s],i=px(n,t);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=0;else{const s=dx(t,n,a);let i=r[s];e&1<<s&&(i=0),o[a]=i}return o}function gx(e,t,n,r,s){const o=[...s],i=px(n,t);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=Number.MAX_SAFE_INTEGER;else{const s=dx(t,n,a);let i=r[s];e&1<<s&&(i=Number.MAX_SAFE_INTEGER),o[a]=i}for(let a=0;a<o.length;a++){const e=s[a];o[a]<0&&(o[a]+=e),o[a]=Xd(0,o[a],s[a])}return o}function yx(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function xx(e,t,n,r,s,o){let i=t[s];(e&1<<s||o&1<<s||null==i)&&(i=(n[s]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const a=r[s];return i<0&&(i+=a),i=Xd(0,i,a-1),i}function bx(e,t,n,r,s,o){let i=t[s];const a=n[s]||1;(e&1<<s||o&1<<s||null==i)&&(i=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const u=r[s];return i<0&&(i+=u),i=a>0?Xd(0,i,u):Xd(-1,i,u-1),i}function vx(e,t,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function wx(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function Cx(e,t,n){let r;const s=e.shape.length;let o;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach(e=>{Qd(-1!==e,()=>"slice() does not support negative begin indexing.")}),o=null==n?new Array(s).fill(-1):"number"==typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,o=o.map((t,n)=>t>=0?t:(Qd(-1===t,()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`),e.shape[n]-r[n])),[r,o]}function _x(e,t,n,r,s,o,i,a,u){let l=t.slice(),c=n.slice(),h=r;null==r&&(h=new Array(l.length));const d=lx(i);if(d.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==i&&0!==a)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==i&&0!==u)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const p=e.length-l.length,f=lx(a),m=e.slice();f.forEach(e=>{l[e]=0,c[e]=1,m.splice(e,0,1)});const{begin:g,end:y,strides:x}=fx(m,d,p,l,c,h,s,o,i);l=g,c=y,h=x;const b=lx(u);b.forEach(e=>{c[e]=l[e]+1,h[e]=1});const v=cx(l,c,h),w=v.filter((e,t)=>-1===b.indexOf(t));return{nonStrided:h.every(e=>1===e),$begin:l,$end:c,$strides:h,size:v,newShape:m,outShape:w}}const kx=py({add_:function(e,t){let n=hy(e,"a","add"),r=hy(t,"b","add");return[n,r]=Yg(n,r),ry.runKernel(Pp,{a:n,b:r})}}),Ex=py({argMax_:function(e,t=0){const n=hy(e,"x","argMax");return ry.runKernel(Lp,{x:n},{axis:t})}}),Sx=py({clipByValue_:function(e,t,n){const r=hy(e,"x","clipByValue");return Qd(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),ry.runKernel(Zp,{x:r},{clipValueMin:t,clipValueMax:n})}}),Tx=py({concat_:function(e,t=0){Qd(e.length>=1,()=>"Pass at least one tensor to concat");const n=dy(e,"tensors","concat","string_or_numeric");return"complex64"===n[0].dtype&&n.forEach(e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)}),1===n.length?Xy(n[0]):ry.runKernel(tf,n,{axis:t})}}),Ix=py({floorDiv_:function(e,t){let n=hy(e,"a","floorDiv"),r=hy(t,"b","floorDiv");return[n,r]=Yg(n,r),ry.runKernel(Ef,{a:n,b:r})}}),Nx=py({div_:function(e,t){let n=hy(e,"a","div"),r=hy(t,"b","div");return[n,r]=Yg(n,r),"int32"===n.dtype&&"int32"===r.dtype?Ix(n,r):ry.runKernel(gf,{a:n,b:r},{})}}),$x=py({exp_:function(e){const t=hy(e,"x","exp");return ry.runKernel(bf,{x:t})}}),Rx=py({expandDims_:function(e,t=0){const n=hy(e,"x","expandDims","string_or_numeric");return Qd(t<=n.rank,()=>"Axis must be <= rank of the tensor"),ry.runKernel(vf,{input:n},{dim:t})}}),Ax=py({mul_:function(e,t){let n=hy(e,"a","mul"),r=hy(t,"b","mul");return[n,r]=Yg(n,r),ry.runKernel(Zf,{a:n,b:r})}}),Ox=py({reshape_:function(e,t){const n=hy(e,"x","reshape","string_or_numeric");return ry.runKernel(pm,{x:n},{shape:t})}});function Fx(e,t){if((dp(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&dp(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return my(e,[],[],t)}const Dx=py({sigmoid_:function(e){const t=hy(e,"x","sigmoid");return ry.runKernel(Sm,{x:t})}}),Px=py({slice_:function(e,t,n){const r=hy(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");return ry.runKernel(_m,{x:r},{begin:t,size:n})}}),Mx=py({squeeze_:function(e,t){const n=hy(e,"x","squeeze");return Ox(n,up(n.shape,t).newShape)}}),Lx=py({stack_:function(e,t=0){const n=dy(e,"tensors","stack","string_or_numeric");return Qd(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&Qd(t<=n[0].rank,()=>"Axis must be <= rank of the tensor"),ry.runKernel(om,n,{axis:t})}}),Bx=py({sub_:function(e,t){let n=hy(e,"a","sub"),r=hy(t,"b","sub");return[n,r]=Yg(n,r),ry.runKernel(zm,{a:n,b:r})}});function Vx(e,t){Jd(e);const n=uy(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return my(e,null,n,t)}function Ux(e,t,n){if(Jd(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=uy(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return my(e,t,r,n)}const zx=py({unstack_:function(e,t=0){const n=hy(e,"x","unstack","string_or_numeric");return Qd(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`),ry.runKernel(Xm,{value:n},{axis:t})}});function Wx(e,t="float32"){if("complex64"===t){const t=Wx(e,"float32"),n=Wx(e,"float32");return fy(t,n)}const n=Cp(tp(e),t);return ry.makeTensor(n,e,t)}const jx=py({imag_:function(e){const t=hy(e,"input","imag");return ry.runKernel(Of,{input:t})}}),Hx=py({real_:function(e){const t=hy(e,"input","real");return ry.runKernel(cm,{input:t})}}),Gx=py({split_:function(e,t,n=0){const r=hy(e,"x","split");return ry.runKernel($m,{x:r},{numOrSizeSplits:t,axis:n})}}),qx=py({zerosLike_:function(e){const t=hy(e,"x","zerosLike");return ry.runKernel(Ym,{x:t})}}),Kx=py({fft_:function(e){return Qd("complex64"===e.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`),ry.runKernel("FFT",{input:e})}}),Xx=py({rfft_:function(e,t){Qd("float32"===e.dtype,()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1];const r=e.size/n;let s;if(null!=t&&t<n){const r=e.shape.map(e=>0),o=e.shape.map(e=>e);o[e.shape.length-1]=t,s=Px(e,r,o),n=t}else if(null!=t&&t>n){const r=e.shape.map(e=>e);r[e.shape.length-1]=t-n,s=Tx([e,Wx(r)],e.shape.length-1),n=t}else s=e;const o=qx(s),i=Ox(fy(s,o),[r,n]),a=Kx(i),u=Math.floor(n/2)+1,l=Hx(a),c=jx(a),h=Gx(l,[u,n-u],l.shape.length-1),d=Gx(c,[u,n-u],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=u,Ox(fy(h[0],d[0]),p)}}),Yx=py({ifft_:function(e){return Qd("complex64"===e.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`),ry.runKernel(Af,{input:e})}}),Qx=py({reverse_:function(e,t){const n=hy(e,"x","reverse");return ry.runKernel(ym,{x:n},{dims:t})}}),Zx=py({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const s=Ox(e,[n,t]);r=Yx(s)}else{const s=[n,2*(t-1)],o=Ox(Hx(e),[n,t]),i=Ox(jx(e),[n,t]),a=Qx(Px(o,[0,1],[n,t-2]),1),u=Ax(Qx(Px(i,[0,1],[n,t-2]),1),Fx(-1)),l=Tx([o,a],1),c=Tx([i,u],1),h=Ox(fy(l,c),[s[0],s[1]]);r=Yx(h)}if(r=Hx(r),3===e.rank&&0!==e.shape[0]){const t=r,n=e.shape[0];r=Ox(r,[n,r.shape[0]/n,r.shape[1]]),t.dispose()}return r}});function Jx(e,t,n){const r=1-e%2,s=new Float32Array(e);for(let o=0;o<e;++o){const i=2*Math.PI*o/(e+r-1);s[o]=t-n*Math.cos(i)}return Vx(s,"float32")}py({hammingWindow_:function(e){return Jx(e,.54,.46)}});const eb=py({hannWindow_:function(e){return Jx(e,.5,.5)}});function tb(e,t,n){return ry.runKernel(Cf,{},{shape:e,value:t,dtype:n})}const nb=py({frame_:function(e,t,n,r=!1,s=0){let o=0;const i=[];for(;o+t<=e.size;)i.push(Px(e,o,t)),o+=n;if(r)for(;o<e.size;){const r=o+t-e.size,a=Tx([Px(e,o,t-r),tb([r],s)]);i.push(a),o+=n}return 0===i.length?Ux([],[0,t]):Ox(Tx(i),[i.length,t])}});py({stft_:function(e,t,n,r,s=eb){null==r&&(r=Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2)))));const o=nb(e,t,n),i=Ax(o,s(t));return Xx(i,r)}});const rb=py({cropAndResize_:function(e,t,n,r,s="bilinear",o=0){const i=hy(e,"image","cropAndResize"),a=hy(t,"boxes","cropAndResize","float32"),u=hy(n,"boxInd","cropAndResize","int32"),l=a.shape[0];return Qd(4===i.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),Qd(2===a.rank&&4===a.shape[1],()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${a.shape}.`),Qd(1===u.rank&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${a.shape}.`),Qd(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),Qd(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),Qd("bilinear"===s||"nearest"===s,()=>`method must be bilinear or nearest, but was ${s}`),ry.runKernel(lf,{image:i,boxes:a,boxInd:u},{method:s,extrapolationValue:o,cropSize:r})}}),sb=py({flipLeftRight_:function(e){const t=hy(e,"image","flipLeftRight","float32");return Qd(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),ry.runKernel(_f,{image:t},{})}}),ob=py({rotateWithOffset_:function(e,t,n=0,r=.5){const s=hy(e,"image","rotateWithOffset","float32");return Qd(4===s.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`),ry.runKernel(Jm,{image:s},{radians:t,fillValue:n,center:r})}});function ib(e,t,n,r,s,o){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==o&&(o=0);const i=e.shape[0];return n=Math.min(n,i),Qd(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),Qd(2===e.rank,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),Qd(4===e.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),Qd(1===t.rank,()=>"scores must be a 1D tensor"),Qd(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),Qd(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}const ab=py({nonMaxSuppression_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const o=hy(e,"boxes","nonMaxSuppression"),i=hy(t,"scores","nonMaxSuppression"),a=ib(o,i,n,r,s);return ry.runKernel(em,{boxes:o,scores:i},{maxOutputSize:n=a.maxOutputSize,iouThreshold:r=a.iouThreshold,scoreThreshold:s=a.scoreThreshold})}});function ub(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,s=e.length,o=0,i=!1;for(;r<s;){o=r+(s-r>>>1);const a=n(t,e[o]);a>0?r=o+1:(s=o,i=!a)}return i?r:-r-1}(e,t,n||lb)}(e,t,n);e.splice(r<0?-(r+1):r,0,t)}function lb(e,t){return e>t?1:e<t?-1:0}function cb(e,t,n,r,s){return pb(e,t,n,r,s,0)}function hb(e,t,n,r,s,o){return pb(e,t,n,r,s,0,!1,o,!0)}function db(e,t,n,r,s,o){return pb(e,t,n,r,s,o,!0)}function pb(e,t,n,r,s,o,i=!1,a=!1,u=!1){const l=[];for(let g=0;g<t.length;g++)t[g]>s&&l.push({score:t[g],boxIndex:g,suppressBeginIndex:0});l.sort(gb);const c=o>0?-.5/o:0,h=[],d=[];for(;h.length<n&&l.length>0;){const t=l.pop(),{score:n,boxIndex:o,suppressBeginIndex:i}=t;if(n<s)break;let a=!1;for(let u=h.length-1;u>=i;--u){const n=fb(e,o,h[u]);if(n>=r){a=!0;break}if(t.score=t.score*mb(r,c,n),t.score<=s)break}t.suppressBeginIndex=h.length,a||(t.score===n?(h.push(o),d.push(t.score)):t.score>s&&ub(l,t,gb))}const p=h.length,f=n-p;a&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return i&&(m.selectedScores=d),u&&(m.validOutputs=p),m}function fb(e,t,n){const r=e.subarray(4*t,4*t+4),s=e.subarray(4*n,4*n+4),o=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),p=(a-o)*(u-i),f=(h-l)*(d-c);if(p<=0||f<=0)return 0;const m=Math.max(o,l),g=Math.max(i,c),y=Math.min(a,h),x=Math.min(u,d),b=Math.max(y-m,0)*Math.max(x-g,0);return b/(p+f-b)}function mb(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function gb(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}function yb(){return(yb=jd(function*(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const o=hy(e,"boxes","nonMaxSuppressionAsync"),i=hy(t,"scores","nonMaxSuppressionAsync"),a=ib(o,i,n,r,s);n=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const u=yield Promise.all([o.data(),i.data()]),l=u[0],c=u[1],{selectedIndices:h}=cb(l,c,n,r,s);return o!==e&&o.dispose(),i!==t&&i.dispose(),Vx(h,"int32")})).apply(this,arguments)}const xb=py({nonMaxSuppressionWithScore_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=hy(e,"boxes","nonMaxSuppression"),a=hy(t,"scores","nonMaxSuppression"),u=ib(i,a,n,r,s,o),l=ry.runKernel(nm,{boxes:i,scores:a},{maxOutputSize:n=u.maxOutputSize,iouThreshold:r=u.iouThreshold,scoreThreshold:s=u.scoreThreshold,softNmsSigma:o=u.softNmsSigma});return{selectedIndices:l[0],selectedScores:l[1]}}});function bb(){return(bb=jd(function*(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=hy(e,"boxes","nonMaxSuppressionAsync"),a=hy(t,"scores","nonMaxSuppressionAsync"),u=ib(i,a,n,r,s,o);n=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,o=u.softNmsSigma;const l=yield Promise.all([i.data(),a.data()]),c=l[0],h=l[1],{selectedIndices:d,selectedScores:p}=db(c,h,n,r,s,o);return i!==e&&i.dispose(),a!==t&&a.dispose(),{selectedIndices:Vx(d,"int32"),selectedScores:Vx(p)}})).apply(this,arguments)}const vb=py({nonMaxSuppressionPadded_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=hy(e,"boxes","nonMaxSuppression"),a=hy(t,"scores","nonMaxSuppression"),u=ib(i,a,n,r,s,null),l=ry.runKernel(tm,{boxes:i,scores:a},{maxOutputSize:u.maxOutputSize,iouThreshold:u.iouThreshold,scoreThreshold:u.scoreThreshold,padToMaxOutputSize:o});return{selectedIndices:l[0],validOutputs:l[1]}}});function wb(){return(wb=jd(function*(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=hy(e,"boxes","nonMaxSuppressionAsync"),a=hy(t,"scores","nonMaxSuppressionAsync"),u=ib(i,a,n,r,s,null),l=u.maxOutputSize,c=u.iouThreshold,h=u.scoreThreshold,[d,p]=yield Promise.all([i.data(),a.data()]),{selectedIndices:f,validOutputs:m}=hb(d,p,l,c,h,o);return i!==e&&i.dispose(),a!==t&&a.dispose(),{selectedIndices:Vx(f,"int32"),validOutputs:Fx(m,"int32")}})).apply(this,arguments)}const Cb=py({resizeBilinear_:function(e,t,n=!1,r=!1){const s=hy(e,"images","resizeBilinear");Qd(3===s.rank||4===s.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),Qd(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),Qd(!1===r||!1===n,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;3===s.rank&&(i=!0,o=Ox(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,a=ry.runKernel(mm,{images:o},{alignCorners:n,halfPixelCenters:r,size:t});return i?Ox(a,[a.shape[1],a.shape[2],a.shape[3]]):a}}),_b=py({resizeNearestNeighbor_:function(e,t,n=!1,r=!1){const s=hy(e,"images","resizeNearestNeighbor");Qd(3===s.rank||4===s.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),Qd(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),Qd("float32"===s.dtype||"int32"===s.dtype,()=>"`images` must have `int32` or `float32` as dtype"),Qd(!1===r||!1===n,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;3===s.rank&&(i=!0,o=Ox(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,a=ry.runKernel(fm,{images:o},{alignCorners:n,halfPixelCenters:r,size:t});return i?Ox(a,[a.shape[1],a.shape[2],a.shape[3]]):a}}),kb=py({bincount_:function(e,t,n){const r=hy(e,"x","bincount"),s=hy(t,"weights","bincount");return Qd("int32"===r.dtype,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),Qd(n>=0,()=>`size must be non-negative, but got ${n}.`),Qd(s.size===r.size||0===s.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`),ry.runKernel(Xp,{x:r,weights:s},{size:n})}});function Eb(e,t){const n=e.length,r=[];for(let s=0;s<n;s++){const o=n-1-s,i=e[o]||1;(t[t.length-1-s]||1)>1&&1===i&&r.unshift(o)}return r}function Sb(e,t){const n=[];for(let r=0;r<t.length;r++){const s=e[e.length-r-1],o=t.length-r-1,i=t[o];(null==s||1===s&&i>1)&&n.unshift(o)}return n}function Tb(e,t){const n=[],r=Math.max(e.length,t.length);for(let s=0;s<r;s++){let r=e[e.length-s-1];null==r&&(r=1);let o=t[t.length-s-1];if(null==o&&(o=1),1===r)n.unshift(o);else if(1===o)n.unshift(r);else{if(r!==o)throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`);n.unshift(r)}}return n}const Ib=py({lessEqual_:function(e,t){let n=hy(e,"a","lessEqual","string_or_numeric"),r=hy(t,"b","lessEqual","string_or_numeric");return[n,r]=Yg(n,r),Tb(n.shape,r.shape),ry.runKernel(Mf,{a:n,b:r})}}),Nb=py({greater_:function(e,t){let n=hy(e,"a","greater","string_or_numeric"),r=hy(t,"b","greater","string_or_numeric");return[n,r]=Yg(n,r),Tb(n.shape,r.shape),ry.runKernel(Nf,{a:n,b:r})}}),$b=py({sum_:function(e,t=null,n=!1){let r=hy(e,"x","sum");return"bool"===r.dtype&&(r=Ky(r,"int32")),ry.runKernel("Sum",{x:r},{axis:t,keepDims:n})}}),Rb=py({round_:function(e){const t=hy(e,"x","round");return ry.runKernel(xm,{x:t})}}),Ab=py({broadcastTo_:function(e,t){let n=hy(e,"broadcastTo","x");const r=n.shape;if(t.some(e=>!(e>0)||e%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Ox(n,e)}const s=n.shape,o=Array.from(t);for(let i=t.length-1;i>=0;i--)if(s[i]===t[i])o[i]=1;else if(1!==n.shape[i])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);return 0===o.map((e,t)=>e>1?t:-1).filter(e=>e>=0).length?Xy(n):ry.runKernel(jm,{x:n},{reps:o})}}),Ob=py({where_:function(e,t,n){const r=hy(t,"a","where"),s=hy(n,"b","where"),o=hy(e,"condition","where","bool"),i=Tb(Tb(o.shape,r.shape),s.shape),a=Ab(o,i),u=Ab(r,i),l=Ab(s,i);return ry.runKernel(wm,{condition:a,t:u,e:l})}});function Fb(e,t,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");return ry.runKernel(lm,{},{start:e,stop:t,step:n,dtype:r})}const Db=py({threshold_:function(e,t="binary",n=!1,r=.5){const s=hy(e,"image","threshold"),o=s.shape[0]*s.shape[1];let i,a,u,l,c=Ax(Vx([r]),255);if(Qd(3===s.rank,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),Qd(3===s.shape[2]||1===s.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),Qd("int32"===s.dtype||"float32"===s.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),Qd("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===s.shape[2]){[i,a,u]=Gx(s,[1,1,1],-1);const e=Ax(i,.2989),t=Ax(a,.587),n=Ax(u,.114);l=kx(kx(e,t),n)}else l=e;"otsu"===t&&(c=function(e,t){let n,r,s,o,i,a,u=Vx([-1]),l=Vx([0]),c=Vx([0]);for(let h=0;h<e.size-1;h++){n=Px(e,0,h+1),r=Px(e,h+1),i=Nx($b(n),t),a=Nx($b(r),t);const d=$b(Ax(n,Fb(0,n.size)));s=Nx(d,$b(n));const p=tb(r.shape,n.size),f=kx(Fb(0,r.size),p),m=Ax(r,f);o=Nx($b(m),$b(r));const g=Bx(s,o),y=Bx(s,o),x=Ax(i,a);c=Ax(Ax(x,g),y);const b=Nb(c,l);l=Ob(b,c,l),u=Ob(b,Vx([h]),u)}return u}(kb(Ky(Rb(l),"int32"),gy([]),256),o));const h=n?Ib(l,c):Nb(l,c);return Ky(Ax(h,255),"int32")}}),Pb=py({transform_:function(e,t,n="nearest",r="constant",s=0,o){const i=hy(e,"image","transform","float32"),a=hy(t,"transforms","transform","float32");return Qd(4===i.rank,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),Qd(2===a.rank&&(a.shape[0]===i.shape[0]||1===a.shape[0])&&8===a.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),Qd(null==o||2===o.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`),ry.runKernel(Gm,{image:i,transforms:a},{interpolation:n,fillMode:r,fillValue:s,outputShape:o})}}),Mb=py({greaterEqual_:function(e,t){let n=hy(e,"a","greaterEqual","string_or_numeric"),r=hy(t,"b","greaterEqual","string_or_numeric");return[n,r]=Yg(n,r),Tb(n.shape,r.shape),ry.runKernel($f,{a:n,b:r})}}),Lb=py({logicalAnd_:function(e,t){const n=hy(e,"a","logicalAnd","bool"),r=hy(t,"b","logicalAnd","bool");return Tb(n.shape,r.shape),ry.runKernel(Uf,{a:n,b:r})}});py({bandPart_:function(e,t,n){Qd(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),Qd(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const r=hy(e,"a","bandPart");Qd(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[o,i]=r.shape.slice(-2);if(!(t<=o))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${o}).`);if(!(n<=i))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`);t<0&&(t=o),n<0&&(n=i);const a=Ox(Fb(0,o,1,"int32"),[-1,1]),u=Fb(0,i,1,"int32"),l=Bx(a,u),c=Lb(Ib(l,Fx(+t,"int32")),Mb(l,Fx(-n,"int32"))),h=Wx([o,i],r.dtype);return Ox(Lx(zx(Ox(r,[-1,o,i])).map(e=>Ob(c,e,h))),s)}});const Bb=py({abs_:function(e){const t=hy(e,"x","abs");return ry.runKernel("complex64"===t.dtype?ef:"Abs",{x:t})}});function Vb(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Ub(e,t,n){const r=e.length+t.length,s=[];let o=0,i=0;for(let a=0;a<r;a++)-1===n.indexOf(a)?s.push(e[o++]):s.push(t[i++]);return s}function zb(e,t){const n=[],r=e.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&n.push(e[s]);return[n,t.map(t=>e[t])]}function Wb(e,t){return Ub(e,t.map(e=>1),t)}function jb(e,t,n){Qd(Vb(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function Hb(e,t){if(Vb(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach(e=>n.push(e)),n}function Gb(e){return e.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function qb(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}const Kb=py({max_:function(e,t=null,n=!1){const r=hy(e,"x","max");return ry.runKernel("Max",{x:r},{reductionIndices:t,keepDims:n})}}),Xb=py({min_:function(e,t=null,n=!1){const r=hy(e,"x","min");return ry.runKernel("Min",{x:r},{axis:t,keepDims:n})}}),Yb=py({pow_:function(e,t){let n=hy(e,"base","pow"),r=hy(t,"exp","pow");return[n,r]=Yg(n,r),ry.runKernel("Pow",{a:n,b:r})}}),Qb=py({sqrt_:function(e){const t=hy(e,"x","sqrt");return ry.runKernel(Im,{x:t})}}),Zb=py({square_:function(e){const t=hy(e,"x","square");return ry.runKernel("Square",{x:t},{})}});function Jb(e,t,n=null){if(0===e.rank)return Bb(e);if(1!==e.rank&&null===n)return Jb(Ox(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return $b(Bb(e),n);if(t===1/0)return Kb(Bb(e),n);if(t===-1/0)return Xb(Bb(e),n);if("euclidean"===t||2===t)return Qb($b(Yb(Bb(e),Fx(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return Kb($b(Bb(e),n[0]),n[1]-1);if(t===1/0)return Kb($b(Bb(e),n[1]),n[0]);if(t===-1/0)return Xb($b(Bb(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return Qb($b(Zb(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const ev=py({norm_:function(e,t="euclidean",n=null,r=!1){const s=Jb(e=hy(e,"x","norm"),t,n);let o=s.shape;if(r){const t=ap(n,e.shape);o=Wb(s.shape,t)}return Ox(s,o)}});function tv(){return ry}function nv(e,t){return ry.tidy(e,t)}function rv(e){Qg(e).forEach(e=>e.dispose())}function sv(e){return ry.keep(e)}py({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Qd(null!=e&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const n=e[0].shape[0];for(let t=1;t<e.length;++t)Qd(e[t].shape[0]===n,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`)}else t=!0,e=Gx(e,e.shape[0],0).map(e=>Mx(e,[0]));Qd(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);const n=[],r=e;for(let s=0;s<e.length;++s)n.push(ry.tidy(()=>{let e=r[s];if(s>0)for(let t=0;t<s;++t){const r=Ax($b(Ax(n[t],e)),n[t]);e=Bx(e,r)}return Nx(e,ev(e,"euclidean"))}));return t?Lx(n,0):n}}),Vg=function(e){Np().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};const ov=py({tile_:function(e,t){const n=hy(e,"x","tile","string_or_numeric");return Qd(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`),ry.runKernel(jm,{x:n},{reps:t})}}),iv=py({eye_:function(e,t,n,r="float32"){null==t&&(t=e);const s=qy([e,t],r),o=e<=t?e:t;for(let a=0;a<o;++a)s.set(1,a,a);const i=Ox(s.toTensor(),[e,t]);if(null==n)return i;if(1===n.length)return ov(Rx(i,0),[n[0],1,1]);if(2===n.length)return ov(Rx(Rx(i,0),0),[n[0],n[1],1,1]);if(3===n.length)return ov(Rx(Rx(Rx(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}}),av=py({matMul_:function(e,t,n=!1,r=!1){let s=hy(e,"a","matMul"),o=hy(t,"b","matMul");return[s,o]=Yg(s,o),ry.runKernel(qp,{a:s,b:o},{transposeA:n,transposeB:r})}}),uv=py({neg_:function(e){const t=hy(e,"x","neg");return ry.runKernel("Neg",{x:t})}}),lv=py({transpose_:function(e,t){const n=hy(e,"x","transpose");return null==t&&(t=n.shape.map((e,t)=>t).reverse()),Qd(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`),t.forEach(e=>{Qd(e>=0&&e<n.rank,()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+` but got ${t}`)}),n.rank<=1?n.clone():ry.runKernel(qm,{x:n},{perm:t})}});function cv(e,t=!1){return ry.tidy(()=>{Qd(2===e.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);const n=e.shape[0],r=e.shape[1];let s=iv(n),o=Xy(e);const i=Ux([[1]],[1,1]);let a=Xy(i);const u=n>=r?r:n;for(let e=0;e<u;++e){const t=o,u=a,l=s;[a,o,s]=ry.tidy(()=>{const t=Px(o,[e,e],[n-e,1]),u=ev(t),l=Px(o,[e,e],[1,1]),c=Ob(Nb(l,0),Ux([[-1]]),Ux([[1]])),h=Bx(l,Ax(c,u)),d=Nx(t,h);a=1===d.shape[0]?Xy(i):Tx([i,Px(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=uv(Nx(av(c,h),u)),f=Px(o,[e,0],[n-e,r]),m=Ax(p,a),g=lv(a);if(0===e)o=Bx(f,av(m,av(g,f)));else{const t=Bx(f,av(m,av(g,f)));o=Tx([Px(o,[0,0],[e,r]),t],0)}const y=lv(m),x=Px(s,[0,e],[n,s.shape[1]-e]);if(0===e)s=Bx(x,av(av(x,a),y));else{const t=Bx(x,av(av(x,a),y));s=Tx([Px(s,[0,0],[n,e]),t],1)}return[a,o,s]}),rv([t,u,l])}return!t&&n>r&&(s=Px(s,[0,0],[n,r]),o=Px(o,[0,0],[r,r])),[s,o]})}py({qr_:function(e,t=!1){if(Qd(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),2===e.rank)return cv(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce((e,t)=>e*t),r=zx(Ox(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],o=[];return r.forEach(e=>{const[n,r]=cv(e,t);s.push(n),o.push(r)}),[Ox(Lx(s,0),e.shape),Ox(Lx(o,0),e.shape)]}}});var hv=(()=>(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(hv||(hv={})),hv))();const dv=py({mean_:function(e,t=null,n=!1){const r=hy(e,"x","mean");return ry.runKernel(Kf,{x:r},{axis:t,keepDims:n})}}),pv=py({notEqual_:function(e,t){let n=hy(e,"a","notEqual","string_or_numeric"),r=hy(t,"b","notEqual","string_or_numeric");return[n,r]=Yg(n,r),Tb(n.shape,r.shape),ry.runKernel(Jf,{a:n,b:r})}});function fv(e,t="float32"){if("complex64"===t){const t=fv(e,"float32"),n=Wx(e,"float32");return fy(t,n)}const n=wp(tp(e),t);return ry.makeTensor(n,e,t)}const mv=py({computeWeightedLoss_:function(e,t,n=hv.SUM_BY_NONZERO_WEIGHTS){const r=hy(e,"losses","computeWeightedLoss");let s=null;null!=t&&(s=hy(t,"weights","computeWeightedLoss"));const o=null==s?r:Ax(r,s);if(n===hv.NONE)return o;if(n===hv.SUM)return $b(o);if(n===hv.MEAN){if(null==s)return dv(o);{const e=r.size/s.size,t=Nx($b(o),$b(s));return e>1?Nx(t,Fx(e)):t}}if(n===hv.SUM_BY_NONZERO_WEIGHTS){if(null==s)return Nx($b(o),Fx(r.size));{const e=Ax(s,fv(r.shape)),t=Ky($b(pv(e,Fx(0))),"float32");return Nx($b(o),t)}}throw Error(`Unknown reduction: ${n}`)}});py({absoluteDifference_:function(e,t,n,r=hv.SUM_BY_NONZERO_WEIGHTS){const s=hy(e,"labels","absoluteDifference"),o=hy(t,"predictions","absoluteDifference");let i=null;null!=n&&(i=hy(n,"weights","absoluteDifference")),Zd(s.shape,o.shape,"Error in absoluteDifference: ");const a=Bb(Bx(s,o));return mv(a,i,r)}}),py({cosineDistance_:function(e,t,n,r,s=hv.SUM_BY_NONZERO_WEIGHTS){const o=hy(e,"labels","cosineDistance"),i=hy(t,"predictions","cosineDistance");let a=null;null!=r&&(a=hy(r,"weights","cosineDistance")),Zd(o.shape,i.shape,"Error in cosineDistance: ");const u=Fx(1),l=Bx(u,$b(Ax(o,i),n,!0));return mv(l,a,s)}});const gv=py({relu_:function(e){const t=hy(e,"x","relu");return ry.runKernel(dm,{x:t})}});py({hingeLoss_:function(e,t,n,r=hv.SUM_BY_NONZERO_WEIGHTS){let s=hy(e,"labels","hingeLoss");const o=hy(t,"predictions","hingeLoss");let i=null;null!=n&&(i=hy(n,"weights","hingeLoss")),Zd(s.shape,o.shape,"Error in hingeLoss: ");const a=Fx(1);s=Bx(Ax(Fx(2),s),a);const u=gv(Bx(a,Ax(s,o)));return mv(u,i,r)}});const yv=py({minimum_:function(e,t){let n=hy(e,"a","minimum"),r=hy(t,"b","minimum");return[n,r]=Yg(n,r),"bool"===n.dtype&&(n=Ky(n,"int32"),r=Ky(r,"int32")),Tb(n.shape,r.shape),ry.runKernel(Xf,{a:n,b:r})}});py({huberLoss_:function(e,t,n,r=1,s=hv.SUM_BY_NONZERO_WEIGHTS){const o=hy(e,"labels","huberLoss"),i=hy(t,"predictions","huberLoss");let a=null;null!=n&&(a=hy(n,"weights","huberLoss")),Zd(o.shape,i.shape,"Error in huberLoss: ");const u=Fx(r),l=Bb(Bx(i,o)),c=yv(l,u),h=Bx(l,c),d=kx(Ax(Fx(.5),Zb(c)),Ax(u,h));return mv(d,a,s)}});const xv=py({log_:function(e){const t=hy(e,"x","log");return ry.runKernel(Bf,{x:t})}});py({logLoss_:function(e,t,n,r=1e-7,s=hv.SUM_BY_NONZERO_WEIGHTS){const o=hy(e,"labels","logLoss"),i=hy(t,"predictions","logLoss");let a=null;null!=n&&(a=hy(n,"weights","logLoss")),Zd(o.shape,i.shape,"Error in logLoss: ");const u=Fx(1),l=Fx(r),c=uv(Ax(o,xv(kx(i,l)))),h=Ax(Bx(u,o),xv(kx(Bx(u,i),l))),d=Bx(c,h);return mv(d,a,s)}});const bv=py({squaredDifference_:function(e,t){let n=hy(e,"a","squaredDifference"),r=hy(t,"b","squaredDifference");return[n,r]=Yg(n,r),Tb(n.shape,r.shape),ry.runKernel(Mm,{a:n,b:r},{})}});py({meanSquaredError_:function(e,t,n,r=hv.SUM_BY_NONZERO_WEIGHTS){const s=hy(e,"labels","meanSquaredError"),o=hy(t,"predictions","meanSquaredError");let i=null;null!=n&&(i=hy(n,"weights","meanSquaredError")),Zd(s.shape,o.shape,"Error in meanSquaredError: ");const a=bv(s,o);return mv(a,i,r)}});const vv=py({log1p_:function(e){const t=hy(e,"x","log1p");return ry.runKernel(Vf,{x:t})}});function wv(e){return ry.customGrad(e)}py({sigmoidCrossEntropy_:function(e,t,n,r=0,s=hv.SUM_BY_NONZERO_WEIGHTS){let o=hy(e,"multiClassLabels","sigmoidCrossEntropy");const i=hy(t,"logits","sigmoidCrossEntropy");let a=null;if(null!=n&&(a=hy(n,"weights","sigmoidCrossEntropy")),Zd(o.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const e=Fx(r),t=Fx(1),n=Fx(.5);o=kx(Ax(o,Bx(t,e)),Ax(n,e))}const u=function(e,t){const n=hy(e,"labels","sigmoidCrossEntropyWithLogits"),r=hy(t,"logits","sigmoidCrossEntropyWithLogits");Zd(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=gv(r),o=Ax(r,n),i=vv($x(uv(Bb(r))));return kx(Bx(s,o),i)}(o,i);return mv(u,a,s)}});const Cv=py({logSumExp_:function(e,t=null,n=!1){const r=hy(e,"x","logSumExp"),s=ap(t,r.shape),o=Kb(r,s,!0),i=Bx(r,o),a=$x(i),u=$b(a,s),l=xv(u),c=kx(Ox(o,l.shape),l);if(n){const e=Wb(c.shape,s);return Ox(c,e)}return c}});py({softmaxCrossEntropy_:function(e,t,n,r=0,s=hv.SUM_BY_NONZERO_WEIGHTS){let o=hy(e,"onehotLabels","softmaxCrossEntropy");const i=hy(t,"logits","softmaxCrossEntropy");let a=null;if(null!=n&&(a=hy(n,"weights","softmaxCrossEntropy")),Zd(o.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const e=Fx(r),t=Fx(1),n=Fx(o.shape[1]);o=kx(Ax(o,Bx(t,e)),Nx(e,n))}const u=function(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return wv((e,t,r)=>{const s=Cv(t,[n],!0),o=Bx(Ky(t,"float32"),s);r([e,o]);const i=uv(Ax(o,e));return{value:$b(i,[n]),gradFunc:(e,t)=>{const[r,s]=t,o=Wb(e.shape,[n]);return[Ax(Ox(e,o),Bx(Ky(r,"float32"),$x(s))),Ax(Ox(e,o),Bx($x(s),Ky(r,"float32")))]}}})(e,t)}(o,i);return mv(u,a,s)}});const _v=py({sparseFillEmptyRows_:function(e,t,n,r){const s=hy(e,"indices","sparseFillEmptyRows"),o=hy(t,"values","sparseFillEmptyRows"),i=hy(n,"denseShape","sparseFillEmptyRows"),a=hy(r,"defaultValue","sparseFillEmptyRows",o.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==o.rank)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==a.rank)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const u=ry.runKernel(Am,{indices:s,values:o,denseShape:i,defaultValue:a});return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}}),kv=py({sparseReshape_:function(e,t,n){const r=hy(e,"inputIndices","sparseReshape"),s=hy(t,"inputShape","sparseReshape"),o=hy(n,"newShape","sparseReshape");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==o.rank)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const i=ry.runKernel(Om,{inputIndices:r,inputShape:s,newShape:o});return{outputIndices:i[0],outputShape:i[1]}}}),Ev=py({sparseSegmentMean_:function(e,t,n){const r=hy(e,"data","sparseSegmentMean"),s=hy(t,"indices","sparseSegmentMean"),o=hy(n,"segmentIds","sparseSegmentMean");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==o.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${o.shape}`);return ry.runKernel(Fm,{data:r,indices:s,segmentIds:o})}}),Sv=py({sparseSegmentSum_:function(e,t,n){const r=hy(e,"data","sparseSegmentSum"),s=hy(t,"indices","sparseSegmentSum"),o=hy(n,"segmentIds","sparseSegmentSum");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==o.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${o.shape}`);return ry.runKernel(Dm,{data:r,indices:s,segmentIds:o})}}),Tv=py({stringNGrams_:function(e,t,n,r,s,o,i,a){const u=hy(e,"data","stringNGrams","string");if("string"!==u.dtype)throw new Error("Data must be of datatype string");if(1!==u.shape.length)throw new Error(`Data must be a vector, saw: ${u.shape}`);const l=hy(t,"dataSplits","stringNGrams");if("int32"!==l.dtype)throw new Error("Data splits must be of datatype int32");const c=ry.runKernel(Bm,{data:u,dataSplits:l},{separator:n,nGramWidths:r,leftPad:s,rightPad:o,padWidth:i,preserveShortSequences:a});return{nGrams:c[0],nGramsSplits:c[1]}}}),Iv=py({stringSplit_:function(e,t,n=!0){const r=hy(e,"input","stringSplit","string"),s=hy(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const o=ry.runKernel(Vm,{input:r,delimiter:s},{skipEmpty:n});return{indices:o[0],values:o[1],shape:o[2]}}}),Nv=py({stringToHashBucketFast_:function(e,t){const n=hy(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");return ry.runKernel(Um,{input:n},r)}}),$v={flipLeftRight:sb,resizeNearestNeighbor:_b,resizeBilinear:Cb,rotateWithOffset:ob,cropAndResize:rb,nonMaxSuppression:ab,nonMaxSuppressionAsync:function(e,t,n){return yb.apply(this,arguments)},nonMaxSuppressionWithScore:xb,nonMaxSuppressionWithScoreAsync:function(e,t,n){return bb.apply(this,arguments)},nonMaxSuppressionPadded:vb,nonMaxSuppressionPaddedAsync:function(e,t,n){return wb.apply(this,arguments)},threshold:Db,transform:Pb},Rv={sparseFillEmptyRows:_v,sparseReshape:kv,sparseSegmentMean:Ev,sparseSegmentSum:Sv},Av={stringNGrams:Tv,stringSplit:Iv,stringToHashBucketFast:Nv};function Ov(e,t){const n=e[0].length;e.forEach((e,t)=>{Qd(e.length===n,()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`)}),Qd(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=e[0];e.forEach((e,s)=>{for(let o=0;o<n;o++)Qd(o===t||e[o]===r[o],()=>`Error in concat${n}D: Shape of tensors[${s}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function Fv(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}function Dv(e,t,n,r,s="NHWC",o){return Lv(e,[...t,e[3]],n,o,r,null,null,qv(s))}function Pv(e,t,n,r,s,o,i="channelsLast"){const[a,u]=Uv(t);let l;if("channelsLast"===i)l=[a,u,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);l=[a,u,e[1],e[1]]}return Lv(e,l,n,r,s,o,!1,i)}function Mv(e,t,n,r,s,o,i="NDHWC"){const[a,u,l]=zv(t);let c,h;if("NDHWC"===i)h="channelsLast",c=[a,u,l,e[4],e[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);h="channelsFirst",c=[a,u,l,e[1],e[1]]}return Bv(e,c,n,r,s,!1,h,o)}function Lv(e,t,n,r,s,o,i=!1,a="channelsLast"){let[u,l,c,h]=[-1,-1,-1,-1];if("channelsLast"===a)[u,l,c,h]=e;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[u,h,l,c]=e}const[d,p,,f]=t,[m,g]=Uv(n),[y,x]=Uv(r),b=Wv(d,y),v=Wv(p,x),{padInfo:w,outHeight:C,outWidth:_}=function(e,t,n,r,s,o,i,a,u){let l,c,h;if("number"==typeof e){l={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const s=function(e,t,n,r,s){null==r&&(r=Vv(e,t,n));const o=e[1];return[jv((e[0]-t+2*r)/n+1,s),jv((o-t+2*r)/n+1,s)]}([t,n],o,r,e,a);c=s[0],h=s[1]}else if("same"===e){c=Math.ceil(t/r),h=Math.ceil(n/s);const e=Math.max(0,(c-1)*r+o-t),a=Math.max(0,(h-1)*s+i-n),u=Math.floor(e/2),d=e-u,p=Math.floor(a/2);l={top:u,bottom:d,left:p,right:a-p,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-o+1)/r),h=Math.ceil((n-i+1)/s);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{const d="channelsLast"===u?e[1][0]:e[2][0],p="channelsLast"===u?e[1][1]:e[2][1],f="channelsLast"===u?e[2][0]:e[3][0],m="channelsLast"===u?e[2][1]:e[3][1];l={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=jv((t-o+d+p)/r+1,a),h=jv((n-i+f+m)/s+1,a)}}return{padInfo:l,outHeight:c,outWidth:h}}(s,l,c,m,g,b,v,o,a),k=i?f*h:f;let E;return"channelsFirst"===a?E=[u,k,C,_]:"channelsLast"===a&&(E=[u,C,_,k]),{batchSize:u,dataFormat:a,inHeight:l,inWidth:c,inChannels:h,outHeight:C,outWidth:_,outChannels:k,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:b,effectiveFilterWidth:v,dilationHeight:y,dilationWidth:x,inShape:e,outShape:E,filterShape:t}}function Bv(e,t,n,r,s,o=!1,i="channelsLast",a){let[u,l,c,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[u,l,c,h,d]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[u,d,l,c,h]=e}const[p,f,m,,g]=t,[y,x,b]=zv(n),[v,w,C]=zv(r),_=Wv(p,v),k=Wv(f,w),E=Wv(m,C),{padInfo:S,outDepth:T,outHeight:I,outWidth:N}=function(e,t,n,r,s,o,i,a,u,l,c){let h,d,p,f;if("number"==typeof e){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const o=function(e,t,n,r,s,o){null==s&&(s=Vv(e,t,r));const i=e[1],a=e[2];return[jv((e[0]-t+2*s)/r+1,o),jv((i-t+2*s)/r+1,o),jv((a-t+2*s)/r+1,o),1]}([t,n,r,1],a,0,s,e,c);d=o[0],p=o[1],f=o[2]}else if("same"===e){d=Math.ceil(t/s),p=Math.ceil(n/o),f=Math.ceil(r/i);const e=(d-1)*s+a-t,c=(p-1)*o+u-n,m=(f-1)*i+l-r,g=Math.floor(e/2),y=e-g,x=Math.floor(c/2),b=c-x,v=Math.floor(m/2);h={top:x,bottom:b,left:v,right:m-v,front:g,back:y,type:"SAME"}}else{if("valid"!==e)throw Error(`Unknown padding parameter: ${e}`);h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((t-a+1)/s),p=Math.ceil((n-u+1)/o),f=Math.ceil((r-l+1)/i)}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(s,l,c,h,y,x,b,_,k,E,a),$=o?g*d:g;let R;return"channelsFirst"===i?R=[u,$,T,I,N]:"channelsLast"===i&&(R=[u,T,I,N,$]),{batchSize:u,dataFormat:i,inDepth:l,inHeight:c,inWidth:h,inChannels:d,outDepth:T,outHeight:I,outWidth:N,outChannels:$,padInfo:S,strideDepth:y,strideHeight:x,strideWidth:b,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:_,effectiveFilterHeight:k,effectiveFilterWidth:E,dilationDepth:v,dilationHeight:w,dilationWidth:C,inShape:e,outShape:R,filterShape:t}}function Vv(e,t,n,r=1){const s=Wv(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)}function Uv(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function zv(e){return"number"==typeof e?[e,e,e]:e}function Wv(e,t){return t<=1?e:e+(e-1)*(t-1)}function jv(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Hv(e){const[t,n,r]=Uv(e);return 1===t&&1===n&&1===r}function Gv(e,t){return Hv(e)||Hv(t)}function qv(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}const Kv=py({elu_:function(e){const t=hy(e,"x","elu");return ry.runKernel("Elu",{x:t})}}),Xv=py({leakyRelu_:function(e,t=.2){const n=hy(e,"x","leakyRelu");return ry.runKernel(Df,{x:n},{alpha:t})}}),Yv=py({prelu_:function(e,t){const n=hy(e,"x","prelu"),r=hy(t,"alpha","prelu");return ry.runKernel(am,{x:n,alpha:r})}}),Qv=py({relu6_:function(e){const t=hy(e,"x","relu6");return ry.runKernel(gm,{x:t})}}),Zv=py({step_:function(e,t=0){const n=hy(e,"x","step");return ry.runKernel(Qm,{x:n},{alpha:t})}});function Jv(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return Ax(e,Zv(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function ew(e,t){let n=t;const r=Sb(e.shape,t.shape);return r.length>0&&(n=$b(n,r)),Ox(n,e.shape)}function tw(e,t,n,r){if("linear"===t)return e;if("relu"===t)return gv(e);if("elu"===t)return Kv(e);if("relu6"===t)return Qv(e);if("prelu"===t)return Yv(e,n);if("leakyrelu"===t)return Xv(e,r);if("sigmoid"===t)return Dx(e);throw new Error(`Unknown fused activation ${t}.`)}const nw=(e,t)=>!(e>0)||"linear"===t,rw=30;function sw(e){return e<=rw?e:yp(e,Math.floor(Math.sqrt(e)))}function ow(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function iw(e,t,n,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)s=s.concat([e[r+1]/t[r],t[r]]);s=s.concat(e.slice(n+1))}return s}function aw(e,t,n=!0){const r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{const n=[],s=[];for(let r=1;r<e;++r)r>=2*t+1||r%2==1?s.push(r):n.push(r);r.push(...n),r.push(0),r.push(...s)}return r}function uw(e,t,n,r=!0){const s=[];s.push(r?e[0]/n:e[0]*n);for(let o=1;o<e.length;++o)s.push(o<=t.length?r?t[o-1]*e[o]:e[o]/t[o-1]:e[o]);return s}function lw(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function cw(e,t,n){const r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}function hw(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===tp(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const s=t.shape,o=s[s.length-1];let i=1;for(let h=0;h<s.length-1;++h)i*=s[h];const a=e.shape,u=s.slice();u.pop();let l=1;for(let h=o;h<n;++h)l*=a[h],u.push(a[h]);const c=[...xp(e.shape).map(e=>e/l),1].slice(0,o);return[u,i,l,c]}function dw(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(o+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(o+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(o+" update.rank != "+(s+e.length-r));for(let i=0;i<s;++i)if(n.shape[i]!==t.shape[i])throw new Error(o+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-s;++i)if(n.shape[i+s]!==e[i+r])throw new Error(o+` updates.shape[${i+s}] (${n.shape[i+s]}) != shape[${i+s}] (${e[i+s]})`)}function pw(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}dw(n,t,e)}function fw(e,t,n){const r=t.shape.length,s=r>1?t.shape[r-1]:1,o=n.length;let i=1;for(let u=s;u<o;++u)i*=n[u];const a=s<1?1:s;return{sliceRank:s,numUpdates:tp(t.shape)/a,sliceSize:i,strides:[...xp(n.slice(0,s)),1],outputSize:tp(n)}}const mw=1.7580993408473768,gw=1.0507009873554805,yw=.3275911,xw=.254829592,bw=-.284496736,vw=1.421413741,ww=-1.453152027,Cw=1.061405429;function _w(...e){Np().getBool("IS_TEST")||console.warn(...e)}function kw(...e){Np().getBool("IS_TEST")||console.log(...e)}function Ew(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function Sw(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function Tw(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function Iw(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function Nw(e,t){return{real:e[2*t],imag:e[2*t+1]}}function $w(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function Rw(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){const o=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(o),r[s]=Math.sin(o)}return{real:n,imag:r}}function Aw(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}const Ow=/->/g;function Fw(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(Ow,"").length)/"->".length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("->").');const[r,s]=e.split("->");Qd(-1===r.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');const o=r.split(","),i=o.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let h=0;h<s.length;++h){const e=s[h];if(!o.some(t=>-1!==t.indexOf(e)))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===a.indexOf(e)&&a.push(e)}for(let h=0;h<r.length;++h){const e=r[h];-1===a.indexOf(e)&&","!==e&&a.push(e)}const u=new Array(o.length);for(let h=0;h<i;++h){if(new Set(o[h].split("")).size!==o[h].length)throw new Error(`Found duplicate axes in input component ${o[h]}. Support for duplicate axes in input is not implemented yet.`);u[h]=[];for(let e=0;e<o[h].length;++e)u[h].push(a.indexOf(o[h][e]))}const l=a.length,c=[];for(let h=s.length;h<l;++h)c.push(h);return{allDims:a,summedDims:c,idDims:u}}function Dw(e,t){let n=new Array(e);n.fill(-1);for(let s=0;s<t.length;++s)n[t[s]]=s;const r=[];for(let s=0;s<e;++s)-1===n[s]&&r.push(s);return n=n.filter(e=>-1!==e),{permutationIndices:n,expandDims:r}}function Pw(e,t,n){const r=new Array(e);for(let s=0;s<n.length;++s){const e=n[s].shape;for(let n=0;n<t[s].length;++n)void 0===r[t[s][n]]?r[t[s][n]]=e[n]:Qd(r[t[s][n]]===e[n],()=>`Expected dimension ${r[t[s][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`)}}function Mw(e,t){const n=e,r=[];let s=0;0===e.length&&n.push(-1),s=e.length+1;for(let i=0;i<s;++i)r.push([]);const o=[];for(let i=0;i<n.length;++i){const e=Bw(t,n[i]);for(const t of e)-1===o.indexOf(t)&&(r[i].push(t),o.push(t))}return{path:n,steps:r}}function Lw(e){return e.every((e,t)=>e===t)}function Bw(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function Vw(e,t,n=0){let r=[];if("number"==typeof t)Qd(e.shape[n]%t==0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{Qd(t.reduce((e,t)=>(-1===t&&(e+=1),e),0)<=1,()=>"There should be only one negative value in split array.");const s=t.indexOf(-1);if(-1!==s){const r=t.reduce((e,t)=>t>0?e+t:e);t[s]=e.shape[n]-r}Qd(e.shape[n]===t.reduce((e,t)=>e+t),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function Uw(e,t){let n,r=!1;for(e<=rw?(n=e,r=!0):n=yp(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=yp(e,n+1);return n}function zw(e,t,n){const r=[],s=e.length;for(let o=0;o<s;o++)r.push(o!==t?e[o]:n);return r}function Ww(e,t,n,r){const s=t.shape.length,o=e.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${o}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let h=0;h<r;++h)if(e.shape[h]!==t.shape[h])throw new Error(`x.shape[${h}]: ${e.shape[h]} should be equal to indices.shape[${h}]: ${t.shape[h]}.`);const i=e.shape[n],a=[];let u=1,l=1,c=1;for(let h=0;h<r;++h)a.push(e.shape[h]),u*=e.shape[h];for(let h=r;h<n;h++)a.push(e.shape[h]),l*=e.shape[h];for(let h=r;h<s;h++)a.push(t.shape[h]);for(let h=n+1;h<o;h++)a.push(e.shape[h]),c*=e.shape[h];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:i,outputShape:a}}function jw(e){try{return e.map(e=>Ig(e))}catch(CP){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${CP}`)}}function Hw(e){return e.map(e=>Tg(e))}function Gw(e,t){const n=[];for(let o=0;o<t.length;o++)t[o]&&n.push(o);const r=qy(e,"int32"),s=qy([n.length,e.length],"int32");for(let o=0;o<n.length;o++){const t=r.indexToLoc(n[o]);s.values.set(t,o*e.length)}return s.toTensor()}var qw,Kw=(()=>(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(Kw||(Kw={})),Kw))();!function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(qw||(qw={}));const Xw={};function Yw(e){return Xw[e]}function Qw(e,t,n,r,s){const o=t.inputParams[e];if(o&&void 0!==o.inputIndexStart){const e=o.inputIndexStart,i=0===o.inputIndexEnd?void 0:void 0===o.inputIndexEnd?e+1:o.inputIndexEnd;if("tensor"===o.type)return Zw(t.inputNames[o.inputIndexStart],n,r,s);if("tensors"===o.type)return t.inputNames.slice(e,i).map(e=>Zw(e,n,r,s));const a=Zw(t.inputNames.slice(e)[0],n,r,s),u=a.dataSync();return"number"===o.type?u[0]:vp(a.shape,u)}const i=t.attrParams[e];return i&&i.value}function Zw(e,t,n,r){const[s,o]=tC(e);if(null!=r){const e=r.getHashTableHandleByName(s);if(null!=e)return e}const i=n.currentContextIds.find(e=>!!t[eC(s,e)]);return void 0!==i?t[eC(s,i)][o]:void 0}function Jw(e,t){const[n,r,s]=tC(e);return[eC(n,t&&t.currentContextId),r,s]}function eC(e,t){return t?`${e}-${t}`:e}function tC(e){const t=e.split(":");if(1===t.length)return[e,0,void 0];const n=3===t.length?t[1]:void 0;return[t[0],Number(t[t.length-1]),n]}function nC(e,t,n){let r=Qw("pad",e,t,n);if("explicit"===r){r=Qw("explicitPaddings",e,t,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)s[e][0]=r[2*e],s[e][1]=r[2*e+1];return s}return r}function rC(e){return e.kept?e:Xy(e)}const sC=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],oC=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],iC=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],aC=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],uC=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],lC=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],cC=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],hC=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],dC=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],pC=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],fC=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],mC=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],gC=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],yC=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],xC=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],bC=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],vC=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],wC=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],CC=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}];class _C{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[i,a,u,l,c,h,d,p,f,m,g,y,x,b,v,w,C,_,k].map(e=>e.json));this.opMappers=e.reduce((e,t)=>(e[t.tfOpName]=t,e),{})}transformGraph(e,t={}){const n=[],r=[],s=[],o=e.node.reduce((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?n.push(e[t.name]):"Const"===t.op?r.push(e[t.name]):null!=t.input&&0!==t.input.length||s.push(e[t.name]),e),{});let i=[];const a=[];let u={},l={};null!=t&&(u=this.mapSignatureEntries(t.inputs),l=this.mapSignatureEntries(t.outputs));const c=Object.keys(o);c.forEach(e=>{const t=o[e];t.inputNames.forEach((e,n)=>{const[r,,s]=Jw(e),i=o[r];if(null!=i.outputs){const e=i.outputs.indexOf(s);-1!==e&&(t.inputNames[n]=`${r}:${e}`)}t.inputs.push(i),i.children.push(t)})}),0===Object.keys(l).length?c.forEach(e=>{const t=o[e];0===t.children.length&&a.push(t)}):Object.keys(l).forEach(e=>{const[t]=Jw(e),n=o[t];null!=n&&(n.signatureKey=l[e],a.push(n))}),Object.keys(u).length>0?Object.keys(u).forEach(e=>{const[t]=Jw(e),n=o[t];n&&(n.signatureKey=u[e],i.push(n))}):i=n;let h={};null!=e.library&&null!=e.library.function&&(h=e.library.function.reduce((e,t)=>(e[t.signature.name]=this.mapFunction(t),e),{}));const d={nodes:o,inputs:i,outputs:a,weights:r,placeholders:n,signature:t,functions:h};return s.length>0&&(d.initNodes=s),d}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){const t=Yw(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(e=>e.startsWith("^")?e.substr(1):e),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce((t,n)=>{const r=n.type;let s;switch(n.type){case"string":s=EC(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=EC(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":s=DC(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=DC(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":s=TC(e.attr,n.tfName,n.defaultValue||0),void 0===s&&n.tfDeprecatedName&&(s=TC(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":s=FC(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=FC(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":s=SC(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=SC(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":s=MC(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=MC(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":s=OC(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=OC(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":s=PC(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=PC(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":s=$C(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=$C(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":s=RC(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=RC(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":s=NC(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=NC(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:s,type:r},t},{})),n}mapFunction(e){const t=e.nodeDef,n=[];let r={};null!=t&&(r=t.reduce((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e),{}));const s=[],o=[];e.signature.inputArg.forEach(e=>{const[t]=Jw(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:IC(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,s.push(n),r[t]=n}),Object.keys(r).forEach(e=>{const t=r[e];t.inputNames.forEach((e,n)=>{const[s,,o]=Jw(e),i=r[s];if(null!=i.outputs){const e=i.outputs.indexOf(o);-1!==e&&(t.inputNames[n]=`${s}:${e}`)}t.inputs.push(i),i.children.push(t)})});const i=e.ret;e.signature.outputArg.forEach(e=>{const[t,n]=Jw(i[e.name]),s=r[t];null!=s&&(s.defaultOutput=n,o.push(s))});const a=this.mapArgsToSignature(e);return{nodes:r,inputs:s,outputs:o,weights:n,placeholders:[],signature:a}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function kC(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=Np().global;if(void 0!==t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function EC(e,t,n,r=!1){const s=e[t];return null!=s?kC(s.s,r):n}function SC(e,t,n){const r=e[t];return r?r.b:n}function TC(e,t,n){const r=e[t]||{},s=null!=r.i?r.i:null!=r.f?r.f:n;return"number"==typeof s?s:parseInt(s,10)}function IC(e){switch("string"==typeof e&&(e=Kw[e]),e){case Kw.DT_FLOAT:return"float32";case Kw.DT_INT32:case Kw.DT_INT64:case Kw.DT_INT8:case Kw.DT_UINT8:return"int32";case Kw.DT_BOOL:return"bool";case Kw.DT_DOUBLE:return"float32";case Kw.DT_STRING:return"string";default:return null}}function NC(e,t,n){const r=e[t];return r&&r.func?r.func.name:n}function $C(e,t,n){const r=e[t];return r&&r.type?IC(r.type):n}function RC(e,t,n){const r=e[t];return r&&r.list&&r.list.type?r.list.type.map(e=>IC(e)):n}function AC(e){if(!e.unknownRank)return null!=e.dim?e.dim.map(e=>"number"==typeof e.size?e.size:parseInt(e.size,10)):[]}function OC(e,t,n){const r=e[t];return r&&r.shape?AC(r.shape):n}function FC(e,t,n){const r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(e=>"number"==typeof e?e:parseInt(e,10)):n}function DC(e,t,n,r=!1){const s=e[t];return s&&s.list&&s.list.s?s.list.s.map(e=>kC(e,r)):n}function PC(e,t,n){const r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map(e=>AC(e)):n}function MC(e,t,n){const r=e[t];return r&&r.list&&r.list.b?r.list.b:n}class LC{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(e=>this.getInput(e)),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce((e,t)=>(e[t]=this.getAttr(t),e),{}))}getInput(e){return Zw(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return Zw(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return TC(this.node.rawAttrs,e,t);if(null!=n.s)return EC(this.node.rawAttrs,e,t);if(null!=n.b)return SC(this.node.rawAttrs,e,t);if(null!=n.shape)return OC(this.node.rawAttrs,e,t);if(null!=n.type)return $C(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return FC(this.node.rawAttrs,e,t);if(null!=n.list.s)return DC(this.node.rawAttrs,e,t);if(null!=n.list.shape)return PC(this.node.rawAttrs,e,t);if(null!=n.list.b)return MC(this.node.rawAttrs,e,t);if(null!=n.list.type)return RC(this.node.rawAttrs,e,t)}return t}}const BC=py({addN_:function(e){Qd(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),Qd(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);const t=e.map((e,t)=>hy(e,`tensors${t}`,"addN")),n=t[0];return t.forEach(e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(e=>{if(!np(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),ry.runKernel(Mp,t)}}),VC=py({mod_:function(e,t){let n=hy(e,"a","mod"),r=hy(t,"b","mod");return[n,r]=Yg(n,r),ry.runKernel("Mod",{a:n,b:r})}}),UC=py({equal_:function(e,t){let n=hy(e,"a","equal","string_or_numeric"),r=hy(t,"b","equal","string_or_numeric");return[n,r]=Yg(n,r),Tb(n.shape,r.shape),ry.runKernel(xf,{a:n,b:r})}}),zC=py({divNoNan_:function(e,t){let n=hy(e,"a","div"),r=hy(t,"b","div");[n,r]=Yg(n,r);const s=Nx(n,r),o=qx(s),i=UC(r,o);return Ob(i,o,s)}}),WC=py({maximum_:function(e,t){let n=hy(e,"a","maximum"),r=hy(t,"b","maximum");return[n,r]=Yg(n,r),"bool"===n.dtype&&(n=Ky(n,"int32"),r=Ky(r,"int32")),Tb(n.shape,r.shape),ry.runKernel(jf,{a:n,b:r})}}),jC=py({acos_:function(e){const t=hy(e,"x","acos");return ry.runKernel(Fp,{x:t})}}),HC=py({acosh_:function(e){const t=hy(e,"x","acosh");return ry.runKernel(Dp,{x:t})}}),GC=py({asin_:function(e){const t=hy(e,"x","asin");return ry.runKernel(Vp,{x:t})}}),qC=py({asinh_:function(e){const t=hy(e,"x","asinh");return ry.runKernel(Up,{x:t})}}),KC=py({atan_:function(e){const t=hy(e,"x","atan");return ry.runKernel(zp,{x:t})}}),XC=py({atan2_:function(e,t){let n=hy(e,"a","atan2"),r=hy(t,"b","atan2");return[n,r]=Yg(n,r),ry.runKernel(jp,{a:n,b:r})}}),YC=py({atanh_:function(e){const t=hy(e,"x","atanh");return ry.runKernel(Wp,{x:t})}}),QC=py({ceil_:function(e){const t=hy(e,"x","ceil");return ry.runKernel(Qp,{x:t})}}),ZC=py({cos_:function(e){const t=hy(e,"x","cos");return ry.runKernel("Cos",{x:t})}}),JC=py({cosh_:function(e){const t=hy(e,"x","cosh");return ry.runKernel(af,{x:t})}}),e_=py({erf_:function(e){let t=hy(e,"x","erf");return Qd("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=Ky(t,"float32")),ry.runKernel("Erf",{x:t})}}),t_=py({expm1_:function(e){const t=hy(e,"x","expm1");return ry.runKernel(wf,{x:t})}}),n_=py({floor_:function(e){const t=hy(e,"x","floor");return ry.runKernel(kf,{x:t})}}),r_=py({reciprocal_:function(e){const t=hy(e,"x","reciprocal");return ry.runKernel(hm,{x:t})}}),s_=py({selu_:function(e){const t=hy(e,"x","selu");return ry.runKernel(Cm,{x:t})}}),o_=py({sin_:function(e){const t=hy(e,"x","sin");return ry.runKernel("Sin",{x:t})}}),i_=py({sign_:function(e){const t=hy(e,"x","sign");return ry.runKernel(Em,{x:t})}}),a_=py({sinh_:function(e){const t=hy(e,"x","sinh");return ry.runKernel(km,{x:t})}}),u_=py({softplus_:function(e){const t=hy(e,"x","softplus");return ry.runKernel(Tm,{x:t})}}),l_=py({tanh_:function(e){const t=hy(e,"x","tanh");return ry.runKernel(Wm,{x:t})}}),c_=py({tan_:function(e){const t=hy(e,"x","tan");return ry.runKernel("Tan",{x:t})}}),h_=py({rsqrt_:function(e){const t=hy(e,"x","rsqrt");return ry.runKernel(bm,{x:t})}}),d_=py({prod_:function(e,t=null,n=!1){let r=hy(e,"x","prod");return"bool"===r.dtype&&(r=Ky(r,"int32")),ry.runKernel(um,{x:r},{axis:t,keepDims:n})}}),p_=py({isNaN_:function(e){const t=hy(e,"x","isNaN");return ry.runKernel(Ff,{x:t})}});function f_(e,t,n=""){if("number"!=typeof e&&"number"!=typeof t){Qd(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let r=0;r<e.length;r++){const s=e[r],o=t[r];Qd(s<0||o<0||s===o,()=>n+` Shapes ${e} and ${t} must match`)}}}function m_(e){return"number"!=typeof e&&!e.some(e=>e<0)}function g_(e,t,n){let r=y_(e,n);const s=!m_(r);if(s&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach(e=>{r=y_(e.shape,r)}),!m_(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function y_(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let r=0;r<e.length;++r){const s=e[r],o=t[r];if(s>=0&&o>=0&&s!==o)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=s>=0?s:o}return n}class x_{constructor(e,t,n,r,s,o,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=s,this.dynamicSize=o,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=Fx(0),sv(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(e=>this.read(e))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),f_(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,sv(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((e,n)=>this.write(e,t[n]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return gy([],[0].concat(this.elementShape));const n=this.readMany(e);return f_(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Lx(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return gy([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const n=this.readMany(t);return f_(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Tx(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,zx(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const r=e.map(e=>(n+=e,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const s=0===n?0:t.size/n,o=[];nv(()=>{t=Ox(t,[1,n,s]);for(let n=0;n<e.length;++n)o[n]=Ox(Px(t,[0,0===n?0:r[n-1],0],[1,e[n],s]),this.elementShape);return o});const i=[];for(let a=0;a<e.length;a++)i[a]=a;this.writeMany(i,o)}}class b_{constructor(e,t,n,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach(e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);f_(t,e.shape,"TensorList shape mismatch: "),sv(e)}),this.idTensor=Fx(0),this.maxNumElements=r,sv(this.idTensor)}get id(){return this.idTensor.id}copy(){return new b_([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.id)||t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);f_(e,this.elementShape,"TensorList shape mismatch: ");const r=g_(this.elementShape,this.tensors,e);return nv(()=>{const e=this.tensors.map(e=>Ox(e,r));return Lx(e,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=g_(this.elementShape,this.tensors,e),r=this.tensors.pop();return f_(r.shape,e,"TensorList shape mismatch: "),Ox(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(f_(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");sv(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);f_(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=g_(this.elementShape,this.tensors,t);return Ox(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);f_(this.elementShape,t.shape,"TensorList shape mismatch: "),sv(t),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);f_(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=g_(this.elementShape,this.tensors,n);return 0===e.length?gy([],[0].concat(r)):nv(()=>{const t=e.map(e=>Ox(this.tensors[e],r));return Lx(t,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);f_(this.elementShape,t,"TensorList shape mismatch: ");const n=g_(this.elementShape,this.tensors,t);return 0===this.size()?gy([],[0].concat(n)):nv(()=>{const e=this.tensors.map(e=>Ox(e,n));return Tx(e,0)})}}const v_=function(){var e=jd(function*(e,t,n){switch(e.op){case"If":case"StatelessIf":{const r=Qw("thenBranch",e,t,n),s=Qw("elseBranch",e,t,n),o=Qw("cond",e,t,n),i=Qw("args",e,t,n);return(yield o.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=Qw("body",e,t,n),s=Qw("cond",e,t,n),o=Qw("args",e,t,n),i=yield n.functionMap[s].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap),a=o.map(e=>e.id);let u=yield i[0].data();i.forEach(e=>{e.kept||-1!==a.indexOf(e.id)||e.dispose()});let l=o;for(;u[0];){const e=l;l=yield n.functionMap[r].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);const t=l.map(e=>e.id);e.forEach(e=>{e.kept||-1!==a.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()});const o=yield n.functionMap[s].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);u=yield o[0].data(),o.forEach(e=>{e.kept||-1!==a.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()})}return l}case"LoopCond":return[rC(Qw("pred",e,t,n))];case"Switch":{const r=Qw("pred",e,t,n);let s=Qw("data",e,t,n);return s.kept||(s=rC(s)),(yield r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=e.inputNames.find(e=>void 0!==Zw(e,t,n));return r?[rC(Zw(r,t,n))]:void 0}case"Enter":{const r=Qw("frameName",e,t,n),s=Qw("tensor",e,t,n);return n.enterFrame(r),[rC(s)]}case"Exit":{const r=Qw("tensor",e,t,n);return n.exitFrame(),[rC(r)]}case"NextIteration":{const r=Qw("tensor",e,t,n);return n.nextIteration(),[rC(r)]}case"TensorArrayV3":{const r=Qw("size",e,t,n),s=Qw("dtype",e,t,n),o=Qw("elementShape",e,t,n),i=Qw("dynamicSize",e,t,n),a=Qw("clearAfterRead",e,t,n),u=Qw("identicalElementShapes",e,t,n),l=Qw("name",e,t,n),c=new x_(l,s,r,o,u,i,a);return n.addTensorArray(c),[c.idTensor,Fx(1)]}case"TensorArrayWriteV3":{const r=Qw("tensorArrayId",e,t,n),s=Qw("index",e,t,n),o=Qw("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(s,o),[i.idTensor]}case"TensorArrayReadV3":{const r=Qw("tensorArrayId",e,t,n),s=Qw("index",e,t,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=Qw("tensorArrayId",e,t,n),s=Qw("indices",e,t,n),o=Qw("dtype",e,t,n);return[n.getTensorArray(r.id).gather(s,o)]}case"TensorArrayScatterV3":{const r=Qw("tensorArrayId",e,t,n),s=Qw("indices",e,t,n),o=Qw("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(s,o),[i.idTensor]}case"TensorArrayConcatV3":{const r=Qw("tensorArrayId",e,t,n),s=n.getTensorArray(r.id),o=Qw("dtype",e,t,n);return[s.concat(o)]}case"TensorArraySplitV3":{const r=Qw("tensorArrayId",e,t,n),s=Qw("tensor",e,t,n),o=Qw("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(o,s),[i.idTensor]}case"TensorArraySizeV3":{const r=Qw("tensorArrayId",e,t,n);return[Fx(n.getTensorArray(r.id).size(),"int32")]}case"TensorArrayCloseV3":{const r=Qw("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=Qw("tensorListId",e,t,n),s=Qw("index",e,t,n),o=Qw("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(s,o),[i.idTensor]}case"TensorListGetItem":{const r=Qw("tensorListId",e,t,n),s=Qw("index",e,t,n),o=Qw("elementShape",e,t,n),i=Qw("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(s,o,i)]}case"TensorListScatterV2":case"TensorListScatter":{const r=Qw("indices",e,t,n),s=function(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const s=Math.max(...t);if(null!=r&&-1!==r&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const o=new b_([],n,e.dtype,r),i=zx(e,0);return t.forEach((e,t)=>{o.setItem(e,i[t])}),o}(Qw("tensor",e,t,n),r,Qw("elementShape",e,t,n),Qw("numElements",e,t,n));return n.addTensorList(s),[s.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=Qw("elementShape",e,t,n),s=Qw("elementDType",e,t,n);let o;o="TensorListReserve"===e.op?"numElements":"maxNumElements";const i=function(e,t,n){return new b_([],e,t,n)}(r,s,Qw(o,e,t,n));return n.addTensorList(i),[i.idTensor]}case"TensorListGather":{const r=Qw("tensorListId",e,t,n),s=Qw("indices",e,t,n),o=Qw("elementShape",e,t,n),i=Qw("elementDType",e,t,n);return[n.getTensorList(r.id).gather(s,i,o)]}case"TensorListStack":{const r=Qw("tensorListId",e,t,n),s=Qw("elementShape",e,t,n),o=Qw("elementDType",e,t,n),i=Qw("numElements",e,t,n);return[n.getTensorList(r.id).stack(s,o,i)]}case"TensorListFromTensor":{const r=function(e,t,n){const r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);f_(e.shape.slice(1),t,"TensorList shape mismatch: ");const s=zx(e);return new b_(s,t,r)}(Qw("tensor",e,t,n),Qw("elementShape",e,t,n),Qw("elementDType",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":{const r=Qw("tensorListId",e,t,n),s=n.getTensorList(r.id),o=Qw("dtype",e,t,n),i=Qw("elementShape",e,t,n);return[s.concat(o,i)]}case"TensorListPushBack":{const r=Qw("tensorListId",e,t,n),s=Qw("tensor",e,t,n),o=n.getTensorList(r.id);return o.pushBack(s),[o.idTensor]}case"TensorListPopBack":{const r=Qw("tensorListId",e,t,n),s=Qw("elementShape",e,t,n),o=Qw("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(s,o)]}case"TensorListSplit":{const r=Qw("tensor",e,t,n),s=Qw("elementShape",e,t,n),o=function(e,t,n){let r=0;const s=t.map(e=>(r+=e,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);const o=y_(e.shape.slice(1),n),i=0===r?0:e.size/r,a=nv(()=>{const n=[];e=Ox(e,[1,r,i]);for(let r=0;r<t.length;++r)n[r]=Ox(Px(e,[0,0===r?0:s[r-1],0],[1,t[r],i]),o);return e.dispose(),n}),u=new b_([],n,e.dtype,t.length);for(let l=0;l<a.length;l++)u.setItem(l,a[l]);return u}(r,Qw("lengths",e,t,n),s);return n.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}});return function(t,n,r){return e.apply(this,arguments)}}(),w_=py({conv2d_:function(e,t,n,r,s="NHWC",o=[1,1],i){const a=hy(e,"x","conv2d"),u=hy(t,"filter","conv2d");let l=a,c=!1;3===a.rank&&(c=!0,l=Ox(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Qd(4===l.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),Qd(4===u.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),null!=i&&Qd(rp(r),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`);const h="NHWC"===s?l.shape[3]:l.shape[1];Qd(h===u.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${u.shape[2]}.`),Qd(Gv(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);const d=ry.runKernel(nf,{x:l,filter:u},{strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i});return c?Ox(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),C_=py({conv1d_:function(e,t,n,r,s="NWC",o=1,i){const a=hy(e,"x","conv1d"),u=hy(t,"filter","conv1d");let l=a,c=!1;2===a.rank&&(c=!0,l=Ox(a,[1,a.shape[0],a.shape[1]])),Qd(3===l.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),Qd(3===u.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),null!=i&&Qd(rp(r),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`),Qd(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),Qd(Gv(n,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${o}'`),Qd("NWC"===s,()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const h=Ox(u,[1,u.shape[0],u.shape[1],u.shape[2]]),d=Ox(l,[l.shape[0],1,l.shape[1],l.shape[2]]),p=w_(d,h,[1,n],r,"NHWC",[1,o],i);return Ox(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}}),__=py({conv2DBackpropFilter_:function(e,t,n,r,s,o="NHWC",i){let a=e;3===e.rank&&(a=Ox(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;3===u.rank&&(u=Ox(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Qd(4===a.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),Qd(4===u.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),Qd(4===n.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const l="NHWC"===o?a.shape[3]:a.shape[1],c="NHWC"===o?u.shape[3]:u.shape[1];return Qd(l===n[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${n[2]}.`),Qd(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),null!=i&&Qd(rp(s),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${i} but got pad ${s}.`),ry.runKernel(rf,{x:a,dy:u},{strides:r,pad:s,dataFormat:o,dimRoundingMode:i,filterShape:n})}}),k_=py({conv2DBackpropInput_:function(e,t,n,r,s,o="NHWC",i){Qd(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let a=e,u=t,l=!1;3===t.rank&&(l=!0,u=Ox(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,e[0],e[1],e[2]]),Qd(4===a.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),Qd(4===u.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),Qd(4===n.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c="NHWC"===o?a[3]:a[1],h="NHWC"===o?u.shape[3]:u.shape[1];Qd(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),Qd(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),null!=i&&Qd(rp(s),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${i} but got pad ${s}.`);const d=ry.runKernel(sf,{dy:u,filter:n},{strides:r,pad:s,dataFormat:o,dimRoundingMode:i,inputShape:a});return l?Ox(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),E_=py({fusedConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(!1===nw(ry.state.gradientDepth,u=u||"linear")){let h=w_(e,t,n,r,s,o,i);return null!=a&&(h=kx(h,a)),tw(h,u,l,c)}const h=hy(e,"x","conv2d"),d=hy(t,"filter","conv2d");let p=h,f=!1;3===h.rank&&(f=!0,p=Ox(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Qd(4===p.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),Qd(4===d.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),null!=i&&Qd(rp(r),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`),Qd(p.shape[3]===d.shape[2],()=>`Error in conv2d: depth of input (${p.shape[3]}) must match input depth for filter ${d.shape[2]}.`),Qd(Gv(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),Qd("NHWC"===s,()=>`Error in conv2d: got dataFormat of ${s} but only NHWC is currently supported.`);const m=Lv(p.shape,d.shape,n,o,r,i);let g,y;null!=a&&(g=hy(a,"bias","fused conv2d"),[g]=Yg(g,h),Tb(m.outShape,g.shape)),null!=l&&(y=hy(l,"prelu weights","fused conv2d"));const x=(e,t)=>{const[s,i,a,l]=t,c=Jv(e,a,u);Qd(Hv(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const h=[k_(i.shape,c,s,n,r),__(i,c,s.shape,n,r)];if(null!=l){const e=ew(l,c);h.push(e)}return h},b={x:p,filter:d,bias:g,preluActivationWeights:y},v={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return null==a?wv((e,t,n)=>{let r=ry.runKernel(tg,b,v);return n([t,e,r]),f&&(r=Ox(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}})(p,d):wv((e,t,n,r)=>{let s=ry.runKernel(tg,b,v);return r([t,e,s,n]),f&&(s=Ox(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:x}})(p,d,g)}}),S_=py({depthwiseConv2d_:function(e,t,n,r,s="NHWC",o=[1,1],i){const a=hy(e,"x","depthwiseConv2d"),u=hy(t,"filter","depthwiseConv2d");let l=a,c=!1;3===a.rank&&(c=!0,l=Ox(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Qd(4===l.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),Qd(4===u.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`),Qd(l.shape[3]===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),null!=i&&Qd(rp(r),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`);const h=ry.runKernel(df,{x:l,filter:u},{strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i});return c?Ox(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),T_=py({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,s,o=[1,1],i){let a=e;3===e.rank&&(a=Ox(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;return 3===u.rank&&(u=Ox(t,[1,t.shape[0],t.shape[1],t.shape[2]])),ry.runKernel(pf,{x:a,dy:u},{strides:r,pad:s,dimRoundingMode:i,dilations:o,filterShape:n})}}),I_=py({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,s,o=[1,1],i){let a=t,u=!1;3===t.rank&&(u=!0,a=Ox(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l=ry.runKernel(ff,{dy:a,filter:n},{strides:r,pad:s,dimRoundingMode:i,dilations:o,inputShape:e});return u?Ox(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),N_=py({fusedDepthwiseConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(!1===nw(ry.state.gradientDepth,u)){let h=S_(e,t,n,r,s,o,i);return null!=a&&(h=kx(h,a)),tw(h,u,l,c)}const h=hy(e,"x","depthwiseConv2d"),d=hy(t,"filter","depthwiseConv2d");let p=h,f=!1;3===h.rank&&(f=!0,p=Ox(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Qd(4===p.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),Qd(4===d.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),Qd(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),null==o&&(o=[1,1]),Qd(Gv(n,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),null!=i&&Qd(rp(r),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${i} but got pad ${r}.`);const m=Lv(p.shape,d.shape,n,o,r,i,!0);let g,y;null!=a&&(g=hy(a,"bias","fused conv2d"),[g]=Yg(g,h),Tb(m.outShape,g.shape)),null!=l&&(y=hy(l,"prelu weights","fused depthwiseConv2d"));const x=(e,t)=>{Qd(Hv(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[s,a,l,c]=t,h=Jv(e,l,u),d=I_(a.shape,h,s,n,r,o,i),p=T_(a,h,s.shape,n,r,o,i);return null!=c?[d,p,ew(g,h)]:[d,p]},b={x:p,filter:d,bias:g,preluActivationWeights:y},v={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return null==a?wv((e,t,n)=>{let r=ry.runKernel(ng,b,v);return n([t,e,r]),f&&(r=Ox(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}})(p,d):wv((e,t,n,r)=>{let s=ry.runKernel(ng,b,v);return r([t,e,s,n]),f&&(s=Ox(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:x}})(p,d,g)}}),$_=py({fusedMatMul_:function({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:a}){if(!1===nw(ry.state.gradientDepth,o)){let u=av(e,t,n,r);return null!=s&&(u=kx(u,s)),tw(u,o,i,a)}let u=hy(e,"a","fused matMul"),l=hy(t,"b","fused matMul");[u,l]=Yg(u,l);const c=n?u.shape[u.rank-2]:u.shape[u.rank-1],h=r?l.shape[l.rank-1]:l.shape[l.rank-2],d=n?u.shape[u.rank-1]:u.shape[u.rank-2],p=r?l.shape[l.rank-2]:l.shape[l.rank-1],f=u.shape.slice(0,-2),m=l.shape.slice(0,-2),g=tp(f),y=tp(m);Qd(u.rank>=2&&l.rank>=2&&u.rank===l.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${u.rank} and ${l.rank}.`),Qd(np(f,m),()=>`Error in fused matMul: outer dimensions (${f}) and (${m}) of Tensors with shapes ${u.shape} and ${l.shape} must match.`),Qd(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${n} and transposeB=${r} must match.`);const x=u.shape.slice(0,-2).concat([d,p]),b=Ox(u,n?[g,c,d]:[g,d,c]),v=Ox(l,r?[y,p,h]:[y,h,p]);let w,C;null!=s&&(w=hy(s,"bias","fused matMul"),[w]=Yg(w,u),Tb(x,w.shape)),null!=i&&(C=hy(i,"prelu weights","fused matMul"));const _=(e,t)=>{const[i,a,u,l]=t,c=Jv(Ox(e,u.shape),u,o);let h,d;return n||r?!n&&r?(h=av(c,a,!1,!1),d=av(c,i,!0,!1)):n&&!r?(h=av(a,c,!1,!0),d=av(i,c,!1,!1)):(h=av(a,c,!0,!0),d=av(c,i,!0,!0)):(h=av(c,a,!1,!0),d=av(i,c,!0,!1)),null!=s?[h,d,ew(l,c)]:[h,d]},k={a:b,b:v,bias:w,preluActivationWeights:C},E={transposeA:n,transposeB:r,activation:o,leakyreluAlpha:a};return null==s?wv((e,t,n)=>{const r=ry.runKernel(eg,k,E);return n([e,t,r]),{value:Ox(r,x),gradFunc:_}})(b,v):wv((e,t,n,r)=>{const s=ry.runKernel(eg,k,E);return r([e,t,s,n]),{value:Ox(s,x),gradFunc:_}})(b,v,w)}}),R_=py({conv2dTranspose_:function(e,t,n,r,s,o){const i=hy(e,"x","conv2dTranspose"),a=hy(t,"filter","conv2dTranspose");return k_(n,i,a,r,s,"NHWC",o)}}),A_=py({conv3d_:function(e,t,n,r,s="NDHWC",o=[1,1,1]){const i=hy(e,"x","conv3d"),a=hy(t,"filter","conv3d");let u=i,l=!1;4===i.rank&&(l=!0,u=Ox(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Qd(5===u.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),Qd(5===a.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),Qd(u.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${a.shape[3]}.`),Qd(Gv(n,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),Qd("NDHWC"===s,()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);const c=ry.runKernel(of,{x:u,filter:a},{strides:n,pad:r,dataFormat:s,dilations:o});return l?Ox(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),O_=py({avgPool_:function(e,t,n,r,s){const o=hy(e,"x","avgPool","float32");Qd(Gv(n,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`);let i=o,a=!1;3===o.rank&&(a=!0,i=Ox(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Qd(4===i.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),null!=s&&Qd(rp(r),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let u=ry.runKernel(Hp,{x:i},{filterSize:t,strides:n,pad:r,dimRoundingMode:s});return u=Ky(u,o.dtype),a?Ox(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),F_=py({maxPool_:function(e,t,n,r,s){const o=hy(e,"x","maxPool");let i=o,a=!1;3===o.rank&&(a=!0,i=Ox(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Qd(4===i.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),Qd(Gv(n,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`),null!=s&&Qd(rp(r),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const u=ry.runKernel(Hf,{x:i},{filterSize:t,strides:n,pad:r,dimRoundingMode:s});return a?Ox(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),D_=py({maxPoolWithArgmax_:function(e,t,n,r,s=!1){const o=hy(e,"x","maxPoolWithArgmax"),i=ry.runKernel(qf,{x:o},{filterSize:t,strides:n,pad:r,includeBatchInIndex:s});return{result:i[0],indexes:i[1]}}}),P_=py({avgPool3d_:function(e,t,n,r,s,o="NDHWC"){const i=hy(e,"x","avgPool3d","float32");let a=i,u=!1;4===i.rank&&(u=!0,a=Ox(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Qd(5===a.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),Qd("NDHWC"===o,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),null!=s&&Qd(rp(r),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let l=ry.runKernel(Gp,{x:a},{filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:o});return l=Ky(l,a.dtype),u?Ox(l,[l.shape[1],l.shape[2],l.shape[3],l.shape[4]]):l}}),M_=py({maxPool3d_:function(e,t=[1,1,1],n,r,s,o="NDHWC"){const i=hy(e,"x","maxPool3d");let a=i,u=!1;4===i.rank&&(u=!0,a=Ox(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Qd(5===a.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),Qd("NDHWC"===o,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),null!=s&&Qd(rp(r),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const l=ry.runKernel(Gf,{x:a},{filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:o});return u?Ox(l,[l.shape[1],l.shape[2],l.shape[3],l.shape[4]]):l}}),L_=py({dilation2d_:function(e,t,n,r,s=[1,1],o="NHWC"){const i=hy(e,"x","dilation2d"),a=hy(t,"filter","dilation2d");Qd(3===i.rank||4===i.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),Qd(3===a.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),Qd("NHWC"===o,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let u=i,l=!1;3===i.rank&&(u=Ox(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0);const c=ry.runKernel(mf,{x:u,filter:a},{strides:n,pad:r,dilations:s});return l?Ox(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});function B_(e,t,n){const[r,s]=Qw("fusedOps",e,t,n),o="biasadd"===r,i=!o,a="prelu"===s,u="fusedbatchnorm"===r,l=Qw("numArgs",e,t,n);if(o){if(a&&2!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&o&&1!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=Qw("strides",e,t,n),h=nC(e,t,n),d=Qw("dataFormat",e,t,n).toUpperCase(),p=Qw("dilations",e,t,n);let[f,m]=Qw("args",e,t,n);return i&&(m=f,f=void 0),{stride:c,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:m,activationFunc:s,leakyreluAlpha:Qw("leakyreluAlpha",e,t,n)}}function V_(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");return ry.runKernel(Lf,{},{start:e,stop:t,num:n})}const U_=py({multinomial_:function(e,t,n,r=!1){const s=hy(e,"logits","multinomial"),o=s.size,i=s.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const a=1===i?Ox(s,[1,-1]):s,u=ry.runKernel(Qf,{logits:a},{numSamples:t,seed:n,normalized:r});return 1===i?Ox(u,[u.size]):u}}),z_=py({oneHot_:function(e,t,n=1,r=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const s=hy(e,"indices","oneHot","int32");return ry.runKernel(sm,{indices:s},{depth:t,onValue:n,offValue:r})}}),W_=py({onesLike_:function(e){const t=hy(e,"x","onesLike");return ry.runKernel(rm,{x:t})}});var j_=n(176);class H_{constructor(e,t,n,r,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const o=s||Math.random();this.random=j_.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,s,o;do{r=2*this.random()-1,s=2*this.random()-1,o=r*r+s*s}while(o>=1||0===o);const i=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*s*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class G_{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=j_.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const q_=py({randomUniform_:function(e,t=0,n=1,r="float32",s){const o=qy(e,r),i=new G_(t,n,null,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),K_=py({truncatedNormal_:function(e,t=0,n=1,r,s){if(null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const o=new H_(t,n,r,!0,s),i=qy(e,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}});function X_(){return(X_=jd(function*(e){const t=hy(e,"condition","whereAsync","bool"),n=yield t.data(),r=Gw(t.shape,n);return e!==t&&t.dispose(),r})).apply(this,arguments)}const Y_=function(e){return X_.apply(this,arguments)};function Q_(){return(Q_=jd(function*(e,t){const n=hy(e,"x","setdiff1d"),r=hy(t,"y","setdiff1d");Qd(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),Qd(1===n.rank,()=>`x should be 1D tensor, but got x (${n.shape}).`),Qd(1===r.rank,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=yield n.data(),o=yield r.data(),i=new Set(o);let a=0;for(let c=0;c<s.length;c++)i.has(s[c])||a++;const u=new Mg([a],n.dtype),l=new Mg([a],"int32");for(let c=0,h=0;c<s.length;c++)i.has(s[c])||(u.values[h]=s[c],l.values[h]=c,h++);return[u.toTensor(),l.toTensor()]})).apply(this,arguments)}function Z_(e,t,n){return{boxes:Qw("boxes",e,t,n),scores:Qw("scores",e,t,n),maxOutputSize:Qw("maxOutputSize",e,t,n),iouThreshold:Qw("iouThreshold",e,t,n),scoreThreshold:Qw("scoreThreshold",e,t,n),softNmsSigma:Qw("softNmsSigma",e,t,n)}}const J_=function(){var e=jd(function*(e,t,n){switch(e.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:a,softNmsSigma:u}=Z_(e,t,n),l=yield $v.nonMaxSuppressionWithScoreAsync(r,s,o,i,a,u);return[l.selectedIndices,l.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:a}=Z_(e,t,n),u=Qw("padToMaxOutputSize",e,t,n),l=yield $v.nonMaxSuppressionPaddedAsync(r,s,o,i,a,u);return[l.selectedIndices,l.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:a}=Z_(e,t,n);return[yield $v.nonMaxSuppressionAsync(r,s,o,i,a)]}case"Where":{const r=Ky(Qw("condition",e,t,n),"bool"),s=[yield Y_(r)];return r.dispose(),s}case"ListDiff":return function(e,t){return Q_.apply(this,arguments)}(Qw("x",e,t,n),Qw("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}});return function(t,n,r){return e.apply(this,arguments)}}(),ek=py({topk_:function(e,t=1,n=!0){const r=hy(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const o={x:r},i={k:t,sorted:n},[a,u]=ry.runKernel(Hm,o,i);return{values:a,indices:u}}}),tk=py({unique_:function(e,t=0){const n=hy(e,"x","unique","string_or_numeric");Qd(n.rank>0,()=>"The input tensor must be at least 1D");const r={x:n},s={axis:t},[o,i]=ry.runKernel(Km,r,s);return{values:o,indices:i}}});class nk{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Fx(0),this.tensorMap=new Map,sv(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Fx(this.size(),"int32")}import(e,t){var n=this;return jd(function*(){n.checkKeyAndValueTensor(e,t);const r=yield e.data();return n.tensorMap.forEach(e=>e.dispose()),n.tensorMap.clear(),nv(()=>{const e=zx(t),s=r.length,o=e.length;Qd(s===o,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${o} elements.`);for(let t=0;t<s;t++){const s=r[t],o=e[t];sv(o),n.tensorMap.set(s,o)}return n.handle})})()}find(e,t){var n=this;return jd(function*(){n.checkKeyAndValueTensor(e,t);const r=yield e.data();return nv(()=>{const e=[];for(let s=0;s<r.length;s++){const o=n.findWithDefault(r[s],t);e.push(o)}return Lx(e)})})()}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}const rk=function(){var e=jd(function*(e,t,n,r){switch(e.op){case"HashTable":case"HashTableV2":{const s=Qw("keyDType",e,t,n),o=Qw("valueDType",e,t,n),i=new nk(s,o);return r.addHashTable(e.name,i),[i.handle]}case"LookupTableImport":case"LookupTableImportV2":{const s=Qw("tableHandle",e,t,n,r),o=Qw("keys",e,t,n),i=Qw("values",e,t,n),a=r.getHashTableById(s.id);return[yield a.import(o,i)]}case"LookupTableFind":case"LookupTableFindV2":{const s=Qw("tableHandle",e,t,n,r),o=Qw("keys",e,t,n),i=Qw("defaultValue",e,t,n),a=r.getHashTableById(s.id);return[yield a.find(o,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=Qw("tableHandle",e,t,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}});return function(t,n,r,s){return e.apply(this,arguments)}}(),sk=py({less_:function(e,t){let n=hy(e,"a","less","string_or_numeric"),r=hy(t,"b","less","string_or_numeric");return[n,r]=Yg(n,r),Tb(n.shape,r.shape),ry.runKernel(Pf,{a:n,b:r})}}),ok=py({logicalNot_:function(e){const t=hy(e,"x","logicalNot","bool");return ry.runKernel(zf,{x:t})}}),ik=py({logicalOr_:function(e,t){const n=hy(e,"a","logicalOr","bool"),r=hy(t,"b","logicalOr","bool");return Tb(n.shape,r.shape),ry.runKernel(Wf,{a:n,b:r})}}),ak=py({einsum_:function(e,...t){const n=t.map((e,t)=>hy(e,`tensors${t}`,"einsum"));return ry.runKernel(yf,n,{equation:e})}}),uk=py({batchNorm_:function(e,t,n,r,s,o){null==o&&(o=.001);const i=hy(e,"x","batchNorm"),a=hy(t,"mean","batchNorm"),u=hy(n,"variance","batchNorm");let l,c;null!=s&&(l=hy(s,"scale","batchNorm")),null!=r&&(c=hy(r,"offset","batchNorm")),Qd(a.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Qd(null==c||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Qd(null==l||a.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h=function(e){let t;return t=0===e.rank||1===e.rank?Ox(e,[1,1,1,e.size]):2===e.rank?Ox(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Ox(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(i),d=ry.runKernel(Sf,{x:h,scale:l,offset:c,mean:a,variance:u},{varianceEpsilon:o});return Ox(d,i.shape)}}),lk=py({localResponseNormalization_:function(e,t=5,n=1,r=1,s=.5){const o=hy(e,"x","localResponseNormalization");Qd(4===o.rank||3===o.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${o.rank}.`),Qd(rp(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=o,a=!1;3===o.rank&&(a=!0,i=Ox(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const u=ry.runKernel("LRN",{x:i},{depthRadius:t,bias:n,alpha:r,beta:s});return a?Ox(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),ck=py({softmax_:function(e,t=-1){const n=hy(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);return ry.runKernel(Rm,{logits:n},{dim:t})}}),hk=py({logSoftmax_:function(e,t=-1){const n=hy(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return wv((e,n)=>{const r=Kb(e,t,!0),s=Bx(e,r),o=Bx(Ky(s,"float32"),xv($b($x(s),t,!0)));return n([o]),{value:o,gradFunc:(e,n)=>{const[r]=n,s=$x(r);return Bx(e,Ax($b(e,t,!0),s))}}})(n)}}),dk=py({sparseToDense_:function(e,t,n,r=0){const s=hy(e,"sparseIndices","sparseToDense","int32"),o=hy(t,"sparseValues","sparseToDense"),i=hy(r,"defaultValue","sparseToDense",o.dtype);return function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const s=e.rank>0?e.shape[0]:1,o=e.rank>1?e.shape[1]:1;if(n.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${o}.`);if(0!==t.rank&&(1!==t.rank||t.size!==s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,o,n,i),ry.runKernel(Pm,{sparseIndices:s,sparseValues:o,defaultValue:i},{outputShape:n})}}),pk=py({all_:function(e,t=null,n=!1){const r=hy(e,"x","all","bool");return ry.runKernel("All",{x:r},{axis:t,keepDims:n})}}),fk=py({any_:function(e,t=null,n=!1){const r=hy(e,"x","any","bool");return ry.runKernel("Any",{x:r},{axis:t,keepDims:n})}}),mk=py({argMin_:function(e,t=0){const n=hy(e,"x","argMin");return ry.runKernel(Bp,{x:n},{axis:t})}}),gk=py({cumsum_:function(e,t=0,n=!1,r=!1){const s=hy(e,"x","cumsum");return ry.runKernel(uf,{x:s},{axis:t,exclusive:n,reverse:r})}}),yk=py({denseBincount_:function(e,t,n,r=!1){const s=hy(e,"x","denseBincount"),o=hy(t,"weights","denseBincount");return Qd("int32"===s.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),Qd(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),Qd(n>=0,()=>`size must be non-negative, but got ${n}.`),Qd(o.size===s.size||0===o.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${o.shape}.`),ry.runKernel(cf,{x:s,weights:o},{size:n,binaryOutput:r})}}),xk=py({gather_:function(e,t,n=0,r=0){const s=hy(e,"x","gather"),o=hy(t,"indices","gather","int32");return ry.runKernel(Tf,{x:s,indices:o},{axis:n,batchDims:r})}}),bk=py({stridedSlice_:function(e,t,n,r,s=0,o=0,i=0,a=0,u=0){const l=hy(e,"x","stridedSlice","string_or_numeric");return ry.runKernel(Lm,{x:l},{begin:t,end:n,strides:r,beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u})}}),vk=py({scatterND_:function(e,t,n){const r=hy(e,"indices","scatterND","int32"),s=hy(t,"updates","scatterND");return pw(s,r,n),ry.runKernel(vm,{indices:r,updates:s},{shape:n})}}),wk=py({gatherND_:function(e,t){const n=hy(t,"indices","gatherND","int32"),r=hy(e,"x","gatherND","string_or_numeric");return ry.runKernel(If,{params:r,indices:n})}}),Ck=py({mirrorPad_:function(e,t,n){Qd("reflect"===n||"symmetric"===n,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const r=hy(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Qd(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);const s="reflect"===n?1:0;for(let o=0;o<r.rank;o++)Qd(2===t[o].length,()=>"Invalid number of paddings. Must be length of 2 each."),Qd(t[o][0]>=0&&t[o][0]<=r.shape[o]-s&&t[o][1]>=0&&t[o][1]<=r.shape[o]-s,()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-s} or less than 0 for input of shape ${r.shape}`);return ry.runKernel(Yf,{x:r},{paddings:t,mode:n})}}),_k=py({pad_:function(e,t,n=0){const r=hy(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return ry.runKernel(im,{x:r},{paddings:t,constantValue:n})}}),kk=py({spaceToBatchND_:function(e,t,n){const r=hy(e,"x","spaceToBatchND");return Qd(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),Qd(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),Qd(r.shape.reduce((e,r,s)=>s>0&&s<=t.length?e&&(r+n[s-1][0]+n[s-1][1])%t[s-1]==0:e,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`),ry.runKernel(Nm,{x:r},{blockShape:t,paddings:n})}}),Ek=py({batchToSpaceND_:function(e,t,n){const r=hy(e,"x","batchToSpaceND"),s=t.reduce((e,t)=>e*t);return Qd(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),Qd(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),Qd(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`),ry.runKernel(Kp,{x:r},{blockShape:t,crops:n})}}),Sk=py({depthToSpace_:function(e,t,n="NHWC"){const r=hy(e,"x","depthToSpace"),s="NHWC"===n?r.shape[1]:r.shape[2],o="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];return Qd(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t}  for depthToSpace with input shape\n    ${r.shape}`),Qd(o*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${o} and ${t} for depthToSpace with input shape\n        ${r.shape}`),Qd(i%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`),ry.runKernel(hf,{x:r},{blockSize:t,dataFormat:n})}});function Tk(e,t,n,r){const s=((e,t,n)=>{switch(e.category){case"arithmetic":return nv(()=>((e,t,n)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[kx(Qw("a",e,t,n),Qw("b",e,t,n))];case"AddN":return[BC(Qw("tensors",e,t,n))];case"FloorMod":case"Mod":return[VC(Qw("a",e,t,n),Qw("b",e,t,n))];case"Mul":return[Ax(Qw("a",e,t,n),Qw("b",e,t,n))];case"RealDiv":case"Div":return[Nx(Qw("a",e,t,n),Qw("b",e,t,n))];case"DivNoNan":return[zC(Qw("a",e,t,n),Qw("b",e,t,n))];case"FloorDiv":return[Ix(Qw("a",e,t,n),Qw("b",e,t,n))];case"Sub":return[Bx(Qw("a",e,t,n),Qw("b",e,t,n))];case"Minimum":return[yv(Qw("a",e,t,n),Qw("b",e,t,n))];case"Maximum":return[WC(Qw("a",e,t,n),Qw("b",e,t,n))];case"Pow":return[Yb(Qw("a",e,t,n),Qw("b",e,t,n))];case"SquaredDifference":return[bv(Qw("a",e,t,n),Qw("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"basic_math":return nv(()=>((e,t,n)=>{switch(e.op){case"Abs":case"ComplexAbs":return[Bb(Qw("x",e,t,n))];case"Acos":return[jC(Qw("x",e,t,n))];case"Acosh":return[HC(Qw("x",e,t,n))];case"Asin":return[GC(Qw("x",e,t,n))];case"Asinh":return[qC(Qw("x",e,t,n))];case"Atan":return[KC(Qw("x",e,t,n))];case"Atan2":return[XC(Qw("x",e,t,n),Qw("y",e,t,n))];case"Atanh":return[YC(Qw("x",e,t,n))];case"Ceil":return[QC(Qw("x",e,t,n))];case"Complex":return[fy(Qw("real",e,t,n),Qw("imag",e,t,n))];case"Cos":return[ZC(Qw("x",e,t,n))];case"Cosh":return[JC(Qw("x",e,t,n))];case"Elu":return[Kv(Qw("x",e,t,n))];case"Erf":return[e_(Qw("x",e,t,n))];case"Exp":return[$x(Qw("x",e,t,n))];case"Expm1":return[t_(Qw("x",e,t,n))];case"Floor":return[n_(Qw("x",e,t,n))];case"Log":return[xv(Qw("x",e,t,n))];case"Log1p":return[vv(Qw("x",e,t,n))];case"Imag":return[jx(Qw("x",e,t,n))];case"Neg":return[uv(Qw("x",e,t,n))];case"Reciprocal":return[r_(Qw("x",e,t,n))];case"Real":return[Hx(Qw("x",e,t,n))];case"Relu":return[gv(Qw("x",e,t,n))];case"Round":return[Rb(Qw("x",e,t,n))];case"Selu":return[s_(Qw("x",e,t,n))];case"Sigmoid":return[Dx(Qw("x",e,t,n))];case"Sin":return[o_(Qw("x",e,t,n))];case"Sign":return[i_(Qw("x",e,t,n))];case"Sinh":return[a_(Qw("x",e,t,n))];case"Softplus":return[u_(Qw("x",e,t,n))];case"Sqrt":return[Qb(Qw("x",e,t,n))];case"Square":return[Zb(Qw("x",e,t,n))];case"Tanh":return[l_(Qw("x",e,t,n))];case"Tan":return[c_(Qw("x",e,t,n))];case"ClipByValue":return[Sx(Qw("x",e,t,n),Qw("clipValueMin",e,t,n),Qw("clipValueMax",e,t,n))];case"Relu6":return[Qv(Qw("x",e,t,n))];case"Rsqrt":return[h_(Zw(e.inputNames[0],t,n))];case"Prod":return[d_(Qw("x",e,t,n),Qw("axes",e,t,n))];case"LeakyRelu":return[Xv(Qw("x",e,t,n),Qw("alpha",e,t,n))];case"Prelu":return[Yv(Qw("x",e,t,n),Qw("alpha",e,t,n))];case"IsNan":return[p_(Zw(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"control":return v_(e,t,n);case"convolution":return nv(()=>((e,t,n)=>{switch(e.op){case"Conv1D":{const r=Qw("stride",e,t,n),s=Qw("pad",e,t,n),o=Qw("dataFormat",e,t,n).toUpperCase(),i=Qw("dilation",e,t,n);return[C_(Qw("x",e,t,n),Qw("filter",e,t,n),r,s,o,i)]}case"Conv2D":{const r=Qw("strides",e,t,n),s=nC(e,t,n),o=Qw("dataFormat",e,t,n).toUpperCase(),i=Qw("dilations",e,t,n);return[w_(Qw("x",e,t,n),Qw("filter",e,t,n),[r[1],r[2]],s,o,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:r,pad:s,dataFormat:o,dilations:i,biasArg:a,preluArg:u,activationFunc:l,leakyreluAlpha:c}=B_(e,t,n);return[E_({x:Qw("x",e,t,n),filter:Qw("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[i[1],i[2]],bias:a,activation:l,preluActivationWeights:u,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:s,dataFormat:o,dilations:i,biasArg:a,preluArg:u,activationFunc:l,leakyreluAlpha:c}=B_(e,t,n);return[N_({x:Qw("x",e,t,n),filter:Qw("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[i[1],i[2]],bias:a,activation:l,preluActivationWeights:u,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=Qw("outputShape",e,t,n),s=Qw("strides",e,t,n),o=nC(e,t,n);return[R_(Qw("x",e,t,n),Qw("filter",e,t,n),r,[s[1],s[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=Qw("strides",e,t,n),s=nC(e,t,n),o=Qw("dilations",e,t,n),i=Qw("dataFormat",e,t,n).toUpperCase();return[S_(Qw("input",e,t,n),Qw("filter",e,t,n),[r[1],r[2]],s,i,[o[1],o[2]])]}case"Conv3D":{const r=Qw("strides",e,t,n),s=Qw("pad",e,t,n),o=Qw("dataFormat",e,t,n).toUpperCase(),i=Qw("dilations",e,t,n);return[A_(Qw("x",e,t,n),Qw("filter",e,t,n),[r[1],r[2],r[3]],s,o,[i[1],i[2],i[3]])]}case"AvgPool":{const r=Qw("strides",e,t,n),s=Qw("pad",e,t,n),o=Qw("kernelSize",e,t,n);return[O_(Qw("x",e,t,n),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPool":{const r=Qw("strides",e,t,n),s=Qw("pad",e,t,n),o=Qw("kernelSize",e,t,n);return[F_(Qw("x",e,t,n),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPoolWithArgmax":{const r=Qw("strides",e,t,n),s=Qw("pad",e,t,n),o=Qw("kernelSize",e,t,n),i=Qw("includeBatchInIndex",e,t,n),{result:a,indexes:u}=D_(Qw("x",e,t,n),[o[1],o[2]],[r[1],r[2]],s,i);return[a,u]}case"AvgPool3D":{const r=Qw("strides",e,t,n),s=Qw("pad",e,t,n),o=Qw("kernelSize",e,t,n);return[P_(Qw("x",e,t,n),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"MaxPool3D":{const r=Qw("strides",e,t,n),s=Qw("pad",e,t,n),o=Qw("kernelSize",e,t,n);return[M_(Qw("x",e,t,n),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"Dilation2D":{const r=Qw("strides",e,t,n),s=Qw("pad",e,t,n),o=Qw("dilations",e,t,n),i=r[1],a=r[2],u=o[1],l=o[2];return[L_(Qw("x",e,t,n),Qw("filter",e,t,n),[i,a],s,[u,l],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"creation":return nv(()=>((e,t,n)=>{switch(e.op){case"Fill":{const r=Qw("shape",e,t,n),s=Qw("dtype",e,t,n);return[tb(r,Qw("value",e,t,n),s)]}case"LinSpace":return[V_(Qw("start",e,t,n),Qw("stop",e,t,n),Qw("num",e,t,n))];case"Multinomial":{const r=Qw("logits",e,t,n),s=Qw("numSamples",e,t,n),o=Qw("seed",e,t,n);return[U_(r,s,o)]}case"OneHot":{const r=Qw("indices",e,t,n),s=Qw("depth",e,t,n),o=Qw("onValue",e,t,n),i=Qw("offValue",e,t,n);return[z_(r,s,o,i)]}case"Ones":return[fv(Qw("shape",e,t,n),Qw("dtype",e,t,n))];case"OnesLike":return[W_(Qw("x",e,t,n))];case"RandomUniform":return[q_(Qw("shape",e,t,n),Qw("minval",e,t,n),Qw("maxval",e,t,n),Qw("dtype",e,t,n))];case"Range":return[Fb(Qw("start",e,t,n),Qw("stop",e,t,n),Qw("step",e,t,n),Qw("dtype",e,t,n))];case"TruncatedNormal":{const r=Qw("shape",e,t,n),s=Qw("mean",e,t,n),o=Qw("stdDev",e,t,n),i=Qw("seed",e,t,n);return[K_(r,s,o,Qw("dtype",e,t,n),i)]}case"Zeros":return[Wx(Qw("shape",e,t,n),Qw("dtype",e,t,n))];case"ZerosLike":return[qx(Qw("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"dynamic":return J_(e,t,n);case"evaluation":return nv(()=>((e,t,n)=>{switch(e.op){case"TopKV2":{const r=Qw("x",e,t,n),s=Qw("k",e,t,n),o=Qw("sorted",e,t,n),i=ek(r,s,o);return[i.values,i.indices]}case"Unique":{const r=Qw("x",e,t,n),s=tk(r);return[s.values,s.indices]}case"UniqueV2":{const r=Qw("x",e,t,n),s=Qw("axis",e,t,n),o=tk(r,s);return[o.values,o.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"image":return nv(()=>((e,t,n)=>{switch(e.op){case"ResizeBilinear":{const r=Qw("images",e,t,n),s=Qw("size",e,t,n),o=Qw("alignCorners",e,t,n),i=Qw("halfPixelCenters",e,t,n);return[$v.resizeBilinear(r,[s[0],s[1]],o,i)]}case"ResizeNearestNeighbor":{const r=Qw("images",e,t,n),s=Qw("size",e,t,n),o=Qw("alignCorners",e,t,n),i=Qw("halfPixelCenters",e,t,n);return[$v.resizeNearestNeighbor(r,[s[0],s[1]],o,i)]}case"CropAndResize":{const r=Qw("image",e,t,n),s=Qw("boxes",e,t,n),o=Qw("boxInd",e,t,n),i=Qw("cropSize",e,t,n),a=Qw("method",e,t,n),u=Qw("extrapolationValue",e,t,n);return[$v.cropAndResize(r,s,o,i,a,u)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"graph":return nv(()=>((e,t,n)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const r=Qw("default",e,t,n);return[Zw(e.name,t,n)||r];case"Placeholder":return[Zw(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":return[rC(Qw("x",e,t,n))];case"IdentityN":return Qw("x",e,t,n).map(e=>rC(e));case"Snapshot":return[rC(Qw("x",e,t,n))];case"Shape":return[Vx(Qw("x",e,t,n).shape,"int32")];case"ShapeN":return Qw("x",e,t,n).map(e=>Vx(e.shape));case"Size":return[Fx(Qw("x",e,t,n).size,"int32")];case"Rank":return[Fx(Qw("x",e,t,n).rank,"int32")];case"NoOp":return[Fx(1)];case"Print":const s=Qw("x",e,t,n),o=Qw("data",e,t,n),i=Qw("message",e,t,n),a=Qw("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(i);for(let e=0;e<o.length;e++)console.log(Array.prototype.slice.call(o[e].dataSync()).slice(0,a));return[s];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"logical":return nv(()=>((e,t,n)=>{switch(e.op){case"Equal":return[UC(Qw("a",e,t,n),Qw("b",e,t,n))];case"NotEqual":return[pv(Qw("a",e,t,n),Qw("b",e,t,n))];case"Greater":return[Nb(Qw("a",e,t,n),Qw("b",e,t,n))];case"GreaterEqual":return[Mb(Qw("a",e,t,n),Qw("b",e,t,n))];case"Less":return[sk(Qw("a",e,t,n),Qw("b",e,t,n))];case"LessEqual":return[Ib(Qw("a",e,t,n),Qw("b",e,t,n))];case"LogicalAnd":return[Lb(Qw("a",e,t,n),Qw("b",e,t,n))];case"LogicalNot":return[ok(Qw("a",e,t,n))];case"LogicalOr":return[ik(Qw("a",e,t,n),Qw("b",e,t,n))];case"Select":case"SelectV2":return[Ob(Qw("condition",e,t,n),Qw("a",e,t,n),Qw("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"matrices":return nv(()=>((e,t,n)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[av(Qw("a",e,t,n),Qw("b",e,t,n),Qw("transposeA",e,t,n),Qw("transposeB",e,t,n))];case"Einsum":return[ak(Qw("equation",e,t,n),...Qw("tensors",e,t,n))];case"Transpose":return[lv(Qw("x",e,t,n),Qw("perm",e,t,n))];case"_FusedMatMul":const[r,s]=Qw("fusedOps",e,t,n),o="biasadd"===r,i="prelu"===s,a=Qw("numArgs",e,t,n),u=Qw("leakyreluAlpha",e,t,n);if(o){if(i&&2!==a)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&1!==a)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[l,c]=Qw("args",e,t,n);return[$_({a:Qw("a",e,t,n),b:Qw("b",e,t,n),transposeA:Qw("transposeA",e,t,n),transposeB:Qw("transposeB",e,t,n),bias:l,activation:s,preluActivationWeights:c,leakyreluAlpha:u})];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"normalization":return nv(()=>((e,t,n)=>{switch(e.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[uk(Qw("x",e,t,n),Qw("mean",e,t,n),Qw("variance",e,t,n),Qw("offset",e,t,n),Qw("scale",e,t,n),Qw("epsilon",e,t,n))];case"LRN":return[lk(Qw("x",e,t,n),Qw("radius",e,t,n),Qw("bias",e,t,n),Qw("alpha",e,t,n),Qw("beta",e,t,n))];case"Softmax":return[ck(Qw("x",e,t,n))];case"LogSoftmax":return[hk(Qw("x",e,t,n))];case"SparseToDense":return[dk(Qw("sparseIndices",e,t,n),Qw("outputShape",e,t,n),Qw("sparseValues",e,t,n),Qw("defaultValue",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"reduction":return nv(()=>((e,t,n)=>{switch(e.op){case"Max":{const r=Qw("axis",e,t,n),s=Qw("keepDims",e,t,n);return[Kb(Qw("x",e,t,n),r,s)]}case"Mean":{const r=Qw("axis",e,t,n),s=Qw("keepDims",e,t,n);return[dv(Qw("x",e,t,n),r,s)]}case"Min":{const r=Qw("axis",e,t,n),s=Qw("keepDims",e,t,n);return[Xb(Qw("x",e,t,n),r,s)]}case"Sum":{const r=Qw("axis",e,t,n),s=Qw("keepDims",e,t,n);return[$b(Qw("x",e,t,n),r,s)]}case"All":{const r=Qw("axis",e,t,n),s=Qw("keepDims",e,t,n);return[pk(Qw("x",e,t,n),r,s)]}case"Any":{const r=Qw("axis",e,t,n),s=Qw("keepDims",e,t,n);return[fk(Qw("x",e,t,n),r,s)]}case"ArgMax":{const r=Qw("axis",e,t,n);return[Ex(Qw("x",e,t,n),r)]}case"ArgMin":{const r=Qw("axis",e,t,n);return[mk(Qw("x",e,t,n),r)]}case"Prod":{const r=Qw("axis",e,t,n),s=Qw("keepDims",e,t,n);return[d_(Qw("x",e,t,n),r,s)]}case"Cumsum":{const r=Qw("axis",e,t,n),s=Qw("exclusive",e,t,n),o=Qw("reverse",e,t,n);return[gk(Qw("x",e,t,n),r,s,o)]}case"Bincount":const r=Qw("x",e,t,n),s=Qw("weights",e,t,n),o=Qw("size",e,t,n);return[kb(r,s,o)];case"DenseBincount":{const r=Qw("x",e,t,n),s=Qw("weights",e,t,n),o=Qw("size",e,t,n),i=Qw("binaryOutput",e,t,n);return[yk(r,s,o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"slice_join":return nv(()=>((e,t,n)=>{switch(e.op){case"ConcatV2":case"Concat":{const r=Qw("n",e,t,n),s=Qw("axis",e,t,n);let o=Qw("tensors",e,t,n);return o=o.slice(0,r),[Tx(o,s)]}case"Gather":{const r=Qw("x",e,t,n),s=Qw("indices",e,t,n);return[xk(r,Ky(s,"int32"),0)]}case"GatherV2":{const r=Qw("axis",e,t,n),s=Qw("batchDims",e,t,n),o=Qw("x",e,t,n),i=Qw("indices",e,t,n);return[xk(o,Ky(i,"int32"),r,s)]}case"Reverse":{const r=Qw("dims",e,t,n),s=[];for(let e=0;e<r.length;e++)r[e]&&s.push(e);const o=Qw("x",e,t,n);return[Qx(o,s)]}case"ReverseV2":{const r=Qw("axis",e,t,n),s=Qw("x",e,t,n);return[Qx(s,r)]}case"Slice":{const r=Qw("begin",e,t,n),s=Qw("size",e,t,n);return[Px(Qw("x",e,t,n),r,s)]}case"StridedSlice":{const r=Qw("begin",e,t,n),s=Qw("end",e,t,n),o=Qw("strides",e,t,n),i=Qw("beginMask",e,t,n),a=Qw("endMask",e,t,n),u=Qw("ellipsisMask",e,t,n),l=Qw("newAxisMask",e,t,n),c=Qw("shrinkAxisMask",e,t,n),h=Qw("x",e,t,n);return[bk(h,r,s,o,i,a,u,l,c)]}case"Pack":return nv(()=>{const r=Qw("axis",e,t,n),s=Qw("tensors",e,t,n),o=s[0].shape,i=Mx(s[0]).shape,a=s.map(e=>{const t=np(e.shape,o);if(!t&&!np(Mx(e).shape,i))throw new Error("the input tensors shape does not match");return t?e:Ox(e,o)});return[Lx(a,r)]});case"Unpack":{const r=Qw("axis",e,t,n),s=Qw("tensor",e,t,n);return zx(s,r)}case"Tile":{const r=Qw("reps",e,t,n);return[ov(Qw("x",e,t,n),r)]}case"Split":case"SplitV":{const r=Qw("axis",e,t,n),s=Qw("numOrSizeSplits",e,t,n),o=Qw("x",e,t,n);return Gx(o,s,r)}case"ScatterNd":{const r=Qw("indices",e,t,n),s=Qw("values",e,t,n),o=Qw("shape",e,t,n);return[vk(r,s,o)]}case"GatherNd":{const r=Qw("x",e,t,n),s=Qw("indices",e,t,n);return[wk(r,s)]}case"SparseToDense":{const r=Qw("sparseIndices",e,t,n),s=Qw("outputShape",e,t,n),o=Qw("sparseValues",e,t,n),i=Qw("defaultValue",e,t,n);return[dk(r,o,s,o.dtype===i.dtype?i:Ky(i,o.dtype))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"sparse":return nv(()=>((e,t,n)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:s,emptyRowIndicator:o,reverseIndexMap:i}=Rv.sparseFillEmptyRows(Qw("indices",e,t,n),Qw("values",e,t,n),Qw("denseShape",e,t,n),Qw("defaultValue",e,t,n));return[r,s,o,i]}case"SparseReshape":{const{outputIndices:r,outputShape:s}=Rv.sparseReshape(Qw("inputIndices",e,t,n),Qw("inputShape",e,t,n),Qw("newShape",e,t,n));return[r,s]}case"SparseSegmentMean":return[Rv.sparseSegmentMean(Qw("data",e,t,n),Qw("indices",e,t,n),Qw("segmentIds",e,t,n))];case"SparseSegmentSum":return[Rv.sparseSegmentSum(Qw("data",e,t,n),Qw("indices",e,t,n),Qw("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"spectral":return nv(()=>((e,t,n)=>{switch(e.op){case"FFT":return[Kx(Qw("x",e,t,n))];case"IFFT":return[Yx(Qw("x",e,t,n))];case"RFFT":return[Xx(Qw("x",e,t,n))];case"IRFFT":return[Zx(Qw("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"string":return nv(()=>((e,t,n)=>{switch(e.op){case"StringNGrams":{const{nGrams:r,nGramsSplits:s}=Av.stringNGrams(Qw("data",e,t,n),Qw("dataSplits",e,t,n),Qw("separator",e,t,n),Qw("nGramWidths",e,t,n),Qw("leftPad",e,t,n),Qw("rightPad",e,t,n),Qw("padWidth",e,t,n),Qw("preserveShortSequences",e,t,n));return[r,s]}case"StringSplit":{const{indices:r,values:s,shape:o}=Av.stringSplit(Qw("input",e,t,n),Qw("delimiter",e,t,n),Qw("skipEmpty",e,t,n));return[r,s,o]}case"StringToHashBucketFast":return[Av.stringToHashBucketFast(Qw("input",e,t,n),Qw("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"transformation":return nv(()=>((e,t,n)=>{switch(e.op){case"Cast":return[Ky(Qw("x",e,t,n),Qw("dtype",e,t,n))];case"ExpandDims":{const r=Qw("axis",e,t,n);return[Rx(Qw("x",e,t,n),r)]}case"Squeeze":{const r=Qw("axis",e,t,n);return[Mx(Qw("x",e,t,n),r)]}case"Reshape":return[Ox(Qw("x",e,t,n),Qw("shape",e,t,n))];case"MirrorPad":return[Ck(Qw("x",e,t,n),Qw("padding",e,t,n),Qw("mode",e,t,n))];case"PadV2":case"Pad":return[_k(Qw("x",e,t,n),Qw("padding",e,t,n),Qw("constantValue",e,t,n))];case"SpaceToBatchND":{const r=Qw("blockShape",e,t,n),s=Qw("paddings",e,t,n);return[kk(Qw("x",e,t,n),r,s)]}case"BatchToSpaceND":{const r=Qw("blockShape",e,t,n),s=Qw("crops",e,t,n);return[Ek(Qw("x",e,t,n),r,s)]}case"DepthToSpace":{const r=Qw("blockSize",e,t,n),s=Qw("dataFormat",e,t,n).toUpperCase();return[Sk(Qw("x",e,t,n),r,s)]}case"BroadcastTo":return[Ab(Qw("x",e,t,n),Qw("shape",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"hash_table":return rk(e,t,n,r);case"custom":const s=Yw(e.op);if(s&&s.customExecutor)return s.customExecutor(new LC(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return Sp(s)?s.then(e=>[].concat(e)):[].concat(s)}class Ik{constructor(e={},t={},n={},r={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function Nk(e,t,n,r){const s=new Set,o=[];let i=null,a=null;const u=new Set,l=Object.keys(e).map(e=>tC(e)[0]);let c=[];null!=r&&(c=r.map(e=>tC(e.name)[0]));const h=[...t];for(;h.length>0;){const e=h.pop();(Ok(e)||Fk(e)||Dk(e))&&null==i&&(i=e,a=i.children.map(e=>e.name).filter(e=>s.has(e))),s.add(e.name),null==n[e.name]&&-1===l.indexOf(e.name)&&-1===c.indexOf(e.name)&&(0!==e.inputs.length?e.inputs.forEach(e=>{u.has(e.name)||(u.add(e.name),h.push(e))}):o.push(e.name))}return{inputs:e,outputs:t,usedNodes:s,missingInputs:o,dynamicNode:i,syncInputs:a}}const $k=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],Rk=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],Ak=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function Ok(e){return $k.indexOf(e.op)>=0}function Fk(e){return Rk.indexOf(e.op)>=0}function Dk(e){return Ak.indexOf(e.op)>=0}class Pk{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach(t=>{this._functionExecutorMap[t]=new Pk(e.functions[t],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(t=>e[t].map(e=>e.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){const n=e.map(e=>e.name).sort(),r=t.map(e=>e.name).sort();return n.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(e,t){const n=Nk(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:o}=n;if(null!=s)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(r.length>0){const n=t.map(e=>e.name),s=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${s}]. Missing the following inputs: [${r}]`)}return function(e,t,n){const{usedNodes:r,inputs:s}=n,o=[],i=Object.keys(s).map(e=>tC(e)[0]).map(t=>e.nodes[t]),a=e.initNodes;i.forEach(e=>{r.has(e.name)&&o.push(e)}),e.weights.forEach(e=>{r.has(e.name)&&o.push(e)}),null!=a&&a.forEach(e=>{r.has(e.name)&&o.push(e)});const u=new Set,l=[];for(;o.length>0;){const e=o.pop();u.add(e.name),t[e.name]||l.push(e),e.children.forEach(e=>{!u.has(e.name)&&r.has(e.name)&&e.inputs.every(e=>u.has(e.name))&&o.push(e)})}return l}(this.graph,this.weightMap,n)}execute(e,t){e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=n.map(e=>this.graph.nodes[tC(e)[0]]),s=t.map(e=>tC(e)[0]);let o=s.map(e=>this.graph.nodes[e]);0===o.length&&(o=this._outputs);const i=this.getCompilationKey(r,o);let a=this.compiledMap.get(i);null==a&&(a=this.compile(e,o),this.compiledMap.set(i,a));const u={},l={};return nv(()=>{const n=new Ik(this.weightMap,u,l,this.functionExecutorMap),r=Object.assign({},this.weightMap);Object.keys(e).forEach(t=>{const[n,s]=tC(t),o=[];o[s]=e[t],r[n]=o});const o=this.getFrozenTensorIds(r),i={};for(let e=0;e<a.length;e++){const t=a[e];if(!r[t.name]){const e=Tk(t,r,n,this._resourceManager);if(Sp(e))throw new Error(`The execution of the op '${t.op}' returned a promise. Please use model.executeAsync() instead.`);r[t.name]=e,this.checkTensorForDisposal(t.name,t,r,n,o,s,i)}}return null==this.parent&&n.dispose(o),t.map(e=>Zw(e,r,n))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(t=>e[t]).map(e=>e.map(e=>e.id)));return new Set(t)}checkTensorForDisposal(e,t,n,r,s,o,i){"control"!==t.category&&-1===o.indexOf(e)&&(n[e].forEach(e=>{null!=e&&(i[e.id]=(i[e.id]||0)+t.children.length)}),t.inputs.forEach(e=>{if("control"!==e.category){const t=function(e,t,n){return t[eC(e,n.currentContextId)]}(e.name,n,r);null!=t&&t.forEach(e=>{if(e&&!e.kept&&!s.has(e.id)){const t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}})}}))}executeAsync(e,t){var n=this;return jd(function*(){return n._executeAsync(e,t)})()}_executeAsync(e,t,n=!1,r={},s={}){var o=this;return jd(function*(){n||(e=o.mapInputs(e),o.checkInputs(e),o.checkInputShapeAndType(e),t=o.mapOutputs(t),o.checkOutputs(t));const i=new Ik(o.weightMap,r,s,o.functionExecutorMap),a=yield o.executeWithControlFlow(e,i,t,n),u=t.map(e=>Zw(e,a,i)),l=u.map(e=>e.id),c=Object.keys(e).map(t=>e[t].id),h=new Set([...l,...c,...o.weightIds]);return Object.keys(a).forEach(e=>{a[e].forEach(e=>{!e||e.kept||e.isDisposed||h.has(e.id)||e.dispose()})}),null==o.parent&&i.dispose(h),u})()}executeFunctionAsync(e,t,n){var r=this;return jd(function*(){const s=e.reduce((e,t,n)=>(e[r.inputs[n].name]=t,e),{});return r._executeAsync(s,r.outputNodes,!0,t,n)})()}executeWithControlFlow(e,t,n,r){var s=this;return jd(function*(){const o=Object.keys(e),i=o.map(e=>s.graph.nodes[tC(e)[0]]),a=n.map(e=>tC(e)[0]);let u=a.map(e=>s.graph.nodes[e]);0===u.length&&(u=s._outputs);const{usedNodes:l,missingInputs:c,dynamicNode:h,syncInputs:d}=Nk(e,u,s.weightMap,s._initNodes),p=[...i,...s.graph.weights,...s._initNodes||[]].map(e=>({node:e,contexts:t.currentContext})),f=Object.assign({},s.weightMap);Object.keys(e).forEach(t=>{const[n,r]=tC(t),s=[];s[r]=e[t],f[n]=s});const m={},g=s.getFrozenTensorIds(f),y={};for(;p.length>0;){const e=s.processStack(i,p,t,f,y,g,a,m,l);yield Promise.all(e)}null!=h||r||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const x=u.filter(e=>!Ok(e)&&!Zw(e.name,f,t)).map(e=>e.name);if(x.length>0){let e="";throw null!=h&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${x}] from the provided inputs [${o}]. Consider providing the following inputs: [${c}]. ${e}`)}return f})()}processStack(e,t,n,r,s,o,i,a,u){const l=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let c="";if("Enter"===e.node.op&&Qw("isConstant",e.node,r,n)&&([c]=Jw(e.node.name,n)),null==r[e.node.name]){const h=Tk(e.node,r,n,this._resourceManager);c||([c]=Jw(e.node.name,n));const d=n.currentContext;Sp(h)?l.push(h.then(l=>(r[c]=l,n.currentContext=d,this.checkTensorForDisposal(c,e.node,r,n,o,i,a),this.processChildNodes(e.node,t,n,r,s,u),l))):(r[c]=h,this.checkTensorForDisposal(c,e.node,r,n,o,i,a),this.processChildNodes(e.node,t,n,r,s,u))}else this.processChildNodes(e.node,t,n,r,s,u)}return l}processChildNodes(e,t,n,r,s,o){e.children.forEach(e=>{const[i]=Jw(e.name,n);!s[i]&&o.has(e.name)&&("Merge"===e.op?e.inputNames.some(e=>!!Zw(e,r,n))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every(e=>!!Zw(e,r,n))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(e=>e.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const n=e[t],[r]=tC(t),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){const e=s.attrParams.shape.value;Qd(e.length===n.shape.length&&n.shape.every((t,n)=>-1===e[n]||e[n]===t),()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&Qd(n.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(e){const t={};for(const n in e)null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[n]?t[this._signature.inputs[n].name]=e[n]:t[n]=e[n];return t}checkInputs(e){const t=Object.keys(e).filter(e=>{const[t]=tC(e);return null==this.graph.nodes[t]});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(e=>null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[e]?this._signature.outputs[e].name:e,{})}checkOutputs(e){e.forEach(e=>{const[t]=tC(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)})}}class Mk{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}class Lk{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",null==t&&(this.loadOptions={}),this.resourceManager=new Mk}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=ox(e,this.loadOptions);else{const t=_y.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(ox(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){var e=this;return jd(function*(){if(e.findIOHandler(),null==e.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=yield e.handler.load();return e.loadSync(t)})()}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let n;n=null!=this.artifacts.userDefinedMetadata&&null!=this.artifacts.userDefinedMetadata.signature?this.artifacts.userDefinedMetadata.signature:this.artifacts.signature,this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const r=function(e,t){const n={};let r,s=0;for(const o of t){const t=o.name,i=o.dtype,a=o.shape,u=tp(a);let l;if("quantization"in o){const n=o.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${o.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${o.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==i)throw new Error(`Weight ${o.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${i}.`)}const a=yy[n.dtype],c=e.slice(s,s+u*a),h="uint8"===n.dtype?new Uint8Array(c):new Uint16Array(c);if("float32"===i)if("uint8"===n.dtype||"uint16"===n.dtype){l=new Float32Array(h.length);for(let e=0;e<h.length;e++)l[e]=h[e]*n.scale+n.min}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===r&&(r=Cy()),l=r(h)}else{if("int32"!==i)throw new Error(`Unsupported dtype in weight '${t}': ${i}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);l=new Int32Array(h.length);for(let e=0;e<h.length;e++)l[e]=Math.round(h[e]*n.scale+n.min)}s+=u*a}else if("string"===i){const t=tp(o.shape);l=[];for(let n=0;n<t;n++){const t=new Uint32Array(e.slice(s,s+4))[0];s+=4;const n=new Uint8Array(e.slice(s,s+t));l.push(n),s+=t}}else{const r=yy[i],o=e.slice(s,s+u*r);if("float32"===i)l=new Float32Array(o);else if("int32"===i)l=new Int32Array(o);else if("bool"===i)l=new Uint8Array(o);else{if("complex64"!==i)throw new Error(`Unsupported dtype in weight '${t}': ${i}`);{l=new Float32Array(o);const e=new Float32Array(l.length/2),r=new Float32Array(l.length/2);for(let t=0;t<e.length;t++)e[t]=l[2*t],r[t]=l[2*t+1];const s=gy(e,a,"float32"),i=gy(r,a,"float32");n[t]=fy(s,i),s.dispose(),i.dispose()}}s+=u*r}"complex64"!==i&&(n[t]=gy(l,a,i))}return n}(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Pk(_C.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=_C.Instance.transformGraph(e.modelInitializer);this.initializer=new Pk(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}save(e,t){var n=this;return jd(function*(){if("string"==typeof e){const t=_y.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(n.artifacts)})()}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof Ug||Array.isArray(e)))return e;if((e=Array.isArray(e)?e:[e]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,n,r)=>(t[n]=e[r],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}executeAsync(e,t){var n=this;return jd(function*(){e=n.normalizeInputs(e),t=n.normalizeOutputs(t);const r=yield n.executor.executeAsync(e,t);return r.length>1?r:r[0]})()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}function Bk(e){return Vk.apply(this,arguments)}function Vk(){return(Vk=jd(function*(e,t={}){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&null==e.load&&(e.endsWith("/")||(e+="/"),e=`${e}model.json?tfjs-format=file`);const n=new Lk(e,t);return yield n.load(),n})).apply(this,arguments)}var Uk=function(){return(Uk=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var s in t=arguments[n])Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s]);return e}).apply(this,arguments)};function zk(e,t,n,r){return new(n||(n=Promise))(function(s,o){function i(e){try{u(r.next(e))}catch(e){o(e)}}function a(e){try{u(r.throw(e))}catch(e){o(e)}}function u(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n(function(e){e(t)})).then(i,a)}u((r=r.apply(e,t||[])).next())})}function Wk(e,t){var n,r,s,o,i={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function a(o){return function(a){return function(o){if(n)throw new TypeError("Generator is already executing.");for(;i;)try{if(n=1,r&&(s=2&o[0]?r.return:o[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,o[1])).done)return s;switch(r=0,s&&(o=[2&o[0],s.value]),o[0]){case 0:case 1:s=o;break;case 4:return i.label++,{value:o[1],done:!1};case 5:i.label++,r=o[1],o=[0];continue;case 7:o=i.ops.pop(),i.trys.pop();continue;default:if(!((s=(s=i.trys).length>0&&s[s.length-1])||6!==o[0]&&2!==o[0])){i=0;continue}if(3===o[0]&&(!s||o[1]>s[0]&&o[1]<s[3])){i.label=o[1];break}if(6===o[0]&&i.label<s[1]){i.label=s[1],s=o;break}if(s&&i.label<s[2]){i.label=s[2],i.ops.push(o);break}s[2]&&i.ops.pop(),i.trys.pop();continue}o=t.call(e,i)}catch(e){o=[6,e],r=0}finally{n=s=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,a])}}}var jk=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],Hk=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"],Gk={left:[1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31],right:[4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32],middle:[0]},qk={left:[1,3,5,7,9,11,13,15],right:[2,4,6,8,10,12,14,16],middle:[0]},Kk=[[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[5,11],[6,8],[6,12],[7,9],[8,10],[11,12],[11,13],[12,14],[13,15],[14,16]],Xk=[[0,1],[0,4],[1,2],[2,3],[3,7],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[11,23],[12,14],[14,16],[12,24],[13,15],[15,17],[16,18],[16,20],[15,17],[15,19],[15,21],[16,22],[17,19],[18,20],[23,25],[23,24],[24,26],[25,27],[26,28],[27,29],[28,30],[27,31],[28,32],[29,31],[30,32]],Yk={runtime:"mediapipe",enableSmoothing:!0,modelType:"full"},Qk=function(){function e(e){var t,n=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new Hd.Pose({locateFile:function(t,n){return e.solutionPath?e.solutionPath.replace(/\/+$/,"")+"/"+t:n+"/"+t}}),e.modelType){case"lite":t=0;break;case"heavy":t=2;break;case"full":default:t=1}this.poseSolution.setOptions({modelComplexity:t,smoothLandmarks:e.enableSmoothing||!0,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(e){n.height=e.image.height,n.width=e.image.width,n.poses=n.translateOutputs(e)})}return e.prototype.translateOutputs=function(e){var t=this;return null!=e.poseLandmarks?[{keypoints:e.poseLandmarks.map(function(e,n){return{x:e.x*t.width,y:e.y*t.height,z:e.z,score:e.visibility,name:Hk[n]}})}]:[]},e.prototype.estimatePoses=function(e,t,n){return zk(this,void 0,void 0,function(){return Wk(this,function(r){switch(r.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),[4,this.poseSolution.send({image:e},n)];case 1:return r.sent(),[2,this.poses]}})})},e.prototype.dispose=function(){this.poseSolution.close()},e.prototype.reset=function(){this.poseSolution.reset()},e.prototype.initialize=function(){return this.poseSolution.initialize()},e}();function Zk(e){return zk(this,void 0,void 0,function(){var t,n;return Wk(this,function(r){switch(r.label){case 0:return t=function(e){if(null==e)return Uk({},Yk);var t=Uk({},e);return t.runtime="mediapipe",null==t.enableSmoothing&&(t.enableSmoothing=Yk.enableSmoothing),null==t.modelType&&(t.modelType=Yk.modelType),t}(e),[4,(n=new Qk(t)).initialize()];case 1:return r.sent(),[2,n]}})})}function Jk(e){return e instanceof Ug?{height:e.shape[0],width:e.shape[1]}:{height:e.height,width:e.width}}function eE(e){return e-2*Math.PI*Math.floor((e+Math.PI)/(2*Math.PI))}function tE(e){return e instanceof Ug?e:ax(e)}function nE(e,t){Qd(0!==e.width,function(){return t+" width cannot be 0."}),Qd(0!==e.height,function(){return t+" height cannot be 0."})}function rE(e,t,n){var r=t.inputResolution,s=t.keepAspectRatio,o=Jk(e),i=function(e,t){return t?{xCenter:t.xCenter*e.width,yCenter:t.yCenter*e.height,width:t.width*e.width,height:t.height*e.height,rotation:t.rotation}:{xCenter:.5*e.width,yCenter:.5*e.height,width:e.width,height:e.height,rotation:0}}(o,n),a=function(e,t,n){if(void 0===n&&(n=!1),!n)return{top:0,left:0,right:0,bottom:0};var r=t.height,s=t.width;nE(t,"targetSize"),nE(e,"roi");var o,i,a=r/s,u=e.height/e.width,l=0,c=0;return a>u?(o=e.width,i=e.width*a,c=(1-u/a)/2):(o=e.height/a,i=e.height,l=(1-a/u)/2),e.width=o,e.height=i,{top:c,left:l,right:l,bottom:c}}(i,r,s);return{imageTensor:nv(function(){var t=tE(e),n=Ux(function(e,t,n,r){nE(r,"inputResolution");var s=1/t.width,o=1/t.height,i=e.xCenter,a=e.yCenter,u=Math.cos(e.rotation),l=Math.sin(e.rotation),c=e.width,h=e.height;return[1/r.width*c*u*1*s*t.width,1/r.height*-h*l*s*t.width,(-.5*c*u*1+.5*h*l+i)*s*t.width,1/r.width*c*l*1*o*t.height,1/r.height*h*u*o*t.height,(-.5*h*u-.5*c*l*1+a)*o*t.height,0,0]}(i,o,0,r),[1,8]);return $v.transform(Rx(Ky(t,"float32")),n,"bilinear","nearest",0,[r.height,r.width])}),padding:a}}function sE(e){return null!=e&&null!=e.currentTime}var oE=function(){function e(e){this.alpha=e,this.initialized=!1}return e.prototype.apply=function(e,t){var n;return this.initialized?n=null==t?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*t*Math.asinh((e-this.storedValue)/t):(n=e,this.initialized=!0),this.rawValue=e,this.storedValue=n,n},e.prototype.applyWithAlpha=function(e,t,n){return this.alpha=t,this.apply(e,n)},e.prototype.hasLastRawValue=function(){return this.initialized},e.prototype.lastRawValue=function(){return this.rawValue},e.prototype.reset=function(){this.initialized=!1},e}(),iE=function(){function e(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new oE(this.getAlpha(this.minCutOff)),this.dx=new oE(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return e.prototype.apply=function(e,t,n){if(null==e)return e;var r=Math.trunc(t);if(this.lastTimestamp>=r)return e;0!==this.lastTimestamp&&0!==r&&(this.frequency=1/(1e-6*(r-this.lastTimestamp))),this.lastTimestamp=r;var s=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*n*this.frequency:0,o=this.dx.applyWithAlpha(s,this.getAlpha(this.derivateCutOff)),i=this.minCutOff+this.beta*Math.abs(o),a=null!=this.thresholdCutOff?this.thresholdCutOff+this.thresholdBeta*Math.abs(o):null;return this.x.applyWithAlpha(e,this.getAlpha(i),a)},e.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},e}(),aE=function(){function e(e){this.config=e}return e.prototype.apply=function(e,t,n){var r=this;if(null==e)return this.reset(),null;this.initializeFiltersIfEmpty(e);var s=1;if(null!=this.config.minAllowedObjectScale){if(n<this.config.minAllowedObjectScale)return e.slice();s=1/n}return e.map(function(e,n){var o=Uk({},e,{x:r.xFilters[n].apply(e.x,t,s),y:r.yFilters[n].apply(e.y,t,s)});return null!=e.z&&(o.z=r.zFilters[n].apply(e.z,t,s)),o})},e.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},e.prototype.initializeFiltersIfEmpty=function(e){var t=this;null!=this.xFilters&&this.xFilters.length===e.length||(this.xFilters=e.map(function(e){return new iE(t.config)}),this.yFilters=e.map(function(e){return new iE(t.config)}),this.zFilters=e.map(function(e){return new iE(t.config)}))},e}();function uE(e,t){return e.map(function(e){var n=Uk({},e,{x:e.x/t.width,y:e.y/t.height});return null!=e.z&&(e.z=e.z/t.width),n})}var lE=function(){function e(e){this.config=e,this.window=[],this.lowPassFilter=new oE(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return e.prototype.apply=function(e,t,n){if(null==e)return e;var r,s=Math.trunc(t);if(this.lastTimestamp>=s)return e;if(-1===this.lastTimestamp)r=1;else{for(var o=e*n-this.lastValue*this.lastValueScale,i=s-this.lastTimestamp,a=o,u=i,l=(1+this.window.length)*(1e6/30),c=0,h=this.window;c<h.length;c++){var d=h[c];if(u+d.duration>l)break;a+=d.distance,u+=d.duration}r=1-1/(1+this.config.velocityScale*Math.abs(a/(1e-6*u))),this.window.unshift({distance:o,duration:i}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=n,this.lastTimestamp=s,this.lowPassFilter.applyWithAlpha(e,r)},e}(),cE=function(){function e(e){this.config=e}return e.prototype.apply=function(e,t,n){var r=this;if(null==e)return this.reset(),null;var s=1;if(!this.config.disableValueScaling){if(n<this.config.minAllowedObjectScale)return e.slice();s=1/n}return this.initializeFiltersIfEmpty(e),e.map(function(e,n){var o=Uk({},e,{x:r.xFilters[n].apply(e.x,t,s),y:r.yFilters[n].apply(e.y,t,s)});return null!=e.z&&(o.z=r.zFilters[n].apply(e.z,t,s)),o})},e.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},e.prototype.initializeFiltersIfEmpty=function(e){var t=this;null!=this.xFilters&&this.xFilters.length===e.length||(this.xFilters=e.map(function(e){return new lE(t.config)}),this.yFilters=e.map(function(e){return new lE(t.config)}),this.zFilters=e.map(function(e){return new lE(t.config)}))},e}();function hE(e,t){return e.map(function(e){var n=Uk({},e,{x:e.x*t.width,y:e.y*t.height});return null!=e.z&&(n.z=e.z*t.width),n})}var dE=function(){function e(e){if(null!=e.velocityFilter)this.keypointsFilter=new cE(e.velocityFilter);else{if(null==e.oneEuroFilter)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+e+".");this.keypointsFilter=new aE(e.oneEuroFilter)}}return e.prototype.apply=function(e,t,n,r,s){if(void 0===r&&(r=!1),null==e)return this.keypointsFilter.reset(),null;var o=null!=s?function(e,t){return(e.width*t.width+e.height*t.height)/2}(s,n):1,i=r?hE(e,n):e,a=this.keypointsFilter.apply(i,t,o);return r?uE(a,n):a},e}();function pE(e,t){var n=function(e,t,n,r){var s=(r-n)/255;return{scale:s,offset:n-0*s}}(0,0,t[0],t[1]);return nv(function(){return kx(Ax(e,n.scale),n.offset)})}function fE(e,t,n){var r=n.rotationVectorStartKeypointIndex,s=n.rotationVectorEndKeypointIndex,o=e.locationData,i=o.relativeKeypoints[r].x*t.width,a=o.relativeKeypoints[r].y*t.height,u=o.relativeKeypoints[s].x*t.width,l=o.relativeKeypoints[s].y*t.height,c=2*Math.sqrt((u-i)*(u-i)+(l-a)*(l-a)),h=function(e,t,n){var r=e.locationData,s=n.rotationVectorStartKeypointIndex,o=n.rotationVectorEndKeypointIndex;return eE((n.rotationVectorTargetAngle?n.rotationVectorTargetAngle:Math.PI*n.rotationVectorTargetAngleDegree/180)-Math.atan2(-(r.relativeKeypoints[o].y*t.height-r.relativeKeypoints[s].y*t.height),r.relativeKeypoints[o].x*t.width-r.relativeKeypoints[s].x*t.width))}(e,t,n);return{xCenter:i/t.width,yCenter:a/t.height,width:c/t.width,height:c/t.height,rotation:h}}function mE(e,t,n,r){return 1===r?.5*(e+t):e+(t-e)*n/(r-1)}function gE(e){for(var t={locationData:{relativeKeypoints:[]}},n=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,s=Number.MAX_SAFE_INTEGER,o=Number.MIN_SAFE_INTEGER,i=0;i<e.length;++i){var a=e[i];n=Math.min(n,a.x),r=Math.max(r,a.x),s=Math.min(s,a.y),o=Math.max(o,a.y),t.locationData.relativeKeypoints.push({x:a.x,y:a.y})}return t.locationData.relativeBoundingBox={xMin:n,yMin:s,xMax:r,yMax:o,width:r-n,height:o-s},t}function yE(e,t,n,r){return zk(this,void 0,void 0,function(){var s,o,i,a,u;return Wk(this,function(l){switch(l.label){case 0:return s=Ux(e.map(function(e){return[e.locationData.relativeBoundingBox.yMin,e.locationData.relativeBoundingBox.xMin,e.locationData.relativeBoundingBox.yMax,e.locationData.relativeBoundingBox.xMax]})),o=Vx(e.map(function(e){return e.score[0]})),[4,$v.nonMaxSuppressionAsync(s,o,t,n,r)];case 1:return[4,(i=l.sent()).array()];case 2:return a=l.sent(),u=e.filter(function(e,t){return a.indexOf(t)>-1}),rv([s,o,i]),[2,u]}})})}function xE(e,t,n){return zk(this,void 0,void 0,function(){var r,s,o,i,a,u,l,c,h,d,p,f,m,g,y,x,b,v,w,C,_,k,E;return Wk(this,function(S){switch(S.label){case 0:if(r=Mx(t,[0]),o=(s=r.shape)[0],i=s[1],e.length!==(a=s[2]))throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+e.length+", heatmap length: "+a);return u=[],[4,r.buffer()];case 1:for(l=S.sent(),c=0;c<e.length;c++)if(h=Uk({},e[c]),u.push(h),d=Math.trunc(h.x*i),p=Math.trunc(h.y*o),!(d<0||d>=i||p<0||d>=o)){for(f=Math.trunc((n.kernelSize-1)/2),m=Math.max(0,d-f),g=Math.min(i,d+f+1),y=Math.max(0,p-f),x=Math.min(o,p+f+1),b=0,v=0,w=0,C=0,_=y;_<x;++_)for(k=m;k<g;++k)E=l.get(_,k,c),b+=E,C=Math.max(C,E),v+=k*E,w+=_*E;C>=n.minConfidenceToRefine&&b>0&&(h.x=v/i/b,h.y=w/o/b)}return r.dispose(),[2,u]}})})}function bE(e,t,n){return zk(this,void 0,void 0,function(){var r,s,o,i;return Wk(this,function(a){switch(a.label){case 0:return r=e[0],s=function(e,t,n){return nv(function(){var r,s,o,i;n.reverseOutputOrder?(s=Mx(Px(e,[0,n.boxCoordOffset+0],[-1,1])),r=Mx(Px(e,[0,n.boxCoordOffset+1],[-1,1])),i=Mx(Px(e,[0,n.boxCoordOffset+2],[-1,1])),o=Mx(Px(e,[0,n.boxCoordOffset+3],[-1,1]))):(r=Mx(Px(e,[0,n.boxCoordOffset+0],[-1,1])),s=Mx(Px(e,[0,n.boxCoordOffset+1],[-1,1])),o=Mx(Px(e,[0,n.boxCoordOffset+2],[-1,1])),i=Mx(Px(e,[0,n.boxCoordOffset+3],[-1,1]))),s=kx(Ax(Nx(s,n.xScale),t.w),t.x),r=kx(Ax(Nx(r,n.yScale),t.h),t.y),n.applyExponentialOnBoxSize?(o=Ax($x(Nx(o,n.hScale)),t.h),i=Ax($x(Nx(i,n.wScale)),t.w)):(o=Ax(Nx(o,n.hScale),t.h),i=Ax(Nx(i,n.wScale),t.h));var a=Bx(r,Nx(o,2)),u=Bx(s,Nx(i,2)),l=kx(r,Nx(o,2)),c=kx(s,Nx(i,2)),h=Tx([Ox(a,[n.numBoxes,1]),Ox(u,[n.numBoxes,1]),Ox(l,[n.numBoxes,1]),Ox(c,[n.numBoxes,1])],1);if(n.numKeypoints)for(var d=0;d<n.numKeypoints;++d){var p=n.keypointCoordOffset+d*n.numValuesPerKeypoint,f=void 0,m=void 0;n.reverseOutputOrder?(f=Mx(Px(e,[0,p],[-1,1])),m=Mx(Px(e,[0,p+1],[-1,1]))):(m=Mx(Px(e,[0,p],[-1,1])),f=Mx(Px(e,[0,p+1],[-1,1])));var g=kx(Ax(Nx(f,n.xScale),t.w),t.x),y=kx(Ax(Nx(m,n.yScale),t.h),t.y);h=Tx([h,Ox(g,[n.numBoxes,1]),Ox(y,[n.numBoxes,1])],1)}return h})}(e[1],t,n),o=nv(function(){var e=r;return n.sigmoidScore?(null!=n.scoreClippingThresh&&(e=Sx(r,-n.scoreClippingThresh,n.scoreClippingThresh)),e=Dx(e)):e}),[4,vE(s,o,n)];case 1:return i=a.sent(),rv([s,o]),[2,i]}})})}function vE(e,t,n){return zk(this,void 0,void 0,function(){var r,s,o,i,a,u,l,c,h,d,p;return Wk(this,function(f){switch(f.label){case 0:return r=[],[4,e.data()];case 1:return s=f.sent(),[4,t.data()];case 2:for(o=f.sent(),i=0;i<n.numBoxes;++i)if(!(null!=n.minScoreThresh&&o[i]<n.minScoreThresh||(a=i*n.numCoords,u=wE(s[a+0],s[a+1],s[a+2],s[a+3],o[i],n.flipVertically,i),(l=u.locationData.relativeBoundingBox).width<0||l.height<0))){if(n.numKeypoints>0)for((c=u.locationData).relativeKeypoints=[],h=n.numKeypoints*n.numValuesPerKeypoint,d=0;d<h;d+=n.numValuesPerKeypoint)c.relativeKeypoints.push({x:s[(p=a+n.keypointCoordOffset+d)+0],y:n.flipVertically?1-s[p+1]:s[p+1]});r.push(u)}return[2,r]}})})}function wE(e,t,n,r,s,o,i){return{score:[s],ind:i,locationData:{relativeBoundingBox:{xMin:t,yMin:o?1-n:e,xMax:r,yMax:o?1-e:n,width:r-t,height:n-e}}}}function CE(e,t,n,r){return void 0===n&&(n=!1),void 0===r&&(r=!1),zk(this,void 0,void 0,function(){var s,o,i,a,u,l,c;return Wk(this,function(h){switch(h.label){case 0:return s=e.size/t.numLandmarks,[4,e.data()];case 1:for(o=h.sent(),i=[],a=0;a<t.numLandmarks;++a)u=a*s,(c={x:0,y:0}).x=n?t.inputImageWidth-o[u]:o[u],s>1&&(c.y=r?t.inputImageHeight-o[u+1]:o[u+1]),s>2&&(c.z=o[u+2]),s>3&&(c.score=1/(1+Math.exp(-o[u+3]))),i.push(c);for(l=0;l<i.length;++l)(c=i[l]).x=c.x/t.inputImageWidth,c.y=c.y/t.inputImageHeight,c.z=c.z/t.inputImageWidth/(t.normalizeZ||1);return[2,i]}})})}function _E(e,t,n){var r=e.width,s=e.height,o=e.rotation;if(null==n.rotation&&null==n.rotationDegree||(o=function(e,t){return null!=t.rotation?e+=t.rotation:null!=t.rotationDegree&&(e+=Math.PI*t.rotationDegree/180),eE(e)}(o,n)),0===o)e.xCenter=e.xCenter+r*n.shiftX,e.yCenter=e.yCenter+s*n.shiftY;else{var i=(t.width*r*n.shiftX*Math.cos(o)-t.height*s*n.shiftY*Math.sin(o))/t.width,a=(t.width*r*n.shiftX*Math.sin(o)+t.height*s*n.shiftY*Math.cos(o))/t.height;e.xCenter=e.xCenter+i,e.yCenter=e.yCenter+a}if(n.squareLong){var u=Math.max(r*t.width,s*t.height);r=u/t.width,s=u/t.height}else if(n.squareShort){var l=Math.min(r*t.width,s*t.height);r=l/t.width,s=l/t.height}return e.width=r*n.scaleX,e.height=s*n.scaleY,e}var kE,EE,SE=function(){function e(e){this.alpha=e.alpha}return e.prototype.apply=function(e){var t=this;if(null==e)return this.visibilityFilters=null,null;null!=this.visibilityFilters&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map(function(e){return new oE(t.alpha)}));for(var n=[],r=0;r<e.length;++r){var s=e[r],o=Uk({},s);o.score=this.visibilityFilters[r].apply(s.score),n.push(o)}return n},e}(),TE={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},IE={runtime:"tfjs",modelType:"full",enableSmoothing:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazeposedetector/1/default/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazeposelandmark_full/1/default/1"},NE={maxPoses:1,flipHorizontal:!1},$E={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},RE={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},AE={inputResolution:{width:224,height:224},keepAspectRatio:!0},OE={inputResolution:{width:256,height:256},keepAspectRatio:!0},FE={numLandmarks:39,inputImageWidth:256,inputImageHeight:256},DE={kernelSize:7,minConfidenceToRefine:.5},PE={alpha:.1},ME={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},LE={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},BE=function(){function e(e,t,n,r){this.detectorModel=e,this.landmarkModel=t,this.enableSmoothing=n,this.modelType=r,this.regionOfInterest=null,this.anchors=function(e){for(var t=[],n=0;n<e.numLayers;){for(var r=[],s=[],o=[],i=[],a=n;a<e.strides.length&&e.strides[a]===e.strides[n];){var u=mE(e.minScale,e.maxScale,a,e.strides.length);if(0===a&&e.reduceBoxesInLowestLayer)o.push(1),o.push(2),o.push(.5),i.push(.1),i.push(u),i.push(u);else{for(var l=0;l<e.aspectRatios.length;++l)o.push(e.aspectRatios[l]),i.push(u);if(e.interpolatedScaleAspectRatio>0){var c=a===e.strides.length-1?1:mE(e.minScale,e.maxScale,a+1,e.strides.length);i.push(Math.sqrt(u*c)),o.push(e.interpolatedScaleAspectRatio)}}a++}for(var h=0;h<o.length;++h){var d=Math.sqrt(o[h]);r.push(i[h]/d),s.push(i[h]*d)}var p=0,f=0;if(e.featureMapHeight.length>0)p=e.featureMapHeight[n],f=e.featureMapWidth[n];else{var m=e.strides[n];p=Math.ceil(e.inputSizeHeight/m),f=Math.ceil(e.inputSizeWidth/m)}for(var g=0;g<p;++g)for(var y=0;y<f;++y)for(var x=0;x<r.length;++x){var b={xCenter:(y+e.anchorOffsetX)/f,yCenter:(g+e.anchorOffsetY)/p,width:0,height:0};e.fixedAnchorSize?(b.width=1,b.height=1):(b.width=s[x],b.height=r[x]),t.push(b)}n=a}return t}(TE);var s=Vx(this.anchors.map(function(e){return e.width})),o=Vx(this.anchors.map(function(e){return e.height})),i=Vx(this.anchors.map(function(e){return e.xCenter})),a=Vx(this.anchors.map(function(e){return e.yCenter}));this.anchorTensor={x:i,y:a,w:s,h:o}}return e.prototype.estimatePoses=function(e,t,n){return zk(this,void 0,void 0,function(){var r,s,o,i,a,u,l,c,h,d,p;return Wk(this,function(f){switch(f.label){case 0:return r=function(e){var t;if(null==(t=null==e?NE:Uk({},e)).maxPoses&&(t.maxPoses=1),t.maxPoses<=0)throw new Error("Invalid maxPoses "+t.maxPoses+". Should be > 0.");if(t.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return t}(t),null==e?(this.reset(),[2,[]]):(this.maxPoses=r.maxPoses,this.timestamp=null!=n?1e3*n:sE(e)?1e6*e.currentTime:null,s=Jk(e),o=nv(function(){return Ky(tE(e),"float32")}),null!=(i=this.regionOfInterest)?[3,2]:[4,this.detectPose(o)]);case 1:if(0===(a=f.sent()).length)return this.reset(),o.dispose(),[2,[]];i=this.poseDetectionToRoi(a[0],s),f.label=2;case 2:return[4,this.poseLandmarksByRoi(i,o)];case 3:return u=f.sent(),o.dispose(),null==u?(this.reset(),[2,[]]):(l=u.poseScore,c=this.poseLandmarkFiltering(u.actualLandmarks,u.auxiliaryLandmarks,s),h=c.actualLandmarksFiltered,d=this.poseLandmarksToRoi(c.auxiliaryLandmarksFiltered,s),this.regionOfInterest=d,null!=(p=null!=h?hE(h,s):null)&&p.forEach(function(e,t){e.name=Hk[t]}),[2,[{score:l,keypoints:p}]])}})})},e.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),rv([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h])},e.prototype.reset=function(){this.regionOfInterest=null,this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},e.prototype.detectPose=function(e){return zk(this,void 0,void 0,function(){var t,n,r,s,o,i,a,u,l;return Wk(this,function(c){switch(c.label){case 0:return t=rE(e,AE),r=t.padding,s=pE(n=t.imageTensor,[-1,1]),o=function(e,t){return nv(function(){var n=function(e){return nv(function(){var t=Px(e,[0,0,0],[1,-1,1]);return[Dx(t),Px(e,[0,0,1],[1,-1,-1])]})}(t.predict(e)),r=n[0];return{boxes:Mx(n[1]),scores:Mx(r)}})}(s,this.detectorModel),[4,bE([a=o.scores,i=o.boxes],this.anchorTensor,$E)];case 1:return[4,yE(c.sent(),this.maxPoses,.3,-1)];case 2:return u=c.sent(),l=function(e,t){void 0===e&&(e=[]);for(var n=t.left,r=t.top,s=t.left+t.right,o=t.top+t.bottom,i=0;i<e.length;i++){var a=e[i],u=a.locationData.relativeBoundingBox,l=(u.yMin-r)/(1-o),c=u.width/(1-s),h=u.height/(1-o);u.xMin=(u.xMin-n)/(1-s),u.yMin=l,u.width=c,u.height=h;for(var d=0;d<a.locationData.relativeKeypoints.length;++d){var p=a.locationData.relativeKeypoints[d],f=(p.y-r)/(1-o);p.x=(p.x-n)/(1-s),p.y=f}}return e}(u,r),rv([n,s,a,i]),[2,l]}})})},e.prototype.poseDetectionToRoi=function(e,t){return _E(fE(e,t,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),t,RE)},e.prototype.poseLandmarksByRoi=function(e,t){return zk(this,void 0,void 0,function(){var n,r,s,o,i,a,u,l,c,h,d,p,f,m;return Wk(this,function(g){switch(g.label){case 0:switch(n=rE(t,OE,e),s=n.padding,o=pE(r=n.imageTensor,[0,1]),i=this.landmarkModel.predict(o),this.modelType){case"lite":a=i[2],u=i[4],l=i[3];break;case"full":a=i[4],u=i[3],l=i[1];break;case"heavy":a=i[3],u=i[1],l=i[4];break;default:throw new Error("Model type must be one of lite, full or heavy,but got "+this.modelType)}return[4,u.data()];case 1:return(c=g.sent()[0])<.5?(rv(i),rv([r,o]),[2,null]):[4,CE(a,FE)];case 2:return[4,xE(g.sent(),l,DE)];case 3:return h=g.sent(),d=function(e,t){var n=t.left,r=t.top,s=t.left+t.right,o=t.top+t.bottom;return e.map(function(e){return Uk({},e,{x:(e.x-n)/(1-s),y:(e.y-r)/(1-o),z:e.z/(1-s)})})}(h,s),p=function(e,t,n){void 0===n&&(n={ignoreRotation:!1});for(var r=[],s=0,o=e;s<o.length;s++){var i=o[s],a=i.x-.5,u=i.y-.5,l=n.ignoreRotation?0:t.rotation,c=Math.cos(l)*a-Math.sin(l)*u,h=Math.sin(l)*a+Math.cos(l)*u;c=c*t.width+t.xCenter,h=h*t.height+t.yCenter;var d=i.z*t.width,p=Uk({},i);p.x=c,p.y=h,p.z=d,r.push(p)}return r}(d,e),f=p.slice(0,33),m=p.slice(33,35),rv(i),rv([r,o]),[2,{actualLandmarks:f,auxiliaryLandmarks:m,poseScore:c}]}})})},e.prototype.poseLandmarksToRoi=function(e,t){return _E(fE(gE(e),t,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),t,RE)},e.prototype.poseLandmarkFiltering=function(e,t,n){var r,s;if(null!=this.timestamp&&this.enableSmoothing){var o=fE(gE(t),n,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});null==this.visibilitySmoothingFilterActual&&(this.visibilitySmoothingFilterActual=new SE(PE)),r=this.visibilitySmoothingFilterActual.apply(e),null==this.visibilitySmoothingFilterAuxiliary&&(this.visibilitySmoothingFilterAuxiliary=new SE(PE)),s=this.visibilitySmoothingFilterAuxiliary.apply(t),null==this.landmarksSmoothingFilterActual&&(this.landmarksSmoothingFilterActual=new dE(ME)),r=this.landmarksSmoothingFilterActual.apply(r,this.timestamp,n,!0,o),null==this.landmarksSmoothingFilterAuxiliary&&(this.landmarksSmoothingFilterAuxiliary=new dE(LE)),s=this.landmarksSmoothingFilterAuxiliary.apply(s,this.timestamp,n,!0,o)}else r=e,s=t;return{actualLandmarksFiltered:r,auxiliaryLandmarksFiltered:s}},e}();function VE(e){return zk(this,void 0,void 0,function(){var t,n,r,s;return Wk(this,function(o){switch(o.label){case 0:return t=function(e){var t=Uk({},null==e?IE:e);if(null==t.enableSmoothing&&(t.enableSmoothing=IE.enableSmoothing),null==t.modelType&&(t.modelType=IE.modelType),null==t.detectorModelUrl&&(t.detectorModelUrl=IE.detectorModelUrl),null==t.landmarkModelUrl)switch(t.modelType){case"lite":t.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazeposelandmark_lite/1/default/1";break;case"heavy":t.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazeposelandmark_heavy/1/default/1";break;case"full":default:t.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazeposelandmark_full/1/default/1"}return t}(e),n=t.detectorModelUrl.indexOf("https://tfhub.dev")>-1,r=t.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([Bk(t.detectorModelUrl,{fromTFHub:n}),Bk(t.landmarkModelUrl,{fromTFHub:r})])];case 1:return s=o.sent(),[2,new BE(s[0],s[1],t.enableSmoothing,t.modelType)]}})})}function UE(e){switch(e){case kE.BlazePose:return Hk.reduce(function(e,t,n){return e[t]=n,e},{});case kE.PoseNet:case kE.MoveNet:return jk.reduce(function(e,t,n){return e[t]=n,e},{});default:throw new Error("Model "+e+" is not supported.")}}(EE=kE||(kE={})).MoveNet="MoveNet",EE.BlazePose="BlazePose",EE.PoseNet="PoseNet",Object.freeze({__proto__:null,getKeypointIndexBySide:function(e){switch(e){case kE.BlazePose:return Gk;case kE.PoseNet:case kE.MoveNet:return qk;default:throw new Error("Model "+e+" is not supported.")}},getAdjacentPairs:function(e){switch(e){case kE.BlazePose:return Xk;case kE.PoseNet:case kE.MoveNet:return Kk;default:throw new Error("Model "+e+" is not supported.")}},getKeypointIndexByName:UE});var zE=["SinglePose.Lightning","SinglePose.Thunder"],WE={modelType:"SinglePose.Lightning",enableSmoothing:!0},jE={maxPoses:1},HE={frequency:30,minCutOff:6.36,beta:636.61,derivateCutOff:4.77,thresholdCutOff:.5,thresholdBeta:5},GE=function(){function e(e,t){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=UE(kE.MoveNet),this.keypointsFilter=new aE(HE),this.cropRegionFilterYMin=new oE(.9),this.cropRegionFilterXMin=new oE(.9),this.cropRegionFilterYMax=new oE(.9),this.cropRegionFilterXMax=new oE(.9),"SinglePose.Lightning"===t.modelType?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):"SinglePose.Thunder"===t.modelType&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.enableSmoothing=t.enableSmoothing}return e.prototype.detectKeypoints=function(e,t){return void 0===t&&(t=!0),zk(this,void 0,void 0,function(){var n,r,s,o,i;return Wk(this,function(a){switch(a.label){case 0:return this.moveNetModel?(n=17,t?(r=this.moveNetModel.execute(e),[3,3]):[3,1]):[2,null];case 1:return[4,this.moveNetModel.executeAsync(e)];case 2:r=a.sent(),a.label=3;case 3:return r&&4===r.shape.length&&1===r.shape[0]&&1===r.shape[1]&&r.shape[2]===n&&3===r.shape[3]?"webgpu"===ry.backendName?[3,4]:(s=r.dataSync(),[3,6]):(r.dispose(),[2,null]);case 4:return[4,r.data()];case 5:s=a.sent(),a.label=6;case 6:for(r.dispose(),o=[],i=0;i<n;++i)o[i]={y:s[3*i],x:s[3*i+1],score:s[3*i+2]};return[2,o]}})})},e.prototype.estimatePoses=function(e,t,n){return void 0===t&&(t=jE),zk(this,void 0,void 0,function(){var r,s,o,i,a,u,l,c,h,d=this;return Wk(this,function(p){switch(p.label){case 0:return t=function(e){var t=null==e?jE:Uk({},e);if(t.maxPoses||(t.maxPoses=1),t.maxPoses<=0||t.maxPoses>1)throw new Error("Invalid maxPoses "+t.maxPoses+". Should be 1.");return t}(t),null==e?(this.reset(),[2,[]]):(null==n?sE(e)&&(n=1e6*e.currentTime):n*=1e3,r=tE(e),s=Jk(r),o=Rx(r,0),e instanceof Ug||r.dispose(),this.cropRegion||(this.cropRegion=this.initCropRegion(s.width,s.height)),i=nv(function(){var e=Ux([[d.cropRegion.yMin,d.cropRegion.xMin,d.cropRegion.yMax,d.cropRegion.xMax]]),t=Wx([1],"int32");return Ky($v.cropAndResize(o,e,t,[d.modelInputResolution.height,d.modelInputResolution.width],"bilinear",0),"int32")}),o.dispose(),[4,this.detectKeypoints(i)]);case 1:if(a=p.sent(),i.dispose(),null==a)return this.reset(),[2,[]];for(h=0;h<a.length;++h)a[h].y=this.cropRegion.yMin+a[h].y*this.cropRegion.height,a[h].x=this.cropRegion.xMin+a[h].x*this.cropRegion.width;for(null!=n&&this.enableSmoothing&&(a=this.keypointsFilter.apply(a,n,1)),u=this.determineCropRegion(a,s.height,s.width),this.cropRegion=this.filterCropRegion(u),l=0,c=0,h=0;h<a.length;++h)a[h].name=jk[h],a[h].y*=s.height,a[h].x*=s.width,a[h].score>.2&&(++l,c+=a[h].score);return l>0?c/=l:this.resetFilters(),[2,[{score:c,keypoints:a}]]}})})},e.prototype.filterCropRegion=function(e){if(e){var t=this.cropRegionFilterYMin.apply(e.yMin),n=this.cropRegionFilterXMin.apply(e.xMin),r=this.cropRegionFilterYMax.apply(e.yMax),s=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:t,xMin:n,yMax:r,xMax:s,height:r-t,width:s-n}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},e.prototype.dispose=function(){this.moveNetModel.dispose()},e.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},e.prototype.resetFilters=function(){this.keypointsFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},e.prototype.torsoVisible=function(e){return(e[this.keypointIndexByName.left_hip].score>.2||e[this.keypointIndexByName.right_hip].score>.2)&&(e[this.keypointIndexByName.left_shoulder].score>.2||e[this.keypointIndexByName.right_shoulder].score>.2)},e.prototype.determineTorsoAndBodyRange=function(e,t,n,r){for(var s=["left_shoulder","right_shoulder","left_hip","right_hip"],o=0,i=0,a=0;a<s.length;a++)(d=Math.abs(n-t[s[a]][0]))>o&&(o=d),(p=Math.abs(r-t[s[a]][1]))>i&&(i=p);for(var u=0,l=0,c=0,h=Object.keys(t);c<h.length;c++){var d,p,f=h[c];e[this.keypointIndexByName[f]].score<.2||((d=Math.abs(n-t[f][0]))>u&&(u=d),(p=Math.abs(r-t[f][1]))>l&&(l=p))}return[o,i,u,l]},e.prototype.determineCropRegion=function(e,t,n){for(var r={},s=0,o=jk;s<o.length;s++){var i=o[s];r[i]=[e[this.keypointIndexByName[i]].y*t,e[this.keypointIndexByName[i]].x*n]}if(this.torsoVisible(e)){var a=(r.left_hip[0]+r.right_hip[0])/2,u=(r.left_hip[1]+r.right_hip[1])/2,l=this.determineTorsoAndBodyRange(e,r,a,u),c=Math.max(1.9*l[1],1.9*l[0],1.2*l[2],1.2*l[3]),h=[a-(c=Math.min(c,Math.max(u,n-u,a,t-a))),u-c];if(c>Math.max(n,t)/2)return this.initCropRegion(t,n);var d=2*c;return{yMin:h[0]/t,xMin:h[1]/n,yMax:(h[0]+d)/t,xMax:(h[1]+d)/n,height:(h[0]+d)/t-h[0]/t,width:(h[1]+d)/n-h[1]/n}}return this.initCropRegion(t,n)},e.prototype.initCropRegion=function(e,t){var n,r,s,o;return this.cropRegion?t>e?(n=t/e,r=1,s=(e/2-t/2)/e,o=0):(n=1,r=e/t,s=0,o=(t/2-e/2)/t):t>e?(n=1,r=e/t,s=0,o=(t/2-e/2)/t):(n=t/e,r=1,s=(e/2-t/2)/e,o=0),{yMin:s,xMin:o,yMax:s+n,xMax:o+r,height:n,width:r}},e}();function qE(e){return void 0===e&&(e=WE),zk(this,void 0,void 0,function(){var t,n,r;return Wk(this,function(s){switch(s.label){case 0:return(t=function(e){var t=null==e?WE:Uk({},e);if(e.modelType){if(zE.indexOf(t.modelType)<0)throw new Error("Invalid architecture "+t.modelType+". Should be one of "+zE)}else e.modelType="SinglePose.Lightning";return null==t.enableSmoothing&&(t.enableSmoothing=!0),t}(e)).modelUrl?[4,Bk(t.modelUrl)]:[3,2];case 1:return n=s.sent(),[3,4];case 2:return r=void 0,"SinglePose.Lightning"===t.modelType?r="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/3":"SinglePose.Thunder"===t.modelType&&(r="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/3"),[4,Bk(r,{fromTFHub:!0})];case 3:n=s.sent(),s.label=4;case 4:return[2,new GE(n,t)]}})})}var KE={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},XE=["MobileNetV1","ResNet50"],YE={MobileNetV1:[8,16],ResNet50:[16]},QE=[8,16,32],ZE={MobileNetV1:[.5,.75,1],ResNet50:[1]},JE=[1,2,4],eS={maxPoses:1,flipHorizontal:!1},tS={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},nS=[-123.15,-115.9,-103.06];function rS(e){return Math.floor(e/2)}var sS=function(){function e(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return e.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},e.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},e.prototype.empty=function(){return-1===this.numberOfElements},e.prototype.size=function(){return this.numberOfElements+1},e.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},e.prototype.max=function(){return this.priorityQueue[0]},e.prototype.swim=function(e){for(;e>0&&this.less(rS(e),e);)this.exchange(e,rS(e)),e=rS(e)},e.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},e.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},e.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},e.prototype.exchange=function(e,t){var n=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=n},e}();function oS(e,t,n,r,s,o){for(var i=o.shape,a=i[0],u=i[1],l=!0,c=Math.max(n-s,0),h=Math.min(n+s+1,a),d=c;d<h;++d){for(var p=Math.max(r-s,0),f=Math.min(r+s+1,u),m=p;m<f;++m)if(o.get(d,m,e)>t){l=!1;break}if(!l)break}return l}function iS(e){return zk(this,void 0,void 0,function(){return Wk(this,function(t){return[2,Promise.all(e.map(function(e){return e.buffer()}))]})})}function aS(e,t,n,r){return{y:r.get(e,t,n),x:r.get(e,t,n+17)}}function uS(e,t,n){var r=aS(e.heatmapY,e.heatmapX,e.id,n);return{x:e.heatmapX*t+r.x,y:e.heatmapY*t+r.y}}function lS(e,t,n,r){var s=n.x,o=n.y;return e.some(function(e){var n,i,a=e.keypoints;return(n=a[r].y-o)*n+(i=a[r].x-s)*i<=t})}var cS=jk.reduce(function(e,t,n){return e[t]=n,e},{}),hS=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(e){return[cS[e[0]],cS[e[1]]]}),dS=hS.map(function(e){return e[1]}),pS=hS.map(function(e){return e[0]});function fS(e,t,n){return e<t?t:e>n?n:e}function mS(e,t,n,r){return{y:fS(Math.round(e.y/t),0,n-1),x:fS(Math.round(e.x/t),0,r-1)}}function gS(e,t){return{x:e.x+t.x,y:e.y+t.y}}function yS(e,t,n,r,s,o,i,a){void 0===a&&(a=2);for(var u=r.shape,l=u[0],c=u[1],h={y:t.y,x:t.x},d=gS(h,function(e,t,n){var r=n.shape[2]/2;return{y:n.get(t.y,t.x,e),x:n.get(t.y,t.x,r+e)}}(e,mS(h,o,l,c),i)),p=0;p<a;p++){var f=mS(d,o,l,c),m=aS(f.y,f.x,n,s);d=gS({x:f.x*o,y:f.y*o},{x:m.x,y:m.y})}var g=mS(d,o,l,c),y=r.get(g.y,g.x,n);return{y:d.y,x:d.x,name:jk[n],score:y}}function xS(e,t,n,r,s,o){var i=dS.length,a=new Array(t.shape[2]),u=e.part,l=e.score,c=uS(u,r,n);a[u.id]={score:l,name:jk[u.id],y:c.y,x:c.x};for(var h=i-1;h>=0;--h){var d=dS[h],p=pS[h];a[d]&&!a[p]&&(a[p]=yS(h,a[d],p,t,n,r,o))}for(h=0;h<i;++h)p=dS[h],a[d=pS[h]]&&!a[p]&&(a[p]=yS(h,a[d],p,t,n,r,s));return a}function bS(e,t,n){return n.reduce(function(n,r,s){var o=r.score;return lS(e,t,{y:r.y,x:r.x},s)||(n+=o),n},0)/n.length}function vS(e,t,n,r,s,o,i,a){return void 0===i&&(i=.5),void 0===a&&(a=20),zk(this,void 0,void 0,function(){var u,l,c,h,d,p,f,m,g,y,x,b;return Wk(this,function(v){switch(v.label){case 0:return[4,iS([e,t,n,r])];case 1:for(u=v.sent(),c=u[1],h=u[2],d=u[3],p=[],f=function(e,t,n){for(var r=n.shape,s=r[0],o=r[1],i=r[2],a=new sS(s*o*i,function(e){return e.score}),u=0;u<s;++u)for(var l=0;l<o;++l)for(var c=0;c<i;++c){var h=n.get(u,l,c);h<e||oS(c,h,u,l,1,n)&&a.enqueue({score:h,part:{heatmapY:u,heatmapX:l,id:c}})}return a}(i,0,l=u[0]),m=a*a;p.length<o&&!f.empty();)g=f.dequeue(),y=uS(g.part,s,c),lS(p,m,y,g.part.id)||(x=xS(g,l,c,s,h,d),b=bS(p,m,x),p.push({keypoints:x,score:b}));return[2,p]}})})}function wS(e,t,n){return nv(function(){var r=function(e,t){for(var n=[],r=0;r<jk.length;r++){var s=CS(e.get(r,0).valueOf(),e.get(r,1).valueOf(),r,t),o=s.x;n.push(s.y),n.push(o)}return Ux(n,[jk.length,2])}(e,n);return kx(Ky(Ax(e.toTensor(),Fx(t,"int32")),"float32"),r)})}function CS(e,t,n,r){return{y:r.get(e,t,n),x:r.get(e,t,n+jk.length)}}function _S(e,t,n){return zk(this,void 0,void 0,function(){var r,s,o,i,a,u,l,c,h;return Wk(this,function(d){switch(d.label){case 0:return r=0,s=function(e){var t=e.shape,n=t[0],r=t[1],s=t[2];return nv(function(){var t,o,i=Ox(e,[n*r,s]),a=Ex(i,0),u=Rx(Nx(a,Fx(r,"int32")),1),l=Rx((t=a,o=r,nv(function(){var e=Nx(t,Fx(o,"int32"));return Bx(t,Ax(e,Fx(o,"int32")))})),1);return Tx([u,l],1)})}(e),[4,Promise.all([e.buffer(),t.buffer(),s.buffer()])];case 1:return o=d.sent(),i=o[0],[4,(u=wS(a=o[2],n,o[1])).buffer()];case 2:return l=d.sent(),c=Array.from(function(e,t){for(var n=t.shape[0],r=new Float32Array(n),s=0;s<n;s++){var o=t.get(s,0),i=t.get(s,1);r[s]=e.get(o,i,s)}return r}(i,a)),h=c.map(function(e,t){return r+=e,{y:l.get(t,0),x:l.get(t,1),score:e,name:jk[t]}}),s.dispose(),u.dispose(),[2,{keypoints:h,score:r/h.length}]}})})}function kS(e,t){return(e-1)%t==0}var ES="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",SS="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function TS(e,t){return function(e,t){return(e-1)%t==0}(e,t)?e:Math.floor(e/t)*t+1}var IS=function(){function e(e,t){this.posenetModel=e;var n=this.posenetModel.inputs[0].shape;Qd(-1===n[1]&&-1===n[2],function(){return"Input shape ["+n[1]+", "+n[2]+"] must both be equal to or -1"});var r,s,o={height:TS((r=t.inputResolution).height,s=t.outputStride),width:TS(r.width,s)};!function(e){Qd(QE.indexOf(e)>=0,function(){return"outputStride of "+e+" is invalid. It must be either 8 or 16."})}(t.outputStride),function(e,t){Qd(kS(e.height,t),function(){return"height of "+e.height+" is invalid for output stride "+t+"."}),Qd(kS(e.width,t),function(){return"width of "+e.width+" is invalid for output stride "+t+"."})}(o,t.outputStride),this.inputResolution=o,this.outputStride=t.outputStride,this.architecture=t.architecture}return e.prototype.estimatePoses=function(e,t){return void 0===t&&(t=eS),zk(this,void 0,void 0,function(){var n,r,s,o,i,a,u,l,c,h,d,p,f,m,g;return Wk(this,function(y){switch(y.label){case 0:return n=function(e){var t=e;if(null==t.maxPoses&&(t.maxPoses=1),t.maxPoses<=0)throw new Error("Invalid maxPoses "+t.maxPoses+". Should be > 0.");if(t.maxPoses>1){if((t=Uk({},tS,t)).scoreThreshold<0||t.scoreThreshold>1)throw new Error("Invalid scoreThreshold "+t.scoreThreshold+". Should be in range [0.0, 1.0]");if(t.nmsRadius<=0)throw new Error("Invalid nmsRadius "+t.nmsRadius+".")}return t}(t),null==e?[2,[]]:(this.maxPoses=n.maxPoses,r=rE(e,{inputResolution:this.inputResolution,keepAspectRatio:!0}),s=r.imageTensor,o=r.padding,i="ResNet50"===this.architecture?kx(s,nS):pE(s,[-1,1]),a=this.posenetModel.predict(i),"ResNet50"===this.architecture?(u=Mx(a[2],[0]),l=Mx(a[3],[0]),c=Mx(a[0],[0]),h=Mx(a[1],[0])):(u=Mx(a[0],[0]),l=Mx(a[1],[0]),c=Mx(a[2],[0]),h=Mx(a[3],[0])),d=Dx(l),1!==this.maxPoses?[3,2]:[4,_S(d,u,this.outputStride)]);case 1:return f=y.sent(),p=[f],[3,4];case 2:return[4,vS(d,u,c,h,this.outputStride,this.maxPoses,n.scoreThreshold,n.nmsRadius)];case 3:p=y.sent(),y.label=4;case 4:return m=Jk(e),g=function(e,t,n,r){var s=t.height/(n.height*(1-r.top-r.bottom)),o=t.width/(n.width*(1-r.left-r.right)),i=-r.top*n.height,a=-r.left*n.width;if(1===o&&1===s&&0===i&&0===a)return e;for(var u=0,l=e;u<l.length;u++)for(var c=0,h=l[u].keypoints;c<h.length;c++){var d=h[c];d.x=(d.x+a)*o,d.y=(d.y+i)*s}return e}(p,m,this.inputResolution,o),n.flipHorizontal&&(g=function(e,t){for(var n=0,r=e;n<r.length;n++)for(var s=0,o=r[n].keypoints;s<o.length;s++){var i=o[s];i.x=t.width-1-i.x}return e}(g,m)),s.dispose(),i.dispose(),rv(a),u.dispose(),l.dispose(),c.dispose(),h.dispose(),d.dispose(),[2,g]}})})},e.prototype.dispose=function(){this.posenetModel.dispose()},e.prototype.reset=function(){},e}();function NS(e){return void 0===e&&(e=KE),zk(this,void 0,void 0,function(){var t,n,r,s,o;return Wk(this,function(i){switch(i.label){case 0:return"ResNet50"!==(t=function(e){var t=e||KE;if(null==t.architecture&&(t.architecture="MobileNetV1"),XE.indexOf(t.architecture)<0)throw new Error("Invalid architecture "+t.architecture+". Should be one of "+XE);if(null==t.inputResolution&&(t.inputResolution={height:257,width:257}),null==t.outputStride&&(t.outputStride=16),YE[t.architecture].indexOf(t.outputStride)<0)throw new Error("Invalid outputStride "+t.outputStride+". Should be one of "+YE[t.architecture]+" for architecture "+t.architecture+".");if(null==t.multiplier&&(t.multiplier=1),ZE[t.architecture].indexOf(t.multiplier)<0)throw new Error("Invalid multiplier "+t.multiplier+". Should be one of "+ZE[t.architecture]+" for architecture "+t.architecture+".");if(null==t.quantBytes&&(t.quantBytes=4),JE.indexOf(t.quantBytes)<0)throw new Error("Invalid quantBytes "+t.quantBytes+". Should be one of "+JE+" for architecture "+t.architecture+".");if("MobileNetV1"===t.architecture&&32===t.outputStride&&1!==t.multiplier)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return t}(e)).architecture?[3,2]:(u="model-stride"+t.outputStride+".json",n=4===(a=t.quantBytes)?SS+"float/"+u:SS+"quant"+a+"/"+u,[4,Bk(t.modelUrl||n)]);case 1:return r=i.sent(),[2,new IS(r,t)];case 2:return s=function(e,t,n){var r={1:"100",.75:"075",.5:"050"},s="model-stride"+e+".json";return 4===n?ES+"float/"+r[t]+"/"+s:ES+"quant"+n+"/"+r[t]+"/"+s}(t.outputStride,t.multiplier,t.quantBytes),[4,Bk(t.modelUrl||s)];case 3:return o=i.sent(),[2,new IS(o,t)]}var a,u})})}var $S={keypointsToNormalizedKeypoints:uE};const RS={},AS={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function OS(e){if(!(e in RS)){const t=function(e){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=function(e){if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e);return t.addEventListener("webglcontextlost",t=>{t.preventDefault(),delete RS[e]},!1),1===e?t.getContext("webgl",AS)||t.getContext("experimental-webgl",AS):t.getContext("webgl2",AS)}(e);if(null===t)return console.log("Could not get context for WebGL version",e),null;RS[e]=t}const t=RS[e];return t.isContextLost()?(delete RS[e],OS(e)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),RS[e])}var FS=(()=>(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(FS||(FS={})),FS))(),DS=(()=>(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(DS||(DS={})),DS))(),PS=(()=>(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(PS||(PS={})),PS))();function MS(e,t){return[t,e]}function LS(e){const t=tp(e);return sp(Math.ceil(t/4))}function BS(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function VS(e,t){const n=e;let r,s,o,i,a,u,l,c,h,d;return 2===Np().getNumber("WEBGL_VERSION")?(r=n.R32F,s=n.R16F,o=n.RGBA16F,i=n.RGBA32F,a=n.RED,l=4,c=1,h=n.HALF_FLOAT,d=n.FLOAT):(r=e.RGBA,s=e.RGBA,o=e.RGBA,i=n.RGBA,a=e.RGBA,l=4,c=4,h=null!=t?t.HALF_FLOAT_OES:null,d=e.FLOAT),u=e.RGBA,{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}function US(e,t){const n=t();return Np().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),n}function zS(e){return!!(Np().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function WS(e,t){return YS(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}const jS=/ERROR: [0-9]+:([0-9]+):/g;function HS(e,t){if(US(e,()=>e.validateProgram(t)),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function GS(e,t,n,r,s,o,i){const a=e.getAttribLocation(t,n);return-1!==a&&(US(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),US(e,()=>e.vertexAttribPointer(a,s,e.FLOAT,!1,o,i)),US(e,()=>e.enableVertexAttribArray(a)),!0)}function qS(e,t,n){US(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),US(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function KS(e,t){US(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),US(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function XS(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function YS(e,t,n){const r=US(e,()=>t());if(null==r)throw new Error(n);return r}function QS(e,t=2){return tp(e.slice(0,e.length-t))}function ZS(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function JS(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[QS(e),...ZS(e)]),t}function eT(e){return e%2==0}function tT(e,t){if(np(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e.slice(-1)[0],r=t.slice(-1)[0];if(n===r)return!0;if(eT(n)&&eT(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&eT(e[0])&&eT(t[0])}let nT,rT;function sT(e,t){return null!=e.getExtension(t)}function oT(e){try{if(null!=OS(e))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function iT(e){const t=VS(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),s}function aT(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&Qd("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const uT=Np();function lT(){let e,t,n,r,s,o,i,a,u,l;return 2===Np().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",s="texture",o="outputColor",i="out vec4 outputColor;",a="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",u="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",s="texture2D",o="gl_FragColor",i="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",u="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:o,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:u,defineRound:l}}function cT(e,t,n="index"){const r=xp(t);return r.map((t,s)=>`int ${e[s]} = ${n} / ${t}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${t}`:`index -= ${e[s]} * ${t}`};`).join("")}function hT(e){const t=xp(e).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}uT.registerFlag("HAS_WEBGL",()=>uT.getNumber("WEBGL_VERSION")>0),uT.registerFlag("WEBGL_VERSION",()=>oT(2)?2:oT(1)?1:0),uT.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),uT.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===uT.get("WEBGL_VERSION")),uT.registerFlag("WEBGL_CPU_FORWARD",()=>!0),uT.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),uT.registerFlag("WEBGL_PACK",()=>uT.getBool("HAS_WEBGL")),uT.registerFlag("WEBGL_PACK_NORMALIZATION",()=>uT.getBool("WEBGL_PACK")),uT.registerFlag("WEBGL_PACK_CLIP",()=>uT.getBool("WEBGL_PACK")),uT.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>uT.getBool("WEBGL_PACK")),uT.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>uT.getBool("WEBGL_PACK")),uT.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>uT.getBool("WEBGL_PACK")),uT.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>uT.getBool("WEBGL_PACK")),uT.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>uT.getBool("WEBGL_PACK")),uT.registerFlag("WEBGL_PACK_REDUCE",()=>uT.getBool("WEBGL_PACK")),uT.registerFlag("WEBGL_LAZILY_UNPACK",()=>uT.getBool("WEBGL_PACK")),uT.registerFlag("WEBGL_CONV_IM2COL",()=>uT.getBool("WEBGL_PACK")),uT.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function(e){if(null==nT){const t=OS(e);nT=t.getParameter(t.MAX_TEXTURE_SIZE)}return nT}(uT.getNumber("WEBGL_VERSION"))),uT.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function(e){if(null==rT){const t=OS(e);rT=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,rT)}(uT.getNumber("WEBGL_VERSION"))),uT.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const e=uT.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=OS(e);return t=sT(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:sT(n,"EXT_disjoint_timer_query")?1:0,t}(e)}),uT.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>uT.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!oy()),uT.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function(e){if(0===e)return!1;const t=OS(e);if(1===e){if(!sT(t,"OES_texture_float"))return!1}else if(!sT(t,"EXT_color_buffer_float"))return!1;return iT(t)}(uT.getNumber("WEBGL_VERSION"))),uT.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!uT.getBool("WEBGL_FORCE_F16_TEXTURES")&&uT.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),uT.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function(e){if(0===e)return!1;const t=OS(e);if(1!==e){if(sT(t,"EXT_color_buffer_float"))return iT(t);const e="EXT_color_buffer_half_float";if(sT(t,e)){const n=t.getExtension(e);return function(e,t){const n=VS(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(s),o}(t,n)}return!1}return!!sT(t,"OES_texture_float")&&!!sT(t,"WEBGL_color_buffer_float")&&iT(t)}(uT.getNumber("WEBGL_VERSION"))),uT.registerFlag("WEBGL_FENCE_API_ENABLED",()=>{return 2===(e=uT.getNumber("WEBGL_VERSION"))&&null!=OS(e).fenceSync;var e}),uT.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>uT.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),uT.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)}),uT.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>oy()&&uT.getBool("IS_CHROME")?1:-1,e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)}),uT.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);const dT="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";class pT{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=FS.DENSE;const t=LS(e),n=lT();this.outputShape=e,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${cT(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${t[0]}, ${t[1]}));\n        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class fT{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=FS.DENSE;const t=LS(e),n=lT();this.outputShape=e,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${cT(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${t[0]}, ${t[1]}));\n        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class mT{constructor(e){this.variableNames=["A"],this.outTexUsage=DS.DOWNLOAD;const t=lT();this.outputShape=e,this.userCode=`\n      ${dT}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class gT{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=DS.DOWNLOAD;const t=lT();this.outputShape=e,this.userCode=`\n      ${dT}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}class yT{constructor(e,t,n=!1){this.variableNames=["A"];const r=lT(),[s,o]=t;this.outputShape=e;let i="result";n&&(i="floor(result * 255. + 0.5)"),this.userCode=`\n      ${hT(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${o};\n        int c = imod(flatIndex, ${o});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${o}.0, ${s}.0);\n        vec4 values = ${r.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${r.output} = vec4(${i}, 0., 0., 0.);\n      }\n    `}}class xT{constructor(e,t,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const r=lT(),[s,o]=t;this.outputShape=e;let i="",a="result";n&&(a="floor(result * 255. + 0.5)");for(let u=0;u<=1;u++)for(let t=0;t<=1;t++){const n=2*u+t;i+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${e[2]}) {\n            localCoords[2] += ${t};\n            if(localCoords[1] + ${u} < ${e[1]}) {\n              localCoords[1] += ${u};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${o};\n              c = imod(flatIndex, ${o});\n              uv = (vec2(c, r) + halfCR) / vec2(${o}.0, ${s}.0);\n              values = ${r.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${n}] = values[0];\n              } else if(offset == 1) {\n                result[${n}] = values[1];\n              } else if(offset == 2) {\n                result[${n}] = values[2];\n              } else {\n                result[${n}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${hT(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${i}\n\n        ${r.output} = ${a};\n      }\n    `}}function bT(e,t,n,r,s,o){!function(e,t){const n=Np().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(t,n);const i=function(e){return YS(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}(e),a=e.TEXTURE_2D;return US(e,()=>e.bindTexture(a,i)),US(e,()=>e.texParameteri(a,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),US(e,()=>e.texParameteri(a,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),US(e,()=>e.texParameteri(a,e.TEXTURE_MIN_FILTER,e.NEAREST)),US(e,()=>e.texParameteri(a,e.TEXTURE_MAG_FILTER,e.NEAREST)),US(e,()=>e.texImage2D(a,0,r,t,n,0,s,o,null)),US(e,()=>e.bindTexture(e.TEXTURE_2D,null)),i}function vT(e){return e.internalFormatFloat}function wT(e){return e.internalFormatHalfFloat}function CT(e){return e.downloadTextureFormat}function _T(e){return e.internalFormatPackedFloat}function kT(e){return e.internalFormatPackedHalfFloat}class ET{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=Np().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,function(e,t){RS[e]=t}(t,e)):this.gl=OS(t);let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(1===Np().getNumber("WEBGL_VERSION")){const e="OES_texture_half_float";if(this.textureFloatExtension=WS(this.gl,"OES_texture_float"),sT(this.gl,e))this.textureHalfFloatExtension=WS(this.gl,e);else if(Np().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),sT(this.gl,r))this.colorBufferHalfFloatExtension=WS(this.gl,r);else if(Np().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",sT(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!sT(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=function(e){return function(e,t){const n=YS(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return US(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),US(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function(e){return function(e,t){const n=YS(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return US(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),US(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}(e,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function(e){return YS(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=VS(this.gl,this.textureHalfFloatExtension)}get debug(){return Np().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;US(e,()=>e.finish()),US(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),US(e,()=>e.deleteFramebuffer(this.framebuffer)),US(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),US(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),US(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,o]=MS(t,n);return bT(e,s,o,vT(r),r.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,o]=MS(t,n);return bT(e,s,o,wT(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,o]=MS(t,n);return bT(e,s,o,CT(r),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){US(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?US(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):US(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),US(e,()=>e.bindTexture(e.TEXTURE_2D,null))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),function(e,t,n,r,s,o){let i,a,u;US(e,()=>e.bindTexture(e.TEXTURE_2D,t)),s instanceof Uint8Array?(i=new Uint8Array(n*r*4),a=e.UNSIGNED_BYTE,u=e.RGBA):(i=new Float32Array(n*r*4),a=e.FLOAT,u=o.internalFormatPackedFloat),i.set(s),US(e,()=>e.texImage2D(e.TEXTURE_2D,0,u,n,r,0,e.RGBA,a,i)),US(e,()=>e.bindTexture(e.TEXTURE_2D,null))}(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,o]=BS(t,n);return bT(e,s,o,kT(r),e.RGBA,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,o]=BS(t,n);return bT(e,s,o,_T(r),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(KS(this.gl,this.framebuffer),this.outputTexture=null),US(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>function(e,t,n,r){const[s,o]=MS(t,n),i=new Uint8Array(t*n*4);return US(e,()=>e.readPixels(0,0,s,o,r.downloadTextureFormat,e.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,s,o){return function(e,t,n,r,s,o,i,a){const u=e,l=new Float32Array(function(e,t){const[n,r]=BS(e,t);return n*r*4}(o,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}(this.gl,e,0,0,0,s,o)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=function(e,t,n,r){const s=e.createBuffer();US(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,s));const o=16*t*n;return US(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,o,e.STREAM_READ)),US(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),US(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),s}(this.gl,t,n);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(Np().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(s,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=s}else Np().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,Np().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>function(e,t,n){const r=new Float32Array(t*n*4);return US(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}(this.gl,t,n))}createProgram(e){this.throwIfDisposed();const t=this.gl,n=function(e,t){const n=YS(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(US(e,()=>e.shaderSource(n,t)),US(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw function(e,t){const n=jS.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const r=+n[1],s=e.split("\n"),o=s.length.toString().length+2,i=s.map((e,t)=>op((t+1).toString(),o)+e);let a=0;for(let h=0;h<i.length;h++)a=Math.max(i[h].length,a);const u=i.slice(0,r-1),l=i.slice(r-1,r),c=i.slice(r);console.log(u.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${op(l[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(t,e);null==this.vertexShader&&(this.vertexShader=function(e){const t=lT();return function(e,t){const n=YS(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(US(e,()=>e.shaderSource(n,t)),US(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(t));const r=function(e){return YS(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}(t);return US(t,()=>t.attachShader(r,this.vertexShader)),US(t,()=>t.attachShader(r,n)),function(e,t){if(US(e,()=>e.linkProgram(t)),!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,r),this.debug&&HS(t,r),this.vertexAttrsAreBound||(this.setProgram(r),this.vertexAttrsAreBound=function(e,t,n){return US(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),GS(e,t,"clipSpacePos",n,3,20,0)&&GS(e,t,"uv",n,2,20,12)}(t,this.program,this.vertexBuffer)),r}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&US(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&HS(this.gl,this.program),US(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?function(e,t,n){return YS(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),US(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),function(e,t,n,r){US(e,()=>function(e,t,n){(function(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)})(e,n),US(e,()=>e.activeTexture(e.TEXTURE0+n)),US(e,()=>e.bindTexture(e.TEXTURE_2D,t))}(e,t,r)),US(e,()=>e.uniform1i(n,r))}(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,s]=BS(t,n);this.setOutputMatrixTextureDriver(e,r,s)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&HS(this.gl,this.program),XS(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),US(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),US(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=WS(this.gl,2===Np().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Np().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===Np().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(e){var t=this;return jd(function*(){return yield ip(()=>t.disposed||t.isQueryAvailable(e,Np().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),t.getQueryTime(e,Np().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||ip(()=>(this.pollItems(),0===this.itemsToPoll.length))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),qS(this.gl,e,this.framebuffer),this.debug&&XS(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(qS(this.gl,this.outputTexture,this.framebuffer),this.debug&&XS(this.gl)):KS(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;qS(r,e,this.framebuffer),this.debug&&XS(r),this.outputTexture=e,US(r,()=>r.viewport(0,0,t,n)),US(r,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),US(this.gl,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{getBroadcastDims:ST}=o;function TT(e,t,n,r){const s=[];e.forEach(e=>{const t=tp(e.shapeInfo.logicalShape);e.shapeInfo.isUniform?s.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(s.push(`uniform sampler2D ${e.name};`),s.push(`uniform int offset${e.name};`))});const o=s.join("\n"),i=e.map(e=>function(e,t,n=!1){let r="";return r+=n?NT(e):IT(e),e.shapeInfo.logicalShape.length<=t.logicalShape.length&&(r+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",o=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,a=ST(e.shapeInfo.logicalShape,t.logicalShape),u=PT(i),l=i-o;let c;const h=["x","y","z","w","u","v"];c=0===o?"":i<2&&a.length>=1?"coords = 0;":a.map(e=>`coords.${h[e+l]} = 0;`).join("\n");let d="";d=i<2&&o>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>`coords.${h[t+l]}`).join(", ");let p="return outputValue;";const f=1===tp(e.shapeInfo.logicalShape),m=1===tp(t.logicalShape);if(1!==o||f||m){if(f&&!m)p=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(a.length){const e=o-2,t=o-1;a.indexOf(e)>-1&&a.indexOf(t)>-1?p="return vec4(outputValue.x);":a.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${u} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${d});\n      ${p}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",o=e.shapeInfo.logicalShape.length,i=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===i&&null==e.shapeInfo.flatOffset&&np(e.shapeInfo.texShape,t.texShape))return`\n      float ${s}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const a=PT(i),u=ST(e.shapeInfo.logicalShape,t.logicalShape),l=i-o;let c;const h=["x","y","z","w","u","v"];c=0===o?"":i<2&&u.length>=1?"coords = 0;":u.map(e=>`coords.${h[e+l]} = 0;`).join("\n");let d="";return d=i<2&&o>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>`coords.${h[t+l]}`).join(", "),`\n    float ${s}() {\n      ${a} coords = getOutputCoords();\n      ${c}\n      return get${r}(${d});\n    }\n  `}(e,t)),r}(e,t,r)).join("\n"),a=t.texShape,u=lT(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(u);let c,h,d=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${$T}\n    ${RT}\n    ${AT}\n  `}(u);return t.isPacked?(c=function(e,t){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===n[0]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);\n    }\n  `}(0,t);case 2:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(np(e,t))return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `;const r=Math.ceil(e[1]/2);return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t);case 3:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),s=r*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t);default:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),s=r*Math.ceil(e[e.length-2]/2);let o=s,i="",a="b, r, c";for(let u=2;u<e.length-1;u++)o*=e[e.length-u-1],i=`\n      int b${u} = index / ${o};\n      index -= b${u} * ${o};\n    `+i,a=`b${u}, `+a;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${i}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${e.length}(${a});\n    }\n  `}(e,t)}}(t.logicalShape,a),h=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(u)):(c=function(e,t){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return 1===(n=t)[0]?`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `;case 2:return function(e,t){return np(e,t)?`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t);case 3:return function(e,t){const n=cT(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}(e,t);case 4:return function(e,t){const n=cT(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${n}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t);case 5:return function(e,t){const n=cT(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=cT(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}var n}(t.logicalShape,a),h=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(u)),r&&(d+=OT),[d,l,h,o,c,i,n].join("\n")}function IT(e){const t=e.shapeInfo.logicalShape;switch(t.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`float ${n}() {return ${t};}`;const[r,s]=e.shapeInfo.texShape;if(1===r&&1===s)return`\n      float ${n}() {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const[o,i]=e.shapeInfo.texShape;return`\n    float ${n}() {\n      vec2 uv = uvFromFlat(${o}, ${i}, ${FT(t)});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 1:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${n}(int index) {\n        ${DT(e)}\n      }\n    `;const r=e.shapeInfo.texShape,s=r[0],o=r[1];if(1===o&&1===s)return`\n      float ${n}(int index) {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const i=FT(t);return 1===o?`\n      float ${n}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${s}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `:1===s?`\n      float ${n}(int index) {\n        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n    float ${n}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${o}, index + ${i});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 2:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape;if(null!=s&&np(t,s))return`\n    float ${r}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${s[0]}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `;const{newShape:o,keptDims:i}=up(t);if(o.length<t.length){const t=["row","col"];return`\n      ${IT(MT(e,o))}\n      float ${r}(int row, int col) {\n        return ${r}(${LT(t,i)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));\n        ${DT(e)}\n      }\n    `;const a=s[0],u=s[1],l=FT(n);return 1===u?`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${l}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${a}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `:1===a?`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${l}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n  float ${r}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${t[1]} + col + ${l};\n    vec2 uv = uvFromFlat(${a}, ${u}, index);\n    return sampleTexture(${n}, uv);\n  }\n`}(e);case 3:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[1]*t[2],o=t[2],{newShape:i,keptDims:a}=up(t);if(i.length<t.length){const t=["row","col","depth"];return`\n        ${IT(MT(e,i))}\n        float ${r}(int row, int col, int depth) {\n          return ${r}(${LT(t,a)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${o}, 1)));\n        ${DT(e)}\n      }\n    `;const u=e.shapeInfo.texShape,l=u[0],c=u[1],h=e.shapeInfo.flatOffset;return c===s&&null==h?`\n        float ${r}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${o}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${c}.0, ${l}.0);\n          return sampleTexture(${n}, uv);\n        }\n      `:c===o&&null==h?`\n    float ${r}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}.0, ${l}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n      float ${r}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${o} + depth + ${FT(n)};\n        vec2 uv = uvFromFlat(${l}, ${c}, index);\n        return sampleTexture(${n}, uv);\n      }\n  `}(e);case 4:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[3],o=t[2]*s,i=t[1]*o,{newShape:a,keptDims:u}=up(t);if(a.length<t.length){const t=["row","col","depth","depth2"];return`\n      ${IT(MT(e,a))}\n      float ${r}(int row, int col, int depth, int depth2) {\n        return ${r}(${LT(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${i}, ${o}, ${s}, 1)));\n        ${DT(e)}\n      }\n    `;const l=e.shapeInfo.flatOffset,c=e.shapeInfo.texShape,h=c[0],d=c[1];return d===i&&null==l?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${d}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:d===s&&null==l?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${t[1]*t[2]}, ${t[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${d}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${o} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${d}, index + ${FT(n)});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],o=t[3]*s,i=t[2]*o,a=t[1]*i,{newShape:u,keptDims:l}=up(t);if(u.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${IT(MT(e,u))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${LT(t,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${i}, ${o}, ${s})) +\n          depth3;\n        ${DT(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1];return p===a&&null==c?`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:p===s&&null==c?`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${i} + depth * ${o} +\n          depth2 * ${s} + depth3 + ${FT(n)};\n      vec2 uv = uvFromFlat(${d}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:o}=up(t);if(s.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${IT(MT(e,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${LT(t,o)});\n      }\n    `}const i=t[5],a=t[4]*i,u=t[3]*a,l=t[2]*u,c=t[1]*l;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${l}, ${u}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${DT(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],f=d[1];return f===c&&null==h?`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${l}, ${u}, ${a}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:f===i&&null==h?`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${l} + depth * ${u} +\n          depth2 * ${a} + depth3 * ${i} + depth4 + ${FT(n)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function NT(e){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${lT().texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e.shapeInfo.texShape,s=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],o=lT();return`\n    vec4 ${n}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${s[0]}, ${s[1]}, index);\n      return ${o.texture2D}(${t}, uv);\n    }\n  `}(e);case 2:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,o=s[0],i=s[1],a=lT();if(null!=s&&np(t,s))return`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${o}.0);\n\n        return ${a.texture2D}(${n}, uv);\n      }\n    `;const u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(t[1]/2)}, ${u[0]}, ${u[1]}, row, col);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(e);case 3:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===t[0]){const n=[1,2],s=["b","row","col"];return`\n        ${NT(MT(e,t.slice(1)))}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${LT(s,n)});\n        }\n      `}const i=o[0],a=o[1],u=Math.ceil(t[2]/2);return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${i}, ${a}, ${u*Math.ceil(t[1]/2)}, ${u}, b, row, col);\n      return ${lT().texture2D}(${n}, uv);\n    }\n  `}(e);default:return function(e){const t=e.shapeInfo.logicalShape,n=t.length,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],a=i[0],u=i[1],l=Math.ceil(t[n-1]/2);let c=l*Math.ceil(t[n-2]/2),h="int b, int row, int col",d=`b * ${c} + (row / 2) * ${l} + (col / 2)`;for(let p=2;p<n-1;p++)h=`int b${p}, `+h,c*=t[n-p-1],d=`b${p} * ${c} + `+d;return`\n    vec4 ${s}(${h}) {\n      int index = ${d};\n      int texR = index / ${u};\n      int texC = index - texR * ${u};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${a});\n      return ${lT().texture2D}(${r}, uv);\n    }\n  `}(e)}}const $T="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",RT="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",AT="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",OT="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function FT(e){return`offset${e}`}function DT(e){const t=e.name,n=tp(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function PT(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function MT(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function LT(e,t){return t.map(t=>e[t]).join(", ")}function BT(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((e,n)=>{const r=e.logicalShape,s=t[n],o=s.shape;if(!np(r,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${o} must match`);if(e.isUniform&&s.isUniform)return;const i=e.texShape,a=s.isUniform?null:s.texData.texShape;if(!np(i,a))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${a} must match`)})}function VT(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&Qd("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}function UT(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}function zT(e){return(t,n,r,s,o)=>{const i=Tb(t,n),a=i.length,u=xp(i),l=lp(o,tp(i)),c=t.length,h=n.length,d=xp(t),p=xp(n),f=Eb(t,i),m=Eb(n,i);if(f.length+m.length===0)for(let g=0;g<l.length;++g)l[g]=e(r[g%r.length],s[g%s.length]);else for(let g=0;g<l.length;++g){const t=Ep(g,a,u),n=t.slice(-c);f.forEach(e=>n[e]=0);const o=kp(n,c,d),i=t.slice(-h);m.forEach(e=>i[e]=0);const y=kp(i,h,p);l[g]=e(r[o],s[y])}return[l,i]}}function WT(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,o=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,a=n.makeTensorInfo(r.shape,"complex64");return n.data.get(a.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",o),imag:n.makeTensorInfo(s.shape,"float32",i)},a}function jT(e,t,n="float32"){if("complex64"===n)return WT({inputs:{real:jT(e,t,"float32"),imag:jT(e,t,"float32")},backend:e});const r=Cp(tp(t),n);return e.makeTensorInfo(t,n,r)}function HT(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function GT(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return HT({inputs:{x:s},backend:n});const e=jT(n,s.shape,s.dtype),t=GT({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),r=WT({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===s.dtype){const e=function(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,o=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,o)}({inputs:{input:s},backend:n}),t=GT({inputs:{x:e},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(e),t}if(!hp(s.dtype,o)){const e=HT({inputs:{x:s},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:o}}if("int32"===o){const e=n.data.get(s.dataId).values,t=Int32Array.from(e);return n.makeTensorInfo(s.shape,"int32",t)}if("bool"===o){const e=n.data.get(s.dataId).values,t=Eg([0],s.dtype),[r,o]=zT((e,t)=>e!==t?1:0)(s.shape,[],e,t,"bool");return n.makeTensorInfo(o,"bool",r)}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}function qT(e,t,n,r){return null==n?({inputs:n,backend:s})=>{const{a:o,b:i}=n,a=s;VT([o,i],e);const u=a.data.get(o.dataId).values,l=a.data.get(i.dataId).values,c="string"===o.dtype?jw(u):u,h="string"===o.dtype?jw(l):l,d=r||o.dtype,[p,f]=t(o.shape,i.shape,c,h,d);return a.makeTensorInfo(f,d,p)}:({inputs:e,backend:s})=>{const{a:o,b:i}=e,a=s;if("complex64"===o.dtype||"complex64"===i.dtype){const e=GT({inputs:{x:o},backend:a,attrs:{dtype:"complex64"}}),t=a.data.get(e.dataId),r=t.complexTensorInfos.imag,s=a.data.get(t.complexTensorInfos.real.dataId).values,u=a.data.get(r.dataId).values,l=GT({inputs:{x:i},backend:a,attrs:{dtype:"complex64"}}),c=a.data.get(l.dataId),h=c.complexTensorInfos.imag,d=a.data.get(c.complexTensorInfos.real.dataId).values,p=a.data.get(h.dataId).values,[f,m,g]=n(o.shape,i.shape,s,u,d,p),y=a.makeTensorInfo(g,"float32",f),x=a.makeTensorInfo(g,"float32",m),b=WT({inputs:{real:y,imag:x},backend:a});return a.disposeIntermediateTensorInfo(e),a.disposeIntermediateTensorInfo(l),a.disposeIntermediateTensorInfo(y),a.disposeIntermediateTensorInfo(x),b}{const e=a.data.get(o.dataId).values,n=a.data.get(i.dataId).values,s=r||o.dtype,[u,l]=t(o.shape,i.shape,e,n,s);return a.makeTensorInfo(l,s,u)}}}function KT(e){return(t,n,r,s,o,i)=>{const a=Tb(t,n),u=tp(a),l=a.length,c=xp(a),h=lp("float32",u),d=lp("float32",u),p=Eb(t,a),f=Eb(n,a),m=Ew(r,s),g=Ew(o,i),y=t.length,x=xp(t),b=n.length,v=xp(n);if(p.length+f.length===0)for(let w=0;w<h.length;w++){const t=w%m.length,n=w%g.length,r=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);h[w]=r.real,d[w]=r.imag}else for(let w=0;w<h.length;w++){const t=Ep(w,l,c),n=t.slice(-y);p.forEach(e=>n[e]=0);const r=kp(n,y,x),s=t.slice(-b);f.forEach(e=>s[e]=0);const o=kp(s,b,v),i=e(m[2*r],m[2*r+1],g[2*o],g[2*o+1]);h[w]=i.real,d[w]=i.imag}return[h,d,a]}}const XT=zT((e,t)=>e+t),YT=KT((e,t,n,r)=>({real:e+n,imag:t+r}));function QT(e,t,n,r,s){const o=tp(r),i=Cp(s,n);for(let a=0;a<e.length;a++){const n=e[a];if(n<0)throw new Error("Input x must be non-negative!");n>=s||(i[n]+=o>0?t[a]:1)}return i}function ZT(e,t,n,r=!1){const s=e.shape[0],o=e.shape[1],i=qy([s,n],t.dtype);for(let a=0;a<s;a++)for(let s=0;s<o;s++){const o=e.get(a,s);if(o<0)throw new Error("Input x must be non-negative!");o>=n||i.set(r?1:t.size>0?i.get(a,o)+t.get(a,s):i.get(a,o)+1,a,o)}return i}function JT(e){return(t,n,r)=>{const s=lp(n,t.length);for(let o=0;o<t.length;++o)s[o]=e(t[o],r);return s}}function eI(e,t,n){return({inputs:r,attrs:s,backend:o})=>{const{x:i}=r;if(VT(i,e),"string"===i.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const a=o,u=a.data.get(i.dataId).values,l=n||i.dtype,c=t(u,l,s);return a.makeTensorInfo(i.shape,l,c)}}qT(Pp,XT,YT);const tI=JT(e=>Math.ceil(e));function nI(e,t,n,r){const s=cp(n,tp(t));if(r&&"string"!==n){let t=0;e.forEach(e=>{const n=tp(e.shape);s.set(e.vals,t),t+=n})}else{let r=0;e.forEach(e=>{const o="string"===n?jw(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const a=n*t[1]+r;for(let t=0;t<e.shape[1];++t)s[a+t]=o[i++]}r+=e.shape[1]})}return s}eI(Qp,tI);const rI=zT((e,t)=>e===t?1:0),sI=(qT(xf,rI,null,"bool"),JT(e=>Math.exp(e))),oI=(eI(bf,sI),JT(e=>Math.expm1(e))),iI=(eI(wf,oI),JT(e=>Math.floor(e)));function aI(e,t,n,r,s,o,i,a,u){const l=qy([r,o],n);for(let c=0;c<r;c++){const n=[];let r=0;for(let t=0;t<s;t++){const o=e[c*s+t];r+=o*i[t],n.push(o)}if(r<0||r>=u/o)throw new Error(`Invalid indices: ${n} does not index into ${a}`);for(let e=0;e<o;e++)l.values[c*o+e]=t.get(...t.indexToLoc(r*o+e))}return l}function uI(e,t,n){const r=qy(n,e.dtype);for(let s=0;s<r.size;++s){const n=r.indexToLoc(s).slice(),o=t.locToIndex([n[0],n[2]]);n[2]=t.values[o];const i=e.locToIndex(n);r.values[s]=e.values[i]}return r}eI(kf,iI);const lI=zT((e,t)=>e>t?1:0),cI=(qT(Nf,lI,null,"bool"),zT((e,t)=>e>=t?1:0)),hI=(qT($f,cI,null,"bool"),zT((e,t)=>e<t?1:0)),dI=(qT(Pf,hI,null,"bool"),zT((e,t)=>e<=t?1:0));function pI(e,t,n){const r=(t-e)/(n-1),s=Cp(n,"float32");s[0]=e;for(let o=1;o<s.length;o++)s[o]=s[o-1]+r;return s}qT(Mf,dI,null,"bool");const fI=JT(e=>Math.log(e));function mI(e,t,n,r){const s=lp(r,tp(n));for(let o=0;o<s.length;++o){const n=o*t;let r=e[n];for(let s=0;s<t;++s){const t=e[n+s];(Number.isNaN(t)||t>r)&&(r=t)}s[o]=r}return s}eI(Bf,fI);const gI=zT((e,t)=>Math.max(e,t)),yI=(qT(jf,gI),zT((e,t)=>Math.min(e,t))),xI=(qT(Xf,yI),zT((e,t)=>e*t)),bI=KT((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}));function vI(e,t,n){const r=kg(-1,n);return xI([],t,r,e,n)}qT(Zf,xI,bI);const wI=zT((e,t)=>e!==t?1:0);function CI(e,t,n,r,s){const o=t.length,i=tp(t),a=xp(t),u=xp(s),l=lp(n,tp(s));for(let c=0;c<i;++c){const t=Ep(c,o,a),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];l[kp(n,o,u)]=e[c]}return l}function _I(e,t,n,r){const[s,o]=zb(e,r),i=Kg(t,"int32"),a=Cp(tp(s),i),u=tp(o);for(let l=0;l<a.length;++l){const e=l*u;let t=1;for(let r=0;r<u;++r)t*=n[e+r];a[l]=t}return{outVals:a,outShape:s,outDtype:i}}function kI(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return Cp(0,r);const s=Cp(Math.abs(Math.ceil((t-e)/n)),r);t<e&&1===n&&(n=-1),s[0]=e;for(let o=1;o<s.length;o++)s[o]=s[o-1]+n;return s}qT(Jf,wI,null,"bool");const EI=JT(e=>1/Math.sqrt(e));function SI(e,t,n,r,s){const o=vx(r,t,n),i=tp(n),a=xp(r);if(o){const n=wx(t,a);return"string"===s?e.slice(n,n+i):e.subarray(n,n+i)}const u=qy(r,s,"string"===s?jw(e):e),l=qy(n,s);for(let c=0;c<l.size;++c){const e=l.indexToLoc(c),n=e.map((e,n)=>e+t[n]);l.set(u.get(...n),...e)}return"string"===s?Hw(l.values):l.values}function TI(e,t,n,r,s,o,i){const a=t[0],u=o[0],l=new Array(u),c=new Array(a),h=t[1];if(0===u){if(0!==a)throw new Error(`Received SparseTensor with denseShape[0] = 0 but\n         indices.shape[0] = ${a}`);return[cp(n,0),[0,h],cp(s,0),l,c]}let d=!0,p=0;const f=new Array(u).fill(0);for(let g=0;g<a;++g){const t=e[g*h];if(t<0)throw new Error(`indices(${g}, 0) is invalid: ${t} < 0`);if(t>=u)throw new Error(`indices(${g}, 0) is invalid: ${t} >= ${u}`);++f[t],d=d&&t>=p,p=t}let m=!0;for(let g=0;g<u;++g){const e=0===f[g];l[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&d){const t=e,n=r;for(let e=0;e<a;++e)c[e]=e;return[t,[a,h],n,l,c]}{const t=f[u-1],o=cp(n,t*h),d=cp(s,t),p=new Array(u).fill(0);for(let n=0;n<a;++n){const t=e[n*h],s=(0===t?0:f[t-1])+p[t];p[t]++;for(let r=0;r<h;++r)o[s*h+r]=e[n*h+r];d[s]=r[n],c[n]=s}for(let e=0;e<u;++e)if(0===p[e]){const t=0===e?0:f[e-1];o[t*h+0]=e;for(let e=1;e<h;++e)o[t*h+e]=0;d[t]=i}return[o,[t,h],d,l,c]}}function II(e,t,n,r,s){const o=tp(r),i=t[0],a=s.length,u=[];let l=1,c=-1;for(let g=0;g<a;++g){const e=s[g];if(-1===e){if(-1!==c)throw new Error(`only one output dimension may be -1, not both ${c} and ${g}`);c=g,u.push(1)}else{if(e<0)throw new Error(`size ${g} must be non-negative, not ${e}`);l*=e,u.push(e)}}if(-1!==c){if(l<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(o/l);if(l*e!==o)throw new Error(`Input to reshape is a SparseTensor with ${o}\n          dense values, but the requested shape requires a multiple of ${l}. inputShape=${r} outputShape= ${u}`);u[c]=e}const h=tp(u);if(h!==o)throw new Error(`Input to reshape is a tensor with ${o} dense values, but the requested shape has ${h}. inputShape=${r} outputShape=${u}`);const d=r.length,p=[];if(d>0){p[d-1]=1;for(let e=d-2;e>=0;--e)p[e]=p[e+1]*r[e+1]}const f=[];if(a>0){f[a-1]=1;for(let e=a-2;e>=0;--e)f[e]=f[e+1]*u[e+1]}const m=cp(n,i*a);for(let g=0;g<i;++g){let t=0;for(let n=0;n<d;++n)t+=e[g*d+n]*p[n];for(let e=0;e<a;++e)m[g*a+e]=Math.trunc(t/f[e]),t%=f[e]}return[m,[i,a],u]}function NI(e,t,n,r,s,o=!1,i=0){const a=r.length;if(a!==s.length)throw new Error("segmentIds and indices should have same size.");const u=[t[0],e.length/t[0]],l=u[1],c=a>0?s[a-1]+1:0;if(c<0)throw new Error("segment ids must be >= 0");const h=t.slice();h[0]=c;const d=cp(n,h.reduce((e,t)=>e*t,1));if(0===a)return c>0&&d.fill(i),[d,h];if(c<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,m=0,g=s[p];for(;;){let t=0;if(f<a){if(t=s[f],g===t){++f;continue}if(g>=t)throw new Error("segment ids are not increasing")}if(g<0||g>=c)throw new Error(`Segment id ${g} out of range [0, ${c}), possibly because segmentIds input is not sorted.`);g>m&&d.fill(i,m*l,g*l);for(let n=p;n<f;++n){const t=r[n];if(t<0||t>=u[0])throw new Error(`Bad: indices[${n}] == ${r[n]} out of range [0, ${u[0]})`);for(let n=0;n<l;n++)d[g*l+n]+=e[t*l+n]}if(o)for(let e=0;e<l;e++)d[g*l+e]/=f-p;if(p=f,++f,m=g+1,g=t,f>a)break}return m<c&&d.fill(i,m*l,c*l),[d,h]}eI(bm,EI);const $I=zT((e,t)=>{const n=e-t;return n*n});function RI(e,t,n,r){const s=qy(e,t.dtype);for(let o=0;o<s.size;o++){const e=s.indexToLoc(o),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+r[t];s.set(t.get(...i),...e)}return s}qT(Mm,$I);class AI{constructor(e,t,n,r,s,o){this.separator=Tg(e),this.nGramWidths=t,this.leftPad=Tg(n),this.rightPad=Tg(r),this.padWidth=s,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,s,o){for(let i=0;i<s;++i){const a=this.getPadWidth(o),u=Math.max(0,a-i),l=Math.max(0,a-(s-(i+1))),c=o-(u+l),h=t+(u>0?0:i-a);let d=0;d+=u*this.leftPad.length;for(let t=0;t<c;++t)d+=e[h+t].length;d+=l*this.rightPad.length,d+=(u+l+c-1)*this.separator.length,n[r+i]=new Uint8Array(d);const p=n[r+i];let f=0;const m=e=>e.forEach(e=>p[f++]=e);for(let e=0;e<u;++e)m(this.leftPad),m(this.separator);for(let t=0;t<c-1;++t)m(e[h+t]),m(this.separator);if(c>0){m(e[h+c-1]);for(let e=0;e<l;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<l-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let s=1;s<r;++s){let r=t[s]>=e;if(r=r&&t[s]<=n,!r)throw new Error(`Invalid split value ${t[s]}, must be in [${e}, ${n}]`);e=t[s]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const s=r-1,o=cp("int32",r);if(0===n||0===r){const e=new Array(n);for(let t=0;t<=s;++t)o[t]=0;return[e,o]}o[0]=0;for(let a=1;a<=s;++a){const e=t[a]-t[a-1];let n=0;this.nGramWidths.forEach(t=>{n+=this.getNumNGrams(e,t)}),this.preserveShort&&e>0&&0===n&&(n=1),o[a]=o[a-1]+n}const i=new Array(o[s]);for(let a=0;a<s;++a){const n=t[a];let r=o[a];if(this.nGramWidths.forEach(s=>{const o=this.getNumNGrams(t[a+1]-t[a],s);this.createNGrams(e,n,i,r,o,s),r+=o}),this.preserveShort&&r===o[a]){const s=t[a+1]-t[a];if(0===s)continue;this.createNGrams(e,n,i,r,1,s+2*this.padWidth)}}return[i,o]}}function OI(e,t,n,r,s,o,i,a){return new AI(n,r,s,o,i,a).compute(e,t)}function FI(e,t,n){if(!e.length)return[];if(0===t.length){const t=new Array(e.length);for(let n=0;n<e.length;++n)t[n]=e.subarray(n,n+1);return t}if(1===t.length){const r=t[0],s=[];let o=e.indexOf(r);for(;-1!==o;){const t=e.subarray(0,o);n&&0===t.length||s.push(t),o=(e=e.subarray(o+1)).indexOf(r)}return n&&0===e.length||s.push(e),s}const r=[];let s=0;for(let o=0;o<e.length+1;o++)if(o===e.length||-1!==t.indexOf(e[o])){const t=e.subarray(s,o);n&&0===t.length||r.push(t),s=o+1}return r}function DI(e,t,n){const r=e.length,s=[];let o=0,i=0;const a=new Array(r);for(let d=0;d<r;++d){const r=FI(e[d],t,n),u=r.length;a[d]=u,o+=u,i=Math.max(i,u),s.push(...r)}const u=cp("int32",2*o),l=new Array(o),c=[r,i];let h=0;for(let d=0;d<r;++d)for(let e=0;e<a[d];++e)u[2*h]=d,u[2*h+1]=e,l[h]=s[h],++h;return[u,l,c]}function PI(e,t){const n=cp("int32",e.length);for(let r=0;r<e.length;++r)n[r]=_g(e[r]).modulo(t).getLowBitsUnsigned();return n}const MI=zT((e,t)=>e-t),LI=KT((e,t,n,r)=>({real:e-n,imag:t-r}));function BI(e,t){const n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=e.shape[s]*t[s];const r=qy(n,e.dtype);for(let s=0;s<r.values.length;++s){const t=r.indexToLoc(s),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];const o=e.locToIndex(n);r.values[s]=e.values[o]}return r}function VI(e,t,n,r,s){const o=t[t.length-1],[i,a]=[e.length/o,o],u=lp(n,i*r),l=lp("int32",i*r);for(let h=0;h<i;h++){const t=h*a,n=e.subarray(t,t+a),s=[];for(let e=0;e<n.length;e++)s.push({value:n[e],index:e});s.sort((e,t)=>t.value-e.value);const o=h*r,i=u.subarray(o,o+r),c=l.subarray(o,o+r);for(let e=0;e<r;e++)i[e]=s[e].value,c[e]=s[e].index}const c=t.slice();return c[c.length-1]=r,[qy(c,n,u),qy(c,"int32",l)]}function UI(e,t,n,r){const s=ap(t,n)[0],o=[1,n[0],1];for(let f=0;f<s;f++)o[0]*=n[f];o[1]=n[s];for(let f=s+1;f<n.length;f++)o[2]*=n[f];const i={},a=new Int32Array(n[s]),u=new Mg(o,r,e),l=[],c=1===o[0]&&1===o[2];for(let f=0;f<n[s];f++){let t;if(c)t=e[f].toString();else{const e=[];for(let t=0;t<o[0];t++)for(let n=0;n<o[2];n++)e.push(u.get(t,f,n));t=e.join(",")}if(void 0!==i[t])a[f]=i[t];else{const e=Object.keys(i).length;i[t]=e,a[f]=e,l.push(f)}}const h=o.slice();h[1]=Object.keys(i).length;const d=new Mg(h,r);l.forEach((e,t)=>{for(let n=0;n<o[0];n++)for(let r=0;r<o[2];r++)d.set(u.get(n,e,r),n,t,r)});const p=n.slice();return p[s]=h[1],{outputValues:d.values,outputShape:p,indices:a}}qT(zm,MI,LI);const{addImpl:zI,bincountImpl:WI,bincountReduceImpl:jI,ceilImpl:HI,concatImpl:GI,equalImpl:qI,expImpl:KI,expm1Impl:XI,floorImpl:YI,gatherNdImpl:QI,gatherV2Impl:ZI,greaterImpl:JI,greaterEqualImpl:eN,lessImpl:tN,lessEqualImpl:nN,linSpaceImpl:rN,logImpl:sN,maxImpl:oN,maximumImpl:iN,minimumImpl:aN,multiplyImpl:uN,negImpl:lN,notEqualImpl:cN,prodImpl:hN,rangeImpl:dN,rsqrtImpl:pN,simpleAbsImpl:fN,sliceImpl:mN,sparseFillEmptyRowsImpl:gN,sparseReshapeImpl:yN,sparseSegmentReductionImpl:xN,stridedSliceImpl:bN,stringNGramsImpl:vN,stringSplitImpl:wN,stringToHashBucketFastImpl:CN,subImpl:_N,tileImpl:kN,topKImpl:EN,transposeImpl:SN,uniqueImpl:TN}=E;function IN(e,t){return["x","y","z","w","u","v"].slice(0,t).map(t=>`${e}.${t}`)}function NN(e,t){return 1===t?[e]:IN(e,t)}class $N{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e;const t=e.length;if(0===t)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=NN("rc",t),r=PT(t),s=function(e,t,n){if(1===e)return`rc > ${t[0]}`;let r="";for(let s=e-2;s<e;s++)r+=`${n[s]} >= ${t[s]}`,s<e-1&&(r+="||");return r}(t,e,n),o=function(e,t,n,r){if(1===e)return"";const s=r.slice(-2);return`\n    int r = ${s[0]};\n    int c = ${s[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${t};\n    bool rEdge = rp1 >= ${n};\n  `}(t,e[e.length-1],e[e.length-2],n),i=function(e,t){const n=e.length,r=function(e,t){const n=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let o=`${0===r?"r":"rp1"}, ${0===s?"c":"cp1"}`;for(let n=2;n<e;n++)o=`${t[t.length-1-n]},`+o;n.push(o)}return n}(n,t);return 1===n?`getA(rc),\n            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),\n            0, 0`:`getA(${r[0]}),\n          cEdge ? 0. : getA(${r[1]}),\n          rEdge ? 0. : getA(${r[2]}),\n          rEdge || cEdge ? 0. : getA(${r[3]})`}(e,n);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${s}) {\n            setOutput(vec4(0));\n          } else {\n            ${o}\n\n            setOutput(vec4(${i}));\n          }\n        }\n      `}}}class RN{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;let n="";for(let s=0;s<4;s++){let e="thisRC = rc;";s%2==1&&(e+="thisRC.z += 1;"),s>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${s}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${s>0?"}":""}\n      `}var r;this.userCode=`\n      ${r=t,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${cT(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${hT(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${e[1]};\n        int cols = ${e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class AN{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){const r=FN(t,n),s=DN(e,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const o=ON(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const e=this.freeTextures[s].shift();return this.usedTextures[s].push(e),e}let i;return r===PS.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===PS.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===PS.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===PS.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===PS.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),i}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const s=FN(n,r),o=DN(t,s,r);o in this.freeTextures||(this.freeTextures[o]=[]);const i=ON(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),a=Np().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==a&&this._numBytesAllocated>a?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=i):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const u=this.usedTextures[o],l=u.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u.splice(l,1),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});for(const e in this.usedTextures)this.usedTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function ON(e,t,n,r,s){const o=function(e,t){switch(e){case PS.PACKED_2X2_FLOAT32:return _T(t);case PS.PACKED_2X2_FLOAT16:return kT(t);case PS.UNPACKED_FLOAT32:return vT(t);case PS.UNPACKED_FLOAT16:return wT(t);case PS.PACKED_4X1_UNSIGNED_BYTE:return CT(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);let i;if(s){const[t,n]=BS(e[0],e[1]);i=t*n}else{const[t,n]=MS(e[0],e[1]);i=t*n}return i*function(e,t){if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===e.RGBA16F)return 8;throw new Error(`Unknown internal format ${t}`)}(n,o)}function FN(e,t){if(e===DS.UPLOAD)return PS.PACKED_2X2_FLOAT32;if(e===DS.RENDER||null==e)return function(e){return Np().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?PS.PACKED_2X2_FLOAT32:PS.UNPACKED_FLOAT32:e?PS.PACKED_2X2_FLOAT16:PS.UNPACKED_FLOAT16}(t);if(e===DS.DOWNLOAD||e===DS.PIXELS)return PS.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function DN(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class PN{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const MN="return abs(x);",LN="return x;";class BN{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class VN{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e;const t=e.length,n=NN("rc",t),r=PT(t),s=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),o=n.slice(-2),i=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}}const UN=Gw,zN={},WN=Np().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let jN=(()=>{class e extends qd{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Np().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==e){const e=OS(Np().getNumber("WEBGL_VERSION"));this.binaryCache=((t=Np().getNumber("WEBGL_VERSION"))in zN||(zN[t]={}),zN[t]),this.gpgpu=new ET(e),this.canvas=e.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;var t;this.textureManager=new AN(this.gpgpu),this.numMBBeforeWarning=null==Np().global.screen?1024:Np().global.screen.height*Np().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new Gd(this,tv())}nextDataId(){return e.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if((Np().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Np().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:DS.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,t,n,r,s){if(Np().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:DS.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:s,slice:o,shape:i,isPacked:a}=t;if(null!=o){let t;t=a?new BN(i,LN):new PN(i,LN);const n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),s=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const u=null!=this.activeTimers;let l,c;return u&&(l=Sg()),c="complex64"===r?Ew(this.readSync(s.real.dataId),this.readSync(s.imag.dataId)):this.getValuesFromTexture(e),u&&(this.downloadWaitMs+=Sg()-l),this.convertAndCacheOnCPU(e,c)}read(e){var t=this;return jd(function*(){if(t.pendingRead.has(e)){const n=t.pendingRead.get(e);return new Promise(e=>n.push(e))}const n=t.texData.get(e),{values:r,shape:s,slice:o,dtype:i,complexTensorInfos:a,isPacked:u}=n;if(null!=o){let n;n=u?new BN(s,LN):new PN(s,LN);const r=t.runWebGLProgram(n,[{dataId:e,shape:s,dtype:i}],i),o=t.read(r.dataId);return t.disposeIntermediateTensorInfo(r),o}if(null!=r)return t.convertAndCacheOnCPU(e);if(!Np().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Np().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,c,h=null;if("complex64"!==i&&Np().get("WEBGL_BUFFER_SUPPORTED")){l=t.decode(e);const n=t.texData.get(l.dataId);h=t.gpgpu.createBufferFromTexture(n.texture,...LS(s))}if(t.pendingRead.set(e,[]),"complex64"!==i&&(yield t.gpgpu.createAndWaitForFence()),"complex64"===i){const e=yield Promise.all([t.read(a.real.dataId),t.read(a.imag.dataId)]);c=Ew(e[0],e[1])}else if(null==h)c=t.getValuesFromTexture(e);else{const e=tp(s);c=t.gpgpu.downloadFloat32MatrixFromBuffer(h,e)}null!=l&&t.disposeIntermediateTensorInfo(l);const d=t.convertAndCacheOnCPU(e,c),p=t.pendingRead.get(e);return t.pendingRead.delete(e),p.forEach(e=>e(d)),t.pendingDisposal.has(e)&&(t.pendingDisposal.delete(e),t.disposeData(e)&&tv().removeDataId(e,t),t.pendingDeletes--),d})()}bufferSync(e){const t=this.readSync(e.dataId);let n=t;if("string"===e.dtype)try{n=t.map(e=>Ig(e))}catch(r){throw new Error("Failed to decode encoded string bytes into utf-8")}return qy(e.shape,e.dtype,n)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!zS(n)){if(Np().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),s=tp(t);if(Np().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),o=this.gpgpu.downloadMatrixFromPackedTexture(r.texture,...LS(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(n),o}const o=Np().getBool("WEBGL_PACK")&&!0===r,i=o?JS(t):t,a=o?new gT(i):new mT(i),u=this.runWebGLProgram(a,[{shape:i,dtype:n,dataId:e}],"float32"),l=this.texData.get(u.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture,l.texShape[0],l.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(u),c}timerAvailable(){return Np().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var t=this;return jd(function*(){const n=t.activeTimers,r=[];let s=!1;null==t.programTimersStack?(t.programTimersStack=r,s=!0):t.activeTimers.push(r),t.activeTimers=r,e();const o=ep(t.activeTimers.map(e=>e.query)).filter(e=>null!=e),i=ep(t.activeTimers.map(e=>e.name)).filter(e=>null!=e);t.activeTimers=n,s&&(t.programTimersStack=null);const a={uploadWaitMs:t.uploadWaitMs,downloadWaitMs:t.downloadWaitMs,kernelMs:null,wallMs:null};if(Np().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=yield Promise.all(o);a.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),a.getExtraProfileInfo=()=>e.map((e,t)=>({name:i[t],ms:e})).map(e=>`${e.name}: ${e.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return t.uploadWaitMs=0,t.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Np().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Sg(),endMs:null}}endTimer(e){return Np().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Sg(),e)}getQueryTime(e){var t=this;return jd(function*(){return Np().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?t.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:s,isPacked:o,slice:i}=this.texData.get(e),a=i&&i.origDataId||e,u=this.dataRefCount.get(a);u>1?this.dataRefCount.set(a,u-1):(this.dataRefCount.delete(a),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,s,o)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=WN){return Np().getBool("WEBGL_CPU_FORWARD")&&e.every(e=>null==this.texData.get(e.dataId).texture&&tp(e.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){_w("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return UN(e.shape,t)}packedUnaryOp(e,t,n){const r=new BN(e.shape,t),s=this.compileAndRun(r,[e],n);return tv().makeTensorFromDataId(s.dataId,s.shape,s.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=fN(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(Np().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,MN,e.dtype);const t=new PN(e.shape,MN),n=this.compileAndRun(t,[e]);return tv().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&fp(n[0])){const s=n.map(e=>Tg(e));r=this.write(s,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){const{dataId:r}=this.makeTensorInfo(e,t,n);return tv().makeTensorFromDataId(r,e,t,this)}unpackTensor(e){const t=new VN(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new $N(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[QS(e.shape),...ZS(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},s=[QS(t),...ZS(t)],o=new RN(s,n),i=this.runWebGLProgram(o,[r],e.dtype,null,!0);return{dataId:i.dataId,shape:t,dtype:i.dtype}}decode(e){const t=this.texData.get(e),{isPacked:n,shape:r,dtype:s}=t,o=JS(r);let i;return i=n?new fT(o):new pT(o),{dtype:s,shape:r,dataId:this.runWebGLProgram(i,[{shape:o,dtype:s,dataId:e}],s,null,!0).dataId}}runWebGLProgram(e,t,n,r,s=!1){const o=this.makeTensorInfo(e.outputShape,n),i=this.texData.get(o.dataId);if(e.packedOutput&&(i.isPacked=!0),e.outPackingScheme===FS.DENSE){const t=LS(e.outputShape);i.texShape=t.map(e=>2*e)}if(null!=e.outTexUsage&&(i.usage=e.outTexUsage),0===tp(o.shape))return i.values=lp(o.dtype,0),o;const a=[],u=t.map(t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&tp(t.shape)<=Np().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}else if(!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),a.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!tT(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),a.push(t),n=this.texData.get(t.dataId),e.shape=r}return this.uploadToGPU(t.dataId),{shape:t.shape,texData:n,isUniform:!1}});this.uploadToGPU(o.dataId);const l={shape:o.shape,texData:i,isUniform:!1},c=function(e,t,n){let r="";t.concat(n).forEach(e=>{r+=`${e.shape}_${e.isUniform?"uniform":e.texData.texShape}_${null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0}`});let s=e.constructor.name;return s+="_"+r+"_"+e.userCode,s}(e,u,l),h=this.getAndSaveBinary(c,()=>function(e,t,n,r){const s=t.userCode,o=n.map((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}}),i=o.map(e=>e.shapeInfo),a={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},u=TT(o,a,s,t.packedInputs),l=e.createProgram(u);let c=null;const h=e.getUniformLocation(l,"NAN",!1);1===Np().getNumber("WEBGL_VERSION")&&(c=e.getUniformLocation(l,"INFINITY",!1));const d={};for(let p=0;p<t.variableNames.length;p++){const n=t.variableNames[p],r=!1;d[n]=e.getUniformLocation(l,n,r),d[`offset${n}`]=e.getUniformLocation(l,`offset${n}`,r)}return{program:t,source:u,webGLProgram:l,uniformLocations:d,inShapeInfos:i,outShapeInfo:a,infLoc:c,nanLoc:h}}(this.gpgpu,e,u,l)),d=null!=this.activeTimers;let p;d&&(p=this.startTimer()),function(e,t,n,r,s){BT(t.inShapeInfos,n),BT([t.outShapeInfo],[r]);const o=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(o,i[0],i[1]):e.setOutputMatrixTexture(o,i[0],i[1]),e.setProgram(t.webGLProgram),1===Np().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach((n,r)=>{const s=t.program.variableNames[r],o=t.uniformLocations[s],i=t.uniformLocations[`offset${s}`];if(null!=o)if(n.isUniform)if(tp(n.shape)<2)e.gl.uniform1f(o,n.uniformValues[0]);else{let t=n.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(o,t)}else null!=n.texData.slice&&null!=i&&e.gl.uniform1i(i,n.texData.slice.flatOffset),e.setInputMatrixTexture(n.texData.texture,o,r)}),null!=s&&s(e,t.webGLProgram),e.executeProgram()}(this.gpgpu,h,u,l,r),a.forEach(e=>this.disposeIntermediateTensorInfo(e)),d&&(p=this.endTimer(p),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(p)}));const f=Np().get("WEBGL_FLUSH_THRESHOLD");if(f>0){const e=Sg();e-this.lastGlFlushTime>f&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!Np().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&!1===s){const e=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),e}return o}compileAndRun(e,t,n,r,s=!1){return this.runWebGLProgram(e,t,n=n||t[0].dtype,r,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Np().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=nv(()=>{if(!Np().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Np().getBool("DEBUG");Np().set("DEBUG",!1);const t=this.abs(Fx(1e-8)).dataSync()[0];if(Np().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:s,texture:o,usage:i,isPacked:a}=t;if(null!=o)return;const u=null!=this.activeTimers;let l;u&&(l=Sg());let c=t.texShape;if(null==c&&(c=function(e,t=!1){let n=Np().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t&&(n*=2,1===(e=e.map((t,n)=>n>=e.length-2?Yd(e[n]):e[n])).length&&(e=[2,e[0]])),2!==e.length){const t=up(e);e=t.newShape}let r=tp(e);if(e.length<=1&&r<=n)return[1,r];if(2===e.length&&e[0]<=n&&e[1]<=n)return e;if(3===e.length&&e[0]*e[1]<=n&&e[2]<=n)return[e[0]*e[1],e[2]];if(3===e.length&&e[0]<=n&&e[1]*e[2]<=n)return[e[0],e[1]*e[2]];if(4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n)return[e[0]*e[1]*e[2],e[3]];if(4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n)return[e[0],e[1]*e[2]*e[3]];if(t){const t=QS(e);let n=2,s=2;return e.length&&([n,s]=ZS(e)),r=t*(n/2)*(s/2),sp(r).map(e=>2*e)}return sp(r)}(n,a),t.texShape=c),null!=s){const e=JS(n);let o,i=c[1],h=c[0];const d=s instanceof Uint8Array;a?([i,h]=BS(c[0],c[1]),o=new xT(e,[h,i],d)):o=new yT(e,[h,i],d);const p=this.makeTensorInfo([h,i],r);this.texData.get(p.dataId).usage=d?DS.PIXELS:DS.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(p.dataId),i,h,s);const f=this.runWebGLProgram(o,[p],r,null,!0),m=this.texData.get(f.dataId);t.texture=m.texture,t.texShape=m.texShape,t.isPacked=m.isPacked,t.usage=m.usage,this.disposeIntermediateTensorInfo(p),this.texData.delete(f.dataId),t.values=null,u&&(this.uploadWaitMs+=Sg()-l)}else{const e=this.acquireTexture(c,i,r,a);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return this.releaseGPUData(e),null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*pp(t)}}return e.nextDataId=0,e})();iy()&&function(e,t,n=1){ry.registerBackend("webgl",t,n)}(0,()=>new jN,2);class HN{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=Tb(t,n),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class GN{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Tb(t,n);const s=this.outputShape.length;let o="";if(r)if(0===s||1===tp(this.outputShape))o="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(o=`\n          ${PT(s)} coords = getOutputCoords();\n        `,1===s)o+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=NN("coords",s);o+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${o}\n\n        setOutput(result);\n      }\n    `}}function qN(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const KN={kernelName:Rf,backendName:"webgl",kernelFunc:qN};function XN(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,o=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(o.dataId),a=qN({inputs:{x:r},backend:n}),u=qN({inputs:{x:s},backend:n});return i.complexTensorInfos={real:a,imag:u},o}const YN={kernelName:Jp,backendName:"webgl",kernelFunc:XN},QN="return (a < 0.) ? b * a : a;",ZN="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",JN={kernelName:Df,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:o}=r,i=n.makeTensorInfo([],"float32",kg(o,"float32")),a=Np().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new GN(ZN,s.shape,i.shape):new HN(QN,s.shape,i.shape),u=n.runWebGLProgram(a,[s,i],s.dtype);return n.disposeIntermediateTensorInfo(i),u}},e$="return (a < 0.) ? b * a : a;",t$="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",n$={kernelName:am,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t,o=Np().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new GN(t$,r.shape,s.shape):new HN(e$,r.shape,s.shape);return n.runWebGLProgram(o,[r,s],r.dtype)}};function r$({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:o})=>{const{x:i}=s,a=o,u=r||i.dtype;if(a.shouldExecuteOnCPU([i])&&null!=n){const e=a.texData.get(i.dataId),t=n(e.values,u);return a.makeTensorInfo(i.shape,u,t)}let l;return l=Np().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new BN(i.shape,t):new PN(i.shape,e),a.runWebGLProgram(l,[i],u)}}function s$({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:o}){return({inputs:i,backend:a})=>{const{a:u,b:l}=i,c=a;if(r&&"complex64"===u.dtype){const t=c.texData.get(u.dataId),n=c.texData.get(l.dataId),[r,s]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map(t=>{const[n,r]=t,s={dataId:n.dataId,dtype:n.dtype,shape:u.shape},o={dataId:r.dataId,dtype:r.dtype,shape:l.shape},i=new HN(e,u.shape,l.shape);return c.runWebGLProgram(i,[s,o],Kg(n.dtype,r.dtype))}),o=XN({inputs:{real:r,imag:s},backend:c});return c.disposeIntermediateTensorInfo(r),c.disposeIntermediateTensorInfo(s),o}const h=o||Kg(u.dtype,l.dtype);if(("string"===u.dtype||"string"===l.dtype||c.shouldExecuteOnCPU([u,l]))&&null!=s){const e=c.texData.get(u.dataId).values,t=c.texData.get(l.dataId).values,n="string"===u.dtype?jw(e):e,r="string"===u.dtype?jw(t):t,[o,i]=s(u.shape,l.shape,n,r,h),a=c.makeTensorInfo(i,h);return c.texData.get(a.dataId).values=o,a}let d;return d=Np().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new GN(t,u.shape,l.shape,n):new HN(e,u.shape,l.shape),c.runWebGLProgram(d,[u,l],h)}}function o$(e,t=!1){if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===e)return t?t$:e$;if("leakyrelu"===e)return t?ZN:QN;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class i${constructor(e,t,n,r=!1,s=!1,o=!1,i=null,a=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;const l=Math.ceil((r?e[1]:e[2])/2),c=r?"i * 2, rc.y":"rc.y, i * 2",h=s?"rc.z, i * 2":"i * 2, rc.z",d=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],p=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let f="",m="";i&&(f=a?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:u?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,m="result = activation(result);");const g=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let y="rc.x",x="rc.x";e[0]<t[0]?y=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(x=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`\n      ${f}\n\n      const float sharedDimension = ${l}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${l}; i++) {\n          int batchA = ${y};\n          int batchB = ${x};\n          vec4 a = getMatrixA(batchA, ${c});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${d[0]} * ${p[0]});\n          result += (${d[1]} * ${p[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${g}\n\n        ${m}\n\n        setOutput(result);\n      }\n    `}}class a${constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Tb(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const u$="return a * b;";function l$(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,o=Kg(r.dtype,s.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),o=new a$("return areal * breal - aimag * bimag;",r.shape,s.shape),i=new a$("return areal * bimag + aimag * breal;",r.shape,s.shape),a=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],u=n.runWebGLProgram(o,a,"float32"),l=n.runWebGLProgram(i,a,"float32"),c=XN({inputs:{real:u,imag:l},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(l),c}if(n.shouldExecuteOnCPU([r,s])){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),[i,a]=uN(r.shape,s.shape,e.values,t.values,o),u=n.makeTensorInfo(a,o);return n.texData.get(u.dataId).values=i,u}let i;return i=Np().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new GN(u$,r.shape,s.shape):new HN(u$,r.shape,s.shape),n.runWebGLProgram(i,[r,s],o)}const c$={kernelName:Zf,backendName:"webgl",kernelFunc:l$};function h$(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:o}=r,i=n,a=tp(s.shape),u=function(e,t){let n=1,r=-1;for(let o=0;o<e.length;++o)if(e[o]>=0)n*=e[o];else if(-1===e[o]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${o}`);r=o}else if(e[o]<0)throw Error(`Shapes can not be < 0. Found ${e[o]} at dim ${o}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const s=e.slice();return s[r]=t/n,s}(o,a),l=tp(u);Qd(a===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const c=i.texData.get(s.dataId);return!c.isPacked||tT(s.shape,u)||null!==c.texture&&tT(c.shape,u)?(i.incRef(s.dataId),{dataId:s.dataId,shape:u,dtype:s.dtype}):function(e,t,n){const r=[QS(e.shape),...ZS(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},o=[QS(t),...ZS(t)],i=new RN(o,r),a=n.runWebGLProgram(i,[s],e.dtype,null,!0);return{dataId:a.dataId,shape:t,dtype:a.dtype}}(s,u,i)}const d$={kernelName:pm,backendName:"webgl",kernelFunc:h$};class p${constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:o}=e;this.outputShape=[r,o];const i=4*Math.floor(n/4),a=n%4;let u="sumValue += dot(values, ones);";if(null!=t){const e=1/t;u=`sumValue += dot(values * ${rp(e)?e.toPrecision(2):e}, ones);`}let l="";s%n>0&&(l=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${l}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===a}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===a}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===a}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class f${constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:o}=e;this.outputShape=[r,o];let i="0.0",a="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",a="min"):"max"===t&&(i="-1.0 / 1e-20",a="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?u="sumValue":"prod"===t?u="prodValue":"all"===t?u="allValue":"any"===t&&(u="anyValue");const l=4*Math.floor(n/4),c=n%4;let h=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${a}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${a}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,d="vec4";"all"===t?(i="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===t&&(i="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";s%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${l}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${l};\n        if (${1===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${u});\n      }\n    `}}function m$(e,t,n,r){const s=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=sw(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let o=e;for(let i=0;i<s.length;i++){const{inSize:a,windowSize:u,outSize:l}=s[i];let c,h;c="mean"===n?0===i?new p$({windowSize:u,inSize:a,batchSize:e.shape[0],outSize:l},a):new p$({windowSize:u,inSize:a,batchSize:e.shape[0],outSize:l}):new f$({windowSize:u,inSize:a,batchSize:e.shape[0],outSize:l},n),h=o,o=r.runWebGLProgram(c,[o],t),h.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(h)}return o}class g${constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[t[o]];this.outputShape=n,this.rank=n.length;const r=PT(this.rank),s=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<e.length;s++)r[e[s]]=n[s];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${s}));\n    }\n    `}}class y${constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let l=0;l<n.length;l++)n[l]=e[t[l]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=PT(this.rank),s=IN("rc",this.rank),o=new Array(this.rank);for(let l=0;l<t.length;l++)o[t[l]]=s[l];const i=`vec2(${o.slice(-2).join()})`,a=`++${s[this.rank-1]} < ${n[this.rank-1]}`,u=`getChannel(getA(${o.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${a}) {\n        result[1] = ${u};\n      }\n      --${s[this.rank-1]};\n      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${u};\n        if(${a}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function x$(e,t,n){const r=Np().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new y$(e.shape,t):new g$(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function b$(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:i}=r;return function(e,t,n,r){const s=e.shape.length,o=ap(t,e.shape);let i=o;const a=Hb(i,s),u=null!=a;let l=e;u&&(l=x$(e,a,r),i=qb(i.length,s)),jb("sum",i,s);const[c,h]=zb(l.shape,i);let d=c;n&&(d=Wb(c,o));const p=tp(h),f=h$({inputs:{x:l},attrs:{shape:[tp(e.shape)/p,p]},backend:r}),m=m$(f,Xg(e.dtype),"sum",r),g=h$({inputs:{x:m},attrs:{shape:d},backend:r});return r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(m),u&&r.disposeIntermediateTensorInfo(l),g}(s,o,i,n)}const v$={kernelName:"Sum",backendName:"webgl",kernelFunc:b$};function w$(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:o}=r,i=n,a=new Array(s.shape.length);for(let l=0;l<a.length;l++)a[l]=s.shape[o[l]];let u;if(i.shouldExecuteOnCPU([s])){const e=i.texData.get(s.dataId),t=SN(e.values,s.shape,s.dtype,o,a);u=i.makeTensorInfo(a,s.dtype),i.texData.get(u.dataId).values=t}else u=x$(s,o,i);return u}const C$={kernelName:qm,backendName:"webgl",kernelFunc:w$};function _$({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:u=null}){const l=e.shape.length,c=t.shape.length,h=n?e.shape[l-2]:e.shape[l-1],d=r?t.shape[c-1]:t.shape[c-2],p=n?e.shape[l-1]:e.shape[l-2],f=r?t.shape[c-2]:t.shape[c-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),y=tp(m),x=tp(g);Qd(l>=2&&c>=2&&(y===x||1===y||1===x),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${m}) and (${g}).`);const b=(y>x?e.shape.slice(0,-2):t.shape.slice(0,-2)).concat([p,f]);Qd(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);const v=n?[y,h,p]:[y,p,h],w=r?[x,f,d]:[x,d,f],C=h$({inputs:{x:e},backend:s,attrs:{shape:v}}),_=h$({inputs:{x:t},backend:s,attrs:{shape:w}}),k=[C,_],E=Math.max(y,x),S=n?C.shape[1]:C.shape[2],T=null!=o,I=null!=i,N="leakyrelu"===u,$=null!=u?o$(u,!0):null;let R;if((1===p||1===f)&&S>1e3&&!1===(T||I||N||null!=$)){let e=C,t=_;n&&(e=w$({inputs:{x:C},backend:s,attrs:{perm:[0,2,1]}}),k.push(e)),r&&(t=w$({inputs:{x:_},backend:s,attrs:{perm:[0,2,1]}}),k.push(t));const o=1===f;let i=e;1!==f&&(i=h$({inputs:{x:e},backend:s,attrs:{shape:[E,S,1]}}),k.push(i));const a=1===f?2:1;let u=t;o&&(u=h$({inputs:{x:t},backend:s,attrs:{shape:[E,1,S]}}),k.push(u));const l=l$({inputs:{a:i,b:u},backend:s});R=b$({inputs:{x:l},backend:s,attrs:{axis:a,keepDims:!0}}),k.push(l)}else{const u=Kg(e.dtype,t.dtype),l=new i$(v,w,[E,p,f],n,r,T,$,I,N),c=[C,_];if(null!=o&&c.push(o),I&&c.push(i),N){const e=s.makeTensorInfo([],"float32",kg(a,"float32"));c.push(e),k.push(e)}R=s.runWebGLProgram(l,c,u)}const A=h$({inputs:{x:R},backend:s,attrs:{shape:b}});k.push(R);for(const O of k)s.disposeIntermediateTensorInfo(O);return A}const k$={kernelName:eg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:o,bias:i,preluActivationWeights:a}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:h}=r;return _$({a:s,b:o,transposeA:u,transposeB:l,backend:n,bias:i,preluActivationWeights:a,leakyreluAlpha:h,activation:c})}},E$="return abs(x);",S$={kernelName:"Abs",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=fN(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let s;return s=Np().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new BN(r.shape,E$):new PN(r.shape,E$),n.runWebGLProgram(s,[r],r.dtype)}},T$=r$({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),I$={kernelName:Fp,backendName:"webgl",kernelFunc:T$},N$=r$({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),$$={kernelName:Dp,backendName:"webgl",kernelFunc:N$},R$="return a + b;",A$=s$({opSnippet:R$,packedOpSnippet:R$,supportsComplex:!0,cpuKernelImpl:zI}),O$={kernelName:Pp,backendName:"webgl",kernelFunc:A$};class F${constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);const n=[];this.variableNames.forEach(e=>{n.push(`float v${e} = get${e}AtOutCoords();`)});const r=this.variableNames.map(e=>`v${e}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class D${constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);const n=[];this.variableNames.forEach(e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)});const r=this.variableNames.map(e=>`v${e}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const P$={kernelName:Mp,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,s=n;if(1===s.length)return qN({inputs:{x:s[0]},backend:r});if(s.length>Np().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(s.length/2),n=e({inputs:s.slice(0,t),backend:r}),o=e({inputs:s.slice(t),backend:r});return e({inputs:[n,o],backend:r})}const o=s.map(e=>e.dtype).reduce((e,t)=>Kg(e,t)),i=s.map(e=>e.shape),a=Np().getBool("WEBGL_PACK")?new D$(s[0].shape,i):new F$(s[0].shape,i);return r.runWebGLProgram(a,s,o)}},M$={kernelName:"All",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:i}=r,a=s.shape.length,u=ap(o,s.shape);let l=u;const c=Hb(l,a);let h=s;null!=c&&(h=w$({inputs:{x:s},backend:n,attrs:{perm:c}}),l=qb(l.length,a)),jb("all",l,a);const[d,p]=zb(h.shape,l),f=h$({inputs:{x:h},backend:n,attrs:{shape:[-1,tp(p)]}}),m=m$(f,f.dtype,"all",n);let g;return g=h$(i?{inputs:{x:m},backend:n,attrs:{shape:Wb(d,u)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}},L$={kernelName:"Any",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:i}=r,a=s.shape.length,u=ap(o,s.shape);let l=u;const c=Hb(l,a);let h=s;null!=c&&(h=w$({inputs:{x:s},backend:n,attrs:{perm:c}}),l=qb(l.length,a)),jb("any",l,a);const[d,p]=zb(h.shape,l),f=h$({inputs:{x:h},backend:n,attrs:{shape:[-1,tp(p)]}}),m=m$(f,f.dtype,"any",n);let g;return g=h$(i?{inputs:{x:m},backend:n,attrs:{shape:Wb(d,u)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}};class B${constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:s,outSize:o}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,o],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===t?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class V${constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Qd(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);const s=Math.ceil(e[e.length-1]/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");const o=this.outputShape,i=o.length,a=PT(i),u=NN("coords",i);let l,c;if(1===s){c=i+1;const e=PT(c);l=`\n        ${e} sourceLocR = ${e}(${u.join()}, 0);\n        ++${u[i-1]};\n        ${e} sourceLocG = ${e}(${u.join()}, 0);\n        ++${u[i-2]};\n        ${e} sourceLocA = ${e}(${u.join()}, 0);\n        --${u[i-1]};\n        ${e} sourceLocB = ${e}(${u.join()}, 0);\n        --${u[i-2]};`}else c=i,l=`\n        ${a} sourceLocR = coords;\n        ++${u[i-1]};\n        ${a} sourceLocG = coords;\n        ++${u[i-2]};\n        ${a} sourceLocA = coords;\n        --${u[i-1]};\n        ${a} sourceLocB = coords;\n        --${u[i-2]};`;const h=["x","y","z","w","u","v"].slice(0,c),d="."+h[c-1],p=h.map(e=>"int "+e),f=NN("sourceLocR",c-1).concat("inIdx.r"),m=NN("sourceLocG",c-1).concat("inIdx.g"),g=NN("sourceLocB",c-1).concat("inIdx.b"),y=NN("sourceLocA",c-1).concat("inIdx.a"),x="max"===n?"greaterThan":"lessThan",b=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${f.join()}),\n                             getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()})));`,v=`vec4(\n            getAChannel(${f.join()}),\n            hasNextCol ? getAChannel(${m.join()}) : 0.,\n            hasNextRow ? getAChannel(${g.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${y.join()}) : 0.)`,w=r?"":`\n      float getBestIndicesAChannel(${p.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${p.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${w}\n      void main() {\n        ${a} coords = getOutputCoords();\n        bool hasNextCol = ${u[i-1]} < ${o[i-1]-1};\n        bool hasNextRow = ${u[i-2]} < ${o[i-2]-1};\n        ${l}\n        ivec4 srcIdx = ivec4(sourceLocR${d}, sourceLocG${d},\n          sourceLocB${d}, sourceLocA${d}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${v};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${b}\n          vec4 candidate = ${v};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function U$(e,t,n,r=null){let s=t.shape[0],o=t.shape[1];null!=r&&(s=r.shape[0],o=r.shape[1]);const i=sw(o),a={windowSize:i,inSize:o,batchSize:s,outSize:Math.ceil(o/i)},u=new B$(a,n,null==r),l=[t];null!=r&&l.push(r);const c=e.runWebGLProgram(u,l,"int32");if(1===c.shape[1])return c;const h=U$(e,t,n,c);return e.disposeIntermediateTensorInfo(c),h}function z$(e,t,n,r=null){const s=null!=r?r.shape:t.shape,o=sw(s[s.length-1]),i=new V$(s,o,n,null==r),a=e.runWebGLProgram(i,null==r?[t]:[t,r],"int32");if(a.shape.length===t.shape.length){const r=z$(e,t,n,a);return e.disposeIntermediateTensorInfo(a),r}return a}function W$(e,t,n,r){const s=[n];if(jb("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!Np().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],[o,i]=zb(t.shape,s),a=tp(i),u=h$({inputs:{x:t},backend:e,attrs:{shape:[-1,a]}});n.push(u);const l=U$(e,u,r);n.push(l);const c=h$({inputs:{x:l},backend:e,attrs:{shape:o}});return n.forEach(t=>e.disposeIntermediateTensorInfo(t)),c}return z$(e,t,r)}const j$={kernelName:Lp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o}=r;let i=ap(o,s.shape);const a=Hb(i,s.shape.length);let u=s;const l=[];null!=a&&(u=w$({inputs:{x:s},backend:n,attrs:{perm:a}}),l.push(u),i=qb(i.length,u.shape.length)),jb("argMax",[i[0]],u.shape.length);const c=W$(n,u,i[0],"max");return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}},H$={kernelName:Bp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o}=r;let i=ap(o,s.shape);const a=Hb(i,s.shape.length);let u=s;const l=[];null!=a&&(u=w$({inputs:{x:s},backend:n,attrs:{perm:a}}),l.push(u),i=qb(i.length,u.shape.length)),jb("argMin",[i[0]],u.shape.length);const c=W$(n,u,i[0],"min");return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}},G$=r$({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),q$={kernelName:Vp,backendName:"webgl",kernelFunc:G$},K$=r$({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),X$={kernelName:Up,backendName:"webgl",kernelFunc:K$},Y$=r$({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),Q$={kernelName:zp,backendName:"webgl",kernelFunc:Y$},Z$=s$({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),J$={kernelName:jp,backendName:"webgl",kernelFunc:Z$},eR=r$({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),tR={kernelName:Wp,backendName:"webgl",kernelFunc:eR};class nR{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,i=e.strideHeight,a=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t;let m="0.0";if(f||(m="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${a});\n        const ivec2 pads = ivec2(${d}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${l}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?s?`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`:`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let g=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(g="avgValue / count");const y=4*Math.floor(o/4),x=o%4,b=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${a});\n      const ivec2 pads = ivec2(${d}, ${p});\n      const float initializationValue = ${m};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${m});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${y}; wC += 4) {\n            int xC = xCCorner + wC * ${l};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              getValue(batch, xR, xC + 3 * ${l}, d)\n            );\n\n            ${b}\n          }\n\n          int xC = xCCorner + ${y};\n          if (${1===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${b}\n          } else if (${2===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${b}\n          } else if (${3===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              initializationValue\n            );\n\n            ${b}\n          }\n        }\n        setOutput(${g});\n      }\n    `}}class rR{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,i=e.strideDepth,a=e.strideHeight,u=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const x="avg"===t;let b="0.0";if(x||(b="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${a}, ${u});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${l}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(v="avgValue / count");const w=4*Math.floor(o/4),C=o%4,_=`\n      if (${x}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${a}, ${u});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${l}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${_}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===C}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${_}\n            } else if (${2===C}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${_}\n            } else if (${3===C}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${_}\n            }\n          }\n          setOutput(${v});\n        }\n      }\n    `}}const sR={kernelName:Hp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;aT(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:u}=r;Qd(Gv(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const l=Pv(s.shape,o,i,1,a,u);if(1===l.filterWidth&&1===l.filterHeight&&np(l.inShape,l.outShape))return qN({inputs:{x:s},backend:n});const c=new nR(l,"avg",!1);return n.runWebGLProgram(c,[s],"float32")}},oR={kernelName:Gp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:o,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=r,c=Mv(s.shape,o,i,[1,1,1],a,u,l),h=new rR(c,"avg",!1);return n.runWebGLProgram(h,[s],"float32")}};class iR{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.effectiveFilterHeight,n=e.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n      const float avgMultiplier = float(${1/(e.filterHeight*e.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t};\n            wR += ${e.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n};\n            wC+= ${e.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class aR{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.effectiveFilterDepth,n=e.effectiveFilterHeight,r=e.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${t-1-e.padInfo.front}, ${n-1-e.padInfo.top}, ${r-1-e.padInfo.left});\n      const float avgMultiplier = float(${1/(e.filterDepth*e.filterHeight*e.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${t};\n            wD += ${e.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${e.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${e.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${r};\n                wC += ${e.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const uR={kernelName:"AvgPool3DGrad",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o}=t,i=o,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=r,h=Mv(i.shape,a,u,[1,1,1],l,c),d=new aR(h);return n.runWebGLProgram(d,[s],i.dtype)}},lR={kernelName:"AvgPoolGrad",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o}=t,i=o;aT([s,o],"avgPoolGrad");const{filterSize:a,strides:u,pad:l}=r,c=Pv(i.shape,a,u,1,l),h=new iR(c);return n.runWebGLProgram(h,[s],i.dtype)}},cR={kernelName:qp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:o}=t,{transposeA:i,transposeB:a}=r;return _$({a:s,b:o,transposeA:i,transposeB:a,backend:n})}};class hR{constructor(e,t,n,r,s,o){this.outputShape=[],this.variableNames=["x","mean","variance"],Tb(e,t),Tb(e,n);let i="0.0";null!=r&&(Tb(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let a="1.0";null!=s&&(Tb(e,s),this.variableNames.push("scale"),a="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${a};\n        float inv = scale * inversesqrt(variance + float(${o}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class dR{constructor(e,t,n,r,s,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Tb(e,t),Tb(e,n);let i="vec4(0.0)";null!=r&&(Tb(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let a="vec4(1.0)";null!=s&&(Tb(e,s),this.variableNames.push("scale"),a="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${a};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${o}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const pR={kernelName:Sf,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,mean:s,variance:o,offset:i,scale:a}=e;Qd(s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Qd(null==i||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Qd(null==a||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=n;null==u&&(u=.001);const l=[r,s,o];let c=null;null!=i&&(c=i.shape,l.push(i));let h=null;null!=a&&(h=a.shape,l.push(a));const d=Np().getBool("WEBGL_PACK_NORMALIZATION")?new dR(r.shape,s.shape,o.shape,c,h,u):new hR(r.shape,s.shape,o.shape,c,h,u);return t.runWebGLProgram(d,l,l[0].dtype)}};class fR{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=PT(this.rank),n=`uniform int start[${this.rank}];`,r=function(e){if(1===e)return"sourceLoc";if(e<=6)return mR.slice(0,e).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let s;s=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map((e,t)=>`sourceLoc.${mR[t]} = start[${t}] + coords.${mR[t]};`).join("\n")}\n      `,this.userCode=`\n      ${n}\n      void main() {\n        ${s}\n        setOutput(getSource(${r}));\n      }\n    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(t,n)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,e)}}}const mR=["x","y","z","w","u","v"];class gR{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length;const t=PT(this.rank),n=NN("coords",this.rank),r=NN("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,o=`getChannel(getSource(${r.join()}), ${s})`,i=`\n      result.x = ${o};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${o};\n        --${r[this.rank-1]};\n      }\n    `,a=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${o};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${o};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map((e,t)=>`start[${t}]`).join()});`:e.map((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`).join("\n");this.userCode=`\n      uniform int start[${this.rank}];\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${i}\n        ${a}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(t,n)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,e)}}}function yR(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:o,size:i}=r,[a,u]=Cx(s,o,i);if(ux(s,a,u),0===tp(u))return n.makeTensorInfo(u,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||"string"===s.dtype){const e=n.texData.get(s.dataId),t=mN(e.values,a,u,s.shape,s.dtype);return n.makeTensorInfo(u,s.dtype,t)}const{isPacked:l}=n.texData.get(s.dataId),c=vx(s.shape,a,u);if(l||!c){const e=Np().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new gR(u):new fR(u),t=e.getCustomSetupFunc(a);return n.runWebGLProgram(e,[s],s.dtype,t)}return n.uploadToGPU(s.dataId),function(e,t,n,r){const s=r.texData.get(e.dataId),o=r.makeTensorInfo(n,e.dtype),i=r.texData.get(o.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=e.dtype;let a=wx(t,xp(e.shape));s.slice&&(a+=s.slice.flatOffset),i.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||e.dataId};const u=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,u+1),o}(s,a,u,n)}const xR={kernelName:_m,backendName:"webgl",kernelFunc:yR},bR={kernelName:Kp,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:o,crops:i}=r;Qd(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((e,t)=>e*t),u=iw(s.shape,o,a),l=aw(u.length,o.length),c=uw(s.shape,o,a),h=lw(i,o.length),d=cw(c,i,o.length),p=[],f=h$({inputs:{x:s},backend:n,attrs:{shape:u}}),m=w$({inputs:{x:f},backend:n,attrs:{perm:l}}),g=h$({inputs:{x:m},backend:n,attrs:{shape:c}}),y=yR({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach(e=>n.disposeIntermediateTensorInfo(e)),y}},vR={kernelName:Xp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:o}=t,{size:i}=r,a=n.readSync(s.dataId),u=n.readSync(o.dataId),l=WI(a,u,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,l)}},wR=s$({opSnippet:"return float(a != b);",cpuKernelImpl:cN,dtype:"bool"}),CR={kernelName:Jf,backendName:"webgl",kernelFunc:wR};function _R(e){const{inputs:t,backend:n}=e,{input:r}=t;return qN({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const kR={kernelName:cm,backendName:"webgl",kernelFunc:_R},ER={kernelName:Yp,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:s}=t,{x:o}=n,{dtype:i}=s;if("complex64"===i){if("complex64"===o.dtype)return qN({inputs:{x:o},backend:r});const t=Wx(o.shape),n=e({inputs:{x:o},backend:r,attrs:{dtype:"float32"}}),s=XN({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),s}if("complex64"===o.dtype){const t=_R({inputs:{input:o},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:i}});return r.disposeIntermediateTensorInfo(t),n}if(!hp(o.dtype,i)){const e=qN({inputs:{x:o},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if("int32"===i)return function(e,t){const n=new PN(e.shape,"return float(int(x));"),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(o,r);if("bool"===i){const e=r.makeTensorInfo([],"bool",lp("bool",1)),t=wR({inputs:{a:o,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${i}`)}},SR="return ceil(x);",TR=r$({opSnippet:SR,packedOpSnippet:SR,cpuKernelImpl:HI}),IR={kernelName:Qp,backendName:"webgl",kernelFunc:TR};class NR{constructor(e){this.variableNames=["A"],this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}getCustomSetupFunc(e,t){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}}class $R{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}getCustomSetupFunc(e,t){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}}const RR={kernelName:Zp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:o,clipValueMax:i}=r;let a;a=Np().getBool("WEBGL_PACK_CLIP")?new $R(s.shape):new NR(s.shape);const u=a.getCustomSetupFunc(o,i);return n.runWebGLProgram(a,[s],s.dtype,u)}};class AR{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function OR(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const FR={kernelName:ef,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),o=new AR(r.shape),i=[OR(r,s.complexTensorInfos.real),OR(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(o,i,i[0].dtype)}};class DR{constructor(e){this.outputShape=[],this.outputShape=Fv(e,1),this.variableNames=e.map((e,t)=>`T${t}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let r=1;r<t.length;r++)t[r]=t[r-1]+e[r][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let r=1;r<t.length;r++)n.push(`else if (yC < ${t[r]}) setOutput(getT${r}(yR, yC-${t[r-1]}));`);n.push(`else setOutput(getT${t.length}(yR, yC-${t[t.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class PR{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Fv(e,t);const n=this.outputShape,r=n.length,s=PT(r),o=NN("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((e,t)=>`T${t}`);const a=new Array(e.length-1);a[0]=e[0][t];for(let p=1;p<a.length;p++)a[p]=a[p-1]+e[p][t];const u=i[t],l=i.slice(-2),c=i.join();let h=`if (${u} < ${a[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${l.join()}));\n        }`;for(let p=1;p<a.length;p++){const e=a[p-1];h+=`\n        if (${u} < ${a[p]}  && ${u} >= ${a[p-1]}) {\n          return getChannel(\n            getT${p}(${MR(i,u,e)}),\n            vec2(${MR(l,u,e)}));\n        }`}const d=a[a.length-1];h+=`\n        return getChannel(\n          getT${a.length}(${MR(i,u,d)}),\n          vec2(${MR(l,u,d)}));`,this.userCode=`\n      float getValue(${i.map(e=>"int "+e)}) {\n        ${h}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${o}), 0., 0., 0.);\n\n        ${o[r-1]} = ${o[r-1]} + 1;\n        if (${o[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${o});\n        }\n\n        ${o[r-2]} = ${o[r-2]} + 1;\n        if (${o[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${o});\n        }\n\n        ${o[r-1]} = ${o[r-1]} - 1;\n        if (${o[r-2]} < ${n[r-2]} &&\n            ${o[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${o});\n        }\n        setOutput(result);\n      }\n    `}}function MR(e,t,n){const r=e.indexOf(t);return e.map((e,t)=>t===r?`${e} - ${n}`:e).join()}function LR(e){const{inputs:t,backend:n}=e,{input:r}=t;return qN({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const BR={kernelName:Of,backendName:"webgl",kernelFunc:LR};function VR(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map(e=>_R({inputs:{input:e},backend:n})),s=e.map(e=>LR({inputs:{input:e},backend:n})),o=VR(r,t,n),i=VR(s,t,n),a=XN({inputs:{real:o,imag:i},backend:n});return r.forEach(e=>n.disposeIntermediateTensorInfo(e)),s.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),a}let s=n.shouldExecuteOnCPU(e);if("string"===r&&(s=!0),s){const s=e.map(e=>{const r=tp(e.shape.slice(t));return h$({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})}),o=s.map(e=>({vals:n.readSync(e.dataId),shape:e.shape})),i=Fv(s.map(e=>e.shape),1),a=GI(o,i,r,1===s[0].shape[0]),u=Fv(e.map(e=>e.shape),t),l=n.makeTensorInfo(u,r,a);return s.forEach(e=>n.disposeIntermediateTensorInfo(e)),l}if(e.length>Np().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const r=Math.floor(e.length/2),s=VR(e.slice(0,r),t,n),o=VR(e.slice(r),t,n),i=VR([s,o],t,n);return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),i}if(Np().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){const s=new PR(e.map(e=>e.shape),t);return n.runWebGLProgram(s,e,r)}const{tensors2D:o,outShape:i}=function(e,t,n){const r=Fv(e.map(e=>e.shape),t);return{tensors2D:e.map(e=>h$({inputs:{x:e},attrs:{shape:[-1,tp(e.shape.slice(t))]},backend:n})),outShape:r}}(e,t,n),a=new DR(o.map(e=>e.shape)),u=n.runWebGLProgram(a,o,r);o.forEach(e=>n.disposeIntermediateTensorInfo(e));const l=h$({inputs:{x:u},attrs:{shape:i},backend:n});return n.disposeIntermediateTensorInfo(u),l}function UR(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,o=ap(s,t[0].shape)[0],i=Fv(t.map(e=>e.shape),o);if(0===tp(i))return n.makeTensorInfo(i,t[0].dtype,[]);const a=t.filter(e=>tp(e.shape)>0);return 1===a.length?qN({inputs:{x:a[0]},backend:n}):(Ov(a.map(e=>e.shape),o),VR(a,o,n))}const zR={kernelName:tf,backendName:"webgl",kernelFunc:UR};class WR{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,i=e.padInfo.left,a=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,c=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,x=m?3:1;let b="",v="";n&&(b=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,v="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${b}\n\n      const ivec2 strides = ivec2(${a}, ${u});\n      const ivec2 pads = ivec2(${o}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${x}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${l};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${v}\n        setOutput(result);\n      }\n    `}}class jR{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,s=e.strideDepth,o=e.strideHeight,i=e.strideWidth,a=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.filterDepth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${s}, ${o}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${a};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${l};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class HR{constructor(e,t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;const{filterWidth:r,inChannels:s,strideWidth:o,strideHeight:i,padInfo:a,outWidth:u,dilationWidth:l,dilationHeight:c,dataFormat:h}=n,{left:d,top:p}=a,f=s*r,m=lT(),g="channelsLast"===h,y=g?0:1,x=g?1:2;let b="";for(let v=0;v<=1;v++)for(let n=0;n<=1;n++)b+=`\n          blockIndex = rc.y + ${n};\n          pos = rc.x + ${v};\n\n          if(blockIndex < ${e[1]} && pos < ${e[0]}) {\n            offsetY = int(blockIndex / (${u})) * ${i} - ${p};\n            d0 = offsetY + ${c} * (pos / ${f});\n\n            if(d0 < ${t[y]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${u}.) * ${o}. - ${d}.);\n              d1 = offsetX + ${l} * (int(mod(float(pos), ${f}.) / ${s}.));\n\n              if(d1 < ${t[x]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${s}.));\n\n                if (${g}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*v+n}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*v+n}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${b}\n\n        ${m.output} = result;\n      }\n    `}}function GR({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const u=e.shape,l=r.texData.get(e.dataId),c="channelsLast"===n.dataFormat;let h;const d=[],p=u[2]%2!=0&&!!l.isPacked;if((1!=u[0]*u[1]*u[2]&&1!==n.outChannels||!(n.inChannels>1e3))&&Np().getBool("WEBGL_LAZILY_UNPACK")&&Np().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&p){const p={dataId:e.dataId,shape:[1,c?u[0]*u[1]*(u[2]+1):u[0]*u[2]*(u[3]+1),n.inChannels],dtype:e.dtype},f=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,Qd(tT(l.shape,p.shape),()=>`packed reshape ${l.shape} to ${p.shape} isn't free`);const m=h$({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});d.push(m);const g=_$({a:p,b:m,backend:r,transposeA:!1,transposeB:!1,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),y=r.texData.get(g.dataId);Qd(y.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=f,y.shape=n.outShape,h=qN({inputs:{x:g},backend:r}),h.shape=n.outShape,d.push(g)}else{const l=h$({inputs:{x:e},backend:r,attrs:{shape:[1,c?u[0]*u[1]*u[2]:u[0]*u[2]*u[3],n.inChannels]}}),p=h$({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),f=_$({a:l,b:p,transposeA:!1,transposeB:!1,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i});h=h$({inputs:{x:f},backend:r,attrs:{shape:n.outShape}}),d.push(l),d.push(p),d.push(f)}for(const f of d)r.disposeIntermediateTensorInfo(f);return h}function qR({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:u,filterHeight:l,inChannels:c,outWidth:h,outHeight:d,dataFormat:p}=n,f="channelsLast"===p,m=u*l*c,g=d*h,y=[m,g],x=[],b=h$({inputs:{x:e},backend:r,attrs:{shape:e.shape.slice(1)}}),v=h$({inputs:{x:t},backend:r,attrs:{shape:[1,m,tp(t.shape)/m]}});x.push(b),x.push(v);const w=new HR(y,b.shape,n),C=r.runWebGLProgram(w,[b],"float32"),_=h$({inputs:{x:C},backend:r,attrs:{shape:[1,y[0],y[1]]}});x.push(C),x.push(_);const k=null!=s,E=null!=o,S="leakyrelu"===a,T=a?o$(a,!0):null,I=new i$(_.shape,v.shape,[1,g,n.outChannels],!0,!1,k,T,E,S),N=[_,v];if(s&&N.push(s),E&&N.push(o),S){const e=r.makeTensorInfo([],"float32",kg(i,"float32"));N.push(e),x.push(e)}const $=r.runWebGLProgram(I,N,"float32"),R=h$({inputs:{x:$},backend:r,attrs:{shape:f?[1,d,h,n.outChannels]:[1,n.outChannels,d,h]}});x.push($);for(const A of x)r.disposeIntermediateTensorInfo(A);return R}const KR={kernelName:nf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o}=t,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=r,h=qv(u),d=Lv(s.shape,o.shape,i,l,a,c,!1,h);let p;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(Np().getBool("WEBGL_CONV_IM2COL")&&1===s.shape[0])p=qR({x:s,filter:o,convInfo:d,backend:n});else{const e=new WR(d);p=n.runWebGLProgram(e,[s,o],"float32")}else p=GR({x:s,filter:o,convInfo:d,backend:n});const f=h$({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class XR{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${e.strideHeight} - ${e.padInfo.top};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${e.strideWidth} - ${e.padInfo.left};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${"channelsLast"===e.dataFormat}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class YR{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r="channelsLast"===e.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${r?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${r?1:2}], coords[${r?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${r}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class QR{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${e.strideDepth} - ${e.padInfo.front};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${e.strideHeight} - ${e.padInfo.top};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${e.strideWidth} - ${e.padInfo.left};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ZR{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${t-1-e.padInfo.front}, ${n-1-e.padInfo.top}, ${r-1-e.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${e.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const JR={kernelName:rf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:o}=t,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:c}=r,h=qv(u),d=Lv(s.shape,c,i,1,a,l,!1,h),p=new XR(d);return n.runWebGLProgram(p,[s,o],"float32")}},eA={kernelName:sf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:o}=t,{inputShape:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:c}=r,h=qv(l),d=Lv(i,o.shape,a,1,u,c,!1,h),p=new YR(d);return n.runWebGLProgram(p,[s,o],"float32")}},tA={kernelName:of,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o}=t,{strides:i,pad:a,dilations:u}=r,l=Bv(s.shape,o.shape,i,u,a),c=new jR(l);return n.runWebGLProgram(c,[s,o],"float32")}},nA={kernelName:"Conv3DBackpropFilterV2",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:o}=t,{strides:i,pad:a,filterShape:u}=r,l=Bv(s.shape,u,i,1,a),c=new QR(l);return n.runWebGLProgram(c,[s,o],"float32")}},rA={kernelName:"Conv3DBackpropInputV2",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:o}=t,{pad:i,strides:a,inputShape:u}=r,l=Bv(u,o.shape,a,1,i),c=new ZR(l);return n.runWebGLProgram(c,[s,o],"float32")}},sA={kernelName:"Cos",backendName:"webgl",kernelFunc:r$({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"})},oA=r$({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),iA={kernelName:af,backendName:"webgl",kernelFunc:oA};class aA{constructor(e,t,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,i,a,u]=e,[l]=t,[c,h]=n;this.outputShape=[l,c,h,u];const d="bilinear"===r?1:0,[p,f]=[i-1+".0",a-1+".0"],[m,g,y]=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[x,b,v]=h>1?[""+(a-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${x});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${o}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${b};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${s}));\n          return;\n        }\n        float in_x = ${v};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${s}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const uA={kernelName:lf,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:o,boxInd:i}=t,{cropSize:a,method:u,extrapolationValue:l}=r,c=new aA(s.shape,o.shape,a,u,l);return n.runWebGLProgram(c,[s,o,i],"float32")}};class lA{constructor(e,t,n){this.variableNames=["x"],this.outputShape=e;const r=e.length,s=t?"0.0":`getX(${cA(r,"coords")})`,o=e[e.length-1];let i="",a="";t?(i=n?"end != "+(o-1):"end != 0",a=n?"end + 1":"end - 1"):(i=n?`end + pow2 < ${o}`:"end >= pow2",a=n?"end + pow2":"end - pow2"),this.userCode=`\n      uniform float index;\n      void main() {\n        ${PT(r)} coords = getOutputCoords();\n        int end = ${hA(r,"coords")};\n        float val = ${s};\n        int pow2 = int(pow(2.0, index));\n        if (${i}) {\n          int idx = ${a};\n          ${hA(r,"coords")} = idx;\n          val += getX(${cA(r,"coords")});\n        }\n        setOutput(val);\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.index&&(this.index=t.getUniformLocation(n,"index")),t.gl.uniform1f(this.index,e)}}}function cA(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}function hA(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}const dA={kernelName:uf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,exclusive:i,reverse:a}=r,u=s.shape.length,l=Hb([o],u);let c=s;null!=l&&(c=w$({inputs:{x:s},backend:n,attrs:{perm:l}}));const h=qb(1,u)[0];if(h!==u-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${s.shape.length-1} but got axis=${o}`);const d=c.shape[h];let p=qN({inputs:{x:c},backend:n});for(let f=0;f<=Math.ceil(Math.log2(d))-1;f++){const e=new lA(c.shape,!1,a),t=e.getCustomSetupFunc(f),r=p;p=n.runWebGLProgram(e,[p],p.dtype,t),n.disposeIntermediateTensorInfo(r)}if(i){const e=new lA(c.shape,i,a),t=p;p=n.runWebGLProgram(e,[p],p.dtype),n.disposeIntermediateTensorInfo(t)}if(null!=l){const e=w$({inputs:{x:p},backend:n,attrs:{perm:Gb(l)}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(c),e}return p}},pA={kernelName:cf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:o}=t,{size:i,binaryOutput:a}=r;if(1===s.shape.length){const e=n.readSync(s.dataId),t=n.readSync(o.dataId),r=WI(e,t,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,r)}if(2===s.shape.length){const e=n.bufferSync(s),t=n.bufferSync(o),r=jI(e,t,i,a);return n.makeTensorInfo(r.shape,o.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class fA{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const mA={kernelName:hf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:o,dataFormat:i}=r;Qd(o>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${o}`);const a=s.shape[0],u=("NHWC"===i?s.shape[1]:s.shape[2])*o,l=("NHWC"===i?s.shape[2]:s.shape[3])*o,c=("NHWC"===i?s.shape[3]:s.shape[1])/(o*o),h=new fA("NHWC"===i?[a,u,l,c]:[a,c,u,l],o,i);return n.runWebGLProgram(h,[s],s.dtype)}};class gA{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.inHeight,i=e.inWidth,a=e.padInfo.top,u=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,h=e.dilationHeight,d=e.dilationWidth,p=e.filterHeight,f=e.filterWidth,m=e.outChannels/e.inChannels;let g="",y="";n&&(g=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,y="result = activation(result);");const x=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${g}\n\n      const ivec2 strides = ivec2(${l}, ${c});\n      const ivec2 pads = ivec2(${a}, ${u});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${m};\n        int q = d2 - d1 * ${m};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${p}; wR++) {\n          int xR = xRCorner + wR * ${h};\n\n          if (xR < 0 || xR >= ${o}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${f}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${i}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${x}\n        ${y}\n        setOutput(result);\n      }\n    `}}class yA{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.outShape;const o=e.outChannels/e.inChannels,i=e.inHeight,a=e.inWidth,u=e.padInfo.top,l=e.padInfo.left,c=e.strideHeight,h=e.strideWidth,d=e.dilationHeight,p=e.dilationWidth,f=e.filterHeight,m=e.filterWidth,g=m;let y="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let w=0;w<m;w++)y+=`\n          vec4 xTexelC${2*w};\n          int xTexelC${2*w}Ready;\n          vec4 xC${w};`;for(let w=0;w<f;w++){for(let e=0;e<m;e++)y+=`\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xC${e} = vec4(0.0);`;y+=`\n        xR = xRCorner + ${w*d};\n        if (xR >=0 && xR < ${i}) {\n      `;for(let e=0;e<(g+1)/2;e++){const t=2*e,n=t*p;if(y+=`\n          xC = xCCorner + ${n};\n          `,1===h){if(t<m&&(l%2==1?(y+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < ${a} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ${a}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n              `,y+=1===p&&n>0?`\n                xC${t} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < ${a}) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ${a}) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${t} = vec4(previous.zw, xTexelC${n}.xy);\n                  } else {\n                    xC${t} = vec4(0.0, 0.0, xTexelC${n}.xy);\n                  }\n                  `):y+=`\n                if (xC >= 0 && xC < ${a} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ${a}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                xC${t} = xTexelC${n};\n                `,n+1<m)){const e=l%2==0?Yd(p):p;p%2==0&&l%2==1||p%2!=0&&l%2!=1?(y+=`\n                  xCOffset = xC + ${l%2} + ${e};\n\n                  if (xCOffset >= 0 && xCOffset < ${a} && xTexelC${n+2}Ready == 0) {\n                    xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ${a}) {\n                      xTexelC${n+2}.zw = vec2(0.0);\n                    }\n                    xTexelC${n+2}Ready = 1;\n                  }\n                  `,p>1&&(y+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < ${a} && xTexelC${n}Ready == 0) {\n                      xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                      xTexelC${n}Ready = 1;\n                    }\n                    `),y+=`\n                  xC${t+1} = vec4(xTexelC${n}.zw, xTexelC${n+2}.xy);\n                  `):y+=1===e?`\n                    xC${t+1} = xTexelC${n};\n                    `:`\n                    xCOffset = xC + ${e};\n\n                    if (xCOffset >= 0 && xCOffset < ${a} && xTexelC${n+2}Ready == 0) {\n                      xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= ${a}) {\n                        xTexelC${n+2}.zw = vec2(0.0);\n                      }\n                      xTexelC${n+2}Ready = 1;\n                    }\n\n                    xC${t+1} = xTexelC${n+2};\n                    `}}else n<m&&(l%2==1?(y+=`\n                xCOffset = xC + 1 - ${h};\n                if(xCOffset >= 0 && xCOffset < ${a} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ${a}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${a} && xTexelC${n+2}Ready == 0) {\n                  xTexelC${n+2} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= ${a}) {\n                    xTexelC${n+2}.zw = vec2(0.0);\n                  }\n                  xTexelC${n+2}Ready = 1;\n                }\n\n                xC${t} = vec4(xTexelC${n}.zw, xTexelC${n+2}.zw);\n              `,n+1<m&&(y+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + ${h};\n                  if(xCOffset >= 0 && xCOffset < ${a}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${t+1} = vec4(xTexelC${n+2}.xy, final.xy);\n                `)):(y+=`\n                if(xC >= 0 && xC < ${a} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ${a}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                xCOffset = xC + ${h};\n                if(xCOffset >= 0 && xCOffset < ${a} && xTexelC${n+2}Ready == 0) {\n                  xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= ${a}) {\n                    xTexelC${n+2}.zw = vec2(0.);\n                  }\n                  xTexelC${n+2}Ready = 1;\n                }\n\n                xC${t} = vec4(\n                  xTexelC${n}.xy, xTexelC${n+2}.xy);\n              `,n+1<m&&(y+=`\n                  xC${t+1} = vec4(xTexelC${n}.zw, xTexelC${n+2}.zw);\n                `)));t<m&&(y+=`\n            wTexel = getW(${w}, ${n}, d1, q);\n            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);\n          `,n+1<m&&(y+=`\n              wTexel = getW(${w}, ${n+1}, d1, q);\n              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}y+="\n        }\n      "}let x="",b="";n&&(x=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,b="result = activation(result);");const v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${x}\n\n      const ivec2 strides = ivec2(${c}, ${h});\n      const ivec2 pads = ivec2(${u}, ${l});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${y}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${v}\n        ${b}\n        setOutput(result);\n      }\n    `}}const xA={kernelName:df,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o}=t,{strides:i,pad:a,dilations:u,dimRoundingMode:l}=r;let c=u;null==c&&(c=[1,1]),Qd(Gv(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const h=Lv(s.shape,o.shape,i,c,a,l,!0);let d;return d=Np().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels==1?new yA(h):new gA(h),n.runWebGLProgram(d,[s,o],"float32")}};class bA{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${e.outChannels/e.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${e.strideHeight} - ${e.padInfo.top};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${e.strideWidth} - ${e.padInfo.left};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class vA{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${r}; dm++) {\n              int d2 = d1 * ${r} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const wA={kernelName:pf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:o}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,filterShape:c}=r,h=Lv(s.shape,c,i,a,u,l,!0),d=new bA(h);return n.runWebGLProgram(d,[s,o],"float32")}},CA={kernelName:ff,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:o}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,inputShape:c}=r,h=Lv(c,o.shape,i,a,u,l,!0),d=new vA(h);return n.runWebGLProgram(d,[s,o],"float32")}};class _A{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const kA={kernelName:"Diag",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],o=tp(r.shape),i=h$({inputs:{x:r},backend:n,attrs:{shape:[o]}}),a=new _A(o),u=n.runWebGLProgram(a,[i],i.dtype),l=h$({inputs:{x:u},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),l}};class EA{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:s,strideWidth:o,filterHeight:i,filterWidth:a,dilationHeight:u,dilationWidth:l}=e,{top:c,left:h}=r;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${o});\n      const ivec2 pads = ivec2(${c}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${a}; w++) {\n              int wIn = wBeg + w * ${l};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const SA={kernelName:mf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o}=t,{strides:i,pad:a,dilations:u}=r,l=Dv(s.shape,o.shape,i,a,"NHWC",u);let c;const h=new EA(l);c=n.runWebGLProgram(h,[s,o],"float32");const d=h$({inputs:{x:c},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(c),d}},TA={kernelName:yf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,o=t,{allDims:i,summedDims:a,idDims:u}=Fw(s,o.length);Pw(i.length,u,o);const{path:l,steps:c}=Mw(a,u),h=c.length;let d=null,p=i.length;const f=[];for(let m=0;m<h;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:r}=Dw(p,u[e]);let s;Lw(t)?s=o[e]:(s=w$({inputs:{x:o[e]},backend:n,attrs:{perm:t}}),f.push(s));const i=s.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);np(s.shape,i)||(s=h$({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===d?d=s:(d=l$({inputs:{a:s,b:d},backend:n}),f.push(d))}m<h-1&&(l[m]>=0&&(d=b$({inputs:{x:d},backend:n,attrs:{axis:l[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}},IA={kernelName:"Elu",backendName:"webgl",kernelFunc:r$({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"})},NA={kernelName:"EluGrad",backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:s}=t,o=Np().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new GN("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new HN("return (b >= 1.0) ? a : a * (b + 1.0);",r.shape,s.shape);return n.runWebGLProgram(o,[r,s],r.dtype)}},$A=s$({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:qI}),RA={kernelName:xf,backendName:"webgl",kernelFunc:$A},AA={kernelName:"Erf",backendName:"webgl",kernelFunc:r$({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${yw};\n  float a1 = ${xw};\n  float a2 = ${bw};\n  float a3 = ${vw};\n  float a4 = ${ww};\n  float a5 = ${Cw};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`})},OA="return exp(x);",FA=r$({opSnippet:OA,packedOpSnippet:OA,cpuKernelImpl:KI}),DA={kernelName:bf,backendName:"webgl",kernelFunc:FA};function PA(e){const{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:o}=t,i=o.shape.length,a=o.shape.slice();let u=s;return s<0&&(Qd(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+s+1),a.splice(u,0,1),h$({inputs:{x:o},backend:r,attrs:{shape:a}})}const MA={kernelName:vf,backendName:"webgl",kernelFunc:PA},LA="return exp(x) - 1.0;",BA=r$({opSnippet:LA,packedOpSnippet:LA,cpuKernelImpl:XI}),VA={kernelName:wf,backendName:"webgl",kernelFunc:BA};class UA{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=n?`${r}.0`:"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);i="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${o};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function zA(e,t,n){const r=n.texData.get(e.dataId),s=tp(e.shape),o=e.shape[e.shape.length-1],i=h$({inputs:{x:e},backend:n,attrs:{shape:[s/o,o]}}),a=i.shape,u=new UA("real",a,t),l=new UA("imag",a,t),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:a},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:a}],h=n.runWebGLProgram(u,c,"float32"),d=n.runWebGLProgram(l,c,"float32"),p=XN({inputs:{real:h,imag:d},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d);const f=h$({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(p),f}const WA={kernelName:"FFT",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return zA(r,!1,n)}};class jA{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}function HA(e){const{backend:t,attrs:n}=e,{shape:r,value:s}=n;let{dtype:o}=n;if(o=o||mp(s),"string"===o){const e=cp(o,tp(r));return e.fill(s),t.makeTensorInfo(r,o,e)}{const e=new jA(r,s),n=e.getCustomSetupFunc(s);return t.runWebGLProgram(e,[],o,n)}}const GA={kernelName:Cf,backendName:"webgl",kernelFunc:HA};class qA{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const KA={kernelName:_f,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,s=new qA(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}},XA="return floor(x);",YA=r$({opSnippet:XA,packedOpSnippet:XA,cpuKernelImpl:YI}),QA={kernelName:kf,backendName:"webgl",kernelFunc:YA},ZA=s$({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),JA={kernelName:Ef,backendName:"webgl",kernelFunc:ZA};class eO{constructor(e){this.variableNames=["A"];const t=lT(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class tO{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=lT(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const nO={kernelName:Zm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:s}=t;const{numChannels:o}=r,i="undefined"!=typeof HTMLVideoElement&&s instanceof HTMLVideoElement,a="undefined"!=typeof HTMLImageElement&&s instanceof HTMLImageElement,[u,l]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[l,u],h=[l,u,o];(a||i)&&(null==rO&&(rO=document.createElement("canvas").getContext("2d")),rO.canvas.width=u,rO.canvas.height=l,rO.drawImage(s,0,0,u,l),s=rO.canvas);const d=n.makeTensorInfo(c,"int32");n.texData.get(d.dataId).usage=DS.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),s);const p=Np().getBool("WEBGL_PACK")?new tO(h):new eO(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let rO;const sO={kernelName:tg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r,m=qv(c),g=Lv(s.shape,o.shape,u,h,l,d,!1,m);let y;const x=[];if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(Np().getBool("WEBGL_CONV_IM2COL")&&1===s.shape[0])y=qR({x:s,filter:o,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else{const e=null!=i,t=null!=a,r="leakyrelu"===p,u=p?o$(p,!1):null,l=new WR(g,e,u,t,r),c=[s,o];if(i&&c.push(i),a&&c.push(a),r){const e=n.makeTensorInfo([],"float32",kg(f,"float32"));c.push(e),x.push(e)}y=n.runWebGLProgram(l,c,"float32")}else y=GR({x:s,filter:o,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:a,leakyreluAlpha:f});const b=h$({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return x.push(y),x.forEach(e=>n.disposeIntermediateTensorInfo(e)),b}},oO={kernelName:ng,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=r,f=[];let m=c;null==m&&(m=[1,1]),Qd(Gv(u,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${m}'`);const g=Lv(s.shape,o.shape,u,m,l,h,!0),y=Np().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,x=d?o$(d,y):null,b=[s,o],v=null!=i,w=null!=a,C="leakyrelu"===d;if(v&&b.push(i),w&&b.push(a),C){const e=n.makeTensorInfo([],"float32",kg(p,"float32"));b.push(e),f.push(e)}let _;_=y?new yA(g,v,x,w,C):new gA(g,v,x,w,C);const k=n.runWebGLProgram(_,b,"float32");return f.forEach(e=>n.disposeIntermediateTensorInfo(e)),k}};class iO{constructor(e,t,n){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=n;const r=PT(t.length),s=PT(n.length);this.userCode=`\n        ${r} strides = ${r}(${this.strides});\n         void main() {\n          ${s} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${this.sliceDim>1?"strides[j]":"strides"};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}const aO={kernelName:If,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,o=s.shape,i=o[o.length-1],a=tp(r.shape),[u,l,c,h]=hw(r,s),d=h$({inputs:{x:s},backend:n,attrs:{shape:[l,i]}}),p=h$({inputs:{x:r},backend:n,attrs:{shape:[tp(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const e=n.readSync(s.dataId),t=n.bufferSync(r),o=QI(e,t,r.dtype,l,i,c,h,r.shape,a);return n.makeTensorInfo(u,r.dtype,o.values)}const f=new iO(i,h,[l,c]),m=n.runWebGLProgram(f,[p,d],p.dtype),g=h$({inputs:{x:m},backend:n,attrs:{shape:u}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class uO{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=PT(this.rank),r=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<e.length;s++)r.push(2===s?"int(getIndices(resRC.x, resRC.z))":`${n[s]}`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        setOutput(getA(${r}));\n      }\n    `}}const lO={kernelName:Tf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:o}=t,{axis:i,batchDims:a}=r,u=Ww(s,o,ap(i,s.shape)[0],a),l=tp(o.shape),c=[],h=h$({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),d=h$({inputs:{x:o},backend:n,attrs:{shape:[u.batchSize,l/u.batchSize]}});c.push(h),c.push(d);const p=[u.batchSize,u.outerSize,l/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([s,o])||"string"===s.dtype){const e=n.bufferSync(d),t=n.bufferSync(h),r=ZI(t,e,p);return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}const f=new uO(h.shape,p),m=n.runWebGLProgram(f,[h,d],h.dtype);c.push(m);const g=h$({inputs:{x:m},backend:n,attrs:{shape:u.outputShape}});return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),g}},cO=s$({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:JI,dtype:"bool"}),hO={kernelName:Nf,backendName:"webgl",kernelFunc:cO},dO=s$({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:eN}),pO={kernelName:$f,backendName:"webgl",kernelFunc:dO},fO={kernelName:Af,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return zA(r,!0,n)}},mO={kernelName:"IsFinite",backendName:"webgl",kernelFunc:r$({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"})},gO={kernelName:"IsInf",backendName:"webgl",kernelFunc:r$({opSnippet:"return float(isinf(x));",dtype:"bool"})},yO=r$({opSnippet:"return float(isnan(x));",dtype:"bool"}),xO={kernelName:Ff,backendName:"webgl",kernelFunc:yO},bO=s$({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:tN,dtype:"bool"}),vO={kernelName:Pf,backendName:"webgl",kernelFunc:bO},wO=s$({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:nN,dtype:"bool"}),CO={kernelName:Mf,backendName:"webgl",kernelFunc:wO},_O={kernelName:Lf,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:o}=n,i=rN(r,s,o);return t.makeTensorInfo([i.length],"float32",i)}},kO=r$({opSnippet:"if (x < 0.0) return NAN;\n  return log(x);",packedOpSnippet:"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:sN}),EO={kernelName:Bf,backendName:"webgl",kernelFunc:kO},SO=r$({opSnippet:"return log(1.0 + x);"}),TO={kernelName:Vf,backendName:"webgl",kernelFunc:SO},IO=s$({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),NO={kernelName:Uf,backendName:"webgl",kernelFunc:IO},$O=r$({opSnippet:"return float(!(x >= 1.0));"}),RO={kernelName:zf,backendName:"webgl",kernelFunc:$O},AO=s$({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),OO={kernelName:Wf,backendName:"webgl",kernelFunc:AO};class FO{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[];const o=t,i=e[3]-1;let a;this.outputShape=e;const u=`float(${n}) + float(${r}) * sum`;a=.5===s?`inversesqrt(${u})`:1===s?`1.0/(${u})`:`exp(log(${u}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${o}; j <= ${o}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${a};\n        setOutput(val);\n      }\n    `}}class DO{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,i=e[3]-1;let a;this.outputShape=e;const u=`float(${n}) + float(${r}) * sum`;a=.5===s?`inversesqrt(${u})`:1===s?`1.0/(${u})`:`exp(log(${u}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${o};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${o}; j <= ${o}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${a};\n        setOutput(result);\n      }\n    `}}const PO={kernelName:"LRN",backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:o,bias:i,alpha:a,beta:u}=r,l=Np().getBool("WEBGL_PACK_NORMALIZATION")?new DO(s.shape,o,i,a,u):new FO(s.shape,o,i,a,u);return n.runWebGLProgram(l,[s],s.dtype)}};class MO{constructor(e,t,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${s})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${s});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const LO={kernelName:"LRNGrad",backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s,y:o,dy:i}=t,{depthRadius:a,bias:u,alpha:l,beta:c}=r,h=new MO(s.shape,a,u,l,c);return n.runWebGLProgram(h,[s,o,i],s.dtype)}};function BO(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:o,keepDims:i}=r,a=s.shape.length,u=ap(o,s.shape);let l=u;const c=Hb(l,a),h=null!=c,d=n.shouldExecuteOnCPU([s]);let p=s;if(h){if(d){const e=n.texData.get(p.dataId).values,t=new Array(a);for(let n=0;n<t.length;n++)t[n]=s.shape[c[n]];const r=SN(e,s.shape,s.dtype,c,t);p=n.makeTensorInfo(t,s.dtype),n.texData.get(p.dataId).values=r}else p=x$(s,c,n);l=qb(l.length,a)}jb("max",l,a);const[f,m]=zb(p.shape,l);let g,y=f;if(i&&(y=Wb(f,u)),d){const e=n.texData.get(p.dataId),t=oN(e.values,tp(m),y,s.dtype);g=n.makeTensorInfo(y,s.dtype),n.texData.get(g.dataId).values=t}else g=function(e,t,n,r){const s=tp(t),o=h$({inputs:{x:e},attrs:{shape:[tp(e.shape)/s,s]},backend:r}),i=m$(o,e.dtype,"max",r),a=h$({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(i),a}(p,m,y,n);return h&&n.disposeIntermediateTensorInfo(p),g}const VO={kernelName:"Max",backendName:"webgl",kernelFunc:BO},UO=s$({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:iN}),zO={kernelName:jf,backendName:"webgl",kernelFunc:UO},WO={kernelName:Hf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;aT(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:u}=r;Qd(Gv(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const l=Pv(s.shape,o,i,1,a,u);if(1===l.filterWidth&&1===l.filterHeight&&np(l.inShape,l.outShape))return qN({inputs:{x:s},backend:n});const c=new nR(l,"max",!1);return n.runWebGLProgram(c,[s],s.dtype)}},jO={kernelName:Gf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:o,strides:i,pad:a,dataFormat:u,dimRoundingMode:l}=r,c=Mv(s.shape,o,i,[1,1,1],a,l,u),h=new rR(c,"max",!1);return n.runWebGLProgram(h,[s],s.dtype)}};class HO{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.effectiveFilterHeight,n=e.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t};\n          wR += ${e.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${t*n-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${n} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class GO{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.effectiveFilterDepth,n=e.effectiveFilterHeight,r=e.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${t-1-e.padInfo.front}, ${n-1-e.padInfo.top}, ${r-1-e.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${t};\n           wD += ${e.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${e.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${e.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${r};\n                wC += ${e.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${t*n*r-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${n} * ${r} +\n                  wR * ${r} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const qO={kernelName:"MaxPool3DGrad",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o}=t,i=o,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=r,h=Mv(i.shape,a,u,[1,1,1],l,c),d=new rR(h,"max",!0),p=n.runWebGLProgram(d,[i],i.dtype),f=new GO(h),m=n.runWebGLProgram(f,[s,p],i.dtype);return n.disposeIntermediateTensorInfo(p),m}},KO={kernelName:"MaxPoolGrad",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o,output:i}=t,a=o;aT([o,i],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:h}=r,d=Pv(a.shape,u,l,1,c,h),p=new nR(d,"max",!0),f=n.runWebGLProgram(p,[a],a.dtype),m=new HO(d),g=n.runWebGLProgram(m,[s,f],a.dtype);return n.disposeIntermediateTensorInfo(f),g}},XO={kernelName:qf,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=t,u=n;Qd(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const l=[1,1];Qd(Gv(o,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const c=Pv(r.shape,s,o,l,i),[h,d]=function(e,t,n,r){let s=new nR(n,"max",!1);const o=r.runWebGLProgram(s,[e],"float32");return s=new nR(n,"max",!0,!0,t),[o,r.runWebGLProgram(s,[e],"float32")]}(r,a,c,u);return[h,d]}},YO={kernelName:Kf,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{keepDims:s,axis:o}=t,i=n,a=r.shape.length,u=ap(o,r.shape);let l=u;const c=Hb(l,a),h=null!=c,d=i.shouldExecuteOnCPU([r]),p=[];let f=r;if(h){if(d){const e=i.texData.get(f.dataId).values,t=new Array(a);for(let s=0;s<t.length;s++)t[s]=r.shape[c[s]];const n=SN(e,r.shape,r.dtype,c,t);f=i.makeTensorInfo(t,r.dtype),i.texData.get(f.dataId).values=n}else f=x$(r,c,i);p.push(f),l=qb(l.length,a)}jb("sum",l,a);const[m,g]=zb(f.shape,l);let y=m;s&&(y=Wb(m,u));const x=function(e,t,n,r){const s=tp(t),o=h$({inputs:{x:e},attrs:{shape:[tp(e.shape)/s,s]},backend:r}),i=m$(o,"float32","mean",r),a=h$({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(i),a}(f,g,y,i);for(const b of p)i.disposeIntermediateTensorInfo(b);return x}},QO={kernelName:"Min",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:i}=r,a=s.shape.length,u=ap(o,s.shape);let l=u;const c=Hb(l,a);let h=s;null!=c&&(h=w$({inputs:{x:s},backend:n,attrs:{perm:c}}),l=qb(l.length,s.shape.length)),jb("min",l,a);const[d,p]=zb(h.shape,l),f=h$({inputs:{x:h},backend:n,attrs:{shape:[-1,tp(p)]}}),m=m$(f,f.dtype,"min",n);let g;return g=h$(i?{inputs:{x:m},backend:n,attrs:{shape:Wb(d,u)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}},ZO=s$({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:aN}),JO={kernelName:Xf,backendName:"webgl",kernelFunc:ZO};class eF{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,s=PT(r),o=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),a=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),u="reflect"===n?0:1;this.userCode=1!==r?`\n      ${s} start = ${s}(${o});\n      ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${u};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};\n          }\n        }\n        ${s} coords = outC - start;\n        setOutput(getX(${a}));\n      }\n    `:`\n        int start = ${o};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${u};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${u};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class tF{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,s=PT(r),o=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),a=NN("rc",r),u=NN("source",r),l=`${a[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${u.slice(-2).join()})`,h="reflect"===n?0:1;let d="";if(1===r){const e=`\n        ${s} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;d=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${a[r-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n      `}else{const e=`\n        ${s} source = rc;\n        ${s} lt = ${s}(lessThan(source, start));\n        ${s} gte = ${s}(greaterThanEqual(source, end));\n        ${s} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;d=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${a[r-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${a[r-2]} += 1;\n        if(${a[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${u.join()}), ${c});\n          ${a[r-1]} += 1;\n          if(${l}) {\n            ${e}\n            result[3] = getChannel(getX(${u.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${s} start = ${s}(${o});\n      const ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}const nF={kernelName:Yf,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{paddings:s,mode:o}=n,i=Np().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new tF(r.shape,s,o):new eF(r.shape,s,o);return t.runWebGLProgram(i,[r],r.dtype)}},rF={kernelName:"Mod",backendName:"webgl",kernelFunc:s$({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"})};class sF{constructor(e,t,n){this.variableNames=["probs"],this.outputShape=[e,n],this.userCode=`\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.seedLoc&&(this.seedLoc=t.getUniformLocation(n,"seed")),t.gl.uniform1f(this.seedLoc,e)}}}const oF=s$({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),iF={kernelName:gf,backendName:"webgl",kernelFunc:oF},aF="return a - b;",uF=s$({opSnippet:aF,packedOpSnippet:aF,supportsComplex:!0,cpuKernelImpl:_N}),lF={kernelName:zm,backendName:"webgl",kernelFunc:uF};function cF(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:o}=r,i=ap([o],s.shape),a=BO({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),u=Wb(a.shape,i),l=h$({inputs:{x:a},backend:n,attrs:{shape:u}}),c=uF({inputs:{a:s,b:l},backend:n}),h=FA({inputs:{x:c},backend:n}),d=b$({inputs:{x:h},backend:n,attrs:{axis:i,keepDims:!1}}),p=h$({inputs:{x:d},backend:n,attrs:{shape:u}}),f=oF({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const hF={kernelName:Rm,backendName:"webgl",kernelFunc:cF},dF={kernelName:Qf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:o,seed:i,normalized:a}=r,u=a?s:cF({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),l=new sF(u.shape[0],u.shape[1],o),c=l.getCustomSetupFunc(i),h=n.runWebGLProgram(l,[u],"int32",c);return a||n.disposeIntermediateTensorInfo(u),h}},pF="return -x;",fF={kernelName:"Neg",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,s]=lN(e.values,r.shape,r.dtype);return n.makeTensorInfo(s,r.dtype,t)}let s;return s=Np().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new BN(r.shape,pF):new PN(r.shape,pF),n.runWebGLProgram(s,[r],r.dtype)}},mF=cb,gF={kernelName:em,backendName:"webgl",kernelFunc:function(e){_w("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:o}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=r,l=n.readSync(s.dataId),c=n.readSync(o.dataId),{selectedIndices:h}=mF(l,c,i,a,u);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},yF=hb,xF={kernelName:tm,backendName:"webgl",kernelFunc:function(e){_w("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:o}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:l}=r,c=n.readSync(s.dataId),h=n.readSync(o.dataId),{selectedIndices:d,validOutputs:p}=yF(c,h,i,a,u,l);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},bF=db,vF={kernelName:nm,backendName:"webgl",kernelFunc:function(e){_w("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:o}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=r,c=n.readSync(s.dataId),h=n.readSync(o.dataId),d=i,p=a,f=u,m=l,{selectedIndices:g,selectedScores:y}=bF(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class wF{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const CF={kernelName:sm,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{depth:o,onValue:i,offValue:a}=r,u=tp(s.shape),l=new wF(u,o,i,a),c=h$({inputs:{x:s},backend:n,attrs:{shape:[u]}}),h=n.runWebGLProgram(l,[c],s.dtype);n.disposeIntermediateTensorInfo(c);const d=h$({inputs:{x:h},backend:n,attrs:{shape:[...s.shape,o]}});return n.disposeIntermediateTensorInfo(h),d}};function _F(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=_R({inputs:{input:r},backend:n}),t=_F({inputs:{x:e},backend:n}),s=LR({inputs:{input:r},backend:n}),o=_F({inputs:{x:s},backend:n}),i=XN({inputs:{real:t,imag:o},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),i}return HA({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const kF={kernelName:Ym,backendName:"webgl",kernelFunc:_F},EF={kernelName:rm,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const t=_R({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),o=LR({inputs:{input:s},backend:r}),i=_F({inputs:{x:o},backend:r}),a=XN({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(i),a}return HA({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:r})}},SF={kernelName:om,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return PA({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const o=t[0].shape,i=t[0].dtype;t.forEach(e=>{Zd(o,e.shape,"All tensors passed to stack must have matching shapes"),Qd(i===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=UR({inputs:t.map(e=>{const t=PA({inputs:{input:e},backend:n,attrs:{dim:s}});return a.push(t),t}),backend:n,attrs:{axis:s}});return a.forEach(e=>n.disposeIntermediateTensorInfo(e)),u}};class TF{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,s=PT(r),o=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),a=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${s} start = ${s}(${o});\n      ${s} end = ${s}(${i});\n      uniform float value;\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${s} coords = outC - start;\n          setOutput(getX(${a}));\n        }\n      }\n    `:`\n        int start = ${o};\n        int end = ${i};\n        uniform float value;\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}class IF{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,s=PT(r),o=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),a=NN("rc",r),u=NN("source",r),l=`${a[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${u.slice(-2).join()})`,h=[`${s} rc = outputLoc;`,`${a[r-1]} += 1;\n       if(${l}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${a[r-2]} += 1;\n       if(${a[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${a[r-1]} += 1;\n         if(${l}) {`],d=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===r?2:4;f<m;f++)p+=`\n        ${h[f]}\n        if (${d}) {\n          result[${f}] = float(value);\n        } else {\n          ${s} source = rc - start;\n          result[${f}] = getChannel(getX(${u.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${s} start = ${s}(${o});\n      const ${s} end = ${s}(${i});\n      uniform float value;\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}const NF=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:o,constantValue:i}=r,a=Np().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new IF(s.shape,o,i):new TF(s.shape,o,i),u=a.getCustomSetupFunc(i);return n.runWebGLProgram(a,[s],s.dtype,u)},$F={kernelName:im,backendName:"webgl",kernelFunc:NF},RF={kernelName:"Pow",backendName:"webgl",kernelFunc:s$({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"})},AF={kernelName:um,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:i}=r,a=s.shape.length,u=[],l=ap(o,s.shape);let c=l;const h=Hb(c,a);let d,p=s;if(null!=h&&(p=w$({inputs:{x:s},backend:n,attrs:{perm:h}}),c=qb(c.length,a),u.push(p)),jb("prod",c,a),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:r,outDtype:s}=hN(p.shape,p.dtype,e,c);d=n.makeTensorInfo(r,s,t)}else{const[e,t]=zb(p.shape,c),r=tp(t),o=h$({inputs:{x:p},backend:n,attrs:{shape:[-1,r]}}),i=m$(o,Xg(s.dtype),"prod",n);d=h$({inputs:{x:i},backend:n,attrs:{shape:e}}),u.push(o),u.push(i)}if(i){u.push(d);const e=Wb(d.shape,l);d=h$({inputs:{x:d},backend:n,attrs:{shape:e}})}return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),d}},OF=e=>{const{backend:t,attrs:n}=e,{start:r,stop:s,step:o,dtype:i}=n,a=dN(r,s,o,i);return t.makeTensorInfo([a.length],i,a)},FF={kernelName:lm,backendName:"webgl",kernelFunc:OF},DF=r$({opSnippet:"return 1.0 / x;"}),PF={kernelName:hm,backendName:"webgl",kernelFunc:DF},MF=r$({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),LF={kernelName:dm,backendName:"webgl",kernelFunc:MF},BF=r$({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),VF={kernelName:gm,backendName:"webgl",kernelFunc:BF};class UF{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[o,i,a,u]=e;this.outputShape=[o,t,n,u];const l=[r&&t>1?i-1:i,r&&n>1?a-1:a],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${a}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class zF{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,i,a,u]=e;this.outputShape=[o,t,n,u];const l=[r&&t>1?i-1:i,r&&n>1?a-1:a],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${a}.0,\n                                     ${a}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const WF={kernelName:mm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:o,halfPixelCenters:i,size:a}=r,[u,l]=a,c=Np().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new zF(s.shape,u,l,o,i):new UF(s.shape,u,l,o,i);return n.runWebGLProgram(c,[s],"float32")}};class jF{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,o,i]=e,a=[n&&o>1?r-1:r,n&&i>1?s-1:s],u=[n&&o>1?o-1:o,n&&i>1?i-1:i],l=a[0]/u[0],c=a[1]/u[1],h=1/l,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const HF={kernelName:"ResizeBilinearGrad",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:o}=t,{alignCorners:i}=r,a=new jF(o.shape,s.shape,i);return n.runWebGLProgram(a,[o],o.dtype)}};class GF{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[o,i,a,u]=e;this.outputShape=[o,t,n,u];const l=[r&&t>1?i-1:i,r&&n>1?a-1:a],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${a}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${r?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class qF{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,i,a,u]=e;this.outputShape=[o,t,n,u];const l=[r&&t>1?i-1:i,r&&n>1?a-1:a],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${a}.0,\n                                     ${a}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${r?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const KF={kernelName:fm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:o,halfPixelCenters:i,size:a}=r,[u,l]=a,c=Np().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new qF(s.shape,u,l,o,i):new GF(s.shape,u,l,o,i);return n.runWebGLProgram(c,[s],s.dtype)}};class XF{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,o,i]=e,a=[n&&o>1?r-1:r,n&&i>1?s-1:s],u=[n&&o>1?o-1:o,n&&i>1?i-1:i],l=a[0]/u[0],c=a[1]/u[1],h=1/l,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${a[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${a[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const YF={kernelName:"ResizeNearestNeighborGrad",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:o}=t,{alignCorners:i}=r,a=new XF(o.shape,s.shape,i);return n.runWebGLProgram(a,[o],o.dtype)}};class QF{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r)).join(","),s=PT(n);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class ZF{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=NN("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,o=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=PT(n);function a(n){const r=e.map((r,s)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(s,n));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${s}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return a(e)}(r.slice())};\n          if(${s}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",a(e)}(r.slice())};\n          }\n          if(${o}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",a(e)}(r.slice())};\n            if(${s}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",a(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const JF={kernelName:ym,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:o}=r,i=s.shape.length,a=ap(o,s.shape);if(0===i)return qN({inputs:{x:s},backend:n});const u=Np().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ZF(s.shape,a):new QF(s.shape,a);return n.runWebGLProgram(u,[s],s.dtype)}};class eD{constructor(e,t){this.variableNames=["Image"],this.outputShape=[];const n=e[1],r=e[2];this.outputShape=e;let s="";s="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        uniform vec4 params;\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${s}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}getCustomSetupFunc(e,t,n,r){return(s,o)=>{null==this.paramsLoc&&(this.paramsLoc=s.getUniformLocationNoThrow(o,"params")),s.gl.uniform4f(this.paramsLoc,e,t,n,r)}}}const tD={kernelName:Jm,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:o,center:i}=t,a=n,u=new eD(r.shape,o),[l,c]=ow(i,r.shape[1],r.shape[2]),h=u.getCustomSetupFunc(l,c,Math.sin(s),Math.cos(s));return a.runWebGLProgram(u,[r],r.dtype,h)}},nD=r$({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),rD={kernelName:xm,backendName:"webgl",kernelFunc:nD},sD=r$({opSnippet:"return inversesqrt(x);",cpuKernelImpl:pN}),oD={kernelName:bm,backendName:"webgl",kernelFunc:sD};class iD{constructor(e,t,n,r,s,o,i=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const a=PT(s.length),u=PT(o.length);let l="";1===n?l="i":2===n&&(l="i, j");let c="";1===r?c="i":2===r&&(c="i, coords[1]"),this.userCode=`\n        ${a} strides = ${a}(${s});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(getIndices(${l}));\n              flattenedIndex += index * ${t>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${c});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const aD={kernelName:vm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:o}=t,{shape:i}=r,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:h}=fw(0,s,i),d=[h/l,l];if(0===h)return n.makeTensorInfo(i,s.dtype);const p=h$({inputs:{x:s},backend:n,attrs:{shape:[u,a]}}),f=h$({inputs:{x:o},backend:n,attrs:{shape:[u,l]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g=new iD(u,a,p.shape.length,f.shape.length,c,d),y=n.runWebGLProgram(g,[f,p,m],f.dtype),x=h$({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),x}};class uD{constructor(e,t,n){let r,s;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)s="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&o.push(`${n[r]}`);r=o.join(),s=i.join()}const o=PT(n);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${s}));\n        } else {\n          setOutput(getB(${s}));\n        }\n      }\n    `}}const lD={kernelName:wm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:o}=t,i=new uD(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,o],Kg(s.dtype,o.dtype))}},cD=r$({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${mw};\n  float scale = ${gw};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),hD={kernelName:Cm,backendName:"webgl",kernelFunc:cD},dD=r$({opSnippet:"return 1.0 / (1.0 + exp(-1.0 * x));"}),pD={kernelName:Sm,backendName:"webgl",kernelFunc:dD},fD=r$({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),mD={kernelName:Em,backendName:"webgl",kernelFunc:fD},gD={kernelName:"Sin",backendName:"webgl",kernelFunc:r$({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"})},yD=r$({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),xD={kernelName:km,backendName:"webgl",kernelFunc:yD},bD=r$({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),vD={kernelName:Tm,backendName:"webgl",kernelFunc:bD},wD={kernelName:Nm,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:o,paddings:i}=r;Qd(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((e,t)=>e*t),u=[[0,0]];u.push(...i);for(let y=1+o.length;y<s.shape.length;++y)u.push([0,0]);const l=[],c=NF({inputs:{x:s},backend:n,attrs:{paddings:u,constantValue:0}}),h=iw(c.shape,o,a,!1),d=aw(h.length,o.length,!1),p=uw(c.shape,o,a,!1),f=h$({inputs:{x:c},backend:n,attrs:{shape:h}}),m=w$({inputs:{x:f},backend:n,attrs:{perm:d}}),g=h$({inputs:{x:m},backend:n,attrs:{shape:p}});return l.push(c),l.push(f),l.push(m),l.forEach(e=>n.disposeIntermediateTensorInfo(e)),g}},CD={kernelName:Am,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:o,defaultValue:i}=t;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${o.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const a=n.readSync(r.dataId),u=n.readSync(s.dataId),l=n.readSync(o.dataId),c=n.readSync(i.dataId)[0],[h,d,p,f,m]=gN(a,r.shape,r.dtype,u,s.dtype,l,c);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}},_D={kernelName:Om,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:o}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(n.readSync(s.dataId)),a=n.readSync(r.dataId),u=Array.from(n.readSync(o.dataId)),[l,c,h]=yN(a,r.shape,r.dtype,i,u);return[n.makeTensorInfo(c,r.dtype,l),n.makeTensorInfo([h.length],o.dtype,new Int32Array(h))]}},kD={kernelName:Fm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${o.shape}`);const i=n.readSync(r.dataId),a=n.readSync(s.dataId),u=n.readSync(o.dataId),[l,c]=xN(i,r.shape,r.dtype,a,u,!0);return n.makeTensorInfo(c,r.dtype,l)}},ED={kernelName:Dm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${o.shape}`);const i=n.readSync(r.dataId),a=n.readSync(s.dataId),u=n.readSync(o.dataId),[l,c]=xN(i,r.shape,r.dtype,a,u);return n.makeTensorInfo(c,r.dtype,l)}},SD={kernelName:Pm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:o,defaultValue:i}=t,{outputShape:a}=r,{sliceRank:u,numUpdates:l,strides:c,outputSize:h}=fw(0,s,a),d=new iD(l,u,s.shape.length,o.shape.length,c,[h,1],!1),p=n.runWebGLProgram(d,[o,s,i],o.dtype),f=h$({inputs:{x:p},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(p),f}},TD={kernelName:$m,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:o,axis:i}=r,a=ap(i,s.shape)[0],u=Vw(s,o,a),l=new Array(s.shape.length).fill(0),c=s.shape.slice();return u.map(e=>{const t=[...c];t[a]=e;const r=yR({inputs:{x:s},backend:n,attrs:{begin:l,size:t}});return l[a]+=e,r})}},ID=r$({opSnippet:"return sqrt(x);"}),ND={kernelName:Im,backendName:"webgl",kernelFunc:ID},$D={kernelName:"Square",backendName:"webgl",kernelFunc:r$({opSnippet:"return x * x;"})},RD="return (a - b) * (a - b);",AD=s$({opSnippet:RD,packedOpSnippet:RD}),OD={kernelName:Mm,backendName:"webgl",kernelFunc:AD},FD={kernelName:Qm,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:r}=e,s=new PN(r.shape,`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `);return n.runWebGLProgram(s,[r],r.dtype)}};class DD{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,s=PT(n.length),o=PT(n.length);let i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`)).join(",")}this.userCode=`\n      ${s} begin = ${s}(${e});\n      ${s} strides = ${s}(${t});\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}const PD={kernelName:Lm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:o,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r,{nonStrided:p,$begin:f,$strides:m,size:g,newShape:y,outShape:x}=_x(s.shape,o,i,a,u,l,c,h,d),b=h$({inputs:{x:s},backend:n,attrs:{shape:y}});let v;if(p){const e=yR({inputs:{x:b},backend:n,attrs:{begin:f,size:g}});v=h$({inputs:{x:e},backend:n,attrs:{shape:x}}),n.disposeIntermediateTensorInfo(e)}else if(x.some(e=>0===e))v=n.makeTensorInfo(x,s.dtype,[]);else if(n.shouldExecuteOnCPU([b])){const e=n.texData.get(b.dataId),t=qy(b.shape,b.dtype,e.values),r=bN(x,t,m,f);v=n.makeTensorInfo(x,b.dtype,r.values)}else{const e=new DD(f,m,x);v=n.runWebGLProgram(e,[b],b.dtype)}const w=h$({inputs:{x:v},backend:n,attrs:{shape:x}});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(v),w}},MD={kernelName:Bm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:l}=r,{data:c,dataSplits:h}=t,d=n.readSync(c.dataId),p=n.readSync(h.dataId),[f,m]=vN(d,p,s,o,i,a,u,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}},LD={kernelName:Vm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:o,delimiter:i}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=n.readSync(o.dataId),u=n.readSync(i.dataId)[0],[l,c,h]=wN(a,u,s),d=c.length;return[n.makeTensorInfo([d,2],"int32",l),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}},BD={kernelName:Um,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(o.dataId),a=CN(i,s);return n.makeTensorInfo(o.shape,"int32",a)}},VD={kernelName:"Tan",backendName:"webgl",kernelFunc:r$({opSnippet:"return tan(x);"})},UD=r$({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),zD={kernelName:Wm,backendName:"webgl",kernelFunc:UD};class WD{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[o]*t[o];this.outputShape=n,this.rank=n.length;const r=PT(this.rank),s=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<e.length;s++)r.push(`imod(${n[s]}, ${e[s]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}function jD(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:o}=r;if("string"===s.dtype||s.shape.length>5){const e=n.readSync(s.dataId),t="string"===s.dtype?e.map(e=>Ig(e)):e,r=qy(s.shape,s.dtype,t),i=kN(r,o);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new WD(s.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}const HD={kernelName:jm,backendName:"webgl",kernelFunc:jD},GD={kernelName:Hm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:o,sorted:i}=r,a=n.readSync(s.dataId),[u,l]=EN(a,s.shape,s.dtype,o,i);return[n.makeTensorInfo(u.shape,u.dtype,u.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}};class qD{constructor(e,t,n,r,s,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const i="nearest"===n?1:2;let a;switch(r){case"constant":a=1;break;case"reflect":a=2;break;case"wrap":a=3;break;case"nearest":a=4;break;default:a=1}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${a} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${a} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${a} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${s});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${s});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const KD={kernelName:Gm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:o}=t,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=r,[c,h,d,p]=s.shape,[f,m]=null!=l?l:[h,d],g=new qD(h,d,i,a,u,[c,f,m,p]);return n.runWebGLProgram(g,[s,o],"float32")}},XD={kernelName:Km,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:o}=t;aT(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(o.dataId),{outputValues:a,outputShape:u,indices:l}=TN(i,s,o.shape,o.dtype);return[r.makeTensorInfo(u,o.dtype,a),r.makeTensorInfo([l.length],"int32",l)]}},YD={kernelName:Xm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s,a=i.shape.length,u=s.shape[o],l=new Array(a-1);let c=0;for(let m=0;m<a;m++)m!==o&&(l[c++]=i.shape[m]);const h=[],d=new Array(a).fill(0),p=i.shape.slice();p[o]=1;const f=new Array(u);for(let m=0;m<f.length;m++){d[o]=m;const e=yR({inputs:{x:i},backend:n,attrs:{begin:d,size:p}}),t=h$({inputs:{x:e},backend:n,attrs:{shape:l}});f[m]=t,h.push(e)}return h.forEach(e=>n.disposeIntermediateTensorInfo(e)),f}};class QD{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,s=e.inSize,o=e.numSegments,i=o*Math.ceil(s/n);this.outputShape=[r,i];const a=4*Math.floor(n/4),u=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let c="";s%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `);let h="";s%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${o})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${o})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${l}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${l}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}const ZD=[PO,LO,k$,S$,I$,$$,O$,P$,M$,L$,j$,H$,q$,X$,J$,Q$,tR,oR,sR,uR,lR,cR,pR,bR,vR,ER,IR,RR,FR,YN,zR,JR,eA,KR,nA,rA,tA,sA,iA,uA,dA,pA,mA,wA,CA,xA,kA,SA,TA,IA,NA,RA,AA,DA,MA,VA,WA,GA,KA,QA,JA,nO,sO,oO,aO,lO,hO,pO,KN,fO,BR,mO,gO,xO,JN,vO,CO,_O,TO,EO,NO,RO,OO,VO,jO,WO,qO,KO,XO,zO,YO,QO,JO,nF,rF,dF,c$,fF,gF,xF,vF,CR,CF,EF,SF,$F,RF,n$,AF,FF,kR,iF,PF,VF,LF,d$,WF,HF,KF,YF,JF,tD,rD,oD,aD,lD,hD,pD,mD,gD,xD,xR,hF,vD,wD,CD,_D,kD,ED,SD,TD,ND,$D,OD,FD,PD,MD,LD,BD,lF,v$,VD,zD,HD,GD,KD,C$,XD,YD,{kernelName:"UnsortedSegmentSum",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:o}=t,{numSegments:i}=r,a=s.shape.length,u=[];let l=0;const c=Hb([l],a);let h=s;null!=c&&(h=w$({inputs:{x:s},backend:n,attrs:{perm:c}}),u.push(h),l=qb(1,a)[0]);const d=zw(h.shape,l,i),p=tp([h.shape[l]]),f=h$({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});u.push(f);const m=Xg(s.dtype),g=(e,t,r,s,o)=>{const i=e.shape[0],a=e.shape[1],l=Uw(a,o),c=new QD({windowSize:l,inSize:a,batchSize:i,numSegments:o},t),h=n.compileAndRun(c,[e,r],s);if(u.push(h),h.shape[1]===o)return h;const d=OF({backend:n,attrs:{start:0,stop:o,step:1,dtype:"float32"}}),p=jD({inputs:{x:d},backend:n,attrs:{reps:[a/l]}});return u.push(d),u.push(p),g(h,t,p,s,o)},y=h$({inputs:{x:g(f,"unsortedSegmentSum",o,m,i)},backend:n,attrs:{shape:d}});let x=y;if(null!=c){u.push(y);const e=Gb(c);x=w$({inputs:{x:x},backend:n,attrs:{perm:e}})}return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),x}},kF];for(const _P of ZD)ug(_P);class JD extends F{constructor(e,t){super()}schedule(e,t=0){return this}}let eP=(()=>{class e{constructor(t,n=e.now){this.SchedulerAction=t,this.now=n}schedule(e,t=0,n){return new this.SchedulerAction(this,e).schedule(n,t)}}return e.now=()=>Date.now(),e})();class tP extends eP{constructor(e,t=eP.now){super(e,()=>tP.delegate&&tP.delegate!==this?tP.delegate.now():t()),this.actions=[],this.active=!1,this.scheduled=void 0}schedule(e,t=0,n){return tP.delegate&&tP.delegate!==this?tP.delegate.schedule(e,t,n):super.schedule(e,t,n)}flush(e){const{actions:t}=this;if(this.active)return void t.push(e);let n;this.active=!0;do{if(n=e.execute(e.state,e.delay))break}while(e=t.shift());if(this.active=!1,n){for(;e=t.shift();)e.unsubscribe();throw n}}}const nP=new tP(class extends JD{constructor(e,t){super(e,t),this.scheduler=e,this.work=t,this.pending=!1}schedule(e,t=0){if(this.closed)return this;this.state=e;const n=this.id,r=this.scheduler;return null!=n&&(this.id=this.recycleAsyncId(r,n,t)),this.pending=!0,this.delay=t,this.id=this.id||this.requestAsyncId(r,this.id,t),this}requestAsyncId(e,t,n=0){return setInterval(e.flush.bind(e,this),n)}recycleAsyncId(e,t,n=0){if(null!==n&&this.delay===n&&!1===this.pending)return t;clearInterval(t)}execute(e,t){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;const n=this._execute(e,t);if(n)return n;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(e,t){let n,r=!1;try{this.work(e)}catch(s){r=!0,n=!!s&&s||new Error(s)}if(r)return this.unsubscribe(),n}_unsubscribe(){const e=this.id,t=this.scheduler,n=t.actions,r=n.indexOf(this);this.work=null,this.state=null,this.pending=!1,this.scheduler=null,-1!==r&&n.splice(r,1),null!=e&&(this.id=this.recycleAsyncId(t,e,null)),this.delay=null}});class rP{constructor(e,t,n){this.kind=e,this.value=t,this.error=n,this.hasValue="N"===e}observe(e){switch(this.kind){case"N":return e.next&&e.next(this.value);case"E":return e.error&&e.error(this.error);case"C":return e.complete&&e.complete()}}do(e,t,n){switch(this.kind){case"N":return e&&e(this.value);case"E":return t&&t(this.error);case"C":return n&&n()}}accept(e,t,n){return e&&"function"==typeof e.next?this.observe(e):this.do(e,t,n)}toObservable(){switch(this.kind){case"N":return tl(this.value);case"E":return e=this.error,new U(t=>t.error(e));case"C":return dl()}var e;throw new Error("unexpected notification kind value")}static createNext(e){return void 0!==e?new rP("N",e):rP.undefinedValueNotification}static createError(e){return new rP("E",void 0,e)}static createComplete(){return rP.completeNotification}}function sP(e,t=nP){var n;const r=(n=e)instanceof Date&&!isNaN(+n)?+e-t.now():Math.abs(e);return e=>e.lift(new oP(r,t))}rP.completeNotification=new rP("C"),rP.undefinedValueNotification=new rP("N",void 0);class oP{constructor(e,t){this.delay=e,this.scheduler=t}call(e,t){return t.subscribe(new iP(e,this.delay,this.scheduler))}}class iP extends M{constructor(e,t,n){super(e),this.delay=t,this.scheduler=n,this.queue=[],this.active=!1,this.errored=!1}static dispatch(e){const t=e.source,n=t.queue,r=e.scheduler,s=e.destination;for(;n.length>0&&n[0].time-r.now()<=0;)n.shift().notification.observe(s);if(n.length>0){const t=Math.max(0,n[0].time-r.now());this.schedule(e,t)}else this.unsubscribe(),t.active=!1}_schedule(e){this.active=!0,this.destination.add(e.schedule(iP.dispatch,this.delay,{source:this,destination:this.destination,scheduler:e}))}scheduleNotification(e){if(!0===this.errored)return;const t=this.scheduler,n=new aP(t.now()+this.delay,e);this.queue.push(n),!1===this.active&&this._schedule(t)}_next(e){this.scheduleNotification(rP.createNext(e))}_error(e){this.errored=!0,this.queue=[],this.destination.error(e),this.unsubscribe()}_complete(){this.scheduleNotification(rP.createComplete()),this.unsubscribe()}}class aP{constructor(e,t){this.time=e,this.notification=t}}function uP(e=-1){return t=>0===e?dl():t.lift(new lP(e<0?-1:e-1,t))}class lP{constructor(e,t){this.count=e,this.source=t}call(e,t){return t.subscribe(new cP(e,this.count,this.source))}}class cP extends M{constructor(e,t,n){super(e),this.count=t,this.source=n}complete(){if(!this.isStopped){const{source:e,count:t}=this;if(0===t)return super.complete();t>-1&&(this.count=t-1),e.subscribe(this._unsubscribeAndRecycle())}}}const hP=["webcam"],dP=["canvas"];function pP(e,t){1&e&&(yo(0,"div",10),yo(1,"p"),Co(2,"Loading MoveNet ..."),xo(),xo())}function fP(e,t){if(1&e&&(yo(0,"div"),yo(1,"p"),Co(2),xo(),xo()),2&e){const e=function(e=1){return function(e){return(zt.lFrame.contextLView=function(e,t){for(;e>0;)t=t[15],e--;return t}(e,zt.lFrame.contextLView))[8]}(e)}();as(2),_o("Right wrist pose: (",null==e.wristPose||null==e.wristPose.x?null:e.wristPose.x.toFixed(4),",",null==e.wristPose||null==e.wristPose.y?null:e.wristPose.y.toFixed(4),"), score: ",null==e.wristPose||null==e.wristPose.score?null:e.wristPose.score.toFixed(4),"")}}const mP=10,gP="white";var yP=(()=>(function(e){e[e.COMPUTER=0]="COMPUTER",e[e.HUMAN=1]="HUMAN"}(yP||(yP={})),yP))();const xP=[{path:"",component:(()=>{class e{constructor(){this.pointsComputer=0,this.pointsPlayer=0,this.paddleYComputer=.5,this.ballPosition={x:.5,y:.5},this.ballDirection={x:.2,y:-.98}}ngAfterViewInit(){var e=this;return jd(function*(){e.context=e.canvas.nativeElement.getContext("2d");const t={modelType:"SinglePose.Lightning"};e.detector=yield function(e,t){return zk(this,void 0,void 0,function(){var n,r;return Wk(this,function(s){switch(e){case kE.PoseNet:return[2,NS(t)];case kE.BlazePose:if(r=void 0,null!=(n=t)){if("tfjs"===n.runtime)return[2,VE(t)];if("mediapipe"===n.runtime)return[2,Zk(t)];r=n.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' or 'mediapipe', but got "+r);case kE.MoveNet:return[2,qE(t)];default:throw new Error(e+" is not a supported model name.")}})})}(kE.MoveNet,t);const n=e.webcam.nativeElement;if(navigator.mediaDevices.getUserMedia)try{const e=yield navigator.mediaDevices.getUserMedia({video:!0});n.srcObject=e}catch(CP){console.error(CP)}n.addEventListener("loadeddata",()=>{const t=tl({}).pipe(he(e.updatePaddle.bind(e)),sP(35),uP()),n=tl({}).pipe(he(e.updateGameState.bind(e)),sP(20),uP());t.subscribe(),n.subscribe()})})()}get canvasWidth(){return this.canvas.nativeElement.width}get canvasHeight(){return this.canvas.nativeElement.height}getCanvasPointX(e){return Math.floor(this.canvasWidth*e)}getCanvasPointY(e){return Math.floor(this.canvasHeight*e)}drawBall(e,t){this.context.beginPath(),this.context.arc(this.getCanvasPointX(e),this.getCanvasPointY(t),mP,0,2*Math.PI),this.context.fillStyle="red",this.context.fill()}drawPaddle(e,t){this.context.beginPath(),this.context.fillStyle="white",this.context.fillRect(t==yP.HUMAN?this.canvasWidth-20-10:20,this.getCanvasPointY(e)-35,10,70)}detectRightWristPose(){var e=this;return jd(function*(){const t=yield e.detector.estimatePoses(e.webcam.nativeElement);return $S.keypointsToNormalizedKeypoints(t[0].keypoints,{width:e.webcam.nativeElement.videoWidth,height:e.webcam.nativeElement.videoHeight}).find(e=>"right_wrist"===e.name)})()}getNormalizedPosition(e){if(e)return e.y=e.y<.25?0:e.y>.98?1:(e.y-.25)/.73,e}moveBall(){this.ballPosition={x:this.ballPosition.x+this.ballDirection.x/50,y:this.ballPosition.y+this.ballDirection.y/50}}updatePaddle(){var e=this;return jd(function*(){const t=e.getNormalizedPosition(yield e.detectRightWristPose());e.wristPose||(e.wristPose=t);let n=0;t&&e.wristPose&&(n=Math.abs(t.y-e.wristPose.y)),t&&t.score&&t.score>=.275&&n>=.015&&(e.wristPose=t)})()}updateGameState(){var e=this;return jd(function*(){var t;const n=e.getCanvasPointX(e.ballPosition.x),r=e.getCanvasPointY(e.ballPosition.y),s=e.getCanvasPointY(e.paddleYComputer),o=e.getCanvasPointY((null===(t=e.wristPose)||void 0===t?void 0:t.y)||.5);(r>=s-35&&r<=s+35&&n-mP<=30||r>=o-35&&r<=o+35&&n+mP>=e.canvasWidth-20-10)&&(e.ballDirection.x=-e.ballDirection.x),e.getCanvasPointX(e.ballPosition.x)<=mP?(e.pointsComputer++,e.ballPosition.x=.5,e.ballPosition.y=.5,e.ballDirection.x=1,e.ballDirection.y=0):e.getCanvasPointX(e.ballPosition.x)>=e.canvasHeight-mP&&(e.pointsPlayer++,e.ballPosition.x=.5,e.ballPosition.y=.5,e.ballDirection.x=-1,e.ballDirection.y=0),(e.getCanvasPointY(e.ballPosition.y)<=mP||e.getCanvasPointY(e.ballPosition.y)>=e.canvasHeight-mP)&&(e.ballDirection.y=-e.ballDirection.y),e.paddleYComputer=e.ballPosition.y,e.clearCanvas(),e.drawHalfLine(),e.drawScores(),e.moveBall(),e.drawBall(e.ballPosition.x,e.ballPosition.y),e.drawPaddle(e.paddleYComputer,yP.COMPUTER),e.wristPose&&e.drawPaddle(e.wristPose.y,yP.HUMAN)})()}clearCanvas(){this.context.clearRect(0,0,this.canvasWidth,this.canvasHeight)}drawScores(){this.context.font="96px VT323",this.context.fillStyle=gP,this.context.textAlign="center",this.context.fillText(this.pointsComputer.toString(),this.canvasWidth/4,75),this.context.fillText(this.pointsPlayer.toString(),this.canvasWidth/4*3,75)}drawHalfLine(){this.context.strokeStyle=gP,this.context.beginPath(),this.context.setLineDash([5,15]),this.context.moveTo(this.canvasWidth/2,0),this.context.lineTo(this.canvasWidth/2,this.canvasHeight),this.context.stroke()}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=ut({type:e,selectors:[["app-pong"]],viewQuery:function(e,t){if(1&e&&(Xi(hP,5),Xi(dP,5)),2&e){let e;Ki(e=Yi())&&(t.webcam=e.first),Ki(e=Yi())&&(t.canvas=e.first)}},decls:11,vars:2,consts:[[1,"container-fluid"],[1,"row","text-center"],["class","col-md-12",4,"ngIf"],[1,"row"],[1,"col-md-6"],["id","pong-field","width","600","height","600"],["canvas",""],["autoplay","","playsinline","","muted","","id","webcam","width","300","height","300"],["webcam",""],[4,"ngIf"],[1,"col-md-12"]],template:function(e,t){1&e&&(yo(0,"div",0),yo(1,"div",1),po(2,pP,3,0,"div",2),xo(),yo(3,"div",3),yo(4,"div",4),bo(5,"canvas",5,6),xo(),yo(7,"div",4),bo(8,"video",7,8),po(10,fP,3,3,"div",9),xo(),xo(),xo()),2&e&&(as(2),mo("ngIf",!t.wristPose),as(8),mo("ngIf",t.wristPose))},directives:[xu],styles:["#webcam[_ngcontent-%COMP%]{transform:rotateY(180deg);-webkit-transform:rotateY(180deg);-moz-transform:rotateY(180deg)}#pong-field[_ngcontent-%COMP%]{background:#000}"]}),e})()}];let bP=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=dt({type:e}),e.\u0275inj=Ae({imports:[[Fd.forRoot(xP)],Fd]}),e})(),vP=(()=>{class e{constructor(){this.title="pong-posenet"}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=ut({type:e,selectors:[["app-root"]],decls:1,vars:0,template:function(e,t){1&e&&bo(0,"router-outlet")},directives:[kd],styles:[""]}),e})(),wP=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=dt({type:e,bootstrap:[vP]}),e.\u0275inj=Ae({providers:[],imports:[[el,bP]]}),e})();(function(){if(Aa)throw new Error("Cannot enable prod mode after platform setup.");Ra=!1})(),Zu().bootstrapModule(wP).catch(e=>console.error(e))},410:()=>{},628:()=>{},778:()=>{}},e=>{"use strict";e(e.s=339)}]);