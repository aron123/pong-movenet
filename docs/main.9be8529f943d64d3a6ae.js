(self.webpackChunkpong_posenet=self.webpackChunkpong_posenet||[]).push([[179],{255:e=>{function t(e){return Promise.resolve().then(()=>{var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t})}t.keys=()=>[],t.resolve=t,t.id=255,e.exports=t},394:function(){(function(){"use strict";var e;function t(e){var t=0;return function(){return t<e.length?{done:!1,value:e[t++]}:{done:!0}}}var n,r="function"==typeof Object.defineProperties?Object.defineProperty:function(e,t,n){return e==Array.prototype||e==Object.prototype||(e[t]=n.value),e},s=function(e){e=["object"==typeof globalThis&&globalThis,e,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof global&&global];for(var t=0;t<e.length;++t){var n=e[t];if(n&&n.Math==Math)return n}throw Error("Cannot find global object")}(this);function o(e,t){if(t)e:{var n=s;e=e.split(".");for(var o=0;o<e.length-1;o++){var i=e[o];if(!(i in n))break e;n=n[i]}(t=t(o=n[e=e[e.length-1]]))!=o&&null!=t&&r(n,e,{configurable:!0,writable:!0,value:t})}}function i(e){return(e={next:e})[Symbol.iterator]=function(){return this},e}function a(e){var n="undefined"!=typeof Symbol&&Symbol.iterator&&e[Symbol.iterator];return n?n.call(e):{next:t(e)}}function u(e){if(!(e instanceof Array)){e=a(e);for(var t,n=[];!(t=e.next()).done;)n.push(t.value);e=n}return e}if(o("Symbol",function(e){function t(e,t){this.g=e,r(this,"description",{configurable:!0,writable:!0,value:t})}if(e)return e;t.prototype.toString=function(){return this.g};var n="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",s=0;return function e(r){if(this instanceof e)throw new TypeError("Symbol is not a constructor");return new t(n+(r||"")+"_"+s++,r)}}),o("Symbol.iterator",function(e){if(e)return e;e=Symbol("Symbol.iterator");for(var n="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),o=0;o<n.length;o++){var a=s[n[o]];"function"==typeof a&&"function"!=typeof a.prototype[e]&&r(a.prototype,e,{configurable:!0,writable:!0,value:function(){return i(t(this))}})}return e}),"function"==typeof Object.setPrototypeOf)n=Object.setPrototypeOf;else{var l;e:{var c={};try{c.__proto__={a:!0},l=c.a;break e}catch(V){}l=!1}n=l?function(e,t){if(e.__proto__=t,e.__proto__!==t)throw new TypeError(e+" is not extensible");return e}:null}var h=n;function d(){this.l=!1,this.i=null,this.h=void 0,this.g=1,this.s=this.m=0,this.j=null}function p(e){if(e.l)throw new TypeError("Generator is already running");e.l=!0}function f(e,t){e.j={S:t,T:!0},e.g=e.m||e.s}function m(e,t,n){return e.g=n,{value:t}}function g(e){this.g=new d,this.h=e}function y(e,t,n,r){try{var s=t.call(e.g.i,n);if(!(s instanceof Object))throw new TypeError("Iterator result "+s+" is not an object");if(!s.done)return e.g.l=!1,s;var o=s.value}catch(i){return e.g.i=null,f(e.g,i),x(e)}return e.g.i=null,r.call(e.g,o),x(e)}function x(e){for(;e.g.g;)try{var t=e.h(e.g);if(t)return e.g.l=!1,{value:t.value,done:!1}}catch(n){e.g.h=void 0,f(e.g,n)}if(e.g.l=!1,e.g.j){if(t=e.g.j,e.g.j=null,t.T)throw t.S;return{value:t.return,done:!0}}return{value:void 0,done:!0}}function b(e){this.next=function(t){return p(e.g),e.g.i?t=y(e,e.g.i.next,t,e.g.o):(e.g.o(t),t=x(e)),t},this.throw=function(t){return p(e.g),e.g.i?t=y(e,e.g.i.throw,t,e.g.o):(f(e.g,t),t=x(e)),t},this.return=function(t){return function(e,t){p(e.g);var n=e.g.i;return n?y(e,"return"in n?n.return:function(e){return{value:e,done:!0}},t,e.g.return):(e.g.return(t),x(e))}(e,t)},this[Symbol.iterator]=function(){return this}}function v(e,t){return t=new b(new g(t)),h&&e.prototype&&h(t,e.prototype),t}d.prototype.o=function(e){this.h=e},d.prototype.return=function(e){this.j={return:e},this.g=this.s};var w="function"==typeof Object.assign?Object.assign:function(e,t){for(var n=1;n<arguments.length;n++){var r=arguments[n];if(r)for(var s in r)Object.prototype.hasOwnProperty.call(r,s)&&(e[s]=r[s])}return e};o("Object.assign",function(e){return e||w}),o("Promise",function(e){function t(e){this.h=0,this.i=void 0,this.g=[],this.o=!1;var t=this.j();try{e(t.resolve,t.reject)}catch(n){t.reject(n)}}function n(){this.g=null}function r(e){return e instanceof t?e:new t(function(t){t(e)})}if(e)return e;n.prototype.h=function(e){if(null==this.g){this.g=[];var t=this;this.i(function(){t.l()})}this.g.push(e)};var o=s.setTimeout;n.prototype.i=function(e){o(e,0)},n.prototype.l=function(){for(;this.g&&this.g.length;){var e=this.g;this.g=[];for(var t=0;t<e.length;++t){var n=e[t];e[t]=null;try{n()}catch(r){this.j(r)}}}this.g=null},n.prototype.j=function(e){this.i(function(){throw e})},t.prototype.j=function(){function e(e){return function(r){n||(n=!0,e.call(t,r))}}var t=this,n=!1;return{resolve:e(this.B),reject:e(this.l)}},t.prototype.B=function(e){if(e===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(e instanceof t)this.D(e);else{e:switch(typeof e){case"object":var n=null!=e;break e;case"function":n=!0;break e;default:n=!1}n?this.A(e):this.m(e)}},t.prototype.A=function(e){var t=void 0;try{t=e.then}catch(n){return void this.l(n)}"function"==typeof t?this.F(t,e):this.m(e)},t.prototype.l=function(e){this.s(2,e)},t.prototype.m=function(e){this.s(1,e)},t.prototype.s=function(e,t){if(0!=this.h)throw Error("Cannot settle("+e+", "+t+"): Promise already settled in state"+this.h);this.h=e,this.i=t,2===this.h&&this.C(),this.u()},t.prototype.C=function(){var e=this;o(function(){if(e.v()){var t=s.console;void 0!==t&&t.error(e.i)}},1)},t.prototype.v=function(){if(this.o)return!1;var e=s.CustomEvent,t=s.Event,n=s.dispatchEvent;return void 0===n||("function"==typeof e?e=new e("unhandledrejection",{cancelable:!0}):"function"==typeof t?e=new t("unhandledrejection",{cancelable:!0}):(e=s.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection",!1,!0,e),e.promise=this,e.reason=this.i,n(e))},t.prototype.u=function(){if(null!=this.g){for(var e=0;e<this.g.length;++e)i.h(this.g[e]);this.g=null}};var i=new n;return t.prototype.D=function(e){var t=this.j();e.I(t.resolve,t.reject)},t.prototype.F=function(e,t){var n=this.j();try{e.call(t,n.resolve,n.reject)}catch(r){n.reject(r)}},t.prototype.then=function(e,n){function r(e,t){return"function"==typeof e?function(t){try{s(e(t))}catch(n){o(n)}}:t}var s,o,i=new t(function(e,t){s=e,o=t});return this.I(r(e,s),r(n,o)),i},t.prototype.catch=function(e){return this.then(void 0,e)},t.prototype.I=function(e,t){function n(){switch(r.h){case 1:e(r.i);break;case 2:t(r.i);break;default:throw Error("Unexpected state: "+r.h)}}var r=this;null==this.g?i.h(n):this.g.push(n),this.o=!0},t.resolve=r,t.reject=function(e){return new t(function(t,n){n(e)})},t.race=function(e){return new t(function(t,n){for(var s=a(e),o=s.next();!o.done;o=s.next())r(o.value).I(t,n)})},t.all=function(e){var n=a(e),s=n.next();return s.done?r([]):new t(function(e,t){function o(t){return function(n){i[t]=n,0==--a&&e(i)}}var i=[],a=0;do{i.push(void 0),a++,r(s.value).I(o(i.length-1),t),s=n.next()}while(!s.done)})},t}),o("Array.prototype.keys",function(e){return e||function(){return function(e,t){e instanceof String&&(e+="");var n=0,r=!1,s={next:function(){return!r&&n<e.length?{value:n++,done:!1}:(r=!0,{done:!0,value:void 0})}};return s[Symbol.iterator]=function(){return s},s}(this)}});var C=this||self;function _(e,t){e=e.split(".");var n,r=C;e[0]in r||void 0===r.execScript||r.execScript("var "+e[0]);for(;e.length&&(n=e.shift());)e.length||void 0===t?r=r[n]&&r[n]!==Object.prototype[n]?r[n]:r[n]={}:r[n]=t}function k(e,t){var n=void 0;return new(n||(n=Promise))(function(r,s){function o(e){try{a(t.next(e))}catch(n){s(n)}}function i(e){try{a(t.throw(e))}catch(n){s(n)}}function a(e){e.done?r(e.value):new n(function(t){t(e.value)}).then(o,i)}a((t=t.apply(e,void 0)).next())})}function E(e,t,n){if(n=e.createShader(0===n?e.VERTEX_SHADER:e.FRAGMENT_SHADER),e.shaderSource(n,t),e.compileShader(n),!e.getShaderParameter(n,e.COMPILE_STATUS))throw Error("Could not compile WebGL shader.\n\n"+e.getShaderInfoLog(n));return n}function S(e,t,n){this.h=e,this.g=t,this.u=n,this.l=0}function T(e){return"function"==typeof e.g.canvas.transferToImageBitmap?Promise.resolve(e.g.canvas.transferToImageBitmap()):e.u?Promise.resolve(e.g.canvas):"function"==typeof createImageBitmap?createImageBitmap(e.g.canvas):(void 0===e.j&&(e.j=document.createElement("img")),new Promise(function(t){e.j.onload=function(){requestAnimationFrame(function(){t(e.j)})},e.j.src=e.g.canvas.toDataURL()}))}function I(e,t){var n=e.g;if(void 0===e.m){var r=E(n,"\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }",0),s=E(n,"\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }",1),o=n.createProgram();if(n.attachShader(o,r),n.attachShader(o,s),n.linkProgram(o),!n.getProgramParameter(o,n.LINK_STATUS))throw Error("Could not compile WebGL program.\n\n"+n.getProgramInfoLog(o));r=e.m=o,n.useProgram(r),s=n.getUniformLocation(r,"sampler0"),e.i={H:n.getAttribLocation(r,"aVertex"),G:n.getAttribLocation(r,"aTex"),V:s},e.s=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,e.s),n.enableVertexAttribArray(e.i.H),n.vertexAttribPointer(e.i.H,2,n.FLOAT,!1,0,0),n.bufferData(n.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,null),e.o=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,e.o),n.enableVertexAttribArray(e.i.G),n.vertexAttribPointer(e.i.G,2,n.FLOAT,!1,0,0),n.bufferData(n.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,null),n.uniform1i(s,0)}r=e.i,n.useProgram(e.m),n.canvas.width=t.width,n.canvas.height=t.height,n.viewport(0,0,t.width,t.height),n.activeTexture(n.TEXTURE0),e.h.bindTexture2d(t.glName),n.enableVertexAttribArray(r.H),n.bindBuffer(n.ARRAY_BUFFER,e.s),n.vertexAttribPointer(r.H,2,n.FLOAT,!1,0,0),n.enableVertexAttribArray(r.G),n.bindBuffer(n.ARRAY_BUFFER,e.o),n.vertexAttribPointer(r.G,2,n.FLOAT,!1,0,0),n.bindFramebuffer(n.DRAW_FRAMEBUFFER?n.DRAW_FRAMEBUFFER:n.FRAMEBUFFER,null),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),n.colorMask(!0,!0,!0,!0),n.drawArrays(n.TRIANGLE_FAN,0,4),n.disableVertexAttribArray(r.H),n.disableVertexAttribArray(r.G),n.bindBuffer(n.ARRAY_BUFFER,null),e.h.bindTexture2d(0)}function N(e){this.g=e}var $=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function R(e,t){return t+e}function A(e,t){window[e]=t}function O(e){for(var t=[],n=e.size(),r=0;r<n;++r){var s=e.get(r);t.push({x:s.x,y:s.y,z:s.z,visibility:s.hasVisibility?s.visibility:void 0}),s.delete()}return t}function F(e){for(var t=[],n=e.size(),r=0;r<n;++r){var s=e.get(r);t.push({index:s.index,score:s.score,label:s.hasLabel?s.label:void 0,displayName:s.hasDisplayName?s.displayName:void 0})}return t}function D(e){if(this.g=e,this.listeners={},this.l={},this.B={},this.m={},this.s={},this.v=this.o=this.O=!0,this.F=Promise.resolve(),this.N="",this.u={},this.locateFile=e&&e.locateFile||R,"object"==typeof window)e=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else{if("undefined"==typeof location)throw Error("solutions can only be loaded on a web page or in a web worker");e=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/"}this.P=e}function P(e,t){return k(e,function e(){var n,r,s=this;return v(e,function(e){return t in s.B?e.return(s.B[t]):(n=s.locateFile(t,""),r=fetch(n).then(function(e){return e.arrayBuffer()}),s.B[t]=r,e.return(r))})})}function M(e,t){for(var n=t.name||"$",r=[].concat(u(t.wants)),s=new e.h.StringList,o=a(t.wants),i=o.next();!i.done;i=o.next())s.push_back(i.value);o=e.h.PacketListener.implement({onResults:function(s){return k(e,function e(){var o,i,u,l,c,h=this;return v(e,function(e){for(o=h,i={},u=0;u<t.wants.length;++u)i[r[u]]=s.get(u);if(l=function(e,t,n){return k(e,function e(){var r,s,o,i,u,l,c,h,d,p,f,g,y,x,b,w,C,_=this;return v(e,function(e){switch(e.g){case 1:if(!n)return e.return(t);for(r={},s=0,o=a(Object.keys(n)),i=o.next();!i.done;i=o.next())"string"!=typeof(u=n[i.value])&&"texture"===u.type&&++s;1<s&&(_.v=!1),l=a(Object.keys(n)),i=l.next();case 2:if(i.done){e.g=4;break}if("string"==typeof(h=n[c=i.value]))return w=r,C=c,m(e,function(e,t,n){return k(e,function e(){var r,s=this;return v(e,function(e){if(n.isNumber())return e.return(n.getNumber());if(n.isRect())return e.return(n.getRect());if(n.isLandmarks())return e.return(n.getLandmarks());if(n.isLandmarksList())return e.return(n.getLandmarksList());if(n.isClassificationsList())return e.return(n.getClassificationsList());if(n.isObjectDetectionList())return e.return(n.getObjectDetectionList());if(n.isTexture2d()){(r=s.s[t])||(r=new S(s.h,s.A,s.v),s.s[t]=r);var o=e.return,i=r;return I(i,n.getTexture2d()),i=T(i),o.call(e,i)}return e.return(void 0)})})}(_,c,t[h]),15);if(void 0===(d=t[h.stream])){e.g=3;break}if("detection_list"===h.type){var E=d.getRectList(),N=d.getLandmarksList(),$=d.getClassificationsList(),R=[];if(E)for(var A=0;A<E.size();++A){var D={R:E.get(A),M:O(N.get(A)),L:F($.get(A))};R.push(D)}r[c]=R,e.g=7;break}if("landmarks"===h.type){p=d.getLandmarks(),r[c]=p?O(p):void 0,e.g=7;break}if("landmarks_list"===h.type){if(f=d.getLandmarksList())for(E=[],N=f.size(),$=0;$<N;++$)R=f.get($),E.push(O(R)),R.delete();else E=void 0;r[c]=E,e.g=7;break}if("rect_list"===h.type){if(g=d.getRectList())for(E=[],N=g.size(),$=0;$<N;++$)R=g.get($),E.push(R);else E=void 0;r[c]=E,e.g=7;break}if("classifications_list"===h.type){if(y=d.getClassificationsList())for(E=[],N=y.size(),$=0;$<N;++$)R=y.get($),E.push(F(R));else E=void 0;r[c]=E,e.g=7;break}if("object_detection_list"===h.type){if(x=d.getObjectDetectionList())for(E=[],N=x.size(),$=0;$<N;++$){R=x.get($),D=(A=E).push;for(var P=R.id,M=R.keypoints,L=[],B=M.size(),V=0;V<B;++V){var U=M.get(V);L.push({id:U.id,point3d:{x:U.point3d.x,y:U.point3d.y,z:U.point3d.z},point2d:{x:U.point2d.x,y:U.point2d.y,depth:U.point2d.depth}})}D.call(A,{id:P,keypoints:L,visibility:R.visibility})}else E=void 0;r[c]=E,e.g=7;break}if("texture"!==h.type)throw Error("Unknown output config type: '"+h.type+"'");return(b=_.s[c])||(b=new S(_.h,_.A,_.v),_.s[c]=b),I(E=b,N=d.getTexture2d()),m(e,E=T(E),14);case 14:r[c]=e.h;case 7:h.transform&&r[c]&&(r[c]=h.transform(r[c])),e.g=3;break;case 15:w[C]=e.h;case 3:i=l.next(),e.g=2;break;case 4:return e.return(r)}})})}(h,i,t.outs),c=h.listeners[n])return e.return(h.F.then(function(){return l}).then(function(e){return k(o,function n(){var s,o,a=this;return v(n,function(n){for(s=c(e),o=0;o<t.wants.length;++o)i[r[o]].delete();if(s)return a.F=s,n.return(s);n.g=0})})}));e.g=0})})}}),e.i.attachMultiListener(s,o),s.delete()}function L(e){switch(void 0===e&&(e=0),e){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function B(e){var t=this;this.g=new D({locateFile:(e=e||{}).locateFile,files:function(e){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:L(e.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","image_transformed"],outs:{image:"image_transformed",poseLandmarks:{type:"landmarks",stream:"pose_landmarks"},poseWorldLandmarks:{type:"landmarks",stream:"world_landmarks"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{selfieMode:{type:1,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(e){return k(t,function t(){var n,r,s=this;return v(t,function(t){return 1==t.g?(n=L(e),r="third_party/mediapipe/modules/pose_landmark/"+n,m(t,P(s.g,n),2)):(s.g.overrideFile(r,t.h),t.return(!0))})})}},smoothLandmarks:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},minDetectionConfidence:{type:0,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:0,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__poselandmarkbyroipostprocessing__ThresholdingCalculator",fieldName:"threshold"}}}})}(e=D.prototype).close=function(){return this.i&&this.i.delete(),Promise.resolve()},e.reset=function(){return k(this,function e(){var t=this;return v(e,function(e){t.i&&(t.i.reset(),t.m={},t.s={}),e.g=0})})},e.setOptions=function(e){var t=this;if(this.g.options){for(var n=[],r=[],s={},o=a(Object.keys(e)),i=o.next();!i.done;s={J:s.J,K:s.K},i=o.next()){var u=i.value;(!(u in this.l)||this.l[u]!==e[u])&&(this.l[u]=e[u],i=this.g.options[u])&&(i.onChange&&(s.J=i.onChange,s.K=e[u],n.push(function(e){return function(){return k(t,function t(){var n=this;return v(t,function(t){if(1==t.g)return m(t,e.J(e.K),2);!0===t.h&&(n.o=!0),t.g=0})})}}(s))),i.graphOptionXref&&(u={valueNumber:0===i.type?e[u]:0,valueBoolean:1===i.type&&e[u]},i=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),i.graphOptionXref),u),r.push(i)))}0===n.length&&0===r.length||(this.o=!0,this.C=r,this.D=n)}},e.initialize=function(){return k(this,function e(){var t=this;return v(e,function(e){return 1==e.g?m(e,k(t,function e(){var t,n,r,s,o,i,a,l,c,h,d,p=this;return v(e,function(e){switch(e.g){case 1:return t=p,p.O?(n=function(e,t){return void 0===e.g.files?[]:"function"==typeof e.g.files?e.g.files(t):e.g.files}(p,p.l),m(e,function(){return k(this,function e(){return v(e,function(e){switch(e.g){case 1:return e.m=2,m(e,WebAssembly.instantiate($),4);case 4:e.g=3,e.m=0;break;case 2:return e.m=0,e.j=null,e.return(!1);case 3:return e.return(!0)}})})}(),2)):e.return();case 2:if(r=e.h,"object"==typeof window)return A("createMediapipeSolutionsWasm",{locateFile:p.locateFile}),A("createMediapipeSolutionsPackedAssets",{locateFile:p.locateFile}),i=n.filter(function(e){return void 0!==e.data}),a=n.filter(function(e){return void 0===e.data}),l=Promise.all(i.map(function(e){return P(t,e.url)})),c=Promise.all(a.map(function(e){return void 0===e.simd||e.simd&&r||!e.simd&&!r?function(e){var t=document.createElement("script");return t.setAttribute("src",e),t.setAttribute("crossorigin","anonymous"),document.body.appendChild(t),new Promise(function(e){t.addEventListener("load",function(){e()},!1)})}(t.locateFile(e.url,t.P)):Promise.resolve()})).then(function(){return k(t,function e(){var t,n,r=this;return v(e,function(e){if(1==e.g)return t=window.createMediapipeSolutionsWasm,n=window.createMediapipeSolutionsPackedAssets,m(e,t(n),2);r.h=e.h,e.g=0})})}),h=k(t,function e(){var t=this;return v(e,function(e){return t.g.graph&&t.g.graph.url?e=m(e,P(t,t.g.graph.url),0):(e.g=0,e=void 0),e})}),m(e,Promise.all([c,l,h]),7);if("function"!=typeof importScripts)throw Error("solutions can only be loaded on a web page or in a web worker");return s=n.filter(function(e){return void 0===e.simd||e.simd&&r||!e.simd&&!r}).map(function(e){return t.locateFile(e.url,t.P)}),importScripts.apply(null,u(s)),m(e,createMediapipeSolutionsWasm(Module),6);case 6:p.h=e.h,p.j=new OffscreenCanvas(1,1),p.h.canvas=p.j,o=p.h.GL.createContext(p.j,{antialias:!1,alpha:!1,U:"undefined"!=typeof WebGL2RenderingContext?2:1}),p.h.GL.makeContextCurrent(o),e.g=4;break;case 7:if(p.j=document.createElement("canvas"),!(d=p.j.getContext("webgl2",{}))&&!(d=p.j.getContext("webgl",{})))return alert("Failed to create WebGL canvas context when passing video frame."),e.return();p.A=d,p.h.canvas=p.j,p.h.createContext(p.j,!0,!0,{});case 4:p.i=new p.h.SolutionWasm,p.O=!1,e.g=0}})}),2):3!=e.g?m(e,k(t,function e(){var t,n,r,s,o,i,u=this;return v(e,function(e){if(1==e.g)return u.g.graph&&u.g.graph.url&&u.N===u.g.graph.url?e.return():(u.o=!0,u.g.graph&&u.g.graph.url?(u.N=u.g.graph.url,m(e,P(u,u.g.graph.url),3)):void(e.g=2));for(2!=e.g&&u.i.loadGraph(e.h),t=a(Object.keys(u.u)),n=t.next();!n.done;n=t.next())u.i.overrideFile(r=n.value,u.u[r]);if(u.u={},u.g.listeners)for(s=a(u.g.listeners),o=s.next();!o.done;o=s.next())M(u,o.value);i=u.l,u.l={},u.setOptions(i),e.g=0})}),3):m(e,k(t,function e(){var t,n,r,s,o,i=this;return v(e,function(e){switch(e.g){case 1:if(!i.o)return e.return();if(!i.D){e.g=2;break}t=a(i.D),n=t.next();case 3:if(n.done){e.g=5;break}return m(e,(0,n.value)(),4);case 4:n=t.next(),e.g=3;break;case 5:i.D=void 0;case 2:if(i.C){for(r=new i.h.GraphOptionChangeRequestList,s=a(i.C),o=s.next();!o.done;o=s.next())r.push_back(o.value);i.i.changeOptions(r),r.delete(),i.C=void 0}i.o=!1,e.g=0}})}),0)})})},e.overrideFile=function(e,t){this.i?this.i.overrideFile(e,t):this.u[e]=t},e.clearOverriddenFiles=function(){this.u={},this.i&&this.i.clearOverriddenFiles()},e.send=function(e,t){return k(this,function n(){var r,s,o,i,u,l,c,h,d,p=this;return v(n,function(n){if(1==n.g)return p.g.inputs?(r=1e3*(null==t?performance.now():t),m(n,p.F,2)):n.return();if(3!=n.g)return m(n,p.initialize(),3);for(s=new p.h.PacketDataList,o=a(Object.keys(e)),i=o.next();!i.done;i=o.next())if(l=p.g.inputs[u=i.value]){e:{var f=p,g=e[u];switch(l.type){case"video":var y=f.m[l.stream];if(y||(y=new S(f.h,f.A,f.v),f.m[l.stream]=y),0===(f=y).l&&(f.l=f.h.createTexture()),"undefined"!=typeof HTMLVideoElement&&g instanceof HTMLVideoElement){var x=g.videoWidth;y=g.videoHeight}else"undefined"!=typeof HTMLImageElement&&g instanceof HTMLImageElement?(x=g.naturalWidth,y=g.naturalHeight):(x=g.width,y=g.height);y={glName:f.l,width:x,height:y},(x=f.g).canvas.width=y.width,x.canvas.height=y.height,x.activeTexture(x.TEXTURE0),f.h.bindTexture2d(f.l),x.texImage2D(x.TEXTURE_2D,0,x.RGBA,x.RGBA,x.UNSIGNED_BYTE,g),f.h.bindTexture2d(0),f=y;break e;case"detections":for((y=f.m[l.stream])||(y=new N(f.h),f.m[l.stream]=y),(f=y).data||(f.data=new f.g.DetectionListData),f.data.reset(g.length),y=0;y<g.length;++y){if(f.data.setBoundingBox(y,(x=g[y]).R),x.M)for(var b=0;b<x.M.length;++b){var v=x.M[b],w=!!v.visibility;f.data.addNormalizedLandmark(y,Object.assign(Object.assign({},v),{hasVisibility:w,visibility:w?v.visibility:0}))}if(x.L)for(b=0;b<x.L.length;++b){var C=!!(v=x.L[b]).label,_=!!v.displayName;f.data.addClassification(y,{score:v.score,hasIndex:w=!!v.index,index:w?v.index:-1,hasLabel:C,label:C?v.label:"",hasDisplayName:_,displayName:_?v.displayName:""})}}f=f.data;break e;default:f={}}}switch(c=f,h=l.stream,l.type){case"video":s.pushTexture2d(Object.assign(Object.assign({},c),{stream:h,timestamp:r}));break;case"detections":(d=c).stream=h,d.timestamp=r,s.pushDetectionList(d);break;default:throw Error("Unknown input config type: '"+l.type+"'")}}p.i.send(s),s.delete(),n.g=0})})},e.onResults=function(e,t){this.listeners[t||"$"]=e},_("Solution",D),_("OptionType",{NUMBER:0,BOOL:1,0:"NUMBER",1:"BOOL"}),(e=B.prototype).reset=function(){this.g.reset()},e.close=function(){return this.g.close(),Promise.resolve()},e.onResults=function(e){this.g.onResults(e)},e.initialize=function(){return k(this,function e(){var t=this;return v(e,function(e){return m(e,t.g.initialize(),0)})})},e.send=function(e,t){return k(this,function n(){var r=this;return v(n,function(n){return m(n,r.g.send(e,t),0)})})},e.setOptions=function(e){this.g.setOptions(e)},_("Pose",B),_("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),_("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),_("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),_("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),_("POSE_LANDMARKS_NEUTRAL",{NOSE:0})}).call(this)},176:(e,t,n)=>{var r=n(367),s=n(171),o=n(777),i=n(887),a=n(843),u=n(709),l=n(269);l.alea=r,l.xor128=s,l.xorwow=o,l.xorshift7=i,l.xor4096=a,l.tychei=u,e.exports=l},367:function(e,t,n){var r;!function(e,s,o){function i(e){var t,n=this,r=(t=4022871197,function(e){e=e.toString();for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function a(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function u(e,t){var n=new i(e),r=t&&t.state,s=n.next;return s.int32=function(){return 4294967296*n.next()|0},s.double=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.quick=s,r&&("object"==typeof r&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=(function(){return u}).call(t,n,t,s))||(s.exports=r):this.alea=u}(0,e=n.nmd(e))},709:function(e,t,n){var r;!function(e,s,o){function i(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,s=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^s,s=s-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^s,t.a=s-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function u(e,t){var n=new i(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=(function(){return u}).call(t,n,t,s))||(s.exports=r):this.tychei=u}(0,e=n.nmd(e))},171:function(e,t,n){var r;!function(e,s,o){function i(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function u(e,t){var n=new i(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=(function(){return u}).call(t,n,t,s))||(s.exports=r):this.xor128=u}(0,e=n.nmd(e))},843:function(e,t,n){var r;!function(e,s,o){function i(e){var t=this;t.next=function(){var e,n,r=t.w,s=t.X,o=t.i;return t.w=r=r+1640531527|0,n=s[o+34&127],e=s[o=o+1&127],n^=n<<13,e^=e<<17,n=s[o]=(n^=n>>>15)^(e^=e>>>12),t.i=o,n+(r^r>>>16)|0},function(e,t){var n,r,s,o,i,a=[],u=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,u=Math.max(u,t.length)),s=0,o=-32;o<u;++o)t&&(r^=t.charCodeAt((o+32)%t.length)),0===o&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,o>=0&&(s=0==(n=a[127&o]^=r+(i=i+1640531527|0))?s+1:0);for(s>=128&&(a[127&(t&&t.length||0)]=-1),s=127,o=512;o>0;--o)r=a[s+34&127],n=a[s=s+1&127],r^=r<<13,n^=n<<17,a[s]=(r^=r>>>15)^(n^=n>>>12);e.w=i,e.X=a,e.i=s}(t,e)}function a(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function u(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.X&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=(function(){return u}).call(t,n,t,s))||(s.exports=r):this.xor4096=u}(0,e=n.nmd(e))},887:function(e,t,n){var r;!function(e,s,o){function i(e){var t=this;t.next=function(){var e,n,r=t.x,s=t.i;return e=r[s],n=(e^=e>>>7)^e<<24,n^=(e=r[s+1&7])^e>>>10,n^=(e=r[s+3&7])^e>>>3,n^=(e=r[s+4&7])^e<<7,e=r[s+7&7],r[s]=n^=(e^=e<<13)^e<<9,t.i=s+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n&&(r[7]=-1),e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function a(e,t){return t.x=e.x.slice(),t.i=e.i,t}function u(e,t){null==e&&(e=+new Date);var n=new i(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.x&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=(function(){return u}).call(t,n,t,s))||(s.exports=r):this.xorshift7=u}(0,e=n.nmd(e))},777:function(e,t,n){var r;!function(e,s,o){function i(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function u(e,t){var n=new i(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&a(r,n),s.state=function(){return a(n,{})}),s}s&&s.exports?s.exports=u:n.amdD&&n.amdO?void 0===(r=(function(){return u}).call(t,n,t,s))||(s.exports=r):this.xorwow=u}(0,e=n.nmd(e))},269:(e,t,n)=>{var r;!function(s,o){var i,a=this,u=256,l=o.pow(u,6),c=o.pow(2,52),h=2*c,d=255;function p(e,t,n){var r=[],d=y(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,x(s)]:null==e?function(){try{var e;return i&&(e=i.randomBytes)?e=e(u):(e=new Uint8Array(u),(a.crypto||a.msCrypto).getRandomValues(e)),x(e)}catch(r){var t=a.navigator,n=t&&t.plugins;return[+new Date,a,n,a.screen,x(s)]}}():e,3),r),p=new f(r),b=function(){for(var e=p.g(6),t=l,n=0;e<c;)e=(e+n)*u,t*=u,n=p.g(1);for(;e>=h;)e/=2,t/=2,n>>>=1;return(e+n)/t};return b.int32=function(){return 0|p.g(4)},b.quick=function(){return p.g(4)/4294967296},b.double=b,y(x(p.S),s),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,p),e.state=function(){return m(p,{})}),n?(o.random=e,t):e})(b,d,"global"in t?t.global:this==o,t.state)}function f(e){var t,n=e.length,r=this,s=0,o=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);s<u;)i[s]=s++;for(s=0;s<u;s++)i[s]=i[o=d&o+e[s%n]+(t=i[s])],i[o]=t;(r.g=function(e){for(var t,n=0,s=r.i,o=r.j,i=r.S;e--;)t=i[s=d&s+1],n=n*u+i[d&(i[s]=i[o=d&o+t])+(i[o]=t)];return r.i=s,r.j=o,n})(u)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,r=[],s=typeof e;if(t&&"object"==s)for(n in e)try{r.push(g(e[n],t-1))}catch(o){}return r.length?r:"string"==s?e:e+"\0"}function y(e,t){for(var n,r=e+"",s=0;s<r.length;)t[d&s]=d&(n^=19*t[d&s])+r.charCodeAt(s++);return x(t)}function x(e){return String.fromCharCode.apply(0,e)}if(o.seedrandom=p,y(o.random(),s),e.exports){e.exports=p;try{i=n(778)}catch(b){}}else void 0===(r=(function(){return p}).call(t,n,t,e))||(e.exports=r)}([],Math)},80:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(E){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var s={},o={};function i(e,t){var n,r,i;return t?(i=0<=(e>>>=0)&&e<256)&&(r=o[e])?r:(n=u(e,(0|e)<0?-1:0,!0),i&&(o[e]=n),n):(i=-128<=(e|=0)&&e<128)&&(r=s[e])?r:(n=u(e,e<0?-1:0,!1),i&&(s[e]=n),n)}function a(e,t){if(isNaN(e))return t?y:g;if(t){if(e<0)return y;if(e>=p)return C}else{if(e<=-f)return _;if(e+1>=f)return w}return e<0?a(-e,t).neg():u(e%d|0,e/d|0,t)}function u(e,t,r){return new n(e,t,r)}n.fromInt=i,n.fromNumber=a,n.fromBits=u;var l=Math.pow;function c(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(e.substring(1),t,n).neg();for(var s=a(l(n,8)),o=g,i=0;i<e.length;i+=8){var u=Math.min(8,e.length-i),h=parseInt(e.substring(i,i+u),n);if(u<8){var d=a(l(n,u));o=o.mul(d).add(a(h))}else o=(o=o.mul(s)).add(a(h))}return o.unsigned=t,o}function h(e,t){return"number"==typeof e?a(e,t):"string"==typeof e?c(e,t):u(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}n.fromString=c,n.fromValue=h;var d=4294967296,p=d*d,f=p/2,m=i(1<<24),g=i(0);n.ZERO=g;var y=i(0,!0);n.UZERO=y;var x=i(1);n.ONE=x;var b=i(1,!0);n.UONE=b;var v=i(-1);n.NEG_ONE=v;var w=u(-1,2147483647,!1);n.MAX_VALUE=w;var C=u(-1,-1,!0);n.MAX_UNSIGNED_VALUE=C;var _=u(0,-2147483648,!1);n.MIN_VALUE=_;var k=n.prototype;k.toInt=function(){return this.unsigned?this.low>>>0:this.low},k.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},k.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(_)){var t=a(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var s=a(l(e,6),this.unsigned),o=this,i="";;){var u=o.div(s),c=(o.sub(u.mul(s)).toInt()>>>0).toString(e);if((o=u).isZero())return c+i;for(;c.length<6;)c="0"+c;i=""+c+i}},k.getHighBits=function(){return this.high},k.getHighBitsUnsigned=function(){return this.high>>>0},k.getLowBits=function(){return this.low},k.getLowBitsUnsigned=function(){return this.low>>>0},k.getNumBitsAbs=function(){if(this.isNegative())return this.eq(_)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},k.isZero=function(){return 0===this.high&&0===this.low},k.eqz=k.isZero,k.isNegative=function(){return!this.unsigned&&this.high<0},k.isPositive=function(){return this.unsigned||this.high>=0},k.isOdd=function(){return 1==(1&this.low)},k.isEven=function(){return 0==(1&this.low)},k.equals=function(e){return r(e)||(e=h(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&this.high===e.high&&this.low===e.low},k.eq=k.equals,k.notEquals=function(e){return!this.eq(e)},k.neq=k.notEquals,k.ne=k.notEquals,k.lessThan=function(e){return this.comp(e)<0},k.lt=k.lessThan,k.lessThanOrEqual=function(e){return this.comp(e)<=0},k.lte=k.lessThanOrEqual,k.le=k.lessThanOrEqual,k.greaterThan=function(e){return this.comp(e)>0},k.gt=k.greaterThan,k.greaterThanOrEqual=function(e){return this.comp(e)>=0},k.gte=k.greaterThanOrEqual,k.ge=k.greaterThanOrEqual,k.compare=function(e){if(r(e)||(e=h(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},k.comp=k.compare,k.negate=function(){return!this.unsigned&&this.eq(_)?_:this.not().add(x)},k.neg=k.negate,k.add=function(e){r(e)||(e=h(e));var t=0,n=0,s=0,o=0;return s+=(o+=(65535&this.low)+(65535&e.low))>>>16,n+=(s+=(this.low>>>16)+(e.low>>>16))>>>16,t+=(n+=(65535&this.high)+(65535&e.high))>>>16,t+=(this.high>>>16)+(e.high>>>16),u((s&=65535)<<16|(o&=65535),(t&=65535)<<16|(n&=65535),this.unsigned)},k.subtract=function(e){return r(e)||(e=h(e)),this.add(e.neg())},k.sub=k.subtract,k.multiply=function(e){if(this.isZero())return g;if(r(e)||(e=h(e)),t)return u(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(_))return e.isOdd()?_:g;if(e.eq(_))return this.isOdd()?_:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return a(this.toNumber()*e.toNumber(),this.unsigned);var n=65535&this.high,s=this.low>>>16,o=65535&this.low,i=65535&e.high,l=e.low>>>16,c=65535&e.low,d=0,p=0,f=0,y=0;return f+=(y+=o*c)>>>16,p+=(f+=s*c)>>>16,f&=65535,p+=(f+=o*l)>>>16,d+=(p+=n*c)>>>16,p&=65535,d+=(p+=s*l)>>>16,p&=65535,d+=(p+=o*i)>>>16,d+=(this.high>>>16)*c+n*l+s*i+o*(e.high>>>16),u((f&=65535)<<16|(y&=65535),(d&=65535)<<16|(p&=65535),this.unsigned)},k.mul=k.multiply,k.divide=function(e){if(r(e)||(e=h(e)),e.isZero())throw Error("division by zero");var n,s,o;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?u((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return y;if(e.gt(this.shru(1)))return b;o=y}else{if(this.eq(_))return e.eq(x)||e.eq(v)?_:e.eq(_)?x:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?x:v:(s=this.sub(e.mul(n)),o=n.add(s.div(e)));if(e.eq(_))return this.unsigned?y:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();o=g}for(s=this;s.gte(e);){n=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),c=i<=48?1:l(2,i-48),d=a(n),p=d.mul(e);p.isNegative()||p.gt(s);)p=(d=a(n-=c,this.unsigned)).mul(e);d.isZero()&&(d=x),o=o.add(d),s=s.sub(p)}return o},k.div=k.divide,k.modulo=function(e){return r(e)||(e=h(e)),t?u((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},k.mod=k.modulo,k.rem=k.modulo,k.not=function(){return u(~this.low,~this.high,this.unsigned)},k.and=function(e){return r(e)||(e=h(e)),u(this.low&e.low,this.high&e.high,this.unsigned)},k.or=function(e){return r(e)||(e=h(e)),u(this.low|e.low,this.high|e.high,this.unsigned)},k.xor=function(e){return r(e)||(e=h(e)),u(this.low^e.low,this.high^e.high,this.unsigned)},k.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?u(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):u(0,this.low<<e-32,this.unsigned)},k.shl=k.shiftLeft,k.shiftRight=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?u(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):u(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},k.shr=k.shiftRight,k.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0==(e&=63))return this;var t=this.high;return e<32?u(this.low>>>e|t<<32-e,t>>>e,this.unsigned):u(32===e?t:t>>>e-32,0,this.unsigned)},k.shru=k.shiftRightUnsigned,k.shr_u=k.shiftRightUnsigned,k.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},k.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},k.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},k.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},k.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},339:(e,t,n)=>{"use strict";var r={};n.r(r),n.d(r,{assertParamsValid:()=>Ox,computeFlatOffset:()=>Gx,computeOutShape:()=>Dx,getNormalizedAxes:()=>Bx,isSliceContinous:()=>Hx,maskToAxes:()=>Fx,parseSliceParams:()=>qx,sliceInfo:()=>Kx,startForAxis:()=>Wx,startIndicesWithElidedDims:()=>Vx,stopForAxis:()=>jx,stopIndicesWithElidedDims:()=>Ux,stridesForAxis:()=>zx,stridesWithElidedDims:()=>Px});var s={};n.r(s),n.d(s,{collectGatherOpShapeInfo:()=>fC,computeOutShape:()=>pC,segOpComputeOptimalWindowSize:()=>dC});var o={};n.r(o),n.d(o,{ERF_A1:()=>Ww,ERF_A2:()=>jw,ERF_A3:()=>Hw,ERF_A4:()=>Gw,ERF_A5:()=>qw,ERF_P:()=>zw,PARALLELIZE_THRESHOLD:()=>Iw,SELU_SCALE:()=>Uw,SELU_SCALEALPHA:()=>Vw,applyActivation:()=>Sw,assertAndGetBroadcastShape:()=>Zb,assertAxesAreInnerMostDims:()=>mv,assertParamsConsistent:()=>sw,assignToTypedArray:()=>tC,axesAreInnerMostDims:()=>hv,calculateShapes:()=>Bw,checkEinsumDimSizes:()=>aC,combineLocations:()=>dv,complexWithEvenIndex:()=>Zw,complexWithOddIndex:()=>Jw,computeConv2DInfo:()=>lw,computeConv3DInfo:()=>cw,computeDefaultPad:()=>hw,computeDilation2DInfo:()=>iw,computeOptimalWindowSize:()=>Nw,computeOutAndReduceShapes:()=>pv,computeOutShape:()=>ow,computePool2DInfo:()=>aw,computePool3DInfo:()=>uw,convertConv2DDataFormat:()=>xw,decodeEinsumEquation:()=>oC,eitherStridesOrDilationsAreOne:()=>yw,expandShapeToKeepDim:()=>fv,exponent:()=>rC,exponents:()=>nC,fromStringArrayToUint8:()=>gC,fromUint8ToStringArray:()=>mC,getAxesPermutation:()=>gv,getBroadcastDims:()=>Yb,getComplexWithIndex:()=>eC,getEinsumComputePath:()=>uC,getEinsumPermutation:()=>iC,getFusedBiasGradient:()=>Ew,getFusedDyActivation:()=>kw,getImageCenter:()=>$w,getInnerMostAxes:()=>xv,getPermuted:()=>Aw,getReductionAxes:()=>Qb,getReshaped:()=>Rw,getReshapedPermuted:()=>Ow,getSliceBeginCoords:()=>Fw,getSliceSize:()=>Dw,getUndoAxesPermutation:()=>yv,isIdentityPermutation:()=>lC,log:()=>Xw,mergeRealAndImagArrays:()=>Yw,prepareAndValidate:()=>Pw,prepareSplitSize:()=>hC,segment_util:()=>s,shouldFuse:()=>Tw,slice_util:()=>r,splitRealAndImagArrays:()=>Qw,tupleValuesAreOne:()=>gw,upcastType:()=>by,validateInput:()=>Lw,validateUpdateShape:()=>Mw,warn:()=>Kw});var i={};n.r(i),n.d(i,{json:()=>NC});var a={};n.r(a),n.d(a,{json:()=>$C});var u={};n.r(u),n.d(u,{json:()=>RC});var l={};n.r(l),n.d(l,{json:()=>AC});var c={};n.r(c),n.d(c,{json:()=>OC});var h={};n.r(h),n.d(h,{json:()=>FC});var d={};n.r(d),n.d(d,{json:()=>DC});var p={};n.r(p),n.d(p,{json:()=>PC});var f={};n.r(f),n.d(f,{json:()=>MC});var m={};n.r(m),n.d(m,{json:()=>LC});var g={};n.r(g),n.d(g,{json:()=>BC});var y={};n.r(y),n.d(y,{json:()=>VC});var x={};n.r(x),n.d(x,{json:()=>UC});var b={};n.r(b),n.d(b,{json:()=>zC});var v={};n.r(v),n.d(v,{json:()=>WC});var w={};n.r(w),n.d(w,{json:()=>jC});var C={};n.r(C),n.d(C,{json:()=>HC});var _={};n.r(_),n.d(_,{json:()=>GC});var k={};n.r(k),n.d(k,{json:()=>qC});var E={};function S(e){return"function"==typeof e}n.r(E),n.d(E,{addImpl:()=>vI,bincountImpl:()=>CI,bincountReduceImpl:()=>_I,ceilImpl:()=>SI,concatImpl:()=>TI,equalImpl:()=>II,expImpl:()=>NI,expm1Impl:()=>$I,floorImpl:()=>RI,gatherNdImpl:()=>AI,gatherV2Impl:()=>OI,greaterEqualImpl:()=>DI,greaterImpl:()=>FI,lessEqualImpl:()=>MI,lessImpl:()=>PI,linSpaceImpl:()=>LI,logImpl:()=>BI,maxImpl:()=>VI,maximumImpl:()=>UI,minimumImpl:()=>zI,multiplyImpl:()=>WI,negImpl:()=>HI,notEqualImpl:()=>GI,prodImpl:()=>KI,rangeImpl:()=>XI,rsqrtImpl:()=>YI,simpleAbsImpl:()=>dI,sliceImpl:()=>QI,sparseFillEmptyRowsImpl:()=>ZI,sparseReshapeImpl:()=>JI,sparseSegmentReductionImpl:()=>eN,squaredDifferenceImpl:()=>tN,stridedSliceImpl:()=>nN,stringNGramsImpl:()=>sN,stringSplitImpl:()=>iN,stringToHashBucketFastImpl:()=>aN,subImpl:()=>uN,tileImpl:()=>cN,topKImpl:()=>hN,transposeImpl:()=>qI,uniqueImpl:()=>dN});let T=!1;const I={Promise:void 0,set useDeprecatedSynchronousErrorHandling(e){if(e){const e=new Error;console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n"+e.stack)}else T&&console.log("RxJS: Back to a better error behavior. Thank you. <3");T=e},get useDeprecatedSynchronousErrorHandling(){return T}};function N(e){setTimeout(()=>{throw e},0)}const $={closed:!0,next(e){},error(e){if(I.useDeprecatedSynchronousErrorHandling)throw e;N(e)},complete(){}},R=Array.isArray||(e=>e&&"number"==typeof e.length);function A(e){return null!==e&&"object"==typeof e}const O=(()=>{function e(e){return Error.call(this),this.message=e?`${e.length} errors occurred during unsubscription:\n${e.map((e,t)=>`${t+1}) ${e.toString()}`).join("\n  ")}`:"",this.name="UnsubscriptionError",this.errors=e,this}return e.prototype=Object.create(Error.prototype),e})();class F{constructor(e){this.closed=!1,this._parentOrParents=null,this._subscriptions=null,e&&(this._ctorUnsubscribe=!0,this._unsubscribe=e)}unsubscribe(){let e;if(this.closed)return;let{_parentOrParents:t,_ctorUnsubscribe:n,_unsubscribe:r,_subscriptions:s}=this;if(this.closed=!0,this._parentOrParents=null,this._subscriptions=null,t instanceof F)t.remove(this);else if(null!==t)for(let i=0;i<t.length;++i)t[i].remove(this);if(S(r)){n&&(this._unsubscribe=void 0);try{r.call(this)}catch(o){e=o instanceof O?D(o.errors):[o]}}if(R(s)){let t=-1,n=s.length;for(;++t<n;){const n=s[t];if(A(n))try{n.unsubscribe()}catch(o){e=e||[],o instanceof O?e=e.concat(D(o.errors)):e.push(o)}}}if(e)throw new O(e)}add(e){let t=e;if(!e)return F.EMPTY;switch(typeof e){case"function":t=new F(e);case"object":if(t===this||t.closed||"function"!=typeof t.unsubscribe)return t;if(this.closed)return t.unsubscribe(),t;if(!(t instanceof F)){const e=t;t=new F,t._subscriptions=[e]}break;default:throw new Error("unrecognized teardown "+e+" added to Subscription.")}let{_parentOrParents:n}=t;if(null===n)t._parentOrParents=this;else if(n instanceof F){if(n===this)return t;t._parentOrParents=[n,this]}else{if(-1!==n.indexOf(this))return t;n.push(this)}const r=this._subscriptions;return null===r?this._subscriptions=[t]:r.push(t),t}remove(e){const t=this._subscriptions;if(t){const n=t.indexOf(e);-1!==n&&t.splice(n,1)}}}function D(e){return e.reduce((e,t)=>e.concat(t instanceof O?t.errors:t),[])}F.EMPTY=function(e){return e.closed=!0,e}(new F);const P="function"==typeof Symbol?Symbol("rxSubscriber"):"@@rxSubscriber_"+Math.random();class M extends F{constructor(e,t,n){switch(super(),this.syncErrorValue=null,this.syncErrorThrown=!1,this.syncErrorThrowable=!1,this.isStopped=!1,arguments.length){case 0:this.destination=$;break;case 1:if(!e){this.destination=$;break}if("object"==typeof e){e instanceof M?(this.syncErrorThrowable=e.syncErrorThrowable,this.destination=e,e.add(this)):(this.syncErrorThrowable=!0,this.destination=new L(this,e));break}default:this.syncErrorThrowable=!0,this.destination=new L(this,e,t,n)}}[P](){return this}static create(e,t,n){const r=new M(e,t,n);return r.syncErrorThrowable=!1,r}next(e){this.isStopped||this._next(e)}error(e){this.isStopped||(this.isStopped=!0,this._error(e))}complete(){this.isStopped||(this.isStopped=!0,this._complete())}unsubscribe(){this.closed||(this.isStopped=!0,super.unsubscribe())}_next(e){this.destination.next(e)}_error(e){this.destination.error(e),this.unsubscribe()}_complete(){this.destination.complete(),this.unsubscribe()}_unsubscribeAndRecycle(){const{_parentOrParents:e}=this;return this._parentOrParents=null,this.unsubscribe(),this.closed=!1,this.isStopped=!1,this._parentOrParents=e,this}}class L extends M{constructor(e,t,n,r){let s;super(),this._parentSubscriber=e;let o=this;S(t)?s=t:t&&(s=t.next,n=t.error,r=t.complete,t!==$&&(o=Object.create(t),S(o.unsubscribe)&&this.add(o.unsubscribe.bind(o)),o.unsubscribe=this.unsubscribe.bind(this))),this._context=o,this._next=s,this._error=n,this._complete=r}next(e){if(!this.isStopped&&this._next){const{_parentSubscriber:t}=this;I.useDeprecatedSynchronousErrorHandling&&t.syncErrorThrowable?this.__tryOrSetError(t,this._next,e)&&this.unsubscribe():this.__tryOrUnsub(this._next,e)}}error(e){if(!this.isStopped){const{_parentSubscriber:t}=this,{useDeprecatedSynchronousErrorHandling:n}=I;if(this._error)n&&t.syncErrorThrowable?(this.__tryOrSetError(t,this._error,e),this.unsubscribe()):(this.__tryOrUnsub(this._error,e),this.unsubscribe());else if(t.syncErrorThrowable)n?(t.syncErrorValue=e,t.syncErrorThrown=!0):N(e),this.unsubscribe();else{if(this.unsubscribe(),n)throw e;N(e)}}}complete(){if(!this.isStopped){const{_parentSubscriber:e}=this;if(this._complete){const t=()=>this._complete.call(this._context);I.useDeprecatedSynchronousErrorHandling&&e.syncErrorThrowable?(this.__tryOrSetError(e,t),this.unsubscribe()):(this.__tryOrUnsub(t),this.unsubscribe())}else this.unsubscribe()}}__tryOrUnsub(e,t){try{e.call(this._context,t)}catch(n){if(this.unsubscribe(),I.useDeprecatedSynchronousErrorHandling)throw n;N(n)}}__tryOrSetError(e,t,n){if(!I.useDeprecatedSynchronousErrorHandling)throw new Error("bad call");try{t.call(this._context,n)}catch(r){return I.useDeprecatedSynchronousErrorHandling?(e.syncErrorValue=r,e.syncErrorThrown=!0,!0):(N(r),!0)}return!1}_unsubscribe(){const{_parentSubscriber:e}=this;this._context=null,this._parentSubscriber=null,e.unsubscribe()}}const B="function"==typeof Symbol&&Symbol.observable||"@@observable";function V(e){return e}let U=(()=>{class e{constructor(e){this._isScalar=!1,e&&(this._subscribe=e)}lift(t){const n=new e;return n.source=this,n.operator=t,n}subscribe(e,t,n){const{operator:r}=this,s=function(e,t,n){if(e){if(e instanceof M)return e;if(e[P])return e[P]()}return e||t||n?new M(e,t,n):new M($)}(e,t,n);if(s.add(r?r.call(s,this.source):this.source||I.useDeprecatedSynchronousErrorHandling&&!s.syncErrorThrowable?this._subscribe(s):this._trySubscribe(s)),I.useDeprecatedSynchronousErrorHandling&&s.syncErrorThrowable&&(s.syncErrorThrowable=!1,s.syncErrorThrown))throw s.syncErrorValue;return s}_trySubscribe(e){try{return this._subscribe(e)}catch(t){I.useDeprecatedSynchronousErrorHandling&&(e.syncErrorThrown=!0,e.syncErrorValue=t),function(e){for(;e;){const{closed:t,destination:n,isStopped:r}=e;if(t||r)return!1;e=n&&n instanceof M?n:null}return!0}(e)?e.error(t):console.warn(t)}}forEach(e,t){return new(t=z(t))((t,n)=>{let r;r=this.subscribe(t=>{try{e(t)}catch(s){n(s),r&&r.unsubscribe()}},n,t)})}_subscribe(e){const{source:t}=this;return t&&t.subscribe(e)}[B](){return this}pipe(...e){return 0===e.length?this:(0===(t=e).length?V:1===t.length?t[0]:function(e){return t.reduce((e,t)=>t(e),e)})(this);var t}toPromise(e){return new(e=z(e))((e,t)=>{let n;this.subscribe(e=>n=e,e=>t(e),()=>e(n))})}}return e.create=t=>new e(t),e})();function z(e){if(e||(e=I.Promise||Promise),!e)throw new Error("no Promise impl found");return e}const W=(()=>{function e(){return Error.call(this),this.message="object unsubscribed",this.name="ObjectUnsubscribedError",this}return e.prototype=Object.create(Error.prototype),e})();class j extends F{constructor(e,t){super(),this.subject=e,this.subscriber=t,this.closed=!1}unsubscribe(){if(this.closed)return;this.closed=!0;const e=this.subject,t=e.observers;if(this.subject=null,!t||0===t.length||e.isStopped||e.closed)return;const n=t.indexOf(this.subscriber);-1!==n&&t.splice(n,1)}}class H extends M{constructor(e){super(e),this.destination=e}}let G=(()=>{class e extends U{constructor(){super(),this.observers=[],this.closed=!1,this.isStopped=!1,this.hasError=!1,this.thrownError=null}[P](){return new H(this)}lift(e){const t=new q(this,this);return t.operator=e,t}next(e){if(this.closed)throw new W;if(!this.isStopped){const{observers:t}=this,n=t.length,r=t.slice();for(let s=0;s<n;s++)r[s].next(e)}}error(e){if(this.closed)throw new W;this.hasError=!0,this.thrownError=e,this.isStopped=!0;const{observers:t}=this,n=t.length,r=t.slice();for(let s=0;s<n;s++)r[s].error(e);this.observers.length=0}complete(){if(this.closed)throw new W;this.isStopped=!0;const{observers:e}=this,t=e.length,n=e.slice();for(let r=0;r<t;r++)n[r].complete();this.observers.length=0}unsubscribe(){this.isStopped=!0,this.closed=!0,this.observers=null}_trySubscribe(e){if(this.closed)throw new W;return super._trySubscribe(e)}_subscribe(e){if(this.closed)throw new W;return this.hasError?(e.error(this.thrownError),F.EMPTY):this.isStopped?(e.complete(),F.EMPTY):(this.observers.push(e),new j(this,e))}asObservable(){const e=new U;return e.source=this,e}}return e.create=(e,t)=>new q(e,t),e})();class q extends G{constructor(e,t){super(),this.destination=e,this.source=t}next(e){const{destination:t}=this;t&&t.next&&t.next(e)}error(e){const{destination:t}=this;t&&t.error&&this.destination.error(e)}complete(){const{destination:e}=this;e&&e.complete&&this.destination.complete()}_subscribe(e){const{source:t}=this;return t?this.source.subscribe(e):F.EMPTY}}function K(e){return e&&"function"==typeof e.schedule}function X(e,t){return function(n){if("function"!=typeof e)throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");return n.lift(new Y(e,t))}}class Y{constructor(e,t){this.project=e,this.thisArg=t}call(e,t){return t.subscribe(new Q(e,this.project,this.thisArg))}}class Q extends M{constructor(e,t,n){super(e),this.project=t,this.count=0,this.thisArg=n||this}_next(e){let t;try{t=this.project.call(this.thisArg,e,this.count++)}catch(n){return void this.destination.error(n)}this.destination.next(t)}}const Z=e=>t=>{for(let n=0,r=e.length;n<r&&!t.closed;n++)t.next(e[n]);t.complete()},J="function"==typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator",ee=e=>e&&"number"==typeof e.length&&"function"!=typeof e;function te(e){return!!e&&"function"!=typeof e.subscribe&&"function"==typeof e.then}const ne=e=>{if(e&&"function"==typeof e[B])return n=e,e=>{const t=n[B]();if("function"!=typeof t.subscribe)throw new TypeError("Provided object does not correctly implement Symbol.observable");return t.subscribe(e)};if(ee(e))return Z(e);if(te(e))return(e=>t=>(e.then(e=>{t.closed||(t.next(e),t.complete())},e=>t.error(e)).then(null,N),t))(e);if(e&&"function"==typeof e[J])return t=e,e=>{const n=t[J]();for(;;){let t;try{t=n.next()}catch(r){return e.error(r),e}if(t.done){e.complete();break}if(e.next(t.value),e.closed)break}return"function"==typeof n.return&&e.add(()=>{n.return&&n.return()}),e};{const t=A(e)?"an invalid object":`'${e}'`;throw new TypeError(`You provided ${t} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`)}var t,n};function re(e,t){return new U(n=>{const r=new F;let s=0;return r.add(t.schedule(function(){s!==e.length?(n.next(e[s++]),n.closed||r.add(this.schedule())):n.complete()})),r})}function se(e,t){return t?function(e,t){if(null!=e){if(function(e){return e&&"function"==typeof e[B]}(e))return function(e,t){return new U(n=>{const r=new F;return r.add(t.schedule(()=>{const s=e[B]();r.add(s.subscribe({next(e){r.add(t.schedule(()=>n.next(e)))},error(e){r.add(t.schedule(()=>n.error(e)))},complete(){r.add(t.schedule(()=>n.complete()))}}))})),r})}(e,t);if(te(e))return function(e,t){return new U(n=>{const r=new F;return r.add(t.schedule(()=>e.then(e=>{r.add(t.schedule(()=>{n.next(e),r.add(t.schedule(()=>n.complete()))}))},e=>{r.add(t.schedule(()=>n.error(e)))}))),r})}(e,t);if(ee(e))return re(e,t);if(function(e){return e&&"function"==typeof e[J]}(e)||"string"==typeof e)return function(e,t){if(!e)throw new Error("Iterable cannot be null");return new U(n=>{const r=new F;let s;return r.add(()=>{s&&"function"==typeof s.return&&s.return()}),r.add(t.schedule(()=>{s=e[J](),r.add(t.schedule(function(){if(n.closed)return;let e,t;try{const n=s.next();e=n.value,t=n.done}catch(r){return void n.error(r)}t?n.complete():(n.next(e),this.schedule())}))})),r})}(e,t)}throw new TypeError((null!==e&&typeof e||e)+" is not observable")}(e,t):e instanceof U?e:new U(ne(e))}class oe extends M{constructor(e){super(),this.parent=e}_next(e){this.parent.notifyNext(e)}_error(e){this.parent.notifyError(e),this.unsubscribe()}_complete(){this.parent.notifyComplete(),this.unsubscribe()}}class ie extends M{notifyNext(e){this.destination.next(e)}notifyError(e){this.destination.error(e)}notifyComplete(){this.destination.complete()}}function ae(e,t){if(t.closed)return;if(e instanceof U)return e.subscribe(t);let n;try{n=ne(e)(t)}catch(r){t.error(r)}return n}function ue(e,t,n=Number.POSITIVE_INFINITY){return"function"==typeof t?r=>r.pipe(ue((n,r)=>se(e(n,r)).pipe(X((e,s)=>t(n,e,r,s))),n)):("number"==typeof t&&(n=t),t=>t.lift(new le(e,n)))}class le{constructor(e,t=Number.POSITIVE_INFINITY){this.project=e,this.concurrent=t}call(e,t){return t.subscribe(new ce(e,this.project,this.concurrent))}}class ce extends ie{constructor(e,t,n=Number.POSITIVE_INFINITY){super(e),this.project=t,this.concurrent=n,this.hasCompleted=!1,this.buffer=[],this.active=0,this.index=0}_next(e){this.active<this.concurrent?this._tryNext(e):this.buffer.push(e)}_tryNext(e){let t;const n=this.index++;try{t=this.project(e,n)}catch(r){return void this.destination.error(r)}this.active++,this._innerSub(t)}_innerSub(e){const t=new oe(this),n=this.destination;n.add(t);const r=ae(e,t);r!==t&&n.add(r)}_complete(){this.hasCompleted=!0,0===this.active&&0===this.buffer.length&&this.destination.complete(),this.unsubscribe()}notifyNext(e){this.destination.next(e)}notifyComplete(){const e=this.buffer;this.active--,e.length>0?this._next(e.shift()):0===this.active&&this.hasCompleted&&this.destination.complete()}}const he=ue;function de(e=Number.POSITIVE_INFINITY){return ue(V,e)}function pe(e,t){return t?re(e,t):new U(Z(e))}function fe(){return function(e){return e.lift(new me(e))}}class me{constructor(e){this.connectable=e}call(e,t){const{connectable:n}=this;n._refCount++;const r=new ge(e,n),s=t.subscribe(r);return r.closed||(r.connection=n.connect()),s}}class ge extends M{constructor(e,t){super(e),this.connectable=t}_unsubscribe(){const{connectable:e}=this;if(!e)return void(this.connection=null);this.connectable=null;const t=e._refCount;if(t<=0)return void(this.connection=null);if(e._refCount=t-1,t>1)return void(this.connection=null);const{connection:n}=this,r=e._connection;this.connection=null,!r||n&&r!==n||r.unsubscribe()}}class ye extends U{constructor(e,t){super(),this.source=e,this.subjectFactory=t,this._refCount=0,this._isComplete=!1}_subscribe(e){return this.getSubject().subscribe(e)}getSubject(){const e=this._subject;return e&&!e.isStopped||(this._subject=this.subjectFactory()),this._subject}connect(){let e=this._connection;return e||(this._isComplete=!1,e=this._connection=new F,e.add(this.source.subscribe(new be(this.getSubject(),this))),e.closed&&(this._connection=null,e=F.EMPTY)),e}refCount(){return fe()(this)}}const xe=(()=>{const e=ye.prototype;return{operator:{value:null},_refCount:{value:0,writable:!0},_subject:{value:null,writable:!0},_connection:{value:null,writable:!0},_subscribe:{value:e._subscribe},_isComplete:{value:e._isComplete,writable:!0},getSubject:{value:e.getSubject},connect:{value:e.connect},refCount:{value:e.refCount}}})();class be extends H{constructor(e,t){super(e),this.connectable=t}_error(e){this._unsubscribe(),super._error(e)}_complete(){this.connectable._isComplete=!0,this._unsubscribe(),super._complete()}_unsubscribe(){const e=this.connectable;if(e){this.connectable=null;const t=e._connection;e._refCount=0,e._subject=null,e._connection=null,t&&t.unsubscribe()}}}function ve(){return new G}function we(e){for(let t in e)if(e[t]===we)return t;throw Error("Could not find renamed property on target object.")}function Ce(e){if("string"==typeof e)return e;if(Array.isArray(e))return"["+e.map(Ce).join(", ")+"]";if(null==e)return""+e;if(e.overriddenName)return`${e.overriddenName}`;if(e.name)return`${e.name}`;const t=e.toString();if(null==t)return""+t;const n=t.indexOf("\n");return-1===n?t:t.substring(0,n)}function _e(e,t){return null==e||""===e?null===t?"":t:null==t||""===t?e:e+" "+t}const ke=we({__forward_ref__:we});function Ee(e){return e.__forward_ref__=Ee,e.toString=function(){return Ce(this())},e}function Se(e){return"function"==typeof(t=e)&&t.hasOwnProperty(ke)&&t.__forward_ref__===Ee?e():e;var t}class Te extends Error{constructor(e,t){super(function(e,t){return`${e?`NG0${e}: `:""}${t}`}(e,t)),this.code=e}}function Ie(e){return"string"==typeof e?e:null==e?"":String(e)}function Ne(e){return"function"==typeof e?e.name||e.toString():"object"==typeof e&&null!=e&&"function"==typeof e.type?e.type.name||e.type.toString():Ie(e)}function $e(e,t){const n=t?` in ${t}`:"";throw new Te("201",`No provider for ${Ne(e)} found${n}`)}function Re(e){return{token:e.token,providedIn:e.providedIn||null,factory:e.factory,value:void 0}}function Ae(e){return{providers:e.providers||[],imports:e.imports||[]}}function Oe(e){return Fe(e,Pe)||Fe(e,Le)}function Fe(e,t){return e.hasOwnProperty(t)?e[t]:null}function De(e){return e&&(e.hasOwnProperty(Me)||e.hasOwnProperty(Be))?e[Me]:null}const Pe=we({"\u0275prov":we}),Me=we({"\u0275inj":we}),Le=we({ngInjectableDef:we}),Be=we({ngInjectorDef:we});var Ve=(()=>((Ve=Ve||{})[Ve.Default=0]="Default",Ve[Ve.Host=1]="Host",Ve[Ve.Self=2]="Self",Ve[Ve.SkipSelf=4]="SkipSelf",Ve[Ve.Optional=8]="Optional",Ve))();let Ue;function ze(e){const t=Ue;return Ue=e,t}function We(e,t,n){const r=Oe(e);return r&&"root"==r.providedIn?void 0===r.value?r.value=r.factory():r.value:n&Ve.Optional?null:void 0!==t?t:void $e(Ce(e),"Injector")}function je(e){return{toString:e}.toString()}var He=(()=>((He=He||{})[He.OnPush=0]="OnPush",He[He.Default=1]="Default",He))(),Ge=(()=>((Ge=Ge||{})[Ge.Emulated=0]="Emulated",Ge[Ge.None=2]="None",Ge[Ge.ShadowDom=3]="ShadowDom",Ge))();const qe="undefined"!=typeof globalThis&&globalThis,Ke="undefined"!=typeof window&&window,Xe="undefined"!=typeof self&&"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&self,Ye="undefined"!=typeof global&&global,Qe=qe||Ye||Ke||Xe,Ze={},Je=[],et=we({"\u0275cmp":we}),tt=we({"\u0275dir":we}),nt=we({"\u0275pipe":we}),rt=we({"\u0275mod":we}),st=we({"\u0275loc":we}),ot=we({"\u0275fac":we}),it=we({__NG_ELEMENT_ID__:we});let at=0;function ut(e){return je(()=>{const t={},n={type:e.type,providersResolver:null,decls:e.decls,vars:e.vars,factory:null,template:e.template||null,consts:e.consts||null,ngContentSelectors:e.ngContentSelectors,hostBindings:e.hostBindings||null,hostVars:e.hostVars||0,hostAttrs:e.hostAttrs||null,contentQueries:e.contentQueries||null,declaredInputs:t,inputs:null,outputs:null,exportAs:e.exportAs||null,onPush:e.changeDetection===He.OnPush,directiveDefs:null,pipeDefs:null,selectors:e.selectors||Je,viewQuery:e.viewQuery||null,features:e.features||null,data:e.data||{},encapsulation:e.encapsulation||Ge.Emulated,id:"c",styles:e.styles||Je,_:null,setInput:null,schemas:e.schemas||null,tView:null},r=e.directives,s=e.features,o=e.pipes;return n.id+=at++,n.inputs=pt(e.inputs,t),n.outputs=pt(e.outputs),s&&s.forEach(e=>e(n)),n.directiveDefs=r?()=>("function"==typeof r?r():r).map(lt):null,n.pipeDefs=o?()=>("function"==typeof o?o():o).map(ct):null,n})}function lt(e){return mt(e)||function(e){return e[tt]||null}(e)}function ct(e){return function(e){return e[nt]||null}(e)}const ht={};function dt(e){return je(()=>{const t={type:e.type,bootstrap:e.bootstrap||Je,declarations:e.declarations||Je,imports:e.imports||Je,exports:e.exports||Je,transitiveCompileScopes:null,schemas:e.schemas||null,id:e.id||null};return null!=e.id&&(ht[e.id]=e.type),t})}function pt(e,t){if(null==e)return Ze;const n={};for(const r in e)if(e.hasOwnProperty(r)){let s=e[r],o=s;Array.isArray(s)&&(o=s[1],s=s[0]),n[s]=r,t&&(t[s]=o)}return n}const ft=ut;function mt(e){return e[et]||null}function gt(e,t){const n=e[rt]||null;if(!n&&!0===t)throw new Error(`Type ${Ce(e)} does not have '\u0275mod' property.`);return n}const yt=20,xt=10;function bt(e){return Array.isArray(e)&&"object"==typeof e[1]}function vt(e){return Array.isArray(e)&&!0===e[1]}function wt(e){return 0!=(8&e.flags)}function Ct(e){return 2==(2&e.flags)}function _t(e){return 1==(1&e.flags)}function kt(e){return null!==e.template}function Et(e,t){return e.hasOwnProperty(ot)?e[ot]:null}class St{constructor(e,t,n){this.previousValue=e,this.currentValue=t,this.firstChange=n}isFirstChange(){return this.firstChange}}function Tt(){const e=Nt(this),t=null==e?void 0:e.current;if(t){const n=e.previous;if(n===Ze)e.previous=t;else for(let e in t)n[e]=t[e];e.current=null,this.ngOnChanges(t)}}function It(e,t,n,r){const s=Nt(e)||function(e,t){return e.__ngSimpleChanges__=t}(e,{previous:Ze,current:null}),o=s.current||(s.current={}),i=s.previous,a=this.declaredInputs[n],u=i[a];o[a]=new St(u&&u.currentValue,t,i===Ze),e[r]=t}function Nt(e){return e.__ngSimpleChanges__||null}let $t;function Rt(e){return!!e.listen}const At={createRenderer:(e,t)=>void 0!==$t?$t:"undefined"!=typeof document?document:void 0};function Ot(e){for(;Array.isArray(e);)e=e[0];return e}function Ft(e,t){return Ot(t[e])}function Dt(e,t){return Ot(t[e.index])}function Pt(e,t){return e.data[t]}function Mt(e,t){const n=t[e];return bt(n)?n:n[0]}function Lt(e){return 4==(4&e[2])}function Bt(e){return 128==(128&e[2])}function Vt(e,t){return null==t?null:e[t]}function Ut(e){e[18]=0}function zt(e,t){e[5]+=t;let n=e,r=e[3];for(;null!==r&&(1===t&&1===n[5]||-1===t&&0===n[5]);)r[5]+=t,n=r,r=r[3]}const Wt={lFrame:ln(null),bindingsEnabled:!0,isInCheckNoChangesMode:!1};function jt(){return Wt.bindingsEnabled}function Ht(){return Wt.lFrame.lView}function Gt(){return Wt.lFrame.tView}function qt(){let e=Kt();for(;null!==e&&64===e.type;)e=e.parent;return e}function Kt(){return Wt.lFrame.currentTNode}function Xt(e,t){const n=Wt.lFrame;n.currentTNode=e,n.isParent=t}function Yt(){return Wt.lFrame.isParent}function Qt(){return Wt.isInCheckNoChangesMode}function Zt(e){Wt.isInCheckNoChangesMode=e}function Jt(e){const t=Wt.lFrame,n=t.bindingIndex;return t.bindingIndex=t.bindingIndex+e,n}function en(e,t){const n=Wt.lFrame;n.bindingIndex=n.bindingRootIndex=e,tn(t)}function tn(e){Wt.lFrame.currentDirectiveIndex=e}function nn(){return Wt.lFrame.currentQueryIndex}function rn(e){Wt.lFrame.currentQueryIndex=e}function sn(e){const t=e[1];return 2===t.type?t.declTNode:1===t.type?e[6]:null}function on(e,t,n){if(n&Ve.SkipSelf){let r=t,s=e;for(;r=r.parent,!(null!==r||n&Ve.Host||(r=sn(s),null===r)||(s=s[15],10&r.type)););if(null===r)return!1;t=r,e=s}const r=Wt.lFrame=un();return r.currentTNode=t,r.lView=e,!0}function an(e){const t=un(),n=e[1];Wt.lFrame=t,t.currentTNode=n.firstChild,t.lView=e,t.tView=n,t.contextLView=e,t.bindingIndex=n.bindingStartIndex,t.inI18n=!1}function un(){const e=Wt.lFrame,t=null===e?null:e.child;return null===t?ln(e):t}function ln(e){const t={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent:e,child:null,inI18n:!1};return null!==e&&(e.child=t),t}function cn(){const e=Wt.lFrame;return Wt.lFrame=e.parent,e.currentTNode=null,e.lView=null,e}const hn=cn;function dn(){const e=cn();e.isParent=!0,e.tView=null,e.selectedIndex=-1,e.contextLView=null,e.elementDepthCount=0,e.currentDirectiveIndex=-1,e.currentNamespace=null,e.bindingRootIndex=-1,e.bindingIndex=-1,e.currentQueryIndex=0}function pn(){return Wt.lFrame.selectedIndex}function fn(e){Wt.lFrame.selectedIndex=e}function mn(e,t){for(let n=t.directiveStart,r=t.directiveEnd;n<r;n++){const t=e.data[n].type.prototype,{ngAfterContentInit:r,ngAfterContentChecked:s,ngAfterViewInit:o,ngAfterViewChecked:i,ngOnDestroy:a}=t;r&&(e.contentHooks||(e.contentHooks=[])).push(-n,r),s&&((e.contentHooks||(e.contentHooks=[])).push(n,s),(e.contentCheckHooks||(e.contentCheckHooks=[])).push(n,s)),o&&(e.viewHooks||(e.viewHooks=[])).push(-n,o),i&&((e.viewHooks||(e.viewHooks=[])).push(n,i),(e.viewCheckHooks||(e.viewCheckHooks=[])).push(n,i)),null!=a&&(e.destroyHooks||(e.destroyHooks=[])).push(n,a)}}function gn(e,t,n){bn(e,t,3,n)}function yn(e,t,n,r){(3&e[2])===n&&bn(e,t,n,r)}function xn(e,t){let n=e[2];(3&n)===t&&(n&=2047,n+=1,e[2]=n)}function bn(e,t,n,r){const s=null!=r?r:-1,o=t.length-1;let i=0;for(let a=void 0!==r?65535&e[18]:0;a<o;a++)if("number"==typeof t[a+1]){if(i=t[a],null!=r&&i>=r)break}else t[a]<0&&(e[18]+=65536),(i<s||-1==s)&&(vn(e,n,t,a),e[18]=(4294901760&e[18])+a+2),a++}function vn(e,t,n,r){const s=n[r]<0,o=n[r+1],i=e[s?-n[r]:n[r]];if(s){if(e[2]>>11<e[18]>>16&&(3&e[2])===t){e[2]+=2048;try{o.call(i)}finally{}}}else try{o.call(i)}finally{}}const wn=-1;class Cn{constructor(e,t,n){this.factory=e,this.resolving=!1,this.canSeeViewProviders=t,this.injectImpl=n}}function _n(e,t,n){const r=Rt(e);let s=0;for(;s<n.length;){const o=n[s];if("number"==typeof o){if(0!==o)break;s++;const i=n[s++],a=n[s++],u=n[s++];r?e.setAttribute(t,a,u,i):t.setAttributeNS(i,a,u)}else{const i=o,a=n[++s];En(i)?r&&e.setProperty(t,i,a):r?e.setAttribute(t,i,a):t.setAttribute(i,a),s++}}return s}function kn(e){return 3===e||4===e||6===e}function En(e){return 64===e.charCodeAt(0)}function Sn(e,t){if(null===t||0===t.length);else if(null===e||0===e.length)e=t.slice();else{let n=-1;for(let r=0;r<t.length;r++){const s=t[r];"number"==typeof s?n=s:0===n||Tn(e,n,s,null,-1===n||2===n?t[++r]:null)}}return e}function Tn(e,t,n,r,s){let o=0,i=e.length;if(-1===t)i=-1;else for(;o<e.length;){const n=e[o++];if("number"==typeof n){if(n===t){i=-1;break}if(n>t){i=o-1;break}}}for(;o<e.length;){const t=e[o];if("number"==typeof t)break;if(t===n){if(null===r)return void(null!==s&&(e[o+1]=s));if(r===e[o+1])return void(e[o+2]=s)}o++,null!==r&&o++,null!==s&&o++}-1!==i&&(e.splice(i,0,t),o=i+1),e.splice(o++,0,n),null!==r&&e.splice(o++,0,r),null!==s&&e.splice(o++,0,s)}function In(e){return e!==wn}function Nn(e){return 32767&e}function $n(e,t){let n=e>>16,r=t;for(;n>0;)r=r[15],n--;return r}let Rn=!0;function An(e){const t=Rn;return Rn=e,t}let On=0;function Fn(e,t){const n=Pn(e,t);if(-1!==n)return n;const r=t[1];r.firstCreatePass&&(e.injectorIndex=t.length,Dn(r.data,e),Dn(t,null),Dn(r.blueprint,null));const s=Mn(e,t),o=e.injectorIndex;if(In(s)){const e=Nn(s),n=$n(s,t),r=n[1].data;for(let s=0;s<8;s++)t[o+s]=n[e+s]|r[e+s]}return t[o+8]=s,o}function Dn(e,t){e.push(0,0,0,0,0,0,0,0,t)}function Pn(e,t){return-1===e.injectorIndex||e.parent&&e.parent.injectorIndex===e.injectorIndex||null===t[e.injectorIndex+8]?-1:e.injectorIndex}function Mn(e,t){if(e.parent&&-1!==e.parent.injectorIndex)return e.parent.injectorIndex;let n=0,r=null,s=t;for(;null!==s;){const e=s[1],t=e.type;if(r=2===t?e.declTNode:1===t?s[6]:null,null===r)return wn;if(n++,s=s[15],-1!==r.injectorIndex)return r.injectorIndex|n<<16}return wn}function Ln(e,t,n){!function(e,t,n){let r;"string"==typeof n?r=n.charCodeAt(0)||0:n.hasOwnProperty(it)&&(r=n[it]),null==r&&(r=n[it]=On++);const s=255&r;t.data[e+(s>>5)]|=1<<s}(e,t,n)}function Bn(e,t,n){if(n&Ve.Optional)return e;$e(t,"NodeInjector")}function Vn(e,t,n,r){if(n&Ve.Optional&&void 0===r&&(r=null),0==(n&(Ve.Self|Ve.Host))){const s=e[9],o=ze(void 0);try{return s?s.get(t,r,n&Ve.Optional):We(t,r,n&Ve.Optional)}finally{ze(o)}}return Bn(r,t,n)}function Un(e,t,n,r=Ve.Default,s){if(null!==e){const o=function(e){if("string"==typeof e)return e.charCodeAt(0)||0;const t=e.hasOwnProperty(it)?e[it]:void 0;return"number"==typeof t?t>=0?255&t:Wn:t}(n);if("function"==typeof o){if(!on(t,e,r))return r&Ve.Host?Bn(s,n,r):Vn(t,n,r,s);try{const e=o(r);if(null!=e||r&Ve.Optional)return e;$e(n)}finally{hn()}}else if("number"==typeof o){let s=null,i=Pn(e,t),a=wn,u=r&Ve.Host?t[16][6]:null;for((-1===i||r&Ve.SkipSelf)&&(a=-1===i?Mn(e,t):t[i+8],a!==wn&&Kn(r,!1)?(s=t[1],i=Nn(a),t=$n(a,t)):i=-1);-1!==i;){const e=t[1];if(qn(o,i,e.data)){const e=jn(i,t,n,s,r,u);if(e!==zn)return e}a=t[i+8],a!==wn&&Kn(r,t[1].data[i+8]===u)&&qn(o,i,t)?(s=e,i=Nn(a),t=$n(a,t)):i=-1}}}return Vn(t,n,r,s)}const zn={};function Wn(){return new Xn(qt(),Ht())}function jn(e,t,n,r,s,o){const i=t[1],a=i.data[e+8],u=Hn(a,i,n,null==r?Ct(a)&&Rn:r!=i&&0!=(3&a.type),s&Ve.Host&&o===a);return null!==u?Gn(t,i,u,a):zn}function Hn(e,t,n,r,s){const o=e.providerIndexes,i=t.data,a=1048575&o,u=e.directiveStart,l=o>>20,c=s?a+l:e.directiveEnd;for(let h=r?a:a+l;h<c;h++){const e=i[h];if(h<u&&n===e||h>=u&&e.type===n)return h}if(s){const e=i[u];if(e&&kt(e)&&e.type===n)return u}return null}function Gn(e,t,n,r){let s=e[n];const o=t.data;if(s instanceof Cn){const i=s;i.resolving&&function(e,t){throw new Te("200",`Circular dependency in DI detected for ${e}`)}(Ne(o[n]));const a=An(i.canSeeViewProviders);i.resolving=!0;const u=i.injectImpl?ze(i.injectImpl):null;on(e,r,Ve.Default);try{s=e[n]=i.factory(void 0,o,e,r),t.firstCreatePass&&n>=r.directiveStart&&function(e,t,n){const{ngOnChanges:r,ngOnInit:s,ngDoCheck:o}=t.type.prototype;if(r){const r=((i=t).type.prototype.ngOnChanges&&(i.setInput=It),Tt);(n.preOrderHooks||(n.preOrderHooks=[])).push(e,r),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(e,r)}var i;s&&(n.preOrderHooks||(n.preOrderHooks=[])).push(0-e,s),o&&((n.preOrderHooks||(n.preOrderHooks=[])).push(e,o),(n.preOrderCheckHooks||(n.preOrderCheckHooks=[])).push(e,o))}(n,o[n],t)}finally{null!==u&&ze(u),An(a),i.resolving=!1,hn()}}return s}function qn(e,t,n){return!!(n[t+(e>>5)]&1<<e)}function Kn(e,t){return!(e&Ve.Self||e&Ve.Host&&t)}class Xn{constructor(e,t){this._tNode=e,this._lView=t}get(e,t){return Un(this._tNode,this._lView,e,void 0,t)}}const Yn="__parameters__";function Qn(e,t,n){return je(()=>{const r=function(e){return function(...t){if(e){const n=e(...t);for(const e in n)this[e]=n[e]}}}(t);function s(...e){if(this instanceof s)return r.apply(this,e),this;const t=new s(...e);return n.annotation=t,n;function n(e,n,r){const s=e.hasOwnProperty(Yn)?e[Yn]:Object.defineProperty(e,Yn,{value:[]})[Yn];for(;s.length<=r;)s.push(null);return(s[r]=s[r]||[]).push(t),e}}return n&&(s.prototype=Object.create(n.prototype)),s.prototype.ngMetadataName=e,s.annotationCls=s,s})}class Zn{constructor(e,t){this._desc=e,this.ngMetadataName="InjectionToken",this.\u0275prov=void 0,"number"==typeof t?this.__NG_ELEMENT_ID__=t:void 0!==t&&(this.\u0275prov=Re({token:this,providedIn:t.providedIn||"root",factory:t.factory}))}toString(){return`InjectionToken ${this._desc}`}}const Jn=new Zn("AnalyzeForEntryComponents"),er=Function;function tr(e,t){void 0===t&&(t=e);for(let n=0;n<e.length;n++){let r=e[n];Array.isArray(r)?(t===e&&(t=e.slice(0,n)),tr(r,t)):t!==e&&t.push(r)}return t}function nr(e,t){e.forEach(e=>Array.isArray(e)?nr(e,t):t(e))}function rr(e,t,n){t>=e.length?e.push(n):e.splice(t,0,n)}function sr(e,t){return t>=e.length-1?e.pop():e.splice(t,1)[0]}function or(e,t,n){let r=ar(e,t);return r>=0?e[1|r]=n:(r=~r,function(e,t,n,r){let s=e.length;if(s==t)e.push(n,r);else if(1===s)e.push(r,e[0]),e[0]=n;else{for(s--,e.push(e[s-1],e[s]);s>t;)e[s]=e[s-2],s--;e[t]=n,e[t+1]=r}}(e,r,t,n)),r}function ir(e,t){const n=ar(e,t);if(n>=0)return e[1|n]}function ar(e,t){return function(e,t,n){let r=0,s=e.length>>1;for(;s!==r;){const n=r+(s-r>>1),o=e[n<<1];if(t===o)return n<<1;o>t?s=n:r=n+1}return~(s<<1)}(e,t)}const ur={},lr=/\n/gm,cr="__source",hr=we({provide:String,useValue:we});let dr;function pr(e){const t=dr;return dr=e,t}function fr(e,t=Ve.Default){if(void 0===dr)throw new Error("inject() must be called from an injection context");return null===dr?We(e,void 0,t):dr.get(e,t&Ve.Optional?null:void 0,t)}function mr(e,t=Ve.Default){return(Ue||fr)(Se(e),t)}function gr(e){const t=[];for(let n=0;n<e.length;n++){const r=Se(e[n]);if(Array.isArray(r)){if(0===r.length)throw new Error("Arguments array must have arguments.");let e,n=Ve.Default;for(let t=0;t<r.length;t++){const s=r[t],o=s.__NG_DI_FLAG__;"number"==typeof o?-1===o?e=s.token:n|=o:e=s}t.push(mr(e,n))}else t.push(mr(r))}return t}function yr(e,t){return e.__NG_DI_FLAG__=t,e.prototype.__NG_DI_FLAG__=t,e}const xr=yr(Qn("Inject",e=>({token:e})),-1),br=yr(Qn("Optional"),8),vr=yr(Qn("SkipSelf"),4);function wr(e,t){e.__ngContext__=t}function Cr(e){const t=function(e){return e.__ngContext__||null}(e);return t?Array.isArray(t)?t:t.lView:null}function _r(e){return e.ngDebugContext}function kr(e){return e.ngOriginalError}function Er(e,...t){e.error(...t)}class Sr{constructor(){this._console=console}handleError(e){const t=this._findOriginalError(e),n=this._findContext(e),r=function(e){return e.ngErrorLogger||Er}(e);r(this._console,"ERROR",e),t&&r(this._console,"ORIGINAL ERROR",t),n&&r(this._console,"ERROR CONTEXT",n)}_findContext(e){return e?_r(e)?_r(e):this._findContext(kr(e)):null}_findOriginalError(e){let t=kr(e);for(;t&&kr(t);)t=kr(t);return t}}const Tr=(()=>("undefined"!=typeof requestAnimationFrame&&requestAnimationFrame||setTimeout).bind(Qe))();function Ir(e){return e instanceof Function?e():e}var Nr=(()=>((Nr=Nr||{})[Nr.Important=1]="Important",Nr[Nr.DashCase=2]="DashCase",Nr))();function $r(e,t){return(void 0)(e,t)}function Rr(e){const t=e[3];return vt(t)?t[3]:t}function Ar(e){return Fr(e[13])}function Or(e){return Fr(e[4])}function Fr(e){for(;null!==e&&!vt(e);)e=e[4];return e}function Dr(e,t,n,r,s){if(null!=r){let o,i=!1;vt(r)?o=r:bt(r)&&(i=!0,r=r[0]);const a=Ot(r);0===e&&null!==n?null==s?zr(t,n,a):Ur(t,n,a,s||null,!0):1===e&&null!==n?Ur(t,n,a,s||null,!0):2===e?function(e,t,n){const r=jr(e,t);r&&function(e,t,n,r){Rt(e)?e.removeChild(t,n,r):t.removeChild(n)}(e,r,t,n)}(t,a,i):3===e&&t.destroyNode(a),null!=o&&function(e,t,n,r,s){const o=n[7];o!==Ot(n)&&Dr(t,e,r,o,s);for(let i=xt;i<n.length;i++){const s=n[i];Yr(s[1],s,e,t,r,o)}}(t,e,o,n,s)}}function Pr(e,t,n){return Rt(e)?e.createElement(t,n):null===n?e.createElement(t):e.createElementNS(n,t)}function Mr(e,t){const n=e[9],r=n.indexOf(t),s=t[3];1024&t[2]&&(t[2]&=-1025,zt(s,-1)),n.splice(r,1)}function Lr(e,t){if(e.length<=xt)return;const n=xt+t,r=e[n];if(r){const o=r[17];null!==o&&o!==e&&Mr(o,r),t>0&&(e[n-1][4]=r[4]);const i=sr(e,xt+t);Yr(r[1],s=r,s[11],2,null,null),s[0]=null,s[6]=null;const a=i[19];null!==a&&a.detachView(i[1]),r[3]=null,r[4]=null,r[2]&=-129}var s;return r}function Br(e,t){if(!(256&t[2])){const n=t[11];Rt(n)&&n.destroyNode&&Yr(e,t,n,3,null,null),function(e){let t=e[13];if(!t)return Vr(e[1],e);for(;t;){let n=null;if(bt(t))n=t[13];else{const e=t[10];e&&(n=e)}if(!n){for(;t&&!t[4]&&t!==e;)bt(t)&&Vr(t[1],t),t=t[3];null===t&&(t=e),bt(t)&&Vr(t[1],t),n=t&&t[4]}t=n}}(t)}}function Vr(e,t){if(!(256&t[2])){t[2]&=-129,t[2]|=256,function(e,t){let n;if(null!=e&&null!=(n=e.destroyHooks))for(let r=0;r<n.length;r+=2){const e=t[n[r]];if(!(e instanceof Cn)){const t=n[r+1];if(Array.isArray(t))for(let n=0;n<t.length;n+=2){const r=e[t[n]],s=t[n+1];try{s.call(r)}finally{}}else try{t.call(e)}finally{}}}}(e,t),function(e,t){const n=e.cleanup,r=t[7];let s=-1;if(null!==n)for(let o=0;o<n.length-1;o+=2)if("string"==typeof n[o]){const e=n[o+1],i="function"==typeof e?e(t):Ot(t[e]),a=r[s=n[o+2]],u=n[o+3];"boolean"==typeof u?i.removeEventListener(n[o],a,u):u>=0?r[s=u]():r[s=-u].unsubscribe(),o+=2}else{const e=r[s=n[o+1]];n[o].call(e)}if(null!==r){for(let e=s+1;e<r.length;e++)(0,r[e])();t[7]=null}}(e,t),1===t[1].type&&Rt(t[11])&&t[11].destroy();const n=t[17];if(null!==n&&vt(t[3])){n!==t[3]&&Mr(n,t);const r=t[19];null!==r&&r.detachView(e)}}}function Ur(e,t,n,r,s){Rt(e)?e.insertBefore(t,n,r,s):t.insertBefore(n,r,s)}function zr(e,t,n){Rt(e)?e.appendChild(t,n):t.appendChild(n)}function Wr(e,t,n,r,s){null!==r?Ur(e,t,n,r,s):zr(e,t,n)}function jr(e,t){return Rt(e)?e.parentNode(t):t.parentNode}function Hr(e,t,n,r){const s=function(e,t,n){return function(e,t,n){let r=t;for(;null!==r&&40&r.type;)r=(t=r).parent;if(null===r)return n[0];if(2&r.flags){const t=e.data[r.directiveStart].encapsulation;if(t===Ge.None||t===Ge.Emulated)return null}return Dt(r,n)}(e,t.parent,n)}(e,r,t),o=t[11],i=function(e,t,n){return function(e,t,n){return 40&e.type?Dt(e,n):null}(e,0,n)}(r.parent||t[6],0,t);if(null!=s)if(Array.isArray(n))for(let a=0;a<n.length;a++)Wr(o,s,n[a],i,!1);else Wr(o,s,n,i,!1)}function Gr(e,t){if(null!==t){const n=t.type;if(3&n)return Dt(t,e);if(4&n)return Kr(-1,e[t.index]);if(8&n){const n=t.child;if(null!==n)return Gr(e,n);{const n=e[t.index];return vt(n)?Kr(-1,n):Ot(n)}}if(32&n)return $r(t,e)()||Ot(e[t.index]);{const n=qr(e,t);return null!==n?Array.isArray(n)?n[0]:Gr(Rr(e[16]),n):Gr(e,t.next)}}return null}function qr(e,t){return null!==t?e[16][6].projection[t.projection]:null}function Kr(e,t){const n=xt+e+1;if(n<t.length){const e=t[n],r=e[1].firstChild;if(null!==r)return Gr(e,r)}return t[7]}function Xr(e,t,n,r,s,o,i){for(;null!=n;){const a=r[n.index],u=n.type;if(i&&0===t&&(a&&wr(Ot(a),r),n.flags|=4),64!=(64&n.flags))if(8&u)Xr(e,t,n.child,r,s,o,!1),Dr(t,e,s,a,o);else if(32&u){const i=$r(n,r);let u;for(;u=i();)Dr(t,e,s,u,o);Dr(t,e,s,a,o)}else 16&u?Qr(e,t,r,n,s,o):Dr(t,e,s,a,o);n=i?n.projectionNext:n.next}}function Yr(e,t,n,r,s,o){Xr(n,r,e.firstChild,t,s,o,!1)}function Qr(e,t,n,r,s,o){const i=n[16],a=i[6].projection[r.projection];if(Array.isArray(a))for(let u=0;u<a.length;u++)Dr(t,e,s,a[u],o);else Xr(e,t,a,i[3],s,o,!0)}function Zr(e,t,n){Rt(e)?e.setAttribute(t,"style",n):t.style.cssText=n}function Jr(e,t,n){Rt(e)?""===n?e.removeAttribute(t,"class"):e.setAttribute(t,"class",n):t.className=n}function es(e,t,n){let r=e.length;for(;;){const s=e.indexOf(t,n);if(-1===s)return s;if(0===s||e.charCodeAt(s-1)<=32){const n=t.length;if(s+n===r||e.charCodeAt(s+n)<=32)return s}n=s+1}}const ts="ng-template";function ns(e,t,n){let r=0;for(;r<e.length;){let s=e[r++];if(n&&"class"===s){if(s=e[r],-1!==es(s.toLowerCase(),t,0))return!0}else if(1===s){for(;r<e.length&&"string"==typeof(s=e[r++]);)if(s.toLowerCase()===t)return!0;return!1}}return!1}function rs(e){return 4===e.type&&e.value!==ts}function ss(e,t,n){return t===(4!==e.type||n?e.value:ts)}function os(e,t,n){let r=4;const s=e.attrs||[],o=function(e){for(let t=0;t<e.length;t++)if(kn(e[t]))return t;return e.length}(s);let i=!1;for(let a=0;a<t.length;a++){const u=t[a];if("number"!=typeof u){if(!i)if(4&r){if(r=2|1&r,""!==u&&!ss(e,u,n)||""===u&&1===t.length){if(is(r))return!1;i=!0}}else{const l=8&r?u:t[++a];if(8&r&&null!==e.attrs){if(!ns(e.attrs,l,n)){if(is(r))return!1;i=!0}continue}const c=as(8&r?"class":u,s,rs(e),n);if(-1===c){if(is(r))return!1;i=!0;continue}if(""!==l){let e;e=c>o?"":s[c+1].toLowerCase();const t=8&r?e:null;if(t&&-1!==es(t,l,0)||2&r&&l!==e){if(is(r))return!1;i=!0}}}}else{if(!i&&!is(r)&&!is(u))return!1;if(i&&is(u))continue;i=!1,r=u|1&r}}return is(r)||i}function is(e){return 0==(1&e)}function as(e,t,n,r){if(null===t)return-1;let s=0;if(r||!n){let n=!1;for(;s<t.length;){const r=t[s];if(r===e)return s;if(3===r||6===r)n=!0;else{if(1===r||2===r){let e=t[++s];for(;"string"==typeof e;)e=t[++s];continue}if(4===r)break;if(0===r){s+=4;continue}}s+=n?1:2}return-1}return function(e,t){let n=e.indexOf(4);if(n>-1)for(n++;n<e.length;){const r=e[n];if("number"==typeof r)return-1;if(r===t)return n;n++}return-1}(t,e)}function us(e,t,n=!1){for(let r=0;r<t.length;r++)if(os(e,t[r],n))return!0;return!1}function ls(e,t){return e?":not("+t.trim()+")":t}function cs(e){let t=e[0],n=1,r=2,s="",o=!1;for(;n<e.length;){let i=e[n];if("string"==typeof i)if(2&r){const t=e[++n];s+="["+i+(t.length>0?'="'+t+'"':"")+"]"}else 8&r?s+="."+i:4&r&&(s+=" "+i);else""===s||is(i)||(t+=ls(o,s),s=""),r=i,o=o||!is(r);n++}return""!==s&&(t+=ls(o,s)),t}const hs={};function ds(e){ps(Gt(),Ht(),pn()+e,Qt())}function ps(e,t,n,r){if(!r)if(3==(3&t[2])){const r=e.preOrderCheckHooks;null!==r&&gn(t,r,n)}else{const r=e.preOrderHooks;null!==r&&yn(t,r,0,n)}fn(n)}function fs(e,t){return e<<17|t<<2}function ms(e){return e>>17&32767}function gs(e){return 2|e}function ys(e){return(131068&e)>>2}function xs(e,t){return-131069&e|t<<2}function bs(e){return 1|e}function vs(e,t){const n=e.contentQueries;if(null!==n)for(let r=0;r<n.length;r+=2){const s=n[r],o=n[r+1];if(-1!==o){const n=e.data[o];rn(s),n.contentQueries(2,t[o],o)}}}function ws(e,t,n,r,s,o,i,a,u,l){const c=t.blueprint.slice();return c[0]=s,c[2]=140|r,Ut(c),c[3]=c[15]=e,c[8]=n,c[10]=i||e&&e[10],c[11]=a||e&&e[11],c[12]=u||e&&e[12]||null,c[9]=l||e&&e[9]||null,c[6]=o,c[16]=2==t.type?e[16]:c,c}function Cs(e,t,n,r,s){let o=e.data[t];if(null===o)o=function(e,t,n,r,s){const o=Kt(),i=Yt(),a=e.data[t]=function(e,t,n,r,s,o){return{type:n,index:r,insertBeforeIndex:null,injectorIndex:t?t.injectorIndex:-1,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,propertyBindings:null,flags:0,providerIndexes:0,value:s,attrs:o,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tViews:null,next:null,projectionNext:null,child:null,parent:t,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0}}(0,i?o:o&&o.parent,n,t,r,s);return null===e.firstChild&&(e.firstChild=a),null!==o&&(i?null==o.child&&null!==a.parent&&(o.child=a):null===o.next&&(o.next=a)),a}(e,t,n,r,s),Wt.lFrame.inI18n&&(o.flags|=64);else if(64&o.type){o.type=n,o.value=r,o.attrs=s;const e=function(){const e=Wt.lFrame,t=e.currentTNode;return e.isParent?t:t.parent}();o.injectorIndex=null===e?-1:e.injectorIndex}return Xt(o,!0),o}function _s(e,t,n,r){if(0===n)return-1;const s=t.length;for(let o=0;o<n;o++)t.push(r),e.blueprint.push(r),e.data.push(null);return s}function ks(e,t,n){an(t);try{const r=e.viewQuery;null!==r&&Qs(1,r,n);const s=e.template;null!==s&&Ts(e,t,s,1,n),e.firstCreatePass&&(e.firstCreatePass=!1),e.staticContentQueries&&vs(e,t),e.staticViewQueries&&Qs(2,e.viewQuery,n);const o=e.components;null!==o&&function(e,t){for(let n=0;n<t.length;n++)qs(e,t[n])}(t,o)}catch(r){throw e.firstCreatePass&&(e.incompleteFirstPass=!0),r}finally{t[2]&=-5,dn()}}function Es(e,t,n,r){const s=t[2];if(256==(256&s))return;an(t);const o=Qt();try{Ut(t),Wt.lFrame.bindingIndex=e.bindingStartIndex,null!==n&&Ts(e,t,n,2,r);const i=3==(3&s);if(!o)if(i){const n=e.preOrderCheckHooks;null!==n&&gn(t,n,null)}else{const n=e.preOrderHooks;null!==n&&yn(t,n,0,null),xn(t,0)}if(function(e){for(let t=Ar(e);null!==t;t=Or(t)){if(!t[2])continue;const e=t[9];for(let t=0;t<e.length;t++){const n=e[t],r=n[3];0==(1024&n[2])&&zt(r,1),n[2]|=1024}}}(t),function(e){for(let t=Ar(e);null!==t;t=Or(t))for(let e=xt;e<t.length;e++){const n=t[e],r=n[1];Bt(n)&&Es(r,n,r.template,n[8])}}(t),null!==e.contentQueries&&vs(e,t),!o)if(i){const n=e.contentCheckHooks;null!==n&&gn(t,n)}else{const n=e.contentHooks;null!==n&&yn(t,n,1),xn(t,1)}!function(e,t){const n=e.hostBindingOpCodes;if(null!==n)try{for(let e=0;e<n.length;e++){const r=n[e];if(r<0)fn(~r);else{const s=r,o=n[++e],i=n[++e];en(o,s),i(2,t[s])}}}finally{fn(-1)}}(e,t);const a=e.components;null!==a&&function(e,t){for(let n=0;n<t.length;n++)Hs(e,t[n])}(t,a);const u=e.viewQuery;if(null!==u&&Qs(2,u,r),!o)if(i){const n=e.viewCheckHooks;null!==n&&gn(t,n)}else{const n=e.viewHooks;null!==n&&yn(t,n,2),xn(t,2)}!0===e.firstUpdatePass&&(e.firstUpdatePass=!1),o||(t[2]&=-73),1024&t[2]&&(t[2]&=-1025,zt(t[3],-1))}finally{dn()}}function Ss(e,t,n,r){const s=t[10],o=!Qt(),i=Lt(t);try{o&&!i&&s.begin&&s.begin(),i&&ks(e,t,r),Es(e,t,n,r)}finally{o&&!i&&s.end&&s.end()}}function Ts(e,t,n,r,s){const o=pn(),i=2&r;try{fn(-1),i&&t.length>yt&&ps(e,t,yt,Qt()),n(r,s)}finally{fn(o)}}function Is(e,t,n){jt()&&(function(e,t,n,r){const s=n.directiveStart,o=n.directiveEnd;e.firstCreatePass||Fn(n,t),wr(r,t);const i=n.initialInputs;for(let a=s;a<o;a++){const r=e.data[a],o=kt(r);o&&Us(t,n,r);const u=Gn(t,e,a,n);wr(u,t),null!==i&&zs(0,a-s,u,r,0,i),o&&(Mt(n.index,t)[8]=u)}}(e,t,n,Dt(n,t)),128==(128&n.flags)&&function(e,t,n){const r=n.directiveStart,s=n.directiveEnd,o=n.index,i=Wt.lFrame.currentDirectiveIndex;try{fn(o);for(let n=r;n<s;n++){const r=e.data[n],s=t[n];tn(n),null===r.hostBindings&&0===r.hostVars&&null===r.hostAttrs||Ps(r,s)}}finally{fn(-1),tn(i)}}(e,t,n))}function Ns(e,t,n=Dt){const r=t.localNames;if(null!==r){let s=t.index+1;for(let o=0;o<r.length;o+=2){const i=r[o+1],a=-1===i?n(t,e):e[i];e[s++]=a}}}function $s(e){const t=e.tView;return null===t||t.incompleteFirstPass?e.tView=Rs(1,null,e.template,e.decls,e.vars,e.directiveDefs,e.pipeDefs,e.viewQuery,e.schemas,e.consts):t}function Rs(e,t,n,r,s,o,i,a,u,l){const c=yt+r,h=c+s,d=function(e,t){const n=[];for(let r=0;r<t;r++)n.push(r<e?null:hs);return n}(c,h),p="function"==typeof l?l():l;return d[1]={type:e,blueprint:d,template:n,queries:null,viewQuery:a,declTNode:t,data:d.slice().fill(null,c),bindingStartIndex:c,expandoStartIndex:h,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof o?o():o,pipeRegistry:"function"==typeof i?i():i,firstChild:null,schemas:u,consts:p,incompleteFirstPass:!1}}function As(e,t,n,r){const s=(o=t)[7]||(o[7]=[]);var o;null===n?s.push(r):(s.push(n),e.firstCreatePass&&function(e){return e.cleanup||(e.cleanup=[])}(e).push(r,s.length-1))}function Os(e,t,n){for(let r in e)if(e.hasOwnProperty(r)){const s=e[r];(n=null===n?{}:n).hasOwnProperty(r)?n[r].push(t,s):n[r]=[t,s]}return n}function Fs(e,t,n,r){let s=!1;if(jt()){const o=function(e,t,n){const r=e.directiveRegistry;let s=null;if(r)for(let o=0;o<r.length;o++){const i=r[o];us(n,i.selectors,!1)&&(s||(s=[]),Ln(Fn(n,t),e,i.type),kt(i)?(Ms(e,n),s.unshift(i)):s.push(i))}return s}(e,t,n),i=null===r?null:{"":-1};if(null!==o){s=!0,Bs(n,e.data.length,o.length);for(let e=0;e<o.length;e++){const t=o[e];t.providersResolver&&t.providersResolver(t)}let r=!1,a=!1,u=_s(e,t,o.length,null);for(let s=0;s<o.length;s++){const l=o[s];n.mergedAttrs=Sn(n.mergedAttrs,l.hostAttrs),Vs(e,n,t,u,l),Ls(u,l,i),null!==l.contentQueries&&(n.flags|=8),null===l.hostBindings&&null===l.hostAttrs&&0===l.hostVars||(n.flags|=128);const c=l.type.prototype;!r&&(c.ngOnChanges||c.ngOnInit||c.ngDoCheck)&&((e.preOrderHooks||(e.preOrderHooks=[])).push(n.index),r=!0),a||!c.ngOnChanges&&!c.ngDoCheck||((e.preOrderCheckHooks||(e.preOrderCheckHooks=[])).push(n.index),a=!0),u++}!function(e,t){const n=t.directiveEnd,r=e.data,s=t.attrs,o=[];let i=null,a=null;for(let u=t.directiveStart;u<n;u++){const e=r[u],n=e.inputs,l=null===s||rs(t)?null:Ws(n,s);o.push(l),i=Os(n,u,i),a=Os(e.outputs,u,a)}null!==i&&(i.hasOwnProperty("class")&&(t.flags|=16),i.hasOwnProperty("style")&&(t.flags|=32)),t.initialInputs=o,t.inputs=i,t.outputs=a}(e,n)}i&&function(e,t,n){if(t){const r=e.localNames=[];for(let e=0;e<t.length;e+=2){const s=n[t[e+1]];if(null==s)throw new Te("301",`Export of name '${t[e+1]}' not found!`);r.push(t[e],s)}}}(n,r,i)}return n.mergedAttrs=Sn(n.mergedAttrs,n.attrs),s}function Ds(e,t,n,r,s,o){const i=o.hostBindings;if(i){let n=e.hostBindingOpCodes;null===n&&(n=e.hostBindingOpCodes=[]);const o=~t.index;(function(e){let t=e.length;for(;t>0;){const n=e[--t];if("number"==typeof n&&n<0)return n}return 0})(n)!=o&&n.push(o),n.push(r,s,i)}}function Ps(e,t){null!==e.hostBindings&&e.hostBindings(1,t)}function Ms(e,t){t.flags|=2,(e.components||(e.components=[])).push(t.index)}function Ls(e,t,n){if(n){if(t.exportAs)for(let r=0;r<t.exportAs.length;r++)n[t.exportAs[r]]=e;kt(t)&&(n[""]=e)}}function Bs(e,t,n){e.flags|=1,e.directiveStart=t,e.directiveEnd=t+n,e.providerIndexes=t}function Vs(e,t,n,r,s){e.data[r]=s;const o=s.factory||(s.factory=Et(s.type)),i=new Cn(o,kt(s),null);e.blueprint[r]=i,n[r]=i,Ds(e,t,0,r,_s(e,n,s.hostVars,hs),s)}function Us(e,t,n){const r=Dt(t,e),s=$s(n),o=e[10],i=Ks(e,ws(e,s,null,n.onPush?64:16,r,t,o,o.createRenderer(r,n),null,null));e[t.index]=i}function zs(e,t,n,r,s,o){const i=o[t];if(null!==i){const e=r.setInput;for(let t=0;t<i.length;){const s=i[t++],o=i[t++],a=i[t++];null!==e?r.setInput(n,a,s,o):n[o]=a}}}function Ws(e,t){let n=null,r=0;for(;r<t.length;){const s=t[r];if(0!==s)if(5!==s){if("number"==typeof s)break;e.hasOwnProperty(s)&&(null===n&&(n=[]),n.push(s,e[s],t[r+1])),r+=2}else r+=2;else r+=4}return n}function js(e,t,n,r){return new Array(e,!0,!1,t,null,0,r,n,null,null)}function Hs(e,t){const n=Mt(t,e);if(Bt(n)){const e=n[1];80&n[2]?Es(e,n,e.template,n[8]):n[5]>0&&Gs(n)}}function Gs(e){for(let n=Ar(e);null!==n;n=Or(n))for(let e=xt;e<n.length;e++){const t=n[e];if(1024&t[2]){const e=t[1];Es(e,t,e.template,t[8])}else t[5]>0&&Gs(t)}const t=e[1].components;if(null!==t)for(let n=0;n<t.length;n++){const r=Mt(t[n],e);Bt(r)&&r[5]>0&&Gs(r)}}function qs(e,t){const n=Mt(t,e),r=n[1];!function(e,t){for(let n=t.length;n<e.blueprint.length;n++)t.push(e.blueprint[n])}(r,n),ks(r,n,n[8])}function Ks(e,t){return e[13]?e[14][4]=t:e[13]=t,e[14]=t,t}function Xs(e,t,n){const r=t[10];r.begin&&r.begin();try{Es(e,t,e.template,n)}catch(s){throw function(e,t){const n=e[9],r=n?n.get(Sr,null):null;r&&r.handleError(t)}(t,s),s}finally{r.end&&r.end()}}function Ys(e){!function(e){for(let t=0;t<e.components.length;t++){const n=e.components[t],r=Cr(n),s=r[1];Ss(s,r,s.template,n)}}(e[8])}function Qs(e,t,n){rn(0),t(e,n)}const Zs=(()=>Promise.resolve(null))();function Js(e,t,n,r,s){for(let o=0;o<n.length;){const i=n[o++],a=n[o++],u=t[i],l=e.data[i];null!==l.setInput?l.setInput(u,s,r,a):u[a]=s}}function eo(e,t,n){let r=n?e.styles:null,s=n?e.classes:null,o=0;if(null!==t)for(let i=0;i<t.length;i++){const e=t[i];"number"==typeof e?o=e:1==o?s=_e(s,e):2==o&&(r=_e(r,e+": "+t[++i]+";"))}n?e.styles=r:e.stylesWithoutHost=r,n?e.classes=s:e.classesWithoutHost=s}const to=new Zn("INJECTOR",-1);class no{get(e,t=ur){if(t===ur){const t=new Error(`NullInjectorError: No provider for ${Ce(e)}!`);throw t.name="NullInjectorError",t}return t}}const ro=new Zn("Set Injector scope."),so={},oo={};let io;function ao(){return void 0===io&&(io=new no),io}function uo(e,t=null,n=null,r){return new lo(e,n,t||ao(),r)}class lo{constructor(e,t,n,r=null){this.parent=n,this.records=new Map,this.injectorDefTypes=new Set,this.onDestroy=new Set,this._destroyed=!1;const s=[];t&&nr(t,n=>this.processProvider(n,e,t)),nr([e],e=>this.processInjectorType(e,[],s)),this.records.set(to,ho(void 0,this));const o=this.records.get(ro);this.scope=null!=o?o.value:null,this.source=r||("object"==typeof e?null:Ce(e))}get destroyed(){return this._destroyed}destroy(){this.assertNotDestroyed(),this._destroyed=!0;try{this.onDestroy.forEach(e=>e.ngOnDestroy())}finally{this.records.clear(),this.onDestroy.clear(),this.injectorDefTypes.clear()}}get(e,t=ur,n=Ve.Default){this.assertNotDestroyed();const r=pr(this);try{if(!(n&Ve.SkipSelf)){let t=this.records.get(e);if(void 0===t){const n=("function"==typeof(s=e)||"object"==typeof s&&s instanceof Zn)&&Oe(e);t=n&&this.injectableDefInScope(n)?ho(co(e),so):null,this.records.set(e,t)}if(null!=t)return this.hydrate(e,t)}return(n&Ve.Self?ao():this.parent).get(e,t=n&Ve.Optional&&t===ur?null:t)}catch(o){if("NullInjectorError"===o.name){if((o.ngTempTokenPath=o.ngTempTokenPath||[]).unshift(Ce(e)),r)throw o;return function(e,t,n,r){const s=e.ngTempTokenPath;throw t[cr]&&s.unshift(t[cr]),e.message=function(e,t,n,r=null){e=e&&"\n"===e.charAt(0)&&"\u0275"==e.charAt(1)?e.substr(2):e;let s=Ce(t);if(Array.isArray(t))s=t.map(Ce).join(" -> ");else if("object"==typeof t){let e=[];for(let n in t)if(t.hasOwnProperty(n)){let r=t[n];e.push(n+":"+("string"==typeof r?JSON.stringify(r):Ce(r)))}s=`{${e.join(", ")}}`}return`${n}${r?"("+r+")":""}[${s}]: ${e.replace(lr,"\n  ")}`}("\n"+e.message,s,n,r),e.ngTokenPath=s,e.ngTempTokenPath=null,e}(o,e,"R3InjectorError",this.source)}throw o}finally{pr(r)}var s}_resolveInjectorDefTypes(){this.injectorDefTypes.forEach(e=>this.get(e))}toString(){const e=[];return this.records.forEach((t,n)=>e.push(Ce(n))),`R3Injector[${e.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new Error("Injector has already been destroyed.")}processInjectorType(e,t,n){if(!(e=Se(e)))return!1;let r=De(e);const s=null==r&&e.ngModule||void 0,o=void 0===s?e:s,i=-1!==n.indexOf(o);if(void 0!==s&&(r=De(s)),null==r)return!1;if(null!=r.imports&&!i){let e;n.push(o);try{nr(r.imports,r=>{this.processInjectorType(r,t,n)&&(void 0===e&&(e=[]),e.push(r))})}finally{}if(void 0!==e)for(let t=0;t<e.length;t++){const{ngModule:n,providers:r}=e[t];nr(r,e=>this.processProvider(e,n,r||Je))}}this.injectorDefTypes.add(o);const a=Et(o)||(()=>new o);this.records.set(o,ho(a,so));const u=r.providers;if(null!=u&&!i){const t=e;nr(u,e=>this.processProvider(e,t,u))}return void 0!==s&&void 0!==e.providers}processProvider(e,t,n){let r=fo(e=Se(e))?e:Se(e&&e.provide);const s=function(e,t,n){return po(e)?ho(void 0,e.useValue):ho(function(e,t,n){let r;if(fo(e)){const t=Se(e);return Et(t)||co(t)}if(po(e))r=()=>Se(e.useValue);else if((s=e)&&s.useFactory)r=()=>e.useFactory(...gr(e.deps||[]));else if(function(e){return!(!e||!e.useExisting)}(e))r=()=>mr(Se(e.useExisting));else{const t=Se(e&&(e.useClass||e.provide));if(!function(e){return!!e.deps}(e))return Et(t)||co(t);r=()=>new t(...gr(e.deps))}var s;return r}(e),so)}(e);if(fo(e)||!0!==e.multi)this.records.get(r);else{let t=this.records.get(r);t||(t=ho(void 0,so,!0),t.factory=()=>gr(t.multi),this.records.set(r,t)),r=e,t.multi.push(e)}this.records.set(r,s)}hydrate(e,t){var n;return t.value===so&&(t.value=oo,t.value=t.factory()),"object"==typeof t.value&&t.value&&null!==(n=t.value)&&"object"==typeof n&&"function"==typeof n.ngOnDestroy&&this.onDestroy.add(t.value),t.value}injectableDefInScope(e){if(!e.providedIn)return!1;const t=Se(e.providedIn);return"string"==typeof t?"any"===t||t===this.scope:this.injectorDefTypes.has(t)}}function co(e){const t=Oe(e),n=null!==t?t.factory:Et(e);if(null!==n)return n;if(e instanceof Zn)throw new Error(`Token ${Ce(e)} is missing a \u0275prov definition.`);if(e instanceof Function)return function(e){const t=e.length;if(t>0){const n=function(e,t){const n=[];for(let r=0;r<e;r++)n.push("?");return n}(t);throw new Error(`Can't resolve all parameters for ${Ce(e)}: (${n.join(", ")}).`)}const n=function(e){const t=e&&(e[Pe]||e[Le]);if(t){const n=function(e){if(e.hasOwnProperty("name"))return e.name;const t=(""+e).match(/^function\s*([^\s(]+)/);return null===t?"":t[1]}(e);return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`),t}return null}(e);return null!==n?()=>n.factory(e):()=>new e}(e);throw new Error("unreachable")}function ho(e,t,n=!1){return{factory:e,value:t,multi:n?[]:void 0}}function po(e){return null!==e&&"object"==typeof e&&hr in e}function fo(e){return"function"==typeof e}const mo=function(e,t,n){return function(e,t=null,n=null,r){const s=uo(e,t,n,r);return s._resolveInjectorDefTypes(),s}({name:n},t,e,n)};class go{static create(e,t){return Array.isArray(e)?mo(e,t,""):mo(e.providers,e.parent,e.name||"")}}function yo(e,t){mn(Cr(e)[1],qt())}go.THROW_IF_NOT_FOUND=ur,go.NULL=new no,go.\u0275prov=Re({token:go,providedIn:"any",factory:()=>mr(to)}),go.__NG_ELEMENT_ID__=-1;let xo=null;function bo(){if(!xo){const e=Qe.Symbol;if(e&&e.iterator)xo=e.iterator;else{const e=Object.getOwnPropertyNames(Map.prototype);for(let t=0;t<e.length;++t){const n=e[t];"entries"!==n&&"size"!==n&&Map.prototype[n]===Map.prototype.entries&&(xo=n)}}}return xo}function vo(e){return!!wo(e)&&(Array.isArray(e)||!(e instanceof Map)&&bo()in e)}function wo(e){return null!==e&&("function"==typeof e||"object"==typeof e)}function Co(e,t,n){return!Object.is(e[t],n)&&(e[t]=n,!0)}function _o(e,t,n,r,s,o,i,a){const u=function(e,t,n,r,s){const o=function(e,t,n,r){const s=Co(e,t,n);return Co(e,t+1,r)||s}(e,t,n,r);return Co(e,t+2,s)||o}(e,Wt.lFrame.bindingIndex,n,s,i);return Jt(3),u?t+Ie(n)+r+Ie(s)+o+Ie(i)+a:hs}function ko(e,t,n,r,s,o,i,a){const u=Ht(),l=Gt(),c=e+yt,h=l.firstCreatePass?function(e,t,n,r,s,o,i,a,u){const l=t.consts,c=Cs(t,e,4,i||null,Vt(l,a));Fs(t,n,c,Vt(l,u)),mn(t,c);const h=c.tViews=Rs(2,c,r,s,o,t.directiveRegistry,t.pipeRegistry,null,t.schemas,l);return null!==t.queries&&(t.queries.template(t,c),h.queries=t.queries.embeddedTView(c)),c}(c,l,u,t,n,r,s,o,i):l.data[c];Xt(h,!1);const d=u[11].createComment("");Hr(l,u,d,h),wr(d,u),Ks(u,u[c]=js(d,u,d,h)),_t(h)&&Is(l,u,h),null!=i&&Ns(u,h,a)}function Eo(e,t=Ve.Default){const n=Ht();return null===n?mr(e,t):Un(qt(),n,Se(e),t)}function So(e,t,n){const r=Ht();return Co(r,Wt.lFrame.bindingIndex++,t)&&function(e,t,n,r,s,o,i,a){const u=Dt(t,n);let l,c=t.inputs;var h;null!=c&&(l=c[r])?(Js(e,n,l,r,s),Ct(t)&&function(e,t){const n=Mt(t,e);16&n[2]||(n[2]|=64)}(n,t.index)):3&t.type&&(r="class"===(h=r)?"className":"for"===h?"htmlFor":"formaction"===h?"formAction":"innerHtml"===h?"innerHTML":"readonly"===h?"readOnly":"tabindex"===h?"tabIndex":h,s=null!=i?i(s,t.value||"",r):s,Rt(o)?o.setProperty(u,r,s):En(r)||(u.setProperty?u.setProperty(r,s):u[r]=s))}(Gt(),function(){const e=Wt.lFrame;return Pt(e.tView,e.selectedIndex)}(),r,e,t,r[11],n),So}function To(e,t,n,r,s){const o=s?"class":"style";Js(e,n,t.inputs[o],o,r)}function Io(e,t,n,r){const s=Ht(),o=Gt(),i=yt+e,a=s[11],u=s[i]=Pr(a,t,Wt.lFrame.currentNamespace),l=o.firstCreatePass?function(e,t,n,r,s,o,i){const a=t.consts,u=Cs(t,e,2,s,Vt(a,o));return Fs(t,n,u,Vt(a,i)),null!==u.attrs&&eo(u,u.attrs,!1),null!==u.mergedAttrs&&eo(u,u.mergedAttrs,!0),null!==t.queries&&t.queries.elementStart(t,u),u}(i,o,s,0,t,n,r):o.data[i];Xt(l,!0);const c=l.mergedAttrs;null!==c&&_n(a,u,c);const h=l.classes;null!==h&&Jr(a,u,h);const d=l.styles;null!==d&&Zr(a,u,d),64!=(64&l.flags)&&Hr(o,s,u,l),0===Wt.lFrame.elementDepthCount&&wr(u,s),Wt.lFrame.elementDepthCount++,_t(l)&&(Is(o,s,l),function(e,t,n){if(wt(t)){const r=t.directiveEnd;for(let s=t.directiveStart;s<r;s++){const t=e.data[s];t.contentQueries&&t.contentQueries(1,n[s],s)}}}(o,l,s)),null!==r&&Ns(s,l)}function No(){let e=qt();Yt()?Wt.lFrame.isParent=!1:(e=e.parent,Xt(e,!1));const t=e;Wt.lFrame.elementDepthCount--;const n=Gt();n.firstCreatePass&&(mn(n,e),wt(e)&&n.queries.elementEnd(e)),null!=t.classesWithoutHost&&function(e){return 0!=(16&e.flags)}(t)&&To(n,t,Ht(),t.classesWithoutHost,!0),null!=t.stylesWithoutHost&&function(e){return 0!=(32&e.flags)}(t)&&To(n,t,Ht(),t.stylesWithoutHost,!1)}function $o(e,t,n,r){Io(e,t,n,r),No()}function Ro(e){return!!e&&"function"==typeof e.then}const Ao=function(e){return!!e&&"function"==typeof e.subscribe};function Oo(e,t,n,r,s){const o=e[n+1],i=null===t;let a=r?ms(o):ys(o),u=!1;for(;0!==a&&(!1===u||i);){const n=e[a+1];Fo(e[a],t)&&(u=!0,e[a+1]=r?bs(n):gs(n)),a=r?ms(n):ys(n)}u&&(e[n+1]=r?gs(o):bs(o))}function Fo(e,t){return null===e||null==t||(Array.isArray(e)?e[1]:e)===t||!(!Array.isArray(e)||"string"!=typeof t)&&ar(e,t)>=0}const Do={textEnd:0,key:0,keyEnd:0,value:0,valueEnd:0};function Po(e){return e.substring(Do.key,Do.keyEnd)}function Mo(e,t){const n=Do.textEnd;return n===t?-1:(t=Do.keyEnd=function(e,t,n){for(;t<n&&e.charCodeAt(t)>32;)t++;return t}(e,Do.key=t,n),Lo(e,t,n))}function Lo(e,t,n){for(;t<n&&e.charCodeAt(t)<=32;)t++;return t}function Bo(e,t){for(let n=function(e){return function(e){Do.key=0,Do.keyEnd=0,Do.value=0,Do.valueEnd=0,Do.textEnd=e.length}(e),Mo(e,Lo(e,0,Do.textEnd))}(t);n>=0;n=Mo(t,n))or(e,Po(t),!0)}function Vo(e,t){return t>=e.expandoStartIndex}function Uo(e,t,n,r,s){let o=null;const i=n.directiveEnd;let a=n.directiveStylingLast;for(-1===a?a=n.directiveStart:a++;a<i&&(o=t[a],r=zo(r,o.hostAttrs,s),o!==e);)a++;return null!==e&&(n.directiveStylingLast=a),r}function zo(e,t,n){const r=n?1:2;let s=-1;if(null!==t)for(let o=0;o<t.length;o++){const i=t[o];"number"==typeof i?s=i:s===r&&(Array.isArray(e)||(e=void 0===e?[]:["",e]),or(e,i,!!n||t[++o]))}return void 0===e?null:e}function Wo(e,t,n,r,s,o,i,a){if(!(3&t.type))return;const u=e.data,l=u[a+1];Ho(1==(1&l)?jo(u,t,n,s,ys(l),i):void 0)||(Ho(o)||2==(2&l)&&(o=jo(u,null,n,s,a,i)),function(e,t,n,r,s){const o=Rt(e);if(t)s?o?e.addClass(n,r):n.classList.add(r):o?e.removeClass(n,r):n.classList.remove(r);else{let t=-1===r.indexOf("-")?void 0:Nr.DashCase;if(null==s)o?e.removeStyle(n,r,t):n.style.removeProperty(r);else{const i="string"==typeof s&&s.endsWith("!important");i&&(s=s.slice(0,-10),t|=Nr.Important),o?e.setStyle(n,r,s,t):n.style.setProperty(r,s,i?"important":"")}}}(r,i,Ft(pn(),n),s,o))}function jo(e,t,n,r,s,o){const i=null===t;let a;for(;s>0;){const t=e[s],o=Array.isArray(t),u=o?t[1]:t,l=null===u;let c=n[s+1];c===hs&&(c=l?Je:void 0);let h=l?ir(c,r):u===r?c:void 0;if(o&&!Ho(h)&&(h=ir(t,r)),Ho(h)&&(a=h,i))return a;const d=e[s+1];s=i?ms(d):ys(d)}if(null!==t){let e=o?t.residualClasses:t.residualStyles;null!=e&&(a=ir(e,r))}return a}function Ho(e){return void 0!==e}function Go(e,t){return 0!=(e.flags&(t?16:32))}function qo(e,t=""){const n=Ht(),r=Gt(),s=e+yt,o=r.firstCreatePass?Cs(r,s,1,t,null):r.data[s],i=n[s]=function(e,t){return Rt(e)?e.createText(t):e.createTextNode(t)}(n[11],t);Hr(r,n,i,o),Xt(o,!1)}function Ko(e,t,n,r,s,o,i){const a=Ht(),u=_o(a,e,t,n,r,s,o,i);return u!==hs&&function(e,t,n){const r=Ft(t,e);!function(e,t,n){Rt(e)?e.setValue(t,n):t.textContent=n}(e[11],r,n)}(a,pn(),u),Ko}const Xo=void 0;var Yo=["en",[["a","p"],["AM","PM"],Xo],[["AM","PM"],Xo,Xo],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],Xo,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],Xo,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",Xo,"{1} 'at' {0}",Xo],[".",",",";","%","+","-","E","\xd7","\u2030","\u221e","NaN",":"],["#,##0.###","#,##0%","\xa4#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function(e){let t=Math.floor(Math.abs(e)),n=e.toString().replace(/^[^.]*\.?/,"").length;return 1===t&&0===n?1:5}];let Qo={};function Zo(e){return e in Qo||(Qo[e]=Qe.ng&&Qe.ng.common&&Qe.ng.common.locales&&Qe.ng.common.locales[e]),Qo[e]}var Jo=(()=>((Jo=Jo||{})[Jo.LocaleId=0]="LocaleId",Jo[Jo.DayPeriodsFormat=1]="DayPeriodsFormat",Jo[Jo.DayPeriodsStandalone=2]="DayPeriodsStandalone",Jo[Jo.DaysFormat=3]="DaysFormat",Jo[Jo.DaysStandalone=4]="DaysStandalone",Jo[Jo.MonthsFormat=5]="MonthsFormat",Jo[Jo.MonthsStandalone=6]="MonthsStandalone",Jo[Jo.Eras=7]="Eras",Jo[Jo.FirstDayOfWeek=8]="FirstDayOfWeek",Jo[Jo.WeekendRange=9]="WeekendRange",Jo[Jo.DateFormat=10]="DateFormat",Jo[Jo.TimeFormat=11]="TimeFormat",Jo[Jo.DateTimeFormat=12]="DateTimeFormat",Jo[Jo.NumberSymbols=13]="NumberSymbols",Jo[Jo.NumberFormats=14]="NumberFormats",Jo[Jo.CurrencyCode=15]="CurrencyCode",Jo[Jo.CurrencySymbol=16]="CurrencySymbol",Jo[Jo.CurrencyName=17]="CurrencyName",Jo[Jo.Currencies=18]="Currencies",Jo[Jo.Directionality=19]="Directionality",Jo[Jo.PluralCase=20]="PluralCase",Jo[Jo.ExtraData=21]="ExtraData",Jo))();const ei="en-US";let ti=ei;function ni(e){var t,n;n="Expected localeId to be defined",null==(t=e)&&function(e,t,n,r){throw new Error(`ASSERTION ERROR: ${e} [Expected=> null != ${t} <=Actual]`)}(n,t),"string"==typeof e&&(ti=e.toLowerCase().replace(/_/g,"-"))}class ri{}class si{resolveComponentFactory(e){throw function(e){const t=Error(`No component factory found for ${Ce(e)}. Did you add it to @NgModule.entryComponents?`);return t.ngComponent=e,t}(e)}}class oi{}function ii(...e){}function ai(e,t){return new li(Dt(e,t))}oi.NULL=new si;const ui=function(){return ai(qt(),Ht())};let li=(()=>{class e{constructor(e){this.nativeElement=e}}return e.__NG_ELEMENT_ID__=ui,e})();function ci(e){return e instanceof li?e.nativeElement:e}class hi{}let di=(()=>{class e{}return e.\u0275prov=Re({token:e,providedIn:"root",factory:()=>null}),e})();class pi{constructor(e){this.full=e,this.major=e.split(".")[0],this.minor=e.split(".")[1],this.patch=e.split(".").slice(2).join(".")}}const fi=new pi("12.1.1");class mi{constructor(){}supports(e){return vo(e)}create(e){return new yi(e)}}const gi=(e,t)=>t;class yi{constructor(e){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=e||gi}forEachItem(e){let t;for(t=this._itHead;null!==t;t=t._next)e(t)}forEachOperation(e){let t=this._itHead,n=this._removalsHead,r=0,s=null;for(;t||n;){const o=!n||t&&t.currentIndex<wi(n,r,s)?t:n,i=wi(o,r,s),a=o.currentIndex;if(o===n)r--,n=n._nextRemoved;else if(t=t._next,null==o.previousIndex)r++;else{s||(s=[]);const e=i-r,t=a-r;if(e!=t){for(let n=0;n<e;n++){const r=n<s.length?s[n]:s[n]=0,o=r+n;t<=o&&o<e&&(s[n]=r+1)}s[o.previousIndex]=t-e}}i!==a&&e(o,i,a)}}forEachPreviousItem(e){let t;for(t=this._previousItHead;null!==t;t=t._nextPrevious)e(t)}forEachAddedItem(e){let t;for(t=this._additionsHead;null!==t;t=t._nextAdded)e(t)}forEachMovedItem(e){let t;for(t=this._movesHead;null!==t;t=t._nextMoved)e(t)}forEachRemovedItem(e){let t;for(t=this._removalsHead;null!==t;t=t._nextRemoved)e(t)}forEachIdentityChange(e){let t;for(t=this._identityChangesHead;null!==t;t=t._nextIdentityChange)e(t)}diff(e){if(null==e&&(e=[]),!vo(e))throw new Error(`Error trying to diff '${Ce(e)}'. Only arrays and iterables are allowed`);return this.check(e)?this:null}onDestroy(){}check(e){this._reset();let t,n,r,s=this._itHead,o=!1;if(Array.isArray(e)){this.length=e.length;for(let t=0;t<this.length;t++)n=e[t],r=this._trackByFn(t,n),null!==s&&Object.is(s.trackById,r)?(o&&(s=this._verifyReinsertion(s,n,r,t)),Object.is(s.item,n)||this._addIdentityChange(s,n)):(s=this._mismatch(s,n,r,t),o=!0),s=s._next}else t=0,function(e,t){if(Array.isArray(e))for(let n=0;n<e.length;n++)t(e[n]);else{const n=e[bo()]();let r;for(;!(r=n.next()).done;)t(r.value)}}(e,e=>{r=this._trackByFn(t,e),null!==s&&Object.is(s.trackById,r)?(o&&(s=this._verifyReinsertion(s,e,r,t)),Object.is(s.item,e)||this._addIdentityChange(s,e)):(s=this._mismatch(s,e,r,t),o=!0),s=s._next,t++}),this.length=t;return this._truncate(s),this.collection=e,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let e;for(e=this._previousItHead=this._itHead;null!==e;e=e._next)e._nextPrevious=e._next;for(e=this._additionsHead;null!==e;e=e._nextAdded)e.previousIndex=e.currentIndex;for(this._additionsHead=this._additionsTail=null,e=this._movesHead;null!==e;e=e._nextMoved)e.previousIndex=e.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(e,t,n,r){let s;return null===e?s=this._itTail:(s=e._prev,this._remove(e)),null!==(e=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null))?(Object.is(e.item,t)||this._addIdentityChange(e,t),this._reinsertAfter(e,s,r)):null!==(e=null===this._linkedRecords?null:this._linkedRecords.get(n,r))?(Object.is(e.item,t)||this._addIdentityChange(e,t),this._moveAfter(e,s,r)):e=this._addAfter(new xi(t,n),s,r),e}_verifyReinsertion(e,t,n,r){let s=null===this._unlinkedRecords?null:this._unlinkedRecords.get(n,null);return null!==s?e=this._reinsertAfter(s,e._prev,r):e.currentIndex!=r&&(e.currentIndex=r,this._addToMoves(e,r)),e}_truncate(e){for(;null!==e;){const t=e._next;this._addToRemovals(this._unlink(e)),e=t}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(e,t,n){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(e);const r=e._prevRemoved,s=e._nextRemoved;return null===r?this._removalsHead=s:r._nextRemoved=s,null===s?this._removalsTail=r:s._prevRemoved=r,this._insertAfter(e,t,n),this._addToMoves(e,n),e}_moveAfter(e,t,n){return this._unlink(e),this._insertAfter(e,t,n),this._addToMoves(e,n),e}_addAfter(e,t,n){return this._insertAfter(e,t,n),this._additionsTail=null===this._additionsTail?this._additionsHead=e:this._additionsTail._nextAdded=e,e}_insertAfter(e,t,n){const r=null===t?this._itHead:t._next;return e._next=r,e._prev=t,null===r?this._itTail=e:r._prev=e,null===t?this._itHead=e:t._next=e,null===this._linkedRecords&&(this._linkedRecords=new vi),this._linkedRecords.put(e),e.currentIndex=n,e}_remove(e){return this._addToRemovals(this._unlink(e))}_unlink(e){null!==this._linkedRecords&&this._linkedRecords.remove(e);const t=e._prev,n=e._next;return null===t?this._itHead=n:t._next=n,null===n?this._itTail=t:n._prev=t,e}_addToMoves(e,t){return e.previousIndex===t||(this._movesTail=null===this._movesTail?this._movesHead=e:this._movesTail._nextMoved=e),e}_addToRemovals(e){return null===this._unlinkedRecords&&(this._unlinkedRecords=new vi),this._unlinkedRecords.put(e),e.currentIndex=null,e._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=e,e._prevRemoved=null):(e._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=e),e}_addIdentityChange(e,t){return e.item=t,this._identityChangesTail=null===this._identityChangesTail?this._identityChangesHead=e:this._identityChangesTail._nextIdentityChange=e,e}}class xi{constructor(e,t){this.item=e,this.trackById=t,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class bi{constructor(){this._head=null,this._tail=null}add(e){null===this._head?(this._head=this._tail=e,e._nextDup=null,e._prevDup=null):(this._tail._nextDup=e,e._prevDup=this._tail,e._nextDup=null,this._tail=e)}get(e,t){let n;for(n=this._head;null!==n;n=n._nextDup)if((null===t||t<=n.currentIndex)&&Object.is(n.trackById,e))return n;return null}remove(e){const t=e._prevDup,n=e._nextDup;return null===t?this._head=n:t._nextDup=n,null===n?this._tail=t:n._prevDup=t,null===this._head}}class vi{constructor(){this.map=new Map}put(e){const t=e.trackById;let n=this.map.get(t);n||(n=new bi,this.map.set(t,n)),n.add(e)}get(e,t){const n=this.map.get(e);return n?n.get(e,t):null}remove(e){const t=e.trackById;return this.map.get(t).remove(e)&&this.map.delete(t),e}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function wi(e,t,n){const r=e.previousIndex;if(null===r)return r;let s=0;return n&&r<n.length&&(s=n[r]),r+t+s}class Ci{constructor(){}supports(e){return e instanceof Map||wo(e)}create(){return new _i}}class _i{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(e){let t;for(t=this._mapHead;null!==t;t=t._next)e(t)}forEachPreviousItem(e){let t;for(t=this._previousMapHead;null!==t;t=t._nextPrevious)e(t)}forEachChangedItem(e){let t;for(t=this._changesHead;null!==t;t=t._nextChanged)e(t)}forEachAddedItem(e){let t;for(t=this._additionsHead;null!==t;t=t._nextAdded)e(t)}forEachRemovedItem(e){let t;for(t=this._removalsHead;null!==t;t=t._nextRemoved)e(t)}diff(e){if(e){if(!(e instanceof Map||wo(e)))throw new Error(`Error trying to diff '${Ce(e)}'. Only maps and objects are allowed`)}else e=new Map;return this.check(e)?this:null}onDestroy(){}check(e){this._reset();let t=this._mapHead;if(this._appendAfter=null,this._forEach(e,(e,n)=>{if(t&&t.key===n)this._maybeAddToChanges(t,e),this._appendAfter=t,t=t._next;else{const r=this._getOrCreateRecordForKey(n,e);t=this._insertBeforeOrAppend(t,r)}}),t){t._prev&&(t._prev._next=null),this._removalsHead=t;for(let e=t;null!==e;e=e._nextRemoved)e===this._mapHead&&(this._mapHead=null),this._records.delete(e.key),e._nextRemoved=e._next,e.previousValue=e.currentValue,e.currentValue=null,e._prev=null,e._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(e,t){if(e){const n=e._prev;return t._next=e,t._prev=n,e._prev=t,n&&(n._next=t),e===this._mapHead&&(this._mapHead=t),this._appendAfter=e,e}return this._appendAfter?(this._appendAfter._next=t,t._prev=this._appendAfter):this._mapHead=t,this._appendAfter=t,null}_getOrCreateRecordForKey(e,t){if(this._records.has(e)){const n=this._records.get(e);this._maybeAddToChanges(n,t);const r=n._prev,s=n._next;return r&&(r._next=s),s&&(s._prev=r),n._next=null,n._prev=null,n}const n=new ki(e);return this._records.set(e,n),n.currentValue=t,this._addToAdditions(n),n}_reset(){if(this.isDirty){let e;for(this._previousMapHead=this._mapHead,e=this._previousMapHead;null!==e;e=e._next)e._nextPrevious=e._next;for(e=this._changesHead;null!==e;e=e._nextChanged)e.previousValue=e.currentValue;for(e=this._additionsHead;null!=e;e=e._nextAdded)e.previousValue=e.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(e,t){Object.is(t,e.currentValue)||(e.previousValue=e.currentValue,e.currentValue=t,this._addToChanges(e))}_addToAdditions(e){null===this._additionsHead?this._additionsHead=this._additionsTail=e:(this._additionsTail._nextAdded=e,this._additionsTail=e)}_addToChanges(e){null===this._changesHead?this._changesHead=this._changesTail=e:(this._changesTail._nextChanged=e,this._changesTail=e)}_forEach(e,t){e instanceof Map?e.forEach(t):Object.keys(e).forEach(n=>t(e[n],n))}}class ki{constructor(e){this.key=e,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function Ei(){return new Si([new mi])}let Si=(()=>{class e{constructor(e){this.factories=e}static create(t,n){if(null!=n){const e=n.factories.slice();t=t.concat(e)}return new e(t)}static extend(t){return{provide:e,useFactory:n=>e.create(t,n||Ei()),deps:[[e,new vr,new br]]}}find(e){const t=this.factories.find(t=>t.supports(e));if(null!=t)return t;throw new Error(`Cannot find a differ supporting object '${e}' of type '${n=e,n.name||typeof n}'`);var n}}return e.\u0275prov=Re({token:e,providedIn:"root",factory:Ei}),e})();function Ti(){return new Ii([new Ci])}let Ii=(()=>{class e{constructor(e){this.factories=e}static create(t,n){if(n){const e=n.factories.slice();t=t.concat(e)}return new e(t)}static extend(t){return{provide:e,useFactory:n=>e.create(t,n||Ti()),deps:[[e,new vr,new br]]}}find(e){const t=this.factories.find(t=>t.supports(e));if(t)return t;throw new Error(`Cannot find a differ supporting object '${e}'`)}}return e.\u0275prov=Re({token:e,providedIn:"root",factory:Ti}),e})();function Ni(e,t,n,r,s=!1){for(;null!==n;){const o=t[n.index];if(null!==o&&r.push(Ot(o)),vt(o))for(let e=xt;e<o.length;e++){const t=o[e],n=t[1].firstChild;null!==n&&Ni(t[1],t,n,r)}const i=n.type;if(8&i)Ni(e,t,n.child,r);else if(32&i){const e=$r(n,t);let s;for(;s=e();)r.push(s)}else if(16&i){const e=qr(t,n);if(Array.isArray(e))r.push(...e);else{const n=Rr(t[16]);Ni(n[1],n,e,r,!0)}}n=s?n.projectionNext:n.next}return r}class $i{constructor(e,t){this._lView=e,this._cdRefInjectingView=t,this._appRef=null,this._attachedToViewContainer=!1}get rootNodes(){const e=this._lView,t=e[1];return Ni(t,e,t.firstChild,[])}get context(){return this._lView[8]}set context(e){this._lView[8]=e}get destroyed(){return 256==(256&this._lView[2])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const e=this._lView[3];if(vt(e)){const t=e[8],n=t?t.indexOf(this):-1;n>-1&&(Lr(e,n),sr(t,n))}this._attachedToViewContainer=!1}Br(this._lView[1],this._lView)}onDestroy(e){As(this._lView[1],this._lView,null,e)}markForCheck(){!function(e){for(;e;){e[2]|=64;const t=Rr(e);if(0!=(512&e[2])&&!t)return e;e=t}}(this._cdRefInjectingView||this._lView)}detach(){this._lView[2]&=-129}reattach(){this._lView[2]|=128}detectChanges(){Xs(this._lView[1],this._lView,this.context)}checkNoChanges(){!function(e,t,n){Zt(!0);try{Xs(e,t,n)}finally{Zt(!1)}}(this._lView[1],this._lView,this.context)}attachToViewContainerRef(){if(this._appRef)throw new Error("This view is already attached directly to the ApplicationRef!");this._attachedToViewContainer=!0}detachFromAppRef(){var e;this._appRef=null,Yr(this._lView[1],e=this._lView,e[11],2,null,null)}attachToAppRef(e){if(this._attachedToViewContainer)throw new Error("This view is already attached to a ViewContainer!");this._appRef=e}}class Ri extends $i{constructor(e){super(e),this._view=e}detectChanges(){Ys(this._view)}checkNoChanges(){!function(e){Zt(!0);try{Ys(e)}finally{Zt(!1)}}(this._view)}get context(){return null}}const Ai=function(e){return function(e,t,n){if(Ct(e)&&!n){const n=Mt(e.index,t);return new $i(n,n)}return 47&e.type?new $i(t[16],t):null}(qt(),Ht(),16==(16&e))};let Oi=(()=>{class e{}return e.__NG_ELEMENT_ID__=Ai,e})();const Fi=[new Ci],Di=new Si([new mi]),Pi=new Ii(Fi),Mi=function(){return Ui(qt(),Ht())};let Li=(()=>{class e{}return e.__NG_ELEMENT_ID__=Mi,e})();const Bi=Li,Vi=class extends Bi{constructor(e,t,n){super(),this._declarationLView=e,this._declarationTContainer=t,this.elementRef=n}createEmbeddedView(e){const t=this._declarationTContainer.tViews,n=ws(this._declarationLView,t,e,16,null,t.declTNode,null,null,null,null);n[17]=this._declarationLView[this._declarationTContainer.index];const r=this._declarationLView[19];return null!==r&&(n[19]=r.createEmbeddedView(t)),ks(t,n,e),new $i(n)}};function Ui(e,t){return 4&e.type?new Vi(t,e,ai(e,t)):null}class zi{}class Wi{}const ji=function(){return Yi(qt(),Ht())};let Hi=(()=>{class e{}return e.__NG_ELEMENT_ID__=ji,e})();const Gi=Hi,qi=class extends Gi{constructor(e,t,n){super(),this._lContainer=e,this._hostTNode=t,this._hostLView=n}get element(){return ai(this._hostTNode,this._hostLView)}get injector(){return new Xn(this._hostTNode,this._hostLView)}get parentInjector(){const e=Mn(this._hostTNode,this._hostLView);if(In(e)){const t=$n(e,this._hostLView),n=Nn(e);return new Xn(t[1].data[n+8],t)}return new Xn(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(e){const t=Ki(this._lContainer);return null!==t&&t[e]||null}get length(){return this._lContainer.length-xt}createEmbeddedView(e,t,n){const r=e.createEmbeddedView(t||{});return this.insert(r,n),r}createComponent(e,t,n,r,s){const o=n||this.parentInjector;if(!s&&null==e.ngModule&&o){const e=o.get(zi,null);e&&(s=e)}const i=e.create(o,r,void 0,s);return this.insert(i.hostView,t),i}insert(e,t){const n=e._lView,r=n[1];if(vt(n[3])){const t=this.indexOf(e);if(-1!==t)this.detach(t);else{const t=n[3],r=new qi(t,t[6],t[3]);r.detach(r.indexOf(e))}}const s=this._adjustIndex(t),o=this._lContainer;!function(e,t,n,r){const s=xt+r,o=n.length;r>0&&(n[s-1][4]=t),r<o-xt?(t[4]=n[s],rr(n,xt+r,t)):(n.push(t),t[4]=null),t[3]=n;const i=t[17];null!==i&&n!==i&&function(e,t){const n=e[9];t[16]!==t[3][3][16]&&(e[2]=!0),null===n?e[9]=[t]:n.push(t)}(i,t);const a=t[19];null!==a&&a.insertView(e),t[2]|=128}(r,n,o,s);const i=Kr(s,o),a=n[11],u=jr(a,o[7]);return null!==u&&function(e,t,n,r,s,o){r[0]=s,r[6]=t,Yr(e,r,n,1,s,o)}(r,o[6],a,n,u,i),e.attachToViewContainerRef(),rr(Xi(o),s,e),e}move(e,t){return this.insert(e,t)}indexOf(e){const t=Ki(this._lContainer);return null!==t?t.indexOf(e):-1}remove(e){const t=this._adjustIndex(e,-1),n=Lr(this._lContainer,t);n&&(sr(Xi(this._lContainer),t),Br(n[1],n))}detach(e){const t=this._adjustIndex(e,-1),n=Lr(this._lContainer,t);return n&&null!=sr(Xi(this._lContainer),t)?new $i(n):null}_adjustIndex(e,t=0){return null==e?this.length+t:e}};function Ki(e){return e[8]}function Xi(e){return e[8]||(e[8]=[])}function Yi(e,t){let n;const r=t[e.index];if(vt(r))n=r;else{let s;if(8&e.type)s=Ot(r);else{const n=t[11];s=n.createComment("");const r=Dt(e,t);Ur(n,jr(n,r),s,function(e,t){return Rt(e)?e.nextSibling(t):t.nextSibling}(n,r),!1)}t[e.index]=n=js(r,t,s,e),Ks(t,n)}return new qi(n,e,t)}const Qi={};class Zi extends oi{constructor(e){super(),this.ngModule=e}resolveComponentFactory(e){const t=mt(e);return new ta(t,this.ngModule)}}function Ji(e){const t=[];for(let n in e)e.hasOwnProperty(n)&&t.push({propName:e[n],templateName:n});return t}const ea=new Zn("SCHEDULER_TOKEN",{providedIn:"root",factory:()=>Tr});class ta extends ri{constructor(e,t){super(),this.componentDef=e,this.ngModule=t,this.componentType=e.type,this.selector=e.selectors.map(cs).join(","),this.ngContentSelectors=e.ngContentSelectors?e.ngContentSelectors:[],this.isBoundToModule=!!t}get inputs(){return Ji(this.componentDef.inputs)}get outputs(){return Ji(this.componentDef.outputs)}create(e,t,n,r){const s=(r=r||this.ngModule)?function(e,t){return{get:(n,r,s)=>{const o=e.get(n,Qi,s);return o!==Qi||r===Qi?o:t.get(n,r,s)}}}(e,r.injector):e,o=s.get(hi,At),i=s.get(di,null),a=o.createRenderer(null,this.componentDef),u=this.componentDef.selectors[0][0]||"div",l=n?function(e,t,n){if(Rt(e))return e.selectRootElement(t,n===Ge.ShadowDom);let r="string"==typeof t?e.querySelector(t):t;return r.textContent="",r}(a,n,this.componentDef.encapsulation):Pr(o.createRenderer(null,this.componentDef),u,function(e){const t=e.toLowerCase();return"svg"===t?"http://www.w3.org/2000/svg":"math"===t?"http://www.w3.org/1998/MathML/":null}(u)),c=this.componentDef.onPush?576:528,h={components:[],scheduler:Tr,clean:Zs,playerHandler:null,flags:0},d=Rs(0,null,null,1,0,null,null,null,null,null),p=ws(null,d,h,c,null,null,o,a,i,s);let f,m;an(p);try{const e=function(e,t,n,r,s,o){const i=n[1];n[20]=e;const a=Cs(i,20,2,"#host",null),u=a.mergedAttrs=t.hostAttrs;null!==u&&(eo(a,u,!0),null!==e&&(_n(s,e,u),null!==a.classes&&Jr(s,e,a.classes),null!==a.styles&&Zr(s,e,a.styles)));const l=r.createRenderer(e,t),c=ws(n,$s(t),null,t.onPush?64:16,n[20],a,r,l,null,null);return i.firstCreatePass&&(Ln(Fn(a,n),i,t.type),Ms(i,a),Bs(a,n.length,1)),Ks(n,c),n[20]=c}(l,this.componentDef,p,o,a);if(l)if(n)_n(a,l,["ng-version",fi.full]);else{const{attrs:e,classes:t}=function(e){const t=[],n=[];let r=1,s=2;for(;r<e.length;){let o=e[r];if("string"==typeof o)2===s?""!==o&&t.push(o,e[++r]):8===s&&n.push(o);else{if(!is(s))break;s=o}r++}return{attrs:t,classes:n}}(this.componentDef.selectors[0]);e&&_n(a,l,e),t&&t.length>0&&Jr(a,l,t.join(" "))}if(m=Pt(d,yt),void 0!==t){const e=m.projection=[];for(let n=0;n<this.ngContentSelectors.length;n++){const r=t[n];e.push(null!=r?Array.from(r):null)}}f=function(e,t,n,r,s){const o=n[1],i=function(e,t,n){const r=qt();e.firstCreatePass&&(n.providersResolver&&n.providersResolver(n),Vs(e,r,t,_s(e,t,1,null),n));const s=Gn(t,e,r.directiveStart,r);wr(s,t);const o=Dt(r,t);return o&&wr(o,t),s}(o,n,t);if(r.components.push(i),e[8]=i,s&&s.forEach(e=>e(i,t)),t.contentQueries){const e=qt();t.contentQueries(1,i,e.directiveStart)}const a=qt();return!o.firstCreatePass||null===t.hostBindings&&null===t.hostAttrs||(fn(a.index),Ds(n[1],a,0,a.directiveStart,a.directiveEnd,t),Ps(t,i)),i}(e,this.componentDef,p,h,[yo]),ks(d,p,null)}finally{dn()}return new na(this.componentType,f,ai(m,p),p,m)}}class na extends class{}{constructor(e,t,n,r,s){super(),this.location=n,this._rootLView=r,this._tNode=s,this.instance=t,this.hostView=this.changeDetectorRef=new Ri(r),this.componentType=e}get injector(){return new Xn(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(e){this.hostView.onDestroy(e)}}const ra=new Map;class sa extends zi{constructor(e,t){super(),this._parent=t,this._bootstrapComponents=[],this.injector=this,this.destroyCbs=[],this.componentFactoryResolver=new Zi(this);const n=gt(e),r=e[st]||null;r&&ni(r),this._bootstrapComponents=Ir(n.bootstrap),this._r3Injector=uo(e,t,[{provide:zi,useValue:this},{provide:oi,useValue:this.componentFactoryResolver}],Ce(e)),this._r3Injector._resolveInjectorDefTypes(),this.instance=this.get(e)}get(e,t=go.THROW_IF_NOT_FOUND,n=Ve.Default){return e===go||e===zi||e===to?this:this._r3Injector.get(e,t,n)}destroy(){const e=this._r3Injector;!e.destroyed&&e.destroy(),this.destroyCbs.forEach(e=>e()),this.destroyCbs=null}onDestroy(e){this.destroyCbs.push(e)}}class oa extends Wi{constructor(e){super(),this.moduleType=e,null!==gt(e)&&function(e){const t=new Set;!function e(n){const r=gt(n,!0),s=r.id;null!==s&&(function(e,t,n){if(t&&t!==n)throw new Error(`Duplicate module registered for ${e} - ${Ce(t)} vs ${Ce(t.name)}`)}(s,ra.get(s),n),ra.set(s,n));const o=Ir(r.imports);for(const i of o)t.has(i)||(t.add(i),e(i))}(e)}(e)}create(e){return new sa(this.moduleType,e)}}function ia(e){return t=>{setTimeout(e,void 0,t)}}const aa=class extends G{constructor(e=!1){super(),this.__isAsync=e}emit(e){super.next(e)}subscribe(e,t,n){var r,s,o;let i=e,a=t||(()=>null),u=n;if(e&&"object"==typeof e){const t=e;i=null===(r=t.next)||void 0===r?void 0:r.bind(t),a=null===(s=t.error)||void 0===s?void 0:s.bind(t),u=null===(o=t.complete)||void 0===o?void 0:o.bind(t)}this.__isAsync&&(a=ia(a),i&&(i=ia(i)),u&&(u=ia(u)));const l=super.subscribe({next:i,error:a,complete:u});return e instanceof F&&e.add(l),l}};function ua(){return this._results[bo()]()}class la{constructor(e=!1){this._emitDistinctChangesOnly=e,this.dirty=!0,this._results=[],this._changesDetected=!1,this._changes=null,this.length=0,this.first=void 0,this.last=void 0;const t=bo(),n=la.prototype;n[t]||(n[t]=ua)}get changes(){return this._changes||(this._changes=new aa)}get(e){return this._results[e]}map(e){return this._results.map(e)}filter(e){return this._results.filter(e)}find(e){return this._results.find(e)}reduce(e,t){return this._results.reduce(e,t)}forEach(e){this._results.forEach(e)}some(e){return this._results.some(e)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(e,t){const n=this;n.dirty=!1;const r=tr(e);(this._changesDetected=!function(e,t,n){if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++){let s=e[r],o=t[r];if(n&&(s=n(s),o=n(o)),o!==s)return!1}return!0}(n._results,r,t))&&(n._results=r,n.length=r.length,n.last=r[this.length-1],n.first=r[0])}notifyOnChanges(){!this._changes||!this._changesDetected&&this._emitDistinctChangesOnly||this._changes.emit(this)}setDirty(){this.dirty=!0}destroy(){this.changes.complete(),this.changes.unsubscribe()}}Symbol;class ca{constructor(e){this.queryList=e,this.matches=null}clone(){return new ca(this.queryList)}setDirty(){this.queryList.setDirty()}}class ha{constructor(e=[]){this.queries=e}createEmbeddedView(e){const t=e.queries;if(null!==t){const n=null!==e.contentQueries?e.contentQueries[0]:t.length,r=[];for(let e=0;e<n;e++){const n=t.getByIndex(e);r.push(this.queries[n.indexInDeclarationView].clone())}return new ha(r)}return null}insertView(e){this.dirtyQueriesWithMatches(e)}detachView(e){this.dirtyQueriesWithMatches(e)}dirtyQueriesWithMatches(e){for(let t=0;t<this.queries.length;t++)null!==Ca(e,t).matches&&this.queries[t].setDirty()}}class da{constructor(e,t,n=null){this.predicate=e,this.flags=t,this.read=n}}class pa{constructor(e=[]){this.queries=e}elementStart(e,t){for(let n=0;n<this.queries.length;n++)this.queries[n].elementStart(e,t)}elementEnd(e){for(let t=0;t<this.queries.length;t++)this.queries[t].elementEnd(e)}embeddedTView(e){let t=null;for(let n=0;n<this.length;n++){const r=null!==t?t.length:0,s=this.getByIndex(n).embeddedTView(e,r);s&&(s.indexInDeclarationView=n,null!==t?t.push(s):t=[s])}return null!==t?new pa(t):null}template(e,t){for(let n=0;n<this.queries.length;n++)this.queries[n].template(e,t)}getByIndex(e){return this.queries[e]}get length(){return this.queries.length}track(e){this.queries.push(e)}}class fa{constructor(e,t=-1){this.metadata=e,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=t}elementStart(e,t){this.isApplyingToNode(t)&&this.matchTNode(e,t)}elementEnd(e){this._declarationNodeIndex===e.index&&(this._appliesToNextNode=!1)}template(e,t){this.elementStart(e,t)}embeddedTView(e,t){return this.isApplyingToNode(e)?(this.crossesNgTemplate=!0,this.addMatch(-e.index,t),new fa(this.metadata)):null}isApplyingToNode(e){if(this._appliesToNextNode&&1!=(1&this.metadata.flags)){const t=this._declarationNodeIndex;let n=e.parent;for(;null!==n&&8&n.type&&n.index!==t;)n=n.parent;return t===(null!==n?n.index:-1)}return this._appliesToNextNode}matchTNode(e,t){const n=this.metadata.predicate;if(Array.isArray(n))for(let r=0;r<n.length;r++){const s=n[r];this.matchTNodeWithReadOption(e,t,ma(t,s)),this.matchTNodeWithReadOption(e,t,Hn(t,e,s,!1,!1))}else n===Li?4&t.type&&this.matchTNodeWithReadOption(e,t,-1):this.matchTNodeWithReadOption(e,t,Hn(t,e,n,!1,!1))}matchTNodeWithReadOption(e,t,n){if(null!==n){const r=this.metadata.read;if(null!==r)if(r===li||r===Hi||r===Li&&4&t.type)this.addMatch(t.index,-2);else{const n=Hn(t,e,r,!1,!1);null!==n&&this.addMatch(t.index,n)}else this.addMatch(t.index,n)}}addMatch(e,t){null===this.matches?this.matches=[e,t]:this.matches.push(e,t)}}function ma(e,t){const n=e.localNames;if(null!==n)for(let r=0;r<n.length;r+=2)if(n[r]===t)return n[r+1];return null}function ga(e,t,n,r){return-1===n?function(e,t){return 11&e.type?ai(e,t):4&e.type?Ui(e,t):null}(t,e):-2===n?function(e,t,n){return n===li?ai(t,e):n===Li?Ui(t,e):n===Hi?Yi(t,e):void 0}(e,t,r):Gn(e,e[1],n,t)}function ya(e,t,n,r){const s=t[19].queries[r];if(null===s.matches){const r=e.data,o=n.matches,i=[];for(let e=0;e<o.length;e+=2){const s=o[e];i.push(s<0?null:ga(t,r[s],o[e+1],n.metadata.read))}s.matches=i}return s.matches}function xa(e,t,n,r){const s=e.queries.getByIndex(n),o=s.matches;if(null!==o){const i=ya(e,t,s,n);for(let e=0;e<o.length;e+=2){const n=o[e];if(n>0)r.push(i[e/2]);else{const s=o[e+1],i=t[-n];for(let e=xt;e<i.length;e++){const t=i[e];t[17]===t[3]&&xa(t[1],t,s,r)}if(null!==i[9]){const e=i[9];for(let t=0;t<e.length;t++){const n=e[t];xa(n[1],n,s,r)}}}}}return r}function ba(e){const t=Ht(),n=Gt(),r=nn();rn(r+1);const s=Ca(n,r);if(e.dirty&&Lt(t)===(2==(2&s.metadata.flags))){if(null===s.matches)e.reset([]);else{const o=s.crossesNgTemplate?xa(n,t,r,[]):ya(n,t,s,r);e.reset(o,ci),e.notifyOnChanges()}return!0}return!1}function va(e,t,n){const r=Gt();r.firstCreatePass&&(function(e,t,n){null===e.queries&&(e.queries=new pa),e.queries.track(new fa(t,-1))}(r,new da(e,t,n)),2==(2&t)&&(r.staticViewQueries=!0)),function(e,t,n){const r=new la(4==(4&n));As(e,t,r,r.destroy),null===t[19]&&(t[19]=new ha),t[19].queries.push(new ca(r))}(r,Ht(),t)}function wa(){return e=Ht(),t=nn(),e[19].queries[t].queryList;var e,t}function Ca(e,t){return e.queries.getByIndex(t)}const _a=new Zn("Application Initializer");let ka=(()=>{class e{constructor(e){this.appInits=e,this.resolve=ii,this.reject=ii,this.initialized=!1,this.done=!1,this.donePromise=new Promise((e,t)=>{this.resolve=e,this.reject=t})}runInitializers(){if(this.initialized)return;const e=[],t=()=>{this.done=!0,this.resolve()};if(this.appInits)for(let n=0;n<this.appInits.length;n++){const t=this.appInits[n]();if(Ro(t))e.push(t);else if(Ao(t)){const n=new Promise((e,n)=>{t.subscribe({complete:e,error:n})});e.push(n)}}Promise.all(e).then(()=>{t()}).catch(e=>{this.reject(e)}),0===e.length&&t(),this.initialized=!0}}return e.\u0275fac=function(t){return new(t||e)(mr(_a,8))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();const Ea=new Zn("AppId"),Sa={provide:Ea,useFactory:function(){return`${Ta()}${Ta()}${Ta()}`},deps:[]};function Ta(){return String.fromCharCode(97+Math.floor(25*Math.random()))}const Ia=new Zn("Platform Initializer"),Na=new Zn("Platform ID"),$a=new Zn("appBootstrapListener");let Ra=(()=>{class e{log(e){console.log(e)}warn(e){console.warn(e)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();const Aa=new Zn("LocaleId"),Oa=new Zn("DefaultCurrencyCode");class Fa{constructor(e,t){this.ngModuleFactory=e,this.componentFactories=t}}const Da=function(e){return new oa(e)},Pa=Da,Ma=function(e){return Promise.resolve(Da(e))},La=function(e){const t=Da(e),n=Ir(gt(e).declarations).reduce((e,t)=>{const n=mt(t);return n&&e.push(new ta(n)),e},[]);return new Fa(t,n)},Ba=La,Va=function(e){return Promise.resolve(La(e))};let Ua=(()=>{class e{constructor(){this.compileModuleSync=Pa,this.compileModuleAsync=Ma,this.compileModuleAndAllComponentsSync=Ba,this.compileModuleAndAllComponentsAsync=Va}clearCache(){}clearCacheFor(e){}getModuleId(e){}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();const za=(()=>Promise.resolve(0))();function Wa(e){"undefined"==typeof Zone?za.then(()=>{e&&e.apply(null,null)}):Zone.current.scheduleMicroTask("scheduleMicrotask",e)}class ja{constructor({enableLongStackTrace:e=!1,shouldCoalesceEventChangeDetection:t=!1,shouldCoalesceRunChangeDetection:n=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new aa(!1),this.onMicrotaskEmpty=new aa(!1),this.onStable=new aa(!1),this.onError=new aa(!1),"undefined"==typeof Zone)throw new Error("In this configuration Angular requires Zone.js");Zone.assertZonePatched();const r=this;r._nesting=0,r._outer=r._inner=Zone.current,Zone.TaskTrackingZoneSpec&&(r._inner=r._inner.fork(new Zone.TaskTrackingZoneSpec)),e&&Zone.longStackTraceZoneSpec&&(r._inner=r._inner.fork(Zone.longStackTraceZoneSpec)),r.shouldCoalesceEventChangeDetection=!n&&t,r.shouldCoalesceRunChangeDetection=n,r.lastRequestAnimationFrameId=-1,r.nativeRequestAnimationFrame=function(){let e=Qe.requestAnimationFrame,t=Qe.cancelAnimationFrame;if("undefined"!=typeof Zone&&e&&t){const n=e[Zone.__symbol__("OriginalDelegate")];n&&(e=n);const r=t[Zone.__symbol__("OriginalDelegate")];r&&(t=r)}return{nativeRequestAnimationFrame:e,nativeCancelAnimationFrame:t}}().nativeRequestAnimationFrame,function(e){const t=()=>{!function(e){e.isCheckStableRunning||-1!==e.lastRequestAnimationFrameId||(e.lastRequestAnimationFrameId=e.nativeRequestAnimationFrame.call(Qe,()=>{e.fakeTopEventTask||(e.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",()=>{e.lastRequestAnimationFrameId=-1,qa(e),e.isCheckStableRunning=!0,Ga(e),e.isCheckStableRunning=!1},void 0,()=>{},()=>{})),e.fakeTopEventTask.invoke()}),qa(e))}(e)};e._inner=e._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(n,r,s,o,i,a)=>{try{return Ka(e),n.invokeTask(s,o,i,a)}finally{(e.shouldCoalesceEventChangeDetection&&"eventTask"===o.type||e.shouldCoalesceRunChangeDetection)&&t(),Xa(e)}},onInvoke:(n,r,s,o,i,a,u)=>{try{return Ka(e),n.invoke(s,o,i,a,u)}finally{e.shouldCoalesceRunChangeDetection&&t(),Xa(e)}},onHasTask:(t,n,r,s)=>{t.hasTask(r,s),n===r&&("microTask"==s.change?(e._hasPendingMicrotasks=s.microTask,qa(e),Ga(e)):"macroTask"==s.change&&(e.hasPendingMacrotasks=s.macroTask))},onHandleError:(t,n,r,s)=>(t.handleError(r,s),e.runOutsideAngular(()=>e.onError.emit(s)),!1)})}(r)}static isInAngularZone(){return!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!ja.isInAngularZone())throw new Error("Expected to be in Angular Zone, but it is not!")}static assertNotInAngularZone(){if(ja.isInAngularZone())throw new Error("Expected to not be in Angular Zone, but it is!")}run(e,t,n){return this._inner.run(e,t,n)}runTask(e,t,n,r){const s=this._inner,o=s.scheduleEventTask("NgZoneEvent: "+r,e,Ha,ii,ii);try{return s.runTask(o,t,n)}finally{s.cancelTask(o)}}runGuarded(e,t,n){return this._inner.runGuarded(e,t,n)}runOutsideAngular(e){return this._outer.run(e)}}const Ha={};function Ga(e){if(0==e._nesting&&!e.hasPendingMicrotasks&&!e.isStable)try{e._nesting++,e.onMicrotaskEmpty.emit(null)}finally{if(e._nesting--,!e.hasPendingMicrotasks)try{e.runOutsideAngular(()=>e.onStable.emit(null))}finally{e.isStable=!0}}}function qa(e){e.hasPendingMicrotasks=!!(e._hasPendingMicrotasks||(e.shouldCoalesceEventChangeDetection||e.shouldCoalesceRunChangeDetection)&&-1!==e.lastRequestAnimationFrameId)}function Ka(e){e._nesting++,e.isStable&&(e.isStable=!1,e.onUnstable.emit(null))}function Xa(e){e._nesting--,Ga(e)}class Ya{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new aa,this.onMicrotaskEmpty=new aa,this.onStable=new aa,this.onError=new aa}run(e,t,n){return e.apply(t,n)}runGuarded(e,t,n){return e.apply(t,n)}runOutsideAngular(e){return e()}runTask(e,t,n,r){return e.apply(t,n)}}let Qa=(()=>{class e{constructor(e){this._ngZone=e,this._pendingCount=0,this._isZoneStable=!0,this._didWork=!1,this._callbacks=[],this.taskTrackingZone=null,this._watchAngularEvents(),e.run(()=>{this.taskTrackingZone="undefined"==typeof Zone?null:Zone.current.get("TaskTrackingZone")})}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._didWork=!0,this._isZoneStable=!1}}),this._ngZone.runOutsideAngular(()=>{this._ngZone.onStable.subscribe({next:()=>{ja.assertNotInAngularZone(),Wa(()=>{this._isZoneStable=!0,this._runCallbacksIfReady()})}})})}increasePendingRequestCount(){return this._pendingCount+=1,this._didWork=!0,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())Wa(()=>{for(;0!==this._callbacks.length;){let e=this._callbacks.pop();clearTimeout(e.timeoutId),e.doneCb(this._didWork)}this._didWork=!1});else{let e=this.getPendingTasks();this._callbacks=this._callbacks.filter(t=>!t.updateCb||!t.updateCb(e)||(clearTimeout(t.timeoutId),!1)),this._didWork=!0}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map(e=>({source:e.source,creationLocation:e.creationLocation,data:e.data})):[]}addCallback(e,t,n){let r=-1;t&&t>0&&(r=setTimeout(()=>{this._callbacks=this._callbacks.filter(e=>e.timeoutId!==r),e(this._didWork,this.getPendingTasks())},t)),this._callbacks.push({doneCb:e,timeoutId:r,updateCb:n})}whenStable(e,t,n){if(n&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(e,t,n),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}findProviders(e,t,n){return[]}}return e.\u0275fac=function(t){return new(t||e)(mr(ja))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})(),Za=(()=>{class e{constructor(){this._applications=new Map,tu.addToWindow(this)}registerApplication(e,t){this._applications.set(e,t)}unregisterApplication(e){this._applications.delete(e)}unregisterAllApplications(){this._applications.clear()}getTestability(e){return this._applications.get(e)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(e,t=!0){return tu.findTestabilityInTree(this,e,t)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();class Ja{addToWindow(e){}findTestabilityInTree(e,t,n){return null}}let eu,tu=new Ja,nu=!0,ru=!1;const su=new Zn("AllowMultipleToken");class ou{constructor(e,t){this.name=e,this.token=t}}function iu(e,t,n=[]){const r=`Platform: ${t}`,s=new Zn(r);return(t=[])=>{let o=au();if(!o||o.injector.get(su,!1))if(e)e(n.concat(t).concat({provide:s,useValue:!0}));else{const e=n.concat(t).concat({provide:s,useValue:!0},{provide:ro,useValue:"platform"});!function(e){if(eu&&!eu.destroyed&&!eu.injector.get(su,!1))throw new Error("There can be only one platform. Destroy the previous one to create a new one.");eu=e.get(uu);const t=e.get(Ia,null);t&&t.forEach(e=>e())}(go.create({providers:e,name:r}))}return function(e){const t=au();if(!t)throw new Error("No platform exists!");if(!t.injector.get(e,null))throw new Error("A platform with a different configuration has been created. Please destroy it first.");return t}(s)}}function au(){return eu&&!eu.destroyed?eu:null}let uu=(()=>{class e{constructor(e){this._injector=e,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(e,t){const n=function(e,t){let n;return n="noop"===e?new Ya:("zone.js"===e?void 0:e)||new ja({enableLongStackTrace:(ru=!0,nu),shouldCoalesceEventChangeDetection:!!(null==t?void 0:t.ngZoneEventCoalescing),shouldCoalesceRunChangeDetection:!!(null==t?void 0:t.ngZoneRunCoalescing)}),n}(t?t.ngZone:void 0,{ngZoneEventCoalescing:t&&t.ngZoneEventCoalescing||!1,ngZoneRunCoalescing:t&&t.ngZoneRunCoalescing||!1}),r=[{provide:ja,useValue:n}];return n.run(()=>{const t=go.create({providers:r,parent:this.injector,name:e.moduleType.name}),s=e.create(t),o=s.injector.get(Sr,null);if(!o)throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?");return n.runOutsideAngular(()=>{const e=n.onError.subscribe({next:e=>{o.handleError(e)}});s.onDestroy(()=>{hu(this._modules,s),e.unsubscribe()})}),function(e,t,n){try{const r=n();return Ro(r)?r.catch(n=>{throw t.runOutsideAngular(()=>e.handleError(n)),n}):r}catch(r){throw t.runOutsideAngular(()=>e.handleError(r)),r}}(o,n,()=>{const e=s.injector.get(ka);return e.runInitializers(),e.donePromise.then(()=>(ni(s.injector.get(Aa,ei)||ei),this._moduleDoBootstrap(s),s))})})}bootstrapModule(e,t=[]){const n=lu({},t);return function(e,t,n){const r=new oa(n);return Promise.resolve(r)}(0,0,e).then(e=>this.bootstrapModuleFactory(e,n))}_moduleDoBootstrap(e){const t=e.injector.get(cu);if(e._bootstrapComponents.length>0)e._bootstrapComponents.forEach(e=>t.bootstrap(e));else{if(!e.instance.ngDoBootstrap)throw new Error(`The module ${Ce(e.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);e.instance.ngDoBootstrap(t)}this._modules.push(e)}onDestroy(e){this._destroyListeners.push(e)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new Error("The platform has already been destroyed!");this._modules.slice().forEach(e=>e.destroy()),this._destroyListeners.forEach(e=>e()),this._destroyed=!0}get destroyed(){return this._destroyed}}return e.\u0275fac=function(t){return new(t||e)(mr(go))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();function lu(e,t){return Array.isArray(t)?t.reduce(lu,e):Object.assign(Object.assign({},e),t)}let cu=(()=>{class e{constructor(e,t,n,r,s){this._zone=e,this._injector=t,this._exceptionHandler=n,this._componentFactoryResolver=r,this._initStatus=s,this._bootstrapListeners=[],this._views=[],this._runningTick=!1,this._stable=!0,this.componentTypes=[],this.components=[],this._onMicrotaskEmptySubscription=this._zone.onMicrotaskEmpty.subscribe({next:()=>{this._zone.run(()=>{this.tick()})}});const o=new U(e=>{this._stable=this._zone.isStable&&!this._zone.hasPendingMacrotasks&&!this._zone.hasPendingMicrotasks,this._zone.runOutsideAngular(()=>{e.next(this._stable),e.complete()})}),i=new U(e=>{let t;this._zone.runOutsideAngular(()=>{t=this._zone.onStable.subscribe(()=>{ja.assertNotInAngularZone(),Wa(()=>{this._stable||this._zone.hasPendingMacrotasks||this._zone.hasPendingMicrotasks||(this._stable=!0,e.next(!0))})})});const n=this._zone.onUnstable.subscribe(()=>{ja.assertInAngularZone(),this._stable&&(this._stable=!1,this._zone.runOutsideAngular(()=>{e.next(!1)}))});return()=>{t.unsubscribe(),n.unsubscribe()}});this.isStable=function(...e){let t=Number.POSITIVE_INFINITY,n=null,r=e[e.length-1];return K(r)?(n=e.pop(),e.length>1&&"number"==typeof e[e.length-1]&&(t=e.pop())):"number"==typeof r&&(t=e.pop()),null===n&&1===e.length&&e[0]instanceof U?e[0]:de(t)(pe(e,n))}(o,i.pipe(e=>{return fe()((t=ve,function(e){let n;n="function"==typeof t?t:function(){return t};const r=Object.create(e,xe);return r.source=e,r.subjectFactory=n,r})(e));var t}))}bootstrap(e,t){if(!this._initStatus.done)throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.");let n;n=e instanceof ri?e:this._componentFactoryResolver.resolveComponentFactory(e),this.componentTypes.push(n.componentType);const r=n.isBoundToModule?void 0:this._injector.get(zi),s=n.create(go.NULL,[],t||n.selector,r),o=s.location.nativeElement,i=s.injector.get(Qa,null),a=i&&s.injector.get(Za);return i&&a&&a.registerApplication(o,i),s.onDestroy(()=>{this.detachView(s.hostView),hu(this.components,s),a&&a.unregisterApplication(o)}),this._loadComponent(s),s}tick(){if(this._runningTick)throw new Error("ApplicationRef.tick is called recursively");try{this._runningTick=!0;for(let e of this._views)e.detectChanges()}catch(e){this._zone.runOutsideAngular(()=>this._exceptionHandler.handleError(e))}finally{this._runningTick=!1}}attachView(e){const t=e;this._views.push(t),t.attachToAppRef(this)}detachView(e){const t=e;hu(this._views,t),t.detachFromAppRef()}_loadComponent(e){this.attachView(e.hostView),this.tick(),this.components.push(e),this._injector.get($a,[]).concat(this._bootstrapListeners).forEach(t=>t(e))}ngOnDestroy(){this._views.slice().forEach(e=>e.destroy()),this._onMicrotaskEmptySubscription.unsubscribe()}get viewCount(){return this._views.length}}return e.\u0275fac=function(t){return new(t||e)(mr(ja),mr(go),mr(Sr),mr(oi),mr(ka))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();function hu(e,t){const n=e.indexOf(t);n>-1&&e.splice(n,1)}class du{}class pu{}const fu={factoryPathPrefix:"",factoryPathSuffix:".ngfactory"};let mu=(()=>{class e{constructor(e,t){this._compiler=e,this._config=t||fu}load(e){return this.loadAndCompile(e)}loadAndCompile(e){let[t,r]=e.split("#");return void 0===r&&(r="default"),n(255)(t).then(e=>e[r]).then(e=>gu(e,t,r)).then(e=>this._compiler.compileModuleAsync(e))}loadFactory(e){let[t,r]=e.split("#"),s="NgFactory";return void 0===r&&(r="default",s=""),n(255)(this._config.factoryPathPrefix+t+this._config.factoryPathSuffix).then(e=>e[r+s]).then(e=>gu(e,t,r))}}return e.\u0275fac=function(t){return new(t||e)(mr(Ua),mr(pu,8))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();function gu(e,t,n){if(!e)throw new Error(`Cannot find '${n}' in '${t}'`);return e}const yu=iu(null,"core",[{provide:Na,useValue:"unknown"},{provide:uu,deps:[go]},{provide:Za,deps:[]},{provide:Ra,deps:[]}]),xu=[{provide:cu,useClass:cu,deps:[ja,go,Sr,oi,ka]},{provide:ea,deps:[ja],useFactory:function(e){let t=[];return e.onStable.subscribe(()=>{for(;t.length;)t.pop()()}),function(e){t.push(e)}}},{provide:ka,useClass:ka,deps:[[new br,_a]]},{provide:Ua,useClass:Ua,deps:[]},Sa,{provide:Si,useFactory:function(){return Di},deps:[]},{provide:Ii,useFactory:function(){return Pi},deps:[]},{provide:Aa,useFactory:function(e){return ni(e=e||"undefined"!=typeof $localize&&$localize.locale||ei),e},deps:[[new xr(Aa),new br,new vr]]},{provide:Oa,useValue:"USD"}];let bu=(()=>{class e{constructor(e){}}return e.\u0275fac=function(t){return new(t||e)(mr(cu))},e.\u0275mod=dt({type:e}),e.\u0275inj=Ae({providers:xu}),e})(),vu=null;function wu(){return vu}const Cu=new Zn("DocumentToken");let _u=(()=>{class e{historyGo(e){throw new Error("Not implemented")}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=Re({factory:ku,token:e,providedIn:"platform"}),e})();function ku(){return mr(Su)}const Eu=new Zn("Location Initialized");let Su=(()=>{class e extends _u{constructor(e){super(),this._doc=e,this._init()}_init(){this.location=window.location,this._history=window.history}getBaseHrefFromDOM(){return wu().getBaseHref(this._doc)}onPopState(e){const t=wu().getGlobalEventTarget(this._doc,"window");return t.addEventListener("popstate",e,!1),()=>t.removeEventListener("popstate",e)}onHashChange(e){const t=wu().getGlobalEventTarget(this._doc,"window");return t.addEventListener("hashchange",e,!1),()=>t.removeEventListener("hashchange",e)}get href(){return this.location.href}get protocol(){return this.location.protocol}get hostname(){return this.location.hostname}get port(){return this.location.port}get pathname(){return this.location.pathname}get search(){return this.location.search}get hash(){return this.location.hash}set pathname(e){this.location.pathname=e}pushState(e,t,n){Tu()?this._history.pushState(e,t,n):this.location.hash=n}replaceState(e,t,n){Tu()?this._history.replaceState(e,t,n):this.location.hash=n}forward(){this._history.forward()}back(){this._history.back()}historyGo(e=0){this._history.go(e)}getState(){return this._history.state}}return e.\u0275fac=function(t){return new(t||e)(mr(Cu))},e.\u0275prov=Re({factory:Iu,token:e,providedIn:"platform"}),e})();function Tu(){return!!window.history.pushState}function Iu(){return new Su(mr(Cu))}function Nu(e,t){if(0==e.length)return t;if(0==t.length)return e;let n=0;return e.endsWith("/")&&n++,t.startsWith("/")&&n++,2==n?e+t.substring(1):1==n?e+t:e+"/"+t}function $u(e){const t=e.match(/#|\?|$/),n=t&&t.index||e.length;return e.slice(0,n-("/"===e[n-1]?1:0))+e.slice(n)}function Ru(e){return e&&"?"!==e[0]?"?"+e:e}let Au=(()=>{class e{historyGo(e){throw new Error("Not implemented")}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=Re({factory:Ou,token:e,providedIn:"root"}),e})();function Ou(e){const t=mr(Cu).location;return new Du(mr(_u),t&&t.origin||"")}const Fu=new Zn("appBaseHref");let Du=(()=>{class e extends Au{constructor(e,t){if(super(),this._platformLocation=e,this._removeListenerFns=[],null==t&&(t=this._platformLocation.getBaseHrefFromDOM()),null==t)throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");this._baseHref=t}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}prepareExternalUrl(e){return Nu(this._baseHref,e)}path(e=!1){const t=this._platformLocation.pathname+Ru(this._platformLocation.search),n=this._platformLocation.hash;return n&&e?`${t}${n}`:t}pushState(e,t,n,r){const s=this.prepareExternalUrl(n+Ru(r));this._platformLocation.pushState(e,t,s)}replaceState(e,t,n,r){const s=this.prepareExternalUrl(n+Ru(r));this._platformLocation.replaceState(e,t,s)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}historyGo(e=0){var t,n;null===(n=(t=this._platformLocation).historyGo)||void 0===n||n.call(t,e)}}return e.\u0275fac=function(t){return new(t||e)(mr(_u),mr(Fu,8))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})(),Pu=(()=>{class e extends Au{constructor(e,t){super(),this._platformLocation=e,this._baseHref="",this._removeListenerFns=[],null!=t&&(this._baseHref=t)}ngOnDestroy(){for(;this._removeListenerFns.length;)this._removeListenerFns.pop()()}onPopState(e){this._removeListenerFns.push(this._platformLocation.onPopState(e),this._platformLocation.onHashChange(e))}getBaseHref(){return this._baseHref}path(e=!1){let t=this._platformLocation.hash;return null==t&&(t="#"),t.length>0?t.substring(1):t}prepareExternalUrl(e){const t=Nu(this._baseHref,e);return t.length>0?"#"+t:t}pushState(e,t,n,r){let s=this.prepareExternalUrl(n+Ru(r));0==s.length&&(s=this._platformLocation.pathname),this._platformLocation.pushState(e,t,s)}replaceState(e,t,n,r){let s=this.prepareExternalUrl(n+Ru(r));0==s.length&&(s=this._platformLocation.pathname),this._platformLocation.replaceState(e,t,s)}forward(){this._platformLocation.forward()}back(){this._platformLocation.back()}historyGo(e=0){var t,n;null===(n=(t=this._platformLocation).historyGo)||void 0===n||n.call(t,e)}}return e.\u0275fac=function(t){return new(t||e)(mr(_u),mr(Fu,8))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})(),Mu=(()=>{class e{constructor(e,t){this._subject=new aa,this._urlChangeListeners=[],this._platformStrategy=e;const n=this._platformStrategy.getBaseHref();this._platformLocation=t,this._baseHref=$u(Bu(n)),this._platformStrategy.onPopState(e=>{this._subject.emit({url:this.path(!0),pop:!0,state:e.state,type:e.type})})}path(e=!1){return this.normalize(this._platformStrategy.path(e))}getState(){return this._platformLocation.getState()}isCurrentPathEqualTo(e,t=""){return this.path()==this.normalize(e+Ru(t))}normalize(t){return e.stripTrailingSlash(function(e,t){return e&&t.startsWith(e)?t.substring(e.length):t}(this._baseHref,Bu(t)))}prepareExternalUrl(e){return e&&"/"!==e[0]&&(e="/"+e),this._platformStrategy.prepareExternalUrl(e)}go(e,t="",n=null){this._platformStrategy.pushState(n,"",e,t),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Ru(t)),n)}replaceState(e,t="",n=null){this._platformStrategy.replaceState(n,"",e,t),this._notifyUrlChangeListeners(this.prepareExternalUrl(e+Ru(t)),n)}forward(){this._platformStrategy.forward()}back(){this._platformStrategy.back()}historyGo(e=0){var t,n;null===(n=(t=this._platformStrategy).historyGo)||void 0===n||n.call(t,e)}onUrlChange(e){this._urlChangeListeners.push(e),this._urlChangeSubscription||(this._urlChangeSubscription=this.subscribe(e=>{this._notifyUrlChangeListeners(e.url,e.state)}))}_notifyUrlChangeListeners(e="",t){this._urlChangeListeners.forEach(n=>n(e,t))}subscribe(e,t,n){return this._subject.subscribe({next:e,error:t,complete:n})}}return e.\u0275fac=function(t){return new(t||e)(mr(Au),mr(_u))},e.normalizeQueryParams=Ru,e.joinWithSlash=Nu,e.stripTrailingSlash=$u,e.\u0275prov=Re({factory:Lu,token:e,providedIn:"root"}),e})();function Lu(){return new Mu(mr(Au),mr(_u))}function Bu(e){return e.replace(/\/index.html$/,"")}var Vu=(()=>((Vu=Vu||{})[Vu.Zero=0]="Zero",Vu[Vu.One=1]="One",Vu[Vu.Two=2]="Two",Vu[Vu.Few=3]="Few",Vu[Vu.Many=4]="Many",Vu[Vu.Other=5]="Other",Vu))();class Uu{}let zu=(()=>{class e extends Uu{constructor(e){super(),this.locale=e}getPluralCategory(e,t){switch(function(e){return function(e){const t=function(e){return e.toLowerCase().replace(/_/g,"-")}(e);let n=Zo(t);if(n)return n;const r=t.split("-")[0];if(n=Zo(r),n)return n;if("en"===r)return Yo;throw new Error(`Missing locale data for the locale "${e}".`)}(e)[Jo.PluralCase]}(t||this.locale)(e)){case Vu.Zero:return"zero";case Vu.One:return"one";case Vu.Two:return"two";case Vu.Few:return"few";case Vu.Many:return"many";default:return"other"}}}return e.\u0275fac=function(t){return new(t||e)(mr(Aa))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})(),Wu=(()=>{class e{constructor(e,t){this._viewContainer=e,this._context=new ju,this._thenTemplateRef=null,this._elseTemplateRef=null,this._thenViewRef=null,this._elseViewRef=null,this._thenTemplateRef=t}set ngIf(e){this._context.$implicit=this._context.ngIf=e,this._updateView()}set ngIfThen(e){Hu("ngIfThen",e),this._thenTemplateRef=e,this._thenViewRef=null,this._updateView()}set ngIfElse(e){Hu("ngIfElse",e),this._elseTemplateRef=e,this._elseViewRef=null,this._updateView()}_updateView(){this._context.$implicit?this._thenViewRef||(this._viewContainer.clear(),this._elseViewRef=null,this._thenTemplateRef&&(this._thenViewRef=this._viewContainer.createEmbeddedView(this._thenTemplateRef,this._context))):this._elseViewRef||(this._viewContainer.clear(),this._thenViewRef=null,this._elseTemplateRef&&(this._elseViewRef=this._viewContainer.createEmbeddedView(this._elseTemplateRef,this._context)))}static ngTemplateContextGuard(e,t){return!0}}return e.\u0275fac=function(t){return new(t||e)(Eo(Hi),Eo(Li))},e.\u0275dir=ft({type:e,selectors:[["","ngIf",""]],inputs:{ngIf:"ngIf",ngIfThen:"ngIfThen",ngIfElse:"ngIfElse"}}),e})();class ju{constructor(){this.$implicit=null,this.ngIf=null}}function Hu(e,t){if(t&&!t.createEmbeddedView)throw new Error(`${e} must be a TemplateRef, but received '${Ce(t)}'.`)}let Gu=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=dt({type:e}),e.\u0275inj=Ae({providers:[{provide:Uu,useClass:zu}]}),e})(),qu=(()=>{class e{}return e.\u0275prov=Re({token:e,providedIn:"root",factory:()=>new Ku(mr(Cu),window)}),e})();class Ku{constructor(e,t){this.document=e,this.window=t,this.offset=()=>[0,0]}setOffset(e){this.offset=Array.isArray(e)?()=>e:e}getScrollPosition(){return this.supportsScrolling()?[this.window.pageXOffset,this.window.pageYOffset]:[0,0]}scrollToPosition(e){this.supportsScrolling()&&this.window.scrollTo(e[0],e[1])}scrollToAnchor(e){if(!this.supportsScrolling())return;const t=function(e,t){const n=e.getElementById(t)||e.getElementsByName(t)[0];if(n)return n;if("function"==typeof e.createTreeWalker&&e.body&&(e.body.createShadowRoot||e.body.attachShadow)){const n=e.createTreeWalker(e.body,NodeFilter.SHOW_ELEMENT);let r=n.currentNode;for(;r;){const e=r.shadowRoot;if(e){const n=e.getElementById(t)||e.querySelector(`[name="${t}"]`);if(n)return n}r=n.nextNode()}}return null}(this.document,e);t&&(this.scrollToElement(t),this.attemptFocus(t))}setHistoryScrollRestoration(e){if(this.supportScrollRestoration()){const t=this.window.history;t&&t.scrollRestoration&&(t.scrollRestoration=e)}}scrollToElement(e){const t=e.getBoundingClientRect(),n=t.left+this.window.pageXOffset,r=t.top+this.window.pageYOffset,s=this.offset();this.window.scrollTo(n-s[0],r-s[1])}attemptFocus(e){return e.focus(),this.document.activeElement===e}supportScrollRestoration(){try{if(!this.supportsScrolling())return!1;const e=Xu(this.window.history)||Xu(Object.getPrototypeOf(this.window.history));return!(!e||!e.writable&&!e.set)}catch(e){return!1}}supportsScrolling(){try{return!!this.window&&!!this.window.scrollTo&&"pageXOffset"in this.window}catch(e){return!1}}}function Xu(e){return Object.getOwnPropertyDescriptor(e,"scrollRestoration")}class Yu extends class extends class{}{constructor(){super(...arguments),this.supportsDOMEvents=!0}}{static makeCurrent(){var e;e=new Yu,vu||(vu=e)}onAndCancel(e,t,n){return e.addEventListener(t,n,!1),()=>{e.removeEventListener(t,n,!1)}}dispatchEvent(e,t){e.dispatchEvent(t)}remove(e){e.parentNode&&e.parentNode.removeChild(e)}createElement(e,t){return(t=t||this.getDefaultDocument()).createElement(e)}createHtmlDocument(){return document.implementation.createHTMLDocument("fakeTitle")}getDefaultDocument(){return document}isElementNode(e){return e.nodeType===Node.ELEMENT_NODE}isShadowRoot(e){return e instanceof DocumentFragment}getGlobalEventTarget(e,t){return"window"===t?window:"document"===t?e:"body"===t?e.body:null}getBaseHref(e){const t=(Zu=Zu||document.querySelector("base"),Zu?Zu.getAttribute("href"):null);return null==t?null:function(e){Qu=Qu||document.createElement("a"),Qu.setAttribute("href",e);const t=Qu.pathname;return"/"===t.charAt(0)?t:`/${t}`}(t)}resetBaseElement(){Zu=null}getUserAgent(){return window.navigator.userAgent}getCookie(e){return function(e,t){t=encodeURIComponent(t);for(const n of e.split(";")){const e=n.indexOf("="),[r,s]=-1==e?[n,""]:[n.slice(0,e),n.slice(e+1)];if(r.trim()===t)return decodeURIComponent(s)}return null}(document.cookie,e)}}let Qu,Zu=null;const Ju=new Zn("TRANSITION_ID"),el=[{provide:_a,useFactory:function(e,t,n){return()=>{n.get(ka).donePromise.then(()=>{const n=wu();Array.prototype.slice.apply(t.querySelectorAll("style[ng-transition]")).filter(t=>t.getAttribute("ng-transition")===e).forEach(e=>n.remove(e))})}},deps:[Ju,Cu,go],multi:!0}];class tl{static init(){var e;e=new tl,tu=e}addToWindow(e){Qe.getAngularTestability=(t,n=!0)=>{const r=e.findTestabilityInTree(t,n);if(null==r)throw new Error("Could not find testability for element.");return r},Qe.getAllAngularTestabilities=()=>e.getAllTestabilities(),Qe.getAllAngularRootElements=()=>e.getAllRootElements(),Qe.frameworkStabilizers||(Qe.frameworkStabilizers=[]),Qe.frameworkStabilizers.push(e=>{const t=Qe.getAllAngularTestabilities();let n=t.length,r=!1;const s=function(t){r=r||t,n--,0==n&&e(r)};t.forEach(function(e){e.whenStable(s)})})}findTestabilityInTree(e,t,n){if(null==t)return null;const r=e.getTestability(t);return null!=r?r:n?wu().isShadowRoot(t)?this.findTestabilityInTree(e,t.host,!0):this.findTestabilityInTree(e,t.parentElement,!0):null}}let nl=(()=>{class e{build(){return new XMLHttpRequest}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();const rl=new Zn("EventManagerPlugins");let sl=(()=>{class e{constructor(e,t){this._zone=t,this._eventNameToPlugin=new Map,e.forEach(e=>e.manager=this),this._plugins=e.slice().reverse()}addEventListener(e,t,n){return this._findPluginFor(t).addEventListener(e,t,n)}addGlobalEventListener(e,t,n){return this._findPluginFor(t).addGlobalEventListener(e,t,n)}getZone(){return this._zone}_findPluginFor(e){const t=this._eventNameToPlugin.get(e);if(t)return t;const n=this._plugins;for(let r=0;r<n.length;r++){const t=n[r];if(t.supports(e))return this._eventNameToPlugin.set(e,t),t}throw new Error(`No event manager plugin found for event ${e}`)}}return e.\u0275fac=function(t){return new(t||e)(mr(rl),mr(ja))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();class ol{constructor(e){this._doc=e}addGlobalEventListener(e,t,n){const r=wu().getGlobalEventTarget(this._doc,e);if(!r)throw new Error(`Unsupported event target ${r} for event ${t}`);return this.addEventListener(r,t,n)}}let il=(()=>{class e{constructor(){this._stylesSet=new Set}addStyles(e){const t=new Set;e.forEach(e=>{this._stylesSet.has(e)||(this._stylesSet.add(e),t.add(e))}),this.onStylesAdded(t)}onStylesAdded(e){}getAllStyles(){return Array.from(this._stylesSet)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})(),al=(()=>{class e extends il{constructor(e){super(),this._doc=e,this._hostNodes=new Map,this._hostNodes.set(e.head,[])}_addStylesToHost(e,t,n){e.forEach(e=>{const r=this._doc.createElement("style");r.textContent=e,n.push(t.appendChild(r))})}addHost(e){const t=[];this._addStylesToHost(this._stylesSet,e,t),this._hostNodes.set(e,t)}removeHost(e){const t=this._hostNodes.get(e);t&&t.forEach(ul),this._hostNodes.delete(e)}onStylesAdded(e){this._hostNodes.forEach((t,n)=>{this._addStylesToHost(e,n,t)})}ngOnDestroy(){this._hostNodes.forEach(e=>e.forEach(ul))}}return e.\u0275fac=function(t){return new(t||e)(mr(Cu))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();function ul(e){wu().remove(e)}const ll={svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"},cl=/%COMP%/g;function hl(e,t,n){for(let r=0;r<t.length;r++){let s=t[r];Array.isArray(s)?hl(e,s,n):(s=s.replace(cl,e),n.push(s))}return n}function dl(e){return t=>{if("__ngUnwrap__"===t)return e;!1===e(t)&&(t.preventDefault(),t.returnValue=!1)}}let pl=(()=>{class e{constructor(e,t,n){this.eventManager=e,this.sharedStylesHost=t,this.appId=n,this.rendererByCompId=new Map,this.defaultRenderer=new fl(e)}createRenderer(e,t){if(!e||!t)return this.defaultRenderer;switch(t.encapsulation){case Ge.Emulated:{let n=this.rendererByCompId.get(t.id);return n||(n=new ml(this.eventManager,this.sharedStylesHost,t,this.appId),this.rendererByCompId.set(t.id,n)),n.applyToHost(e),n}case 1:case Ge.ShadowDom:return new gl(this.eventManager,this.sharedStylesHost,e,t);default:if(!this.rendererByCompId.has(t.id)){const e=hl(t.id,t.styles,[]);this.sharedStylesHost.addStyles(e),this.rendererByCompId.set(t.id,this.defaultRenderer)}return this.defaultRenderer}}begin(){}end(){}}return e.\u0275fac=function(t){return new(t||e)(mr(sl),mr(al),mr(Ea))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();class fl{constructor(e){this.eventManager=e,this.data=Object.create(null)}destroy(){}createElement(e,t){return t?document.createElementNS(ll[t]||t,e):document.createElement(e)}createComment(e){return document.createComment(e)}createText(e){return document.createTextNode(e)}appendChild(e,t){e.appendChild(t)}insertBefore(e,t,n){e&&e.insertBefore(t,n)}removeChild(e,t){e&&e.removeChild(t)}selectRootElement(e,t){let n="string"==typeof e?document.querySelector(e):e;if(!n)throw new Error(`The selector "${e}" did not match any elements`);return t||(n.textContent=""),n}parentNode(e){return e.parentNode}nextSibling(e){return e.nextSibling}setAttribute(e,t,n,r){if(r){t=r+":"+t;const s=ll[r];s?e.setAttributeNS(s,t,n):e.setAttribute(t,n)}else e.setAttribute(t,n)}removeAttribute(e,t,n){if(n){const r=ll[n];r?e.removeAttributeNS(r,t):e.removeAttribute(`${n}:${t}`)}else e.removeAttribute(t)}addClass(e,t){e.classList.add(t)}removeClass(e,t){e.classList.remove(t)}setStyle(e,t,n,r){r&(Nr.DashCase|Nr.Important)?e.style.setProperty(t,n,r&Nr.Important?"important":""):e.style[t]=n}removeStyle(e,t,n){n&Nr.DashCase?e.style.removeProperty(t):e.style[t]=""}setProperty(e,t,n){e[t]=n}setValue(e,t){e.nodeValue=t}listen(e,t,n){return"string"==typeof e?this.eventManager.addGlobalEventListener(e,t,dl(n)):this.eventManager.addEventListener(e,t,dl(n))}}class ml extends fl{constructor(e,t,n,r){super(e),this.component=n;const s=hl(r+"-"+n.id,n.styles,[]);t.addStyles(s),this.contentAttr="_ngcontent-%COMP%".replace(cl,r+"-"+n.id),this.hostAttr="_nghost-%COMP%".replace(cl,r+"-"+n.id)}applyToHost(e){super.setAttribute(e,this.hostAttr,"")}createElement(e,t){const n=super.createElement(e,t);return super.setAttribute(n,this.contentAttr,""),n}}class gl extends fl{constructor(e,t,n,r){super(e),this.sharedStylesHost=t,this.hostEl=n,this.shadowRoot=n.attachShadow({mode:"open"}),this.sharedStylesHost.addHost(this.shadowRoot);const s=hl(r.id,r.styles,[]);for(let o=0;o<s.length;o++){const e=document.createElement("style");e.textContent=s[o],this.shadowRoot.appendChild(e)}}nodeOrShadowRoot(e){return e===this.hostEl?this.shadowRoot:e}destroy(){this.sharedStylesHost.removeHost(this.shadowRoot)}appendChild(e,t){return super.appendChild(this.nodeOrShadowRoot(e),t)}insertBefore(e,t,n){return super.insertBefore(this.nodeOrShadowRoot(e),t,n)}removeChild(e,t){return super.removeChild(this.nodeOrShadowRoot(e),t)}parentNode(e){return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(e)))}}let yl=(()=>{class e extends ol{constructor(e){super(e)}supports(e){return!0}addEventListener(e,t,n){return e.addEventListener(t,n,!1),()=>this.removeEventListener(e,t,n)}removeEventListener(e,t,n){return e.removeEventListener(t,n)}}return e.\u0275fac=function(t){return new(t||e)(mr(Cu))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();const xl=["alt","control","meta","shift"],bl={"\b":"Backspace","\t":"Tab","\x7f":"Delete","\x1b":"Escape",Del:"Delete",Esc:"Escape",Left:"ArrowLeft",Right:"ArrowRight",Up:"ArrowUp",Down:"ArrowDown",Menu:"ContextMenu",Scroll:"ScrollLock",Win:"OS"},vl={A:"1",B:"2",C:"3",D:"4",E:"5",F:"6",G:"7",H:"8",I:"9",J:"*",K:"+",M:"-",N:".",O:"/","`":"0","\x90":"NumLock"},wl={alt:e=>e.altKey,control:e=>e.ctrlKey,meta:e=>e.metaKey,shift:e=>e.shiftKey};let Cl=(()=>{class e extends ol{constructor(e){super(e)}supports(t){return null!=e.parseEventName(t)}addEventListener(t,n,r){const s=e.parseEventName(n),o=e.eventCallback(s.fullKey,r,this.manager.getZone());return this.manager.getZone().runOutsideAngular(()=>wu().onAndCancel(t,s.domEventName,o))}static parseEventName(t){const n=t.toLowerCase().split("."),r=n.shift();if(0===n.length||"keydown"!==r&&"keyup"!==r)return null;const s=e._normalizeKey(n.pop());let o="";if(xl.forEach(e=>{const t=n.indexOf(e);t>-1&&(n.splice(t,1),o+=e+".")}),o+=s,0!=n.length||0===s.length)return null;const i={};return i.domEventName=r,i.fullKey=o,i}static getEventFullKey(e){let t="",n=function(e){let t=e.key;if(null==t){if(t=e.keyIdentifier,null==t)return"Unidentified";t.startsWith("U+")&&(t=String.fromCharCode(parseInt(t.substring(2),16)),3===e.location&&vl.hasOwnProperty(t)&&(t=vl[t]))}return bl[t]||t}(e);return n=n.toLowerCase()," "===n?n="space":"."===n&&(n="dot"),xl.forEach(r=>{r!=n&&(0,wl[r])(e)&&(t+=r+".")}),t+=n,t}static eventCallback(t,n,r){return s=>{e.getEventFullKey(s)===t&&r.runGuarded(()=>n(s))}}static _normalizeKey(e){switch(e){case"esc":return"escape";default:return e}}}return e.\u0275fac=function(t){return new(t||e)(mr(Cu))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();const _l=iu(yu,"browser",[{provide:Na,useValue:"browser"},{provide:Ia,useValue:function(){Yu.makeCurrent(),tl.init()},multi:!0},{provide:Cu,useFactory:function(){return function(e){$t=e}(document),document},deps:[]}]),kl=[[],{provide:ro,useValue:"root"},{provide:Sr,useFactory:function(){return new Sr},deps:[]},{provide:rl,useClass:yl,multi:!0,deps:[Cu,ja,Na]},{provide:rl,useClass:Cl,multi:!0,deps:[Cu]},[],{provide:pl,useClass:pl,deps:[sl,al,Ea]},{provide:hi,useExisting:pl},{provide:il,useExisting:al},{provide:al,useClass:al,deps:[Cu]},{provide:Qa,useClass:Qa,deps:[ja]},{provide:sl,useClass:sl,deps:[rl,ja]},{provide:class{},useClass:nl,deps:[]},[]];let El=(()=>{class e{constructor(e){if(e)throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.")}static withServerTransition(t){return{ngModule:e,providers:[{provide:Ea,useValue:t.appId},{provide:Ju,useExisting:Ea},el]}}}return e.\u0275fac=function(t){return new(t||e)(mr(e,12))},e.\u0275mod=dt({type:e}),e.\u0275inj=Ae({providers:kl,imports:[Gu,bu]}),e})();function Sl(...e){let t=e[e.length-1];return K(t)?(e.pop(),re(e,t)):pe(e)}"undefined"!=typeof window&&window;class Tl extends G{constructor(e){super(),this._value=e}get value(){return this.getValue()}_subscribe(e){const t=super._subscribe(e);return t&&!t.closed&&e.next(this._value),t}getValue(){if(this.hasError)throw this.thrownError;if(this.closed)throw new W;return this._value}next(e){super.next(this._value=e)}}class Il extends M{notifyNext(e,t,n,r,s){this.destination.next(t)}notifyError(e,t){this.destination.error(e)}notifyComplete(e){this.destination.complete()}}class Nl extends M{constructor(e,t,n){super(),this.parent=e,this.outerValue=t,this.outerIndex=n,this.index=0}_next(e){this.parent.notifyNext(this.outerValue,e,this.outerIndex,this.index++,this)}_error(e){this.parent.notifyError(e,this),this.unsubscribe()}_complete(){this.parent.notifyComplete(this),this.unsubscribe()}}function $l(e,t,n,r,s=new Nl(e,n,r)){if(!s.closed)return t instanceof U?t.subscribe(s):ne(t)(s)}const Rl={};class Al{constructor(e){this.resultSelector=e}call(e,t){return t.subscribe(new Ol(e,this.resultSelector))}}class Ol extends Il{constructor(e,t){super(e),this.resultSelector=t,this.active=0,this.values=[],this.observables=[]}_next(e){this.values.push(Rl),this.observables.push(e)}_complete(){const e=this.observables,t=e.length;if(0===t)this.destination.complete();else{this.active=t,this.toRespond=t;for(let n=0;n<t;n++)this.add($l(this,e[n],void 0,n))}}notifyComplete(e){0==(this.active-=1)&&this.destination.complete()}notifyNext(e,t,n){const r=this.values,s=this.toRespond?r[n]===Rl?--this.toRespond:this.toRespond:0;r[n]=t,0===s&&(this.resultSelector?this._tryResultSelector(r):this.destination.next(r.slice()))}_tryResultSelector(e){let t;try{t=this.resultSelector.apply(this,e)}catch(n){return void this.destination.error(n)}this.destination.next(t)}}const Fl=(()=>{function e(){return Error.call(this),this.message="no elements in sequence",this.name="EmptyError",this}return e.prototype=Object.create(Error.prototype),e})();function Dl(...e){return de(1)(Sl(...e))}const Pl=new U(e=>e.complete());function Ml(e){return e?function(e){return new U(t=>e.schedule(()=>t.complete()))}(e):Pl}function Ll(e){return new U(t=>{let n;try{n=e()}catch(r){return void t.error(r)}return(n?se(n):Ml()).subscribe(t)})}function Bl(e,t){return"function"==typeof t?n=>n.pipe(Bl((n,r)=>se(e(n,r)).pipe(X((e,s)=>t(n,e,r,s))))):t=>t.lift(new Vl(e))}class Vl{constructor(e){this.project=e}call(e,t){return t.subscribe(new Ul(e,this.project))}}class Ul extends ie{constructor(e,t){super(e),this.project=t,this.index=0}_next(e){let t;const n=this.index++;try{t=this.project(e,n)}catch(r){return void this.destination.error(r)}this._innerSub(t)}_innerSub(e){const t=this.innerSubscription;t&&t.unsubscribe();const n=new oe(this),r=this.destination;r.add(n),this.innerSubscription=ae(e,n),this.innerSubscription!==n&&r.add(this.innerSubscription)}_complete(){const{innerSubscription:e}=this;e&&!e.closed||super._complete(),this.unsubscribe()}_unsubscribe(){this.innerSubscription=void 0}notifyComplete(){this.innerSubscription=void 0,this.isStopped&&super._complete()}notifyNext(e){this.destination.next(e)}}const zl=(()=>{function e(){return Error.call(this),this.message="argument out of range",this.name="ArgumentOutOfRangeError",this}return e.prototype=Object.create(Error.prototype),e})();function Wl(e){return t=>0===e?Ml():t.lift(new jl(e))}class jl{constructor(e){if(this.total=e,this.total<0)throw new zl}call(e,t){return t.subscribe(new Hl(e,this.total))}}class Hl extends M{constructor(e,t){super(e),this.total=t,this.count=0}_next(e){const t=this.total,n=++this.count;n<=t&&(this.destination.next(e),n===t&&(this.destination.complete(),this.unsubscribe()))}}function Gl(e,t){let n=!1;return arguments.length>=2&&(n=!0),function(r){return r.lift(new ql(e,t,n))}}class ql{constructor(e,t,n=!1){this.accumulator=e,this.seed=t,this.hasSeed=n}call(e,t){return t.subscribe(new Kl(e,this.accumulator,this.seed,this.hasSeed))}}class Kl extends M{constructor(e,t,n,r){super(e),this.accumulator=t,this._seed=n,this.hasSeed=r,this.index=0}get seed(){return this._seed}set seed(e){this.hasSeed=!0,this._seed=e}_next(e){if(this.hasSeed)return this._tryNext(e);this.seed=e,this.destination.next(e)}_tryNext(e){const t=this.index++;let n;try{n=this.accumulator(this.seed,e,t)}catch(r){this.destination.error(r)}this.seed=n,this.destination.next(n)}}function Xl(e,t){return function(n){return n.lift(new Yl(e,t))}}class Yl{constructor(e,t){this.predicate=e,this.thisArg=t}call(e,t){return t.subscribe(new Ql(e,this.predicate,this.thisArg))}}class Ql extends M{constructor(e,t,n){super(e),this.predicate=t,this.thisArg=n,this.count=0}_next(e){let t;try{t=this.predicate.call(this.thisArg,e,this.count++)}catch(n){return void this.destination.error(n)}t&&this.destination.next(e)}}function Zl(e){return function(t){const n=new Jl(e),r=t.lift(n);return n.caught=r}}class Jl{constructor(e){this.selector=e}call(e,t){return t.subscribe(new ec(e,this.selector,this.caught))}}class ec extends ie{constructor(e,t,n){super(e),this.selector=t,this.caught=n}error(e){if(!this.isStopped){let n;try{n=this.selector(e,this.caught)}catch(t){return void super.error(t)}this._unsubscribeAndRecycle();const r=new oe(this);this.add(r);const s=ae(n,r);s!==r&&this.add(s)}}}function tc(e,t){return ue(e,t,1)}function nc(e){return function(t){return 0===e?Ml():t.lift(new rc(e))}}class rc{constructor(e){if(this.total=e,this.total<0)throw new zl}call(e,t){return t.subscribe(new sc(e,this.total))}}class sc extends M{constructor(e,t){super(e),this.total=t,this.ring=new Array,this.count=0}_next(e){const t=this.ring,n=this.total,r=this.count++;t.length<n?t.push(e):t[r%n]=e}_complete(){const e=this.destination;let t=this.count;if(t>0){const n=this.count>=this.total?this.total:this.count,r=this.ring;for(let s=0;s<n;s++){const s=t++%n;e.next(r[s])}}e.complete()}}function oc(e=uc){return t=>t.lift(new ic(e))}class ic{constructor(e){this.errorFactory=e}call(e,t){return t.subscribe(new ac(e,this.errorFactory))}}class ac extends M{constructor(e,t){super(e),this.errorFactory=t,this.hasValue=!1}_next(e){this.hasValue=!0,this.destination.next(e)}_complete(){if(this.hasValue)return this.destination.complete();{let t;try{t=this.errorFactory()}catch(e){t=e}this.destination.error(t)}}}function uc(){return new Fl}function lc(e=null){return t=>t.lift(new cc(e))}class cc{constructor(e){this.defaultValue=e}call(e,t){return t.subscribe(new hc(e,this.defaultValue))}}class hc extends M{constructor(e,t){super(e),this.defaultValue=t,this.isEmpty=!0}_next(e){this.isEmpty=!1,this.destination.next(e)}_complete(){this.isEmpty&&this.destination.next(this.defaultValue),this.destination.complete()}}function dc(e,t){const n=arguments.length>=2;return r=>r.pipe(e?Xl((t,n)=>e(t,n,r)):V,Wl(1),n?lc(t):oc(()=>new Fl))}function pc(){}function fc(e,t,n){return function(r){return r.lift(new mc(e,t,n))}}class mc{constructor(e,t,n){this.nextOrObserver=e,this.error=t,this.complete=n}call(e,t){return t.subscribe(new gc(e,this.nextOrObserver,this.error,this.complete))}}class gc extends M{constructor(e,t,n,r){super(e),this._tapNext=pc,this._tapError=pc,this._tapComplete=pc,this._tapError=n||pc,this._tapComplete=r||pc,S(t)?(this._context=this,this._tapNext=t):t&&(this._context=t,this._tapNext=t.next||pc,this._tapError=t.error||pc,this._tapComplete=t.complete||pc)}_next(e){try{this._tapNext.call(this._context,e)}catch(t){return void this.destination.error(t)}this.destination.next(e)}_error(e){try{this._tapError.call(this._context,e)}catch(e){return void this.destination.error(e)}this.destination.error(e)}_complete(){try{this._tapComplete.call(this._context)}catch(e){return void this.destination.error(e)}return this.destination.complete()}}class yc{constructor(e){this.callback=e}call(e,t){return t.subscribe(new xc(e,this.callback))}}class xc extends M{constructor(e,t){super(e),this.add(new F(t))}}class bc{constructor(e,t){this.id=e,this.url=t}}class vc extends bc{constructor(e,t,n="imperative",r=null){super(e,t),this.navigationTrigger=n,this.restoredState=r}toString(){return`NavigationStart(id: ${this.id}, url: '${this.url}')`}}class wc extends bc{constructor(e,t,n){super(e,t),this.urlAfterRedirects=n}toString(){return`NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`}}class Cc extends bc{constructor(e,t,n){super(e,t),this.reason=n}toString(){return`NavigationCancel(id: ${this.id}, url: '${this.url}')`}}class _c extends bc{constructor(e,t,n){super(e,t),this.error=n}toString(){return`NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`}}class kc extends bc{constructor(e,t,n,r){super(e,t),this.urlAfterRedirects=n,this.state=r}toString(){return`RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Ec extends bc{constructor(e,t,n,r){super(e,t),this.urlAfterRedirects=n,this.state=r}toString(){return`GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Sc extends bc{constructor(e,t,n,r,s){super(e,t),this.urlAfterRedirects=n,this.state=r,this.shouldActivate=s}toString(){return`GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`}}class Tc extends bc{constructor(e,t,n,r){super(e,t),this.urlAfterRedirects=n,this.state=r}toString(){return`ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Ic extends bc{constructor(e,t,n,r){super(e,t),this.urlAfterRedirects=n,this.state=r}toString(){return`ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`}}class Nc{constructor(e){this.route=e}toString(){return`RouteConfigLoadStart(path: ${this.route.path})`}}class $c{constructor(e){this.route=e}toString(){return`RouteConfigLoadEnd(path: ${this.route.path})`}}class Rc{constructor(e){this.snapshot=e}toString(){return`ChildActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Ac{constructor(e){this.snapshot=e}toString(){return`ChildActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Oc{constructor(e){this.snapshot=e}toString(){return`ActivationStart(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Fc{constructor(e){this.snapshot=e}toString(){return`ActivationEnd(path: '${this.snapshot.routeConfig&&this.snapshot.routeConfig.path||""}')`}}class Dc{constructor(e,t,n){this.routerEvent=e,this.position=t,this.anchor=n}toString(){return`Scroll(anchor: '${this.anchor}', position: '${this.position?`${this.position[0]}, ${this.position[1]}`:null}')`}}const Pc="primary";class Mc{constructor(e){this.params=e||{}}has(e){return Object.prototype.hasOwnProperty.call(this.params,e)}get(e){if(this.has(e)){const t=this.params[e];return Array.isArray(t)?t[0]:t}return null}getAll(e){if(this.has(e)){const t=this.params[e];return Array.isArray(t)?t:[t]}return[]}get keys(){return Object.keys(this.params)}}function Lc(e){return new Mc(e)}function Bc(e){const t=Error("NavigationCancelingError: "+e);return t.ngNavigationCancelingError=!0,t}function Vc(e,t,n){const r=n.path.split("/");if(r.length>e.length)return null;if("full"===n.pathMatch&&(t.hasChildren()||r.length<e.length))return null;const s={};for(let o=0;o<r.length;o++){const t=r[o],n=e[o];if(t.startsWith(":"))s[t.substring(1)]=n;else if(t!==n.path)return null}return{consumed:e.slice(0,r.length),posParams:s}}function Uc(e,t){const n=e?Object.keys(e):void 0,r=t?Object.keys(t):void 0;if(!n||!r||n.length!=r.length)return!1;let s;for(let o=0;o<n.length;o++)if(s=n[o],!zc(e[s],t[s]))return!1;return!0}function zc(e,t){if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;const n=[...e].sort(),r=[...t].sort();return n.every((e,t)=>r[t]===e)}return e===t}function Wc(e){return Array.prototype.concat.apply([],e)}function jc(e){return e.length>0?e[e.length-1]:null}function Hc(e,t){for(const n in e)e.hasOwnProperty(n)&&t(e[n],n)}function Gc(e){return Ao(e)?e:Ro(e)?se(Promise.resolve(e)):Sl(e)}const qc={exact:function e(t,n,r){if(!nh(t.segments,n.segments))return!1;if(!Zc(t.segments,n.segments,r))return!1;if(t.numberOfChildren!==n.numberOfChildren)return!1;for(const s in n.children){if(!t.children[s])return!1;if(!e(t.children[s],n.children[s],r))return!1}return!0},subset:Yc},Kc={exact:function(e,t){return Uc(e,t)},subset:function(e,t){return Object.keys(t).length<=Object.keys(e).length&&Object.keys(t).every(n=>zc(e[n],t[n]))},ignored:()=>!0};function Xc(e,t,n){return qc[n.paths](e.root,t.root,n.matrixParams)&&Kc[n.queryParams](e.queryParams,t.queryParams)&&!("exact"===n.fragment&&e.fragment!==t.fragment)}function Yc(e,t,n){return Qc(e,t,t.segments,n)}function Qc(e,t,n,r){if(e.segments.length>n.length){const s=e.segments.slice(0,n.length);return!!nh(s,n)&&!t.hasChildren()&&!!Zc(s,n,r)}if(e.segments.length===n.length){if(!nh(e.segments,n))return!1;if(!Zc(e.segments,n,r))return!1;for(const n in t.children){if(!e.children[n])return!1;if(!Yc(e.children[n],t.children[n],r))return!1}return!0}{const s=n.slice(0,e.segments.length),o=n.slice(e.segments.length);return!!nh(e.segments,s)&&!!Zc(e.segments,s,r)&&!!e.children.primary&&Qc(e.children.primary,t,o,r)}}function Zc(e,t,n){return t.every((t,r)=>Kc[n](e[r].parameters,t.parameters))}class Jc{constructor(e,t,n){this.root=e,this.queryParams=t,this.fragment=n}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Lc(this.queryParams)),this._queryParamMap}toString(){return oh.serialize(this)}}class eh{constructor(e,t){this.segments=e,this.children=t,this.parent=null,Hc(t,(e,t)=>e.parent=this)}hasChildren(){return this.numberOfChildren>0}get numberOfChildren(){return Object.keys(this.children).length}toString(){return ih(this)}}class th{constructor(e,t){this.path=e,this.parameters=t}get parameterMap(){return this._parameterMap||(this._parameterMap=Lc(this.parameters)),this._parameterMap}toString(){return ph(this)}}function nh(e,t){return e.length===t.length&&e.every((e,n)=>e.path===t[n].path)}class rh{}class sh{parse(e){const t=new xh(e);return new Jc(t.parseRootSegment(),t.parseQueryParams(),t.parseFragment())}serialize(e){var t;return`/${ah(e.root,!0)}${function(e){const t=Object.keys(e).map(t=>{const n=e[t];return Array.isArray(n)?n.map(e=>`${lh(t)}=${lh(e)}`).join("&"):`${lh(t)}=${lh(n)}`}).filter(e=>!!e);return t.length?`?${t.join("&")}`:""}(e.queryParams)}${"string"==typeof e.fragment?`#${t=e.fragment,encodeURI(t)}`:""}`}}const oh=new sh;function ih(e){return e.segments.map(e=>ph(e)).join("/")}function ah(e,t){if(!e.hasChildren())return ih(e);if(t){const t=e.children.primary?ah(e.children.primary,!1):"",n=[];return Hc(e.children,(e,t)=>{t!==Pc&&n.push(`${t}:${ah(e,!1)}`)}),n.length>0?`${t}(${n.join("//")})`:t}{const t=function(e,t){let n=[];return Hc(e.children,(e,r)=>{r===Pc&&(n=n.concat(t(e,r)))}),Hc(e.children,(e,r)=>{r!==Pc&&(n=n.concat(t(e,r)))}),n}(e,(t,n)=>n===Pc?[ah(e.children.primary,!1)]:[`${n}:${ah(t,!1)}`]);return 1===Object.keys(e.children).length&&null!=e.children.primary?`${ih(e)}/${t[0]}`:`${ih(e)}/(${t.join("//")})`}}function uh(e){return encodeURIComponent(e).replace(/%40/g,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",")}function lh(e){return uh(e).replace(/%3B/gi,";")}function ch(e){return uh(e).replace(/\(/g,"%28").replace(/\)/g,"%29").replace(/%26/gi,"&")}function hh(e){return decodeURIComponent(e)}function dh(e){return hh(e.replace(/\+/g,"%20"))}function ph(e){return`${ch(e.path)}${t=e.parameters,Object.keys(t).map(e=>`;${ch(e)}=${ch(t[e])}`).join("")}`;var t}const fh=/^[^\/()?;=#]+/;function mh(e){const t=e.match(fh);return t?t[0]:""}const gh=/^[^=?&#]+/,yh=/^[^?&#]+/;class xh{constructor(e){this.url=e,this.remaining=e}parseRootSegment(){return this.consumeOptional("/"),""===this.remaining||this.peekStartsWith("?")||this.peekStartsWith("#")?new eh([],{}):new eh([],this.parseChildren())}parseQueryParams(){const e={};if(this.consumeOptional("?"))do{this.parseQueryParam(e)}while(this.consumeOptional("&"));return e}parseFragment(){return this.consumeOptional("#")?decodeURIComponent(this.remaining):null}parseChildren(){if(""===this.remaining)return{};this.consumeOptional("/");const e=[];for(this.peekStartsWith("(")||e.push(this.parseSegment());this.peekStartsWith("/")&&!this.peekStartsWith("//")&&!this.peekStartsWith("/(");)this.capture("/"),e.push(this.parseSegment());let t={};this.peekStartsWith("/(")&&(this.capture("/"),t=this.parseParens(!0));let n={};return this.peekStartsWith("(")&&(n=this.parseParens(!1)),(e.length>0||Object.keys(t).length>0)&&(n.primary=new eh(e,t)),n}parseSegment(){const e=mh(this.remaining);if(""===e&&this.peekStartsWith(";"))throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`);return this.capture(e),new th(hh(e),this.parseMatrixParams())}parseMatrixParams(){const e={};for(;this.consumeOptional(";");)this.parseParam(e);return e}parseParam(e){const t=mh(this.remaining);if(!t)return;this.capture(t);let n="";if(this.consumeOptional("=")){const e=mh(this.remaining);e&&(n=e,this.capture(n))}e[hh(t)]=hh(n)}parseQueryParam(e){const t=function(e){const t=e.match(gh);return t?t[0]:""}(this.remaining);if(!t)return;this.capture(t);let n="";if(this.consumeOptional("=")){const e=function(e){const t=e.match(yh);return t?t[0]:""}(this.remaining);e&&(n=e,this.capture(n))}const r=dh(t),s=dh(n);if(e.hasOwnProperty(r)){let t=e[r];Array.isArray(t)||(t=[t],e[r]=t),t.push(s)}else e[r]=s}parseParens(e){const t={};for(this.capture("(");!this.consumeOptional(")")&&this.remaining.length>0;){const n=mh(this.remaining),r=this.remaining[n.length];if("/"!==r&&")"!==r&&";"!==r)throw new Error(`Cannot parse url '${this.url}'`);let s;n.indexOf(":")>-1?(s=n.substr(0,n.indexOf(":")),this.capture(s),this.capture(":")):e&&(s=Pc);const o=this.parseChildren();t[s]=1===Object.keys(o).length?o.primary:new eh([],o),this.consumeOptional("//")}return t}peekStartsWith(e){return this.remaining.startsWith(e)}consumeOptional(e){return!!this.peekStartsWith(e)&&(this.remaining=this.remaining.substring(e.length),!0)}capture(e){if(!this.consumeOptional(e))throw new Error(`Expected "${e}".`)}}class bh{constructor(e){this._root=e}get root(){return this._root.value}parent(e){const t=this.pathFromRoot(e);return t.length>1?t[t.length-2]:null}children(e){const t=vh(e,this._root);return t?t.children.map(e=>e.value):[]}firstChild(e){const t=vh(e,this._root);return t&&t.children.length>0?t.children[0].value:null}siblings(e){const t=wh(e,this._root);return t.length<2?[]:t[t.length-2].children.map(e=>e.value).filter(t=>t!==e)}pathFromRoot(e){return wh(e,this._root).map(e=>e.value)}}function vh(e,t){if(e===t.value)return t;for(const n of t.children){const t=vh(e,n);if(t)return t}return null}function wh(e,t){if(e===t.value)return[t];for(const n of t.children){const r=wh(e,n);if(r.length)return r.unshift(t),r}return[]}class Ch{constructor(e,t){this.value=e,this.children=t}toString(){return`TreeNode(${this.value})`}}function _h(e){const t={};return e&&e.children.forEach(e=>t[e.value.outlet]=e),t}class kh extends bh{constructor(e,t){super(e),this.snapshot=t,$h(this,e)}toString(){return this.snapshot.toString()}}function Eh(e,t){const n=function(e,t){const n=new Ih([],{},{},"",{},Pc,t,null,e.root,-1,{});return new Nh("",new Ch(n,[]))}(e,t),r=new Tl([new th("",{})]),s=new Tl({}),o=new Tl({}),i=new Tl({}),a=new Tl(""),u=new Sh(r,s,i,a,o,Pc,t,n.root);return u.snapshot=n.root,new kh(new Ch(u,[]),n)}class Sh{constructor(e,t,n,r,s,o,i,a){this.url=e,this.params=t,this.queryParams=n,this.fragment=r,this.data=s,this.outlet=o,this.component=i,this._futureSnapshot=a}get routeConfig(){return this._futureSnapshot.routeConfig}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=this.params.pipe(X(e=>Lc(e)))),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=this.queryParams.pipe(X(e=>Lc(e)))),this._queryParamMap}toString(){return this.snapshot?this.snapshot.toString():`Future(${this._futureSnapshot})`}}function Th(e,t="emptyOnly"){const n=e.pathFromRoot;let r=0;if("always"!==t)for(r=n.length-1;r>=1;){const e=n[r],t=n[r-1];if(e.routeConfig&&""===e.routeConfig.path)r--;else{if(t.component)break;r--}}return function(e){return e.reduce((e,t)=>({params:Object.assign(Object.assign({},e.params),t.params),data:Object.assign(Object.assign({},e.data),t.data),resolve:Object.assign(Object.assign({},e.resolve),t._resolvedData)}),{params:{},data:{},resolve:{}})}(n.slice(r))}class Ih{constructor(e,t,n,r,s,o,i,a,u,l,c){this.url=e,this.params=t,this.queryParams=n,this.fragment=r,this.data=s,this.outlet=o,this.component=i,this.routeConfig=a,this._urlSegment=u,this._lastPathIndex=l,this._resolve=c}get root(){return this._routerState.root}get parent(){return this._routerState.parent(this)}get firstChild(){return this._routerState.firstChild(this)}get children(){return this._routerState.children(this)}get pathFromRoot(){return this._routerState.pathFromRoot(this)}get paramMap(){return this._paramMap||(this._paramMap=Lc(this.params)),this._paramMap}get queryParamMap(){return this._queryParamMap||(this._queryParamMap=Lc(this.queryParams)),this._queryParamMap}toString(){return`Route(url:'${this.url.map(e=>e.toString()).join("/")}', path:'${this.routeConfig?this.routeConfig.path:""}')`}}class Nh extends bh{constructor(e,t){super(t),this.url=e,$h(this,t)}toString(){return Rh(this._root)}}function $h(e,t){t.value._routerState=e,t.children.forEach(t=>$h(e,t))}function Rh(e){const t=e.children.length>0?` { ${e.children.map(Rh).join(", ")} } `:"";return`${e.value}${t}`}function Ah(e){if(e.snapshot){const t=e.snapshot,n=e._futureSnapshot;e.snapshot=n,Uc(t.queryParams,n.queryParams)||e.queryParams.next(n.queryParams),t.fragment!==n.fragment&&e.fragment.next(n.fragment),Uc(t.params,n.params)||e.params.next(n.params),function(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!Uc(e[n],t[n]))return!1;return!0}(t.url,n.url)||e.url.next(n.url),Uc(t.data,n.data)||e.data.next(n.data)}else e.snapshot=e._futureSnapshot,e.data.next(e._futureSnapshot.data)}function Oh(e,t){var n,r;return Uc(e.params,t.params)&&nh(n=e.url,r=t.url)&&n.every((e,t)=>Uc(e.parameters,r[t].parameters))&&!(!e.parent!=!t.parent)&&(!e.parent||Oh(e.parent,t.parent))}function Fh(e,t,n){if(n&&e.shouldReuseRoute(t.value,n.value.snapshot)){const r=n.value;r._futureSnapshot=t.value;const s=function(e,t,n){return t.children.map(t=>{for(const r of n.children)if(e.shouldReuseRoute(t.value,r.value.snapshot))return Fh(e,t,r);return Fh(e,t)})}(e,t,n);return new Ch(r,s)}{if(e.shouldAttach(t.value)){const n=e.retrieve(t.value);if(null!==n){const e=n.route;return Dh(t,e),e}}const n=new Sh(new Tl((r=t.value).url),new Tl(r.params),new Tl(r.queryParams),new Tl(r.fragment),new Tl(r.data),r.outlet,r.component,r),s=t.children.map(t=>Fh(e,t));return new Ch(n,s)}var r}function Dh(e,t){if(e.value.routeConfig!==t.value.routeConfig)throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route");if(e.children.length!==t.children.length)throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children");t.value._futureSnapshot=e.value;for(let n=0;n<e.children.length;++n)Dh(e.children[n],t.children[n])}function Ph(e){return"object"==typeof e&&null!=e&&!e.outlets&&!e.segmentPath}function Mh(e){return"object"==typeof e&&null!=e&&e.outlets}function Lh(e,t,n,r,s){let o={};return r&&Hc(r,(e,t)=>{o[t]=Array.isArray(e)?e.map(e=>`${e}`):`${e}`}),new Jc(n.root===e?t:Bh(n.root,e,t),o,s)}function Bh(e,t,n){const r={};return Hc(e.children,(e,s)=>{r[s]=e===t?n:Bh(e,t,n)}),new eh(e.segments,r)}class Vh{constructor(e,t,n){if(this.isAbsolute=e,this.numberOfDoubleDots=t,this.commands=n,e&&n.length>0&&Ph(n[0]))throw new Error("Root segment cannot have matrix parameters");const r=n.find(Mh);if(r&&r!==jc(n))throw new Error("{outlets:{}} has to be the last command")}toRoot(){return this.isAbsolute&&1===this.commands.length&&"/"==this.commands[0]}}class Uh{constructor(e,t,n){this.segmentGroup=e,this.processChildren=t,this.index=n}}function zh(e,t,n){if(e||(e=new eh([],{})),0===e.segments.length&&e.hasChildren())return Wh(e,t,n);const r=function(e,t,n){let r=0,s=t;const o={match:!1,pathIndex:0,commandIndex:0};for(;s<e.segments.length;){if(r>=n.length)return o;const t=e.segments[s],i=n[r];if(Mh(i))break;const a=`${i}`,u=r<n.length-1?n[r+1]:null;if(s>0&&void 0===a)break;if(a&&u&&"object"==typeof u&&void 0===u.outlets){if(!qh(a,u,t))return o;r+=2}else{if(!qh(a,{},t))return o;r++}s++}return{match:!0,pathIndex:s,commandIndex:r}}(e,t,n),s=n.slice(r.commandIndex);if(r.match&&r.pathIndex<e.segments.length){const t=new eh(e.segments.slice(0,r.pathIndex),{});return t.children.primary=new eh(e.segments.slice(r.pathIndex),e.children),Wh(t,0,s)}return r.match&&0===s.length?new eh(e.segments,{}):r.match&&!e.hasChildren()?jh(e,t,n):r.match?Wh(e,0,s):jh(e,t,n)}function Wh(e,t,n){if(0===n.length)return new eh(e.segments,{});{const r=function(e){return Mh(e[0])?e[0].outlets:{[Pc]:e}}(n),s={};return Hc(r,(n,r)=>{"string"==typeof n&&(n=[n]),null!==n&&(s[r]=zh(e.children[r],t,n))}),Hc(e.children,(e,t)=>{void 0===r[t]&&(s[t]=e)}),new eh(e.segments,s)}}function jh(e,t,n){const r=e.segments.slice(0,t);let s=0;for(;s<n.length;){const o=n[s];if(Mh(o)){const e=Hh(o.outlets);return new eh(r,e)}if(0===s&&Ph(n[0])){r.push(new th(e.segments[t].path,Gh(n[0]))),s++;continue}const i=Mh(o)?o.outlets.primary:`${o}`,a=s<n.length-1?n[s+1]:null;i&&a&&Ph(a)?(r.push(new th(i,Gh(a))),s+=2):(r.push(new th(i,{})),s++)}return new eh(r,{})}function Hh(e){const t={};return Hc(e,(e,n)=>{"string"==typeof e&&(e=[e]),null!==e&&(t[n]=jh(new eh([],{}),0,e))}),t}function Gh(e){const t={};return Hc(e,(e,n)=>t[n]=`${e}`),t}function qh(e,t,n){return e==n.path&&Uc(t,n.parameters)}class Kh{constructor(e,t,n,r){this.routeReuseStrategy=e,this.futureState=t,this.currState=n,this.forwardEvent=r}activate(e){const t=this.futureState._root,n=this.currState?this.currState._root:null;this.deactivateChildRoutes(t,n,e),Ah(this.futureState.root),this.activateChildRoutes(t,n,e)}deactivateChildRoutes(e,t,n){const r=_h(t);e.children.forEach(e=>{const t=e.value.outlet;this.deactivateRoutes(e,r[t],n),delete r[t]}),Hc(r,(e,t)=>{this.deactivateRouteAndItsChildren(e,n)})}deactivateRoutes(e,t,n){const r=e.value,s=t?t.value:null;if(r===s)if(r.component){const s=n.getContext(r.outlet);s&&this.deactivateChildRoutes(e,t,s.children)}else this.deactivateChildRoutes(e,t,n);else s&&this.deactivateRouteAndItsChildren(t,n)}deactivateRouteAndItsChildren(e,t){this.routeReuseStrategy.shouldDetach(e.value.snapshot)?this.detachAndStoreRouteSubtree(e,t):this.deactivateRouteAndOutlet(e,t)}detachAndStoreRouteSubtree(e,t){const n=t.getContext(e.value.outlet);if(n&&n.outlet){const t=n.outlet.detach(),r=n.children.onOutletDeactivated();this.routeReuseStrategy.store(e.value.snapshot,{componentRef:t,route:e,contexts:r})}}deactivateRouteAndOutlet(e,t){const n=t.getContext(e.value.outlet),r=n&&e.value.component?n.children:t,s=_h(e);for(const o of Object.keys(s))this.deactivateRouteAndItsChildren(s[o],r);n&&n.outlet&&(n.outlet.deactivate(),n.children.onOutletDeactivated(),n.attachRef=null,n.resolver=null,n.route=null)}activateChildRoutes(e,t,n){const r=_h(t);e.children.forEach(e=>{this.activateRoutes(e,r[e.value.outlet],n),this.forwardEvent(new Fc(e.value.snapshot))}),e.children.length&&this.forwardEvent(new Ac(e.value.snapshot))}activateRoutes(e,t,n){const r=e.value,s=t?t.value:null;if(Ah(r),r===s)if(r.component){const s=n.getOrCreateContext(r.outlet);this.activateChildRoutes(e,t,s.children)}else this.activateChildRoutes(e,t,n);else if(r.component){const t=n.getOrCreateContext(r.outlet);if(this.routeReuseStrategy.shouldAttach(r.snapshot)){const e=this.routeReuseStrategy.retrieve(r.snapshot);this.routeReuseStrategy.store(r.snapshot,null),t.children.onOutletReAttached(e.contexts),t.attachRef=e.componentRef,t.route=e.route.value,t.outlet&&t.outlet.attach(e.componentRef,e.route.value),Xh(e.route)}else{const n=function(e){for(let t=e.parent;t;t=t.parent){const e=t.routeConfig;if(e&&e._loadedConfig)return e._loadedConfig;if(e&&e.component)return null}return null}(r.snapshot),s=n?n.module.componentFactoryResolver:null;t.attachRef=null,t.route=r,t.resolver=s,t.outlet&&t.outlet.activateWith(r,s),this.activateChildRoutes(e,null,t.children)}}else this.activateChildRoutes(e,null,n)}}function Xh(e){Ah(e.value),e.children.forEach(Xh)}class Yh{constructor(e,t){this.routes=e,this.module=t}}function Qh(e){return"function"==typeof e}function Zh(e){return e instanceof Jc}const Jh=Symbol("INITIAL_VALUE");function ed(){return Bl(e=>function(...e){let t,n;return K(e[e.length-1])&&(n=e.pop()),"function"==typeof e[e.length-1]&&(t=e.pop()),1===e.length&&R(e[0])&&(e=e[0]),pe(e,n).lift(new Al(t))}(e.map(e=>e.pipe(Wl(1),function(...e){const t=e[e.length-1];return K(t)?(e.pop(),n=>Dl(e,n,t)):t=>Dl(e,t)}(Jh)))).pipe(Gl((e,t)=>{let n=!1;return t.reduce((e,r,s)=>{if(e!==Jh)return e;if(r===Jh&&(n=!0),!n){if(!1===r)return r;if(s===t.length-1||Zh(r))return r}return e},e)},Jh),Xl(e=>e!==Jh),X(e=>Zh(e)?e:!0===e),Wl(1)))}let td=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=ut({type:e,selectors:[["ng-component"]],decls:1,vars:0,template:function(e,t){1&e&&$o(0,"router-outlet")},directives:function(){return[Xd]},encapsulation:2}),e})();function nd(e,t=""){for(let n=0;n<e.length;n++){const r=e[n];rd(r,sd(t,r))}}function rd(e,t){e.children&&nd(e.children,t)}function sd(e,t){return t?e||t.path?e&&!t.path?`${e}/`:!e&&t.path?t.path:`${e}/${t.path}`:"":e}function od(e){const t=e.children&&e.children.map(od),n=t?Object.assign(Object.assign({},e),{children:t}):Object.assign({},e);return!n.component&&(t||n.loadChildren)&&n.outlet&&n.outlet!==Pc&&(n.component=td),n}function id(e){return e.outlet||Pc}function ad(e,t){const n=e.filter(e=>id(e)===t);return n.push(...e.filter(e=>id(e)!==t)),n}const ud={matched:!1,consumedSegments:[],lastChild:0,parameters:{},positionalParamSegments:{}};function ld(e,t,n){var r;if(""===t.path)return"full"===t.pathMatch&&(e.hasChildren()||n.length>0)?Object.assign({},ud):{matched:!0,consumedSegments:[],lastChild:0,parameters:{},positionalParamSegments:{}};const s=(t.matcher||Vc)(n,e,t);if(!s)return Object.assign({},ud);const o={};Hc(s.posParams,(e,t)=>{o[t]=e.path});const i=s.consumed.length>0?Object.assign(Object.assign({},o),s.consumed[s.consumed.length-1].parameters):o;return{matched:!0,consumedSegments:s.consumed,lastChild:s.consumed.length,parameters:i,positionalParamSegments:null!==(r=s.posParams)&&void 0!==r?r:{}}}function cd(e,t,n,r,s="corrected"){if(n.length>0&&function(e,t,n){return n.some(n=>hd(e,t,n)&&id(n)!==Pc)}(e,n,r)){const s=new eh(t,function(e,t,n,r){const s={};s.primary=r,r._sourceSegment=e,r._segmentIndexShift=t.length;for(const o of n)if(""===o.path&&id(o)!==Pc){const n=new eh([],{});n._sourceSegment=e,n._segmentIndexShift=t.length,s[id(o)]=n}return s}(e,t,r,new eh(n,e.children)));return s._sourceSegment=e,s._segmentIndexShift=t.length,{segmentGroup:s,slicedSegments:[]}}if(0===n.length&&function(e,t,n){return n.some(n=>hd(e,t,n))}(e,n,r)){const o=new eh(e.segments,function(e,t,n,r,s,o){const i={};for(const a of r)if(hd(e,n,a)&&!s[id(a)]){const n=new eh([],{});n._sourceSegment=e,n._segmentIndexShift="legacy"===o?e.segments.length:t.length,i[id(a)]=n}return Object.assign(Object.assign({},s),i)}(e,t,n,r,e.children,s));return o._sourceSegment=e,o._segmentIndexShift=t.length,{segmentGroup:o,slicedSegments:n}}const o=new eh(e.segments,e.children);return o._sourceSegment=e,o._segmentIndexShift=t.length,{segmentGroup:o,slicedSegments:n}}function hd(e,t,n){return(!(e.hasChildren()||t.length>0)||"full"!==n.pathMatch)&&""===n.path}function dd(e,t,n,r){return!!(id(e)===r||r!==Pc&&hd(t,n,e))&&("**"===e.path||ld(t,e,n).matched)}function pd(e,t,n){return 0===t.length&&!e.children[n]}class fd{constructor(e){this.segmentGroup=e||null}}class md{constructor(e){this.urlTree=e}}function gd(e){return new U(t=>t.error(new fd(e)))}function yd(e){return new U(t=>t.error(new md(e)))}function xd(e){return new U(t=>t.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${e}'`)))}class bd{constructor(e,t,n,r,s){this.configLoader=t,this.urlSerializer=n,this.urlTree=r,this.config=s,this.allowRedirects=!0,this.ngModule=e.get(zi)}apply(){const e=cd(this.urlTree.root,[],[],this.config).segmentGroup,t=new eh(e.segments,e.children);return this.expandSegmentGroup(this.ngModule,this.config,t,Pc).pipe(X(e=>this.createUrlTree(vd(e),this.urlTree.queryParams,this.urlTree.fragment))).pipe(Zl(e=>{if(e instanceof md)return this.allowRedirects=!1,this.match(e.urlTree);if(e instanceof fd)throw this.noMatchError(e);throw e}))}match(e){return this.expandSegmentGroup(this.ngModule,this.config,e.root,Pc).pipe(X(t=>this.createUrlTree(vd(t),e.queryParams,e.fragment))).pipe(Zl(e=>{if(e instanceof fd)throw this.noMatchError(e);throw e}))}noMatchError(e){return new Error(`Cannot match any routes. URL Segment: '${e.segmentGroup}'`)}createUrlTree(e,t,n){const r=e.segments.length>0?new eh([],{[Pc]:e}):e;return new Jc(r,t,n)}expandSegmentGroup(e,t,n,r){return 0===n.segments.length&&n.hasChildren()?this.expandChildren(e,t,n).pipe(X(e=>new eh([],e))):this.expandSegment(e,n,t,n.segments,r,!0)}expandChildren(e,t,n){const r=[];for(const s of Object.keys(n.children))"primary"===s?r.unshift(s):r.push(s);return se(r).pipe(tc(r=>{const s=n.children[r],o=ad(t,r);return this.expandSegmentGroup(e,o,s,r).pipe(X(e=>({segment:e,outlet:r})))}),Gl((e,t)=>(e[t.outlet]=t.segment,e),{}),function(e,t){const n=arguments.length>=2;return r=>r.pipe(e?Xl((t,n)=>e(t,n,r)):V,nc(1),n?lc(t):oc(()=>new Fl))}())}expandSegment(e,t,n,r,s,o){return se(n).pipe(tc(i=>this.expandSegmentAgainstRoute(e,t,n,i,r,s,o).pipe(Zl(e=>{if(e instanceof fd)return Sl(null);throw e}))),dc(e=>!!e),Zl((e,n)=>{if(e instanceof Fl||"EmptyError"===e.name){if(pd(t,r,s))return Sl(new eh([],{}));throw new fd(t)}throw e}))}expandSegmentAgainstRoute(e,t,n,r,s,o,i){return dd(r,t,s,o)?void 0===r.redirectTo?this.matchSegmentAgainstRoute(e,t,r,s,o):i&&this.allowRedirects?this.expandSegmentAgainstRouteUsingRedirect(e,t,n,r,s,o):gd(t):gd(t)}expandSegmentAgainstRouteUsingRedirect(e,t,n,r,s,o){return"**"===r.path?this.expandWildCardWithParamsAgainstRouteUsingRedirect(e,n,r,o):this.expandRegularSegmentAgainstRouteUsingRedirect(e,t,n,r,s,o)}expandWildCardWithParamsAgainstRouteUsingRedirect(e,t,n,r){const s=this.applyRedirectCommands([],n.redirectTo,{});return n.redirectTo.startsWith("/")?yd(s):this.lineralizeSegments(n,s).pipe(ue(n=>{const s=new eh(n,{});return this.expandSegment(e,s,t,n,r,!1)}))}expandRegularSegmentAgainstRouteUsingRedirect(e,t,n,r,s,o){const{matched:i,consumedSegments:a,lastChild:u,positionalParamSegments:l}=ld(t,r,s);if(!i)return gd(t);const c=this.applyRedirectCommands(a,r.redirectTo,l);return r.redirectTo.startsWith("/")?yd(c):this.lineralizeSegments(r,c).pipe(ue(r=>this.expandSegment(e,t,n,r.concat(s.slice(u)),o,!1)))}matchSegmentAgainstRoute(e,t,n,r,s){if("**"===n.path)return n.loadChildren?(n._loadedConfig?Sl(n._loadedConfig):this.configLoader.load(e.injector,n)).pipe(X(e=>(n._loadedConfig=e,new eh(r,{})))):Sl(new eh(r,{}));const{matched:o,consumedSegments:i,lastChild:a}=ld(t,n,r);if(!o)return gd(t);const u=r.slice(a);return this.getChildConfig(e,n,r).pipe(ue(e=>{const r=e.module,o=e.routes,{segmentGroup:a,slicedSegments:l}=cd(t,i,u,o),c=new eh(a.segments,a.children);if(0===l.length&&c.hasChildren())return this.expandChildren(r,o,c).pipe(X(e=>new eh(i,e)));if(0===o.length&&0===l.length)return Sl(new eh(i,{}));const h=id(n)===s;return this.expandSegment(r,c,o,l,h?Pc:s,!0).pipe(X(e=>new eh(i.concat(e.segments),e.children)))}))}getChildConfig(e,t,n){return t.children?Sl(new Yh(t.children,e)):t.loadChildren?void 0!==t._loadedConfig?Sl(t._loadedConfig):this.runCanLoadGuards(e.injector,t,n).pipe(ue(n=>n?this.configLoader.load(e.injector,t).pipe(X(e=>(t._loadedConfig=e,e))):function(e){return new U(t=>t.error(Bc(`Cannot load children because the guard of the route "path: '${e.path}'" returned false`)))}(t))):Sl(new Yh([],e))}runCanLoadGuards(e,t,n){const r=t.canLoad;return r&&0!==r.length?Sl(r.map(r=>{const s=e.get(r);let o;if(function(e){return e&&Qh(e.canLoad)}(s))o=s.canLoad(t,n);else{if(!Qh(s))throw new Error("Invalid CanLoad guard");o=s(t,n)}return Gc(o)})).pipe(ed(),fc(e=>{if(!Zh(e))return;const t=Bc(`Redirecting to "${this.urlSerializer.serialize(e)}"`);throw t.url=e,t}),X(e=>!0===e)):Sl(!0)}lineralizeSegments(e,t){let n=[],r=t.root;for(;;){if(n=n.concat(r.segments),0===r.numberOfChildren)return Sl(n);if(r.numberOfChildren>1||!r.children.primary)return xd(e.redirectTo);r=r.children.primary}}applyRedirectCommands(e,t,n){return this.applyRedirectCreatreUrlTree(t,this.urlSerializer.parse(t),e,n)}applyRedirectCreatreUrlTree(e,t,n,r){const s=this.createSegmentGroup(e,t.root,n,r);return new Jc(s,this.createQueryParams(t.queryParams,this.urlTree.queryParams),t.fragment)}createQueryParams(e,t){const n={};return Hc(e,(e,r)=>{if("string"==typeof e&&e.startsWith(":")){const s=e.substring(1);n[r]=t[s]}else n[r]=e}),n}createSegmentGroup(e,t,n,r){const s=this.createSegments(e,t.segments,n,r);let o={};return Hc(t.children,(t,s)=>{o[s]=this.createSegmentGroup(e,t,n,r)}),new eh(s,o)}createSegments(e,t,n,r){return t.map(t=>t.path.startsWith(":")?this.findPosParam(e,t,r):this.findOrReturn(t,n))}findPosParam(e,t,n){const r=n[t.path.substring(1)];if(!r)throw new Error(`Cannot redirect to '${e}'. Cannot find '${t.path}'.`);return r}findOrReturn(e,t){let n=0;for(const r of t){if(r.path===e.path)return t.splice(n),r;n++}return e}}function vd(e){const t={};for(const n of Object.keys(e.children)){const r=vd(e.children[n]);(r.segments.length>0||r.hasChildren())&&(t[n]=r)}return function(e){if(1===e.numberOfChildren&&e.children.primary){const t=e.children.primary;return new eh(e.segments.concat(t.segments),t.children)}return e}(new eh(e.segments,t))}class wd{constructor(e){this.path=e,this.route=this.path[this.path.length-1]}}class Cd{constructor(e,t){this.component=e,this.route=t}}function _d(e,t,n){const r=e._root;return Ed(r,t?t._root:null,n,[r.value])}function kd(e,t,n){const r=function(e){if(!e)return null;for(let t=e.parent;t;t=t.parent){const e=t.routeConfig;if(e&&e._loadedConfig)return e._loadedConfig}return null}(t);return(r?r.module.injector:n).get(e)}function Ed(e,t,n,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const o=_h(t);return e.children.forEach(e=>{!function(e,t,n,r,s={canDeactivateChecks:[],canActivateChecks:[]}){const o=e.value,i=t?t.value:null,a=n?n.getContext(e.value.outlet):null;if(i&&o.routeConfig===i.routeConfig){const u=function(e,t,n){if("function"==typeof n)return n(e,t);switch(n){case"pathParamsChange":return!nh(e.url,t.url);case"pathParamsOrQueryParamsChange":return!nh(e.url,t.url)||!Uc(e.queryParams,t.queryParams);case"always":return!0;case"paramsOrQueryParamsChange":return!Oh(e,t)||!Uc(e.queryParams,t.queryParams);case"paramsChange":default:return!Oh(e,t)}}(i,o,o.routeConfig.runGuardsAndResolvers);u?s.canActivateChecks.push(new wd(r)):(o.data=i.data,o._resolvedData=i._resolvedData),Ed(e,t,o.component?a?a.children:null:n,r,s),u&&a&&a.outlet&&a.outlet.isActivated&&s.canDeactivateChecks.push(new Cd(a.outlet.component,i))}else i&&Sd(t,a,s),s.canActivateChecks.push(new wd(r)),Ed(e,null,o.component?a?a.children:null:n,r,s)}(e,o[e.value.outlet],n,r.concat([e.value]),s),delete o[e.value.outlet]}),Hc(o,(e,t)=>Sd(e,n.getContext(t),s)),s}function Sd(e,t,n){const r=_h(e),s=e.value;Hc(r,(e,r)=>{Sd(e,s.component?t?t.children.getContext(r):null:t,n)}),n.canDeactivateChecks.push(new Cd(s.component&&t&&t.outlet&&t.outlet.isActivated?t.outlet.component:null,s))}class Td{}function Id(e){return new U(t=>t.error(e))}class Nd{constructor(e,t,n,r,s,o){this.rootComponentType=e,this.config=t,this.urlTree=n,this.url=r,this.paramsInheritanceStrategy=s,this.relativeLinkResolution=o}recognize(){const e=cd(this.urlTree.root,[],[],this.config.filter(e=>void 0===e.redirectTo),this.relativeLinkResolution).segmentGroup,t=this.processSegmentGroup(this.config,e,Pc);if(null===t)return null;const n=new Ih([],Object.freeze({}),Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,{},Pc,this.rootComponentType,null,this.urlTree.root,-1,{}),r=new Ch(n,t),s=new Nh(this.url,r);return this.inheritParamsAndData(s._root),s}inheritParamsAndData(e){const t=e.value,n=Th(t,this.paramsInheritanceStrategy);t.params=Object.freeze(n.params),t.data=Object.freeze(n.data),e.children.forEach(e=>this.inheritParamsAndData(e))}processSegmentGroup(e,t,n){return 0===t.segments.length&&t.hasChildren()?this.processChildren(e,t):this.processSegment(e,t,t.segments,n)}processChildren(e,t){const n=[];for(const s of Object.keys(t.children)){const r=t.children[s],o=ad(e,s),i=this.processSegmentGroup(o,r,s);if(null===i)return null;n.push(...i)}const r=Rd(n);return r.sort((e,t)=>e.value.outlet===Pc?-1:t.value.outlet===Pc?1:e.value.outlet.localeCompare(t.value.outlet)),r}processSegment(e,t,n,r){for(const s of e){const e=this.processSegmentAgainstRoute(s,t,n,r);if(null!==e)return e}return pd(t,n,r)?[]:null}processSegmentAgainstRoute(e,t,n,r){if(e.redirectTo||!dd(e,t,n,r))return null;let s,o=[],i=[];if("**"===e.path){const r=n.length>0?jc(n).parameters:{};s=new Ih(n,r,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,Fd(e),id(e),e.component,e,Ad(t),Od(t)+n.length,Dd(e))}else{const r=ld(t,e,n);if(!r.matched)return null;o=r.consumedSegments,i=n.slice(r.lastChild),s=new Ih(o,r.parameters,Object.freeze(Object.assign({},this.urlTree.queryParams)),this.urlTree.fragment,Fd(e),id(e),e.component,e,Ad(t),Od(t)+o.length,Dd(e))}const a=function(e){return e.children?e.children:e.loadChildren?e._loadedConfig.routes:[]}(e),{segmentGroup:u,slicedSegments:l}=cd(t,o,i,a.filter(e=>void 0===e.redirectTo),this.relativeLinkResolution);if(0===l.length&&u.hasChildren()){const e=this.processChildren(a,u);return null===e?null:[new Ch(s,e)]}if(0===a.length&&0===l.length)return[new Ch(s,[])];const c=id(e)===r,h=this.processSegment(a,u,l,c?Pc:r);return null===h?null:[new Ch(s,h)]}}function $d(e){const t=e.value.routeConfig;return t&&""===t.path&&void 0===t.redirectTo}function Rd(e){const t=[],n=new Set;for(const r of e){if(!$d(r)){t.push(r);continue}const e=t.find(e=>r.value.routeConfig===e.value.routeConfig);void 0!==e?(e.children.push(...r.children),n.add(e)):t.push(r)}for(const r of n){const e=Rd(r.children);t.push(new Ch(r.value,e))}return t.filter(e=>!n.has(e))}function Ad(e){let t=e;for(;t._sourceSegment;)t=t._sourceSegment;return t}function Od(e){let t=e,n=t._segmentIndexShift?t._segmentIndexShift:0;for(;t._sourceSegment;)t=t._sourceSegment,n+=t._segmentIndexShift?t._segmentIndexShift:0;return n-1}function Fd(e){return e.data||{}}function Dd(e){return e.resolve||{}}function Pd(e){return Bl(t=>{const n=e(t);return n?se(n).pipe(X(()=>t)):Sl(t)})}class Md extends class{shouldDetach(e){return!1}store(e,t){}shouldAttach(e){return!1}retrieve(e){return null}shouldReuseRoute(e,t){return e.routeConfig===t.routeConfig}}{}const Ld=new Zn("ROUTES");class Bd{constructor(e,t,n,r){this.loader=e,this.compiler=t,this.onLoadStartListener=n,this.onLoadEndListener=r}load(e,t){if(t._loader$)return t._loader$;this.onLoadStartListener&&this.onLoadStartListener(t);const n=this.loadModuleFactory(t.loadChildren).pipe(X(n=>{this.onLoadEndListener&&this.onLoadEndListener(t);const r=n.create(e);return new Yh(Wc(r.injector.get(Ld,void 0,Ve.Self|Ve.Optional)).map(od),r)}),Zl(e=>{throw t._loader$=void 0,e}));return t._loader$=new ye(n,()=>new G).pipe(fe()),t._loader$}loadModuleFactory(e){return"string"==typeof e?se(this.loader.load(e)):Gc(e()).pipe(ue(e=>e instanceof Wi?Sl(e):se(this.compiler.compileModuleAsync(e))))}}class Vd{constructor(){this.outlet=null,this.route=null,this.resolver=null,this.children=new Ud,this.attachRef=null}}class Ud{constructor(){this.contexts=new Map}onChildOutletCreated(e,t){const n=this.getOrCreateContext(e);n.outlet=t,this.contexts.set(e,n)}onChildOutletDestroyed(e){const t=this.getContext(e);t&&(t.outlet=null)}onOutletDeactivated(){const e=this.contexts;return this.contexts=new Map,e}onOutletReAttached(e){this.contexts=e}getOrCreateContext(e){let t=this.getContext(e);return t||(t=new Vd,this.contexts.set(e,t)),t}getContext(e){return this.contexts.get(e)||null}}class zd{shouldProcessUrl(e){return!0}extract(e){return e}merge(e,t){return e}}function Wd(e){throw e}function jd(e,t,n){return t.parse("/")}function Hd(e,t){return Sl(null)}const Gd={paths:"exact",fragment:"ignored",matrixParams:"ignored",queryParams:"exact"},qd={paths:"subset",fragment:"ignored",matrixParams:"ignored",queryParams:"subset"};let Kd=(()=>{class e{constructor(e,t,n,r,s,o,i,a){this.rootComponentType=e,this.urlSerializer=t,this.rootContexts=n,this.location=r,this.config=a,this.lastSuccessfulNavigation=null,this.currentNavigation=null,this.disposed=!1,this.lastLocationChangeInfo=null,this.navigationId=0,this.currentPageId=0,this.isNgZoneEnabled=!1,this.events=new G,this.errorHandler=Wd,this.malformedUriErrorHandler=jd,this.navigated=!1,this.lastSuccessfulId=-1,this.hooks={beforePreactivation:Hd,afterPreactivation:Hd},this.urlHandlingStrategy=new zd,this.routeReuseStrategy=new Md,this.onSameUrlNavigation="ignore",this.paramsInheritanceStrategy="emptyOnly",this.urlUpdateStrategy="deferred",this.relativeLinkResolution="corrected",this.canceledNavigationResolution="replace",this.ngModule=s.get(zi),this.console=s.get(Ra);const u=s.get(ja);this.isNgZoneEnabled=u instanceof ja&&ja.isInAngularZone(),this.resetConfig(a),this.currentUrlTree=new Jc(new eh([],{}),{},null),this.rawUrlTree=this.currentUrlTree,this.browserUrlTree=this.currentUrlTree,this.configLoader=new Bd(o,i,e=>this.triggerEvent(new Nc(e)),e=>this.triggerEvent(new $c(e))),this.routerState=Eh(this.currentUrlTree,this.rootComponentType),this.transitions=new Tl({id:0,targetPageId:0,currentUrlTree:this.currentUrlTree,currentRawUrl:this.currentUrlTree,extractedUrl:this.urlHandlingStrategy.extract(this.currentUrlTree),urlAfterRedirects:this.urlHandlingStrategy.extract(this.currentUrlTree),rawUrl:this.currentUrlTree,extras:{},resolve:null,reject:null,promise:Promise.resolve(!0),source:"imperative",restoredState:null,currentSnapshot:this.routerState.snapshot,targetSnapshot:null,currentRouterState:this.routerState,targetRouterState:null,guards:{canActivateChecks:[],canDeactivateChecks:[]},guardsResult:null}),this.navigations=this.setupNavigations(this.transitions),this.processNavigations()}setupNavigations(e){const t=this.events;return e.pipe(Xl(e=>0!==e.id),X(e=>Object.assign(Object.assign({},e),{extractedUrl:this.urlHandlingStrategy.extract(e.rawUrl)})),Bl(e=>{let n=!1,r=!1;return Sl(e).pipe(fc(e=>{this.currentNavigation={id:e.id,initialUrl:e.currentRawUrl,extractedUrl:e.extractedUrl,trigger:e.source,extras:e.extras,previousNavigation:this.lastSuccessfulNavigation?Object.assign(Object.assign({},this.lastSuccessfulNavigation),{previousNavigation:null}):null}}),Bl(e=>{const n=!this.navigated||e.extractedUrl.toString()!==this.browserUrlTree.toString();if(("reload"===this.onSameUrlNavigation||n)&&this.urlHandlingStrategy.shouldProcessUrl(e.rawUrl))return Sl(e).pipe(Bl(e=>{const n=this.transitions.getValue();return t.next(new vc(e.id,this.serializeUrl(e.extractedUrl),e.source,e.restoredState)),n!==this.transitions.getValue()?Pl:Promise.resolve(e)}),function(e,t,n,r){return Bl(s=>function(e,t,n,r,s){return new bd(e,t,n,r,s).apply()}(e,t,n,s.extractedUrl,r).pipe(X(e=>Object.assign(Object.assign({},s),{urlAfterRedirects:e}))))}(this.ngModule.injector,this.configLoader,this.urlSerializer,this.config),fc(e=>{this.currentNavigation=Object.assign(Object.assign({},this.currentNavigation),{finalUrl:e.urlAfterRedirects})}),function(e,t,n,r,s){return ue(o=>function(e,t,n,r,s="emptyOnly",o="legacy"){try{const i=new Nd(e,t,n,r,s,o).recognize();return null===i?Id(new Td):Sl(i)}catch(i){return Id(i)}}(e,t,o.urlAfterRedirects,n(o.urlAfterRedirects),r,s).pipe(X(e=>Object.assign(Object.assign({},o),{targetSnapshot:e}))))}(this.rootComponentType,this.config,e=>this.serializeUrl(e),this.paramsInheritanceStrategy,this.relativeLinkResolution),fc(e=>{"eager"===this.urlUpdateStrategy&&(e.extras.skipLocationChange||this.setBrowserUrl(e.urlAfterRedirects,e),this.browserUrlTree=e.urlAfterRedirects);const n=new kc(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);t.next(n)}));if(n&&this.rawUrlTree&&this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)){const{id:n,extractedUrl:r,source:s,restoredState:o,extras:i}=e,a=new vc(n,this.serializeUrl(r),s,o);t.next(a);const u=Eh(r,this.rootComponentType).snapshot;return Sl(Object.assign(Object.assign({},e),{targetSnapshot:u,urlAfterRedirects:r,extras:Object.assign(Object.assign({},i),{skipLocationChange:!1,replaceUrl:!1})}))}return this.rawUrlTree=e.rawUrl,this.browserUrlTree=e.urlAfterRedirects,e.resolve(null),Pl}),Pd(e=>{const{targetSnapshot:t,id:n,extractedUrl:r,rawUrl:s,extras:{skipLocationChange:o,replaceUrl:i}}=e;return this.hooks.beforePreactivation(t,{navigationId:n,appliedUrlTree:r,rawUrlTree:s,skipLocationChange:!!o,replaceUrl:!!i})}),fc(e=>{const t=new Ec(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);this.triggerEvent(t)}),X(e=>Object.assign(Object.assign({},e),{guards:_d(e.targetSnapshot,e.currentSnapshot,this.rootContexts)})),function(e,t){return ue(n=>{const{targetSnapshot:r,currentSnapshot:s,guards:{canActivateChecks:o,canDeactivateChecks:i}}=n;return 0===i.length&&0===o.length?Sl(Object.assign(Object.assign({},n),{guardsResult:!0})):function(e,t,n,r){return se(e).pipe(ue(e=>function(e,t,n,r,s){const o=t&&t.routeConfig?t.routeConfig.canDeactivate:null;return o&&0!==o.length?Sl(o.map(o=>{const i=kd(o,t,s);let a;if(function(e){return e&&Qh(e.canDeactivate)}(i))a=Gc(i.canDeactivate(e,t,n,r));else{if(!Qh(i))throw new Error("Invalid CanDeactivate guard");a=Gc(i(e,t,n,r))}return a.pipe(dc())})).pipe(ed()):Sl(!0)}(e.component,e.route,n,t,r)),dc(e=>!0!==e,!0))}(i,r,s,e).pipe(ue(n=>n&&"boolean"==typeof n?function(e,t,n,r){return se(t).pipe(tc(t=>Dl(function(e,t){return null!==e&&t&&t(new Rc(e)),Sl(!0)}(t.route.parent,r),function(e,t){return null!==e&&t&&t(new Oc(e)),Sl(!0)}(t.route,r),function(e,t,n){const r=t[t.length-1],s=t.slice(0,t.length-1).reverse().map(e=>function(e){const t=e.routeConfig?e.routeConfig.canActivateChild:null;return t&&0!==t.length?{node:e,guards:t}:null}(e)).filter(e=>null!==e).map(t=>Ll(()=>Sl(t.guards.map(s=>{const o=kd(s,t.node,n);let i;if(function(e){return e&&Qh(e.canActivateChild)}(o))i=Gc(o.canActivateChild(r,e));else{if(!Qh(o))throw new Error("Invalid CanActivateChild guard");i=Gc(o(r,e))}return i.pipe(dc())})).pipe(ed())));return Sl(s).pipe(ed())}(e,t.path,n),function(e,t,n){const r=t.routeConfig?t.routeConfig.canActivate:null;return r&&0!==r.length?Sl(r.map(r=>Ll(()=>{const s=kd(r,t,n);let o;if(function(e){return e&&Qh(e.canActivate)}(s))o=Gc(s.canActivate(t,e));else{if(!Qh(s))throw new Error("Invalid CanActivate guard");o=Gc(s(t,e))}return o.pipe(dc())}))).pipe(ed()):Sl(!0)}(e,t.route,n))),dc(e=>!0!==e,!0))}(r,o,e,t):Sl(n)),X(e=>Object.assign(Object.assign({},n),{guardsResult:e})))})}(this.ngModule.injector,e=>this.triggerEvent(e)),fc(e=>{if(Zh(e.guardsResult)){const t=Bc(`Redirecting to "${this.serializeUrl(e.guardsResult)}"`);throw t.url=e.guardsResult,t}const t=new Sc(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot,!!e.guardsResult);this.triggerEvent(t)}),Xl(e=>!!e.guardsResult||(this.cancelNavigationTransition(e,""),!1)),Pd(e=>{if(e.guards.canActivateChecks.length)return Sl(e).pipe(fc(e=>{const t=new Tc(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);this.triggerEvent(t)}),Bl(e=>{let t=!1;return Sl(e).pipe((n=this.paramsInheritanceStrategy,r=this.ngModule.injector,ue(e=>{const{targetSnapshot:t,guards:{canActivateChecks:s}}=e;if(!s.length)return Sl(e);let o=0;return se(s).pipe(tc(e=>function(e,t,n,r){return function(e,t,n,r){const s=Object.keys(e);if(0===s.length)return Sl({});const o={};return se(s).pipe(ue(s=>function(e,t,n,r){const s=kd(e,t,r);return Gc(s.resolve?s.resolve(t,n):s(t,n))}(e[s],t,n,r).pipe(fc(e=>{o[s]=e}))),nc(1),ue(()=>Object.keys(o).length===s.length?Sl(o):Pl))}(e._resolve,e,t,r).pipe(X(t=>(e._resolvedData=t,e.data=Object.assign(Object.assign({},e.data),Th(e,n).resolve),null)))}(e.route,t,n,r)),fc(()=>o++),nc(1),ue(t=>o===s.length?Sl(e):Pl))})),fc({next:()=>t=!0,complete:()=>{t||this.cancelNavigationTransition(e,"At least one route resolver didn't emit any value.")}}));var n,r}),fc(e=>{const t=new Ic(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(e.urlAfterRedirects),e.targetSnapshot);this.triggerEvent(t)}))}),Pd(e=>{const{targetSnapshot:t,id:n,extractedUrl:r,rawUrl:s,extras:{skipLocationChange:o,replaceUrl:i}}=e;return this.hooks.afterPreactivation(t,{navigationId:n,appliedUrlTree:r,rawUrlTree:s,skipLocationChange:!!o,replaceUrl:!!i})}),X(e=>{const t=function(e,t,n){const r=Fh(e,t._root,n?n._root:void 0);return new kh(r,t)}(this.routeReuseStrategy,e.targetSnapshot,e.currentRouterState);return Object.assign(Object.assign({},e),{targetRouterState:t})}),fc(e=>{this.currentUrlTree=e.urlAfterRedirects,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,e.rawUrl),this.routerState=e.targetRouterState,"deferred"===this.urlUpdateStrategy&&(e.extras.skipLocationChange||this.setBrowserUrl(this.rawUrlTree,e),this.browserUrlTree=e.urlAfterRedirects)}),(o=this.rootContexts,i=this.routeReuseStrategy,a=e=>this.triggerEvent(e),X(e=>(new Kh(i,e.targetRouterState,e.currentRouterState,a).activate(o),e))),fc({next(){n=!0},complete(){n=!0}}),(s=()=>{n||r||this.cancelNavigationTransition(e,`Navigation ID ${e.id} is not equal to the current navigation id ${this.navigationId}`),this.currentNavigation=null},e=>e.lift(new yc(s))),Zl(n=>{if(r=!0,(s=n)&&s.ngNavigationCancelingError){const r=Zh(n.url);r||(this.navigated=!0,this.resetStateAndUrl(e.currentRouterState,e.currentUrlTree,e.rawUrl));const s=new Cc(e.id,this.serializeUrl(e.extractedUrl),n.message);t.next(s),r?setTimeout(()=>{const t=this.urlHandlingStrategy.merge(n.url,this.rawUrlTree);this.scheduleNavigation(t,"imperative",null,{skipLocationChange:e.extras.skipLocationChange,replaceUrl:"eager"===this.urlUpdateStrategy},{resolve:e.resolve,reject:e.reject,promise:e.promise})},0):e.resolve(!1)}else{this.resetStateAndUrl(e.currentRouterState,e.currentUrlTree,e.rawUrl);const r=new _c(e.id,this.serializeUrl(e.extractedUrl),n);t.next(r);try{e.resolve(this.errorHandler(n))}catch(MS){e.reject(MS)}}var s;return Pl}));var s,o,i,a}))}resetRootComponentType(e){this.rootComponentType=e,this.routerState.root.component=this.rootComponentType}getTransition(){const e=this.transitions.value;return e.urlAfterRedirects=this.browserUrlTree,e}setTransition(e){this.transitions.next(Object.assign(Object.assign({},this.getTransition()),e))}initialNavigation(){this.setUpLocationChangeListener(),0===this.navigationId&&this.navigateByUrl(this.location.path(!0),{replaceUrl:!0})}setUpLocationChangeListener(){this.locationSubscription||(this.locationSubscription=this.location.subscribe(e=>{const t=this.extractLocationChangeInfoFromEvent(e);this.shouldScheduleNavigation(this.lastLocationChangeInfo,t)&&setTimeout(()=>{const{source:e,state:n,urlTree:r}=t,s={replaceUrl:!0};if(n){const e=Object.assign({},n);delete e.navigationId,delete e.\u0275routerPageId,0!==Object.keys(e).length&&(s.state=e)}this.scheduleNavigation(r,e,n,s)},0),this.lastLocationChangeInfo=t}))}extractLocationChangeInfoFromEvent(e){var t;return{source:"popstate"===e.type?"popstate":"hashchange",urlTree:this.parseUrl(e.url),state:(null===(t=e.state)||void 0===t?void 0:t.navigationId)?e.state:null,transitionId:this.getTransition().id}}shouldScheduleNavigation(e,t){if(!e)return!0;const n=t.urlTree.toString()===e.urlTree.toString();return!(t.transitionId===e.transitionId&&n&&("hashchange"===t.source&&"popstate"===e.source||"popstate"===t.source&&"hashchange"===e.source))}get url(){return this.serializeUrl(this.currentUrlTree)}getCurrentNavigation(){return this.currentNavigation}triggerEvent(e){this.events.next(e)}resetConfig(e){nd(e),this.config=e.map(od),this.navigated=!1,this.lastSuccessfulId=-1}ngOnDestroy(){this.dispose()}dispose(){this.transitions.complete(),this.locationSubscription&&(this.locationSubscription.unsubscribe(),this.locationSubscription=void 0),this.disposed=!0}createUrlTree(e,t={}){const{relativeTo:n,queryParams:r,fragment:s,queryParamsHandling:o,preserveFragment:i}=t,a=n||this.routerState.root,u=i?this.currentUrlTree.fragment:s;let l=null;switch(o){case"merge":l=Object.assign(Object.assign({},this.currentUrlTree.queryParams),r);break;case"preserve":l=this.currentUrlTree.queryParams;break;default:l=r||null}return null!==l&&(l=this.removeEmptyProps(l)),function(e,t,n,r,s){if(0===n.length)return Lh(t.root,t.root,t,r,s);const o=function(e){if("string"==typeof e[0]&&1===e.length&&"/"===e[0])return new Vh(!0,0,e);let t=0,n=!1;const r=e.reduce((e,r,s)=>{if("object"==typeof r&&null!=r){if(r.outlets){const t={};return Hc(r.outlets,(e,n)=>{t[n]="string"==typeof e?e.split("/"):e}),[...e,{outlets:t}]}if(r.segmentPath)return[...e,r.segmentPath]}return"string"!=typeof r?[...e,r]:0===s?(r.split("/").forEach((r,s)=>{0==s&&"."===r||(0==s&&""===r?n=!0:".."===r?t++:""!=r&&e.push(r))}),e):[...e,r]},[]);return new Vh(n,t,r)}(n);if(o.toRoot())return Lh(t.root,new eh([],{}),t,r,s);const i=function(e,t,n){if(e.isAbsolute)return new Uh(t.root,!0,0);if(-1===n.snapshot._lastPathIndex){const e=n.snapshot._urlSegment;return new Uh(e,e===t.root,0)}const r=Ph(e.commands[0])?0:1;return function(e,t,n){let r=e,s=t,o=n;for(;o>s;){if(o-=s,r=r.parent,!r)throw new Error("Invalid number of '../'");s=r.segments.length}return new Uh(r,!1,s-o)}(n.snapshot._urlSegment,n.snapshot._lastPathIndex+r,e.numberOfDoubleDots)}(o,t,e),a=i.processChildren?Wh(i.segmentGroup,i.index,o.commands):zh(i.segmentGroup,i.index,o.commands);return Lh(i.segmentGroup,a,t,r,s)}(a,this.currentUrlTree,e,l,null!=u?u:null)}navigateByUrl(e,t={skipLocationChange:!1}){const n=Zh(e)?e:this.parseUrl(e),r=this.urlHandlingStrategy.merge(n,this.rawUrlTree);let s=null;return"computed"===this.canceledNavigationResolution&&(0===this.currentPageId||t.skipLocationChange||t.replaceUrl)&&(s=this.location.getState()),this.scheduleNavigation(r,"imperative",s,t)}navigate(e,t={skipLocationChange:!1}){return function(e){for(let t=0;t<e.length;t++){const n=e[t];if(null==n)throw new Error(`The requested path contains ${n} segment at index ${t}`)}}(e),this.navigateByUrl(this.createUrlTree(e,t),t)}serializeUrl(e){return this.urlSerializer.serialize(e)}parseUrl(e){let t;try{t=this.urlSerializer.parse(e)}catch(n){t=this.malformedUriErrorHandler(n,this.urlSerializer,e)}return t}isActive(e,t){let n;if(n=!0===t?Object.assign({},Gd):!1===t?Object.assign({},qd):t,Zh(e))return Xc(this.currentUrlTree,e,n);const r=this.parseUrl(e);return Xc(this.currentUrlTree,r,n)}removeEmptyProps(e){return Object.keys(e).reduce((t,n)=>{const r=e[n];return null!=r&&(t[n]=r),t},{})}processNavigations(){this.navigations.subscribe(e=>{this.navigated=!0,this.lastSuccessfulId=e.id,this.currentPageId=e.targetPageId,this.events.next(new wc(e.id,this.serializeUrl(e.extractedUrl),this.serializeUrl(this.currentUrlTree))),this.lastSuccessfulNavigation=this.currentNavigation,e.resolve(!0)},e=>{this.console.warn("Unhandled Navigation Error: ")})}scheduleNavigation(e,t,n,r,s){if(this.disposed)return Promise.resolve(!1);const o=this.getTransition(),i="imperative"!==t&&"imperative"===(null==o?void 0:o.source),a=(this.lastSuccessfulId===o.id||this.currentNavigation?o.rawUrl:o.urlAfterRedirects).toString()===e.toString();if(i&&a)return Promise.resolve(!0);let u,l,c;s?(u=s.resolve,l=s.reject,c=s.promise):c=new Promise((e,t)=>{u=e,l=t});const h=++this.navigationId;let d;return d="computed"===this.canceledNavigationResolution?n&&n.\u0275routerPageId?n.\u0275routerPageId:this.currentPageId+1:0,this.setTransition({id:h,targetPageId:d,source:t,restoredState:n,currentUrlTree:this.currentUrlTree,currentRawUrl:this.rawUrlTree,rawUrl:e,extras:r,resolve:u,reject:l,promise:c,currentSnapshot:this.routerState.snapshot,currentRouterState:this.routerState}),c.catch(e=>Promise.reject(e))}setBrowserUrl(e,t){const n=this.urlSerializer.serialize(e),r=Object.assign(Object.assign({},t.extras.state),this.generateNgRouterState(t.id,t.targetPageId));this.location.isCurrentPathEqualTo(n)||t.extras.replaceUrl?this.location.replaceState(n,"",r):this.location.go(n,"",r)}resetStateAndUrl(e,t,n){this.routerState=e,this.currentUrlTree=t,this.rawUrlTree=this.urlHandlingStrategy.merge(this.currentUrlTree,n),this.resetUrlToCurrentUrlTree()}resetUrlToCurrentUrlTree(){this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree),"",this.generateNgRouterState(this.lastSuccessfulId,this.currentPageId))}cancelNavigationTransition(e,t){"computed"===this.canceledNavigationResolution?"popstate"!==e.source&&"eager"!==this.urlUpdateStrategy||this.location.historyGo(this.currentPageId-e.targetPageId):this.resetUrlToCurrentUrlTree();const n=new Cc(e.id,this.serializeUrl(e.extractedUrl),t);this.triggerEvent(n),e.resolve(!1)}generateNgRouterState(e,t){return"computed"===this.canceledNavigationResolution?{navigationId:e,"\u0275routerPageId":t}:{navigationId:e}}}return e.\u0275fac=function(t){return new(t||e)(mr(er),mr(rh),mr(Ud),mr(Mu),mr(go),mr(du),mr(Ua),mr(void 0))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})(),Xd=(()=>{class e{constructor(e,t,n,r,s){this.parentContexts=e,this.location=t,this.resolver=n,this.changeDetector=s,this.activated=null,this._activatedRoute=null,this.activateEvents=new aa,this.deactivateEvents=new aa,this.name=r||Pc,e.onChildOutletCreated(this.name,this)}ngOnDestroy(){this.parentContexts.onChildOutletDestroyed(this.name)}ngOnInit(){if(!this.activated){const e=this.parentContexts.getContext(this.name);e&&e.route&&(e.attachRef?this.attach(e.attachRef,e.route):this.activateWith(e.route,e.resolver||null))}}get isActivated(){return!!this.activated}get component(){if(!this.activated)throw new Error("Outlet is not activated");return this.activated.instance}get activatedRoute(){if(!this.activated)throw new Error("Outlet is not activated");return this._activatedRoute}get activatedRouteData(){return this._activatedRoute?this._activatedRoute.snapshot.data:{}}detach(){if(!this.activated)throw new Error("Outlet is not activated");this.location.detach();const e=this.activated;return this.activated=null,this._activatedRoute=null,e}attach(e,t){this.activated=e,this._activatedRoute=t,this.location.insert(e.hostView)}deactivate(){if(this.activated){const e=this.component;this.activated.destroy(),this.activated=null,this._activatedRoute=null,this.deactivateEvents.emit(e)}}activateWith(e,t){if(this.isActivated)throw new Error("Cannot activate an already activated outlet");this._activatedRoute=e;const n=(t=t||this.resolver).resolveComponentFactory(e._futureSnapshot.routeConfig.component),r=this.parentContexts.getOrCreateContext(this.name).children,s=new Yd(e,r,this.location.injector);this.activated=this.location.createComponent(n,this.location.length,s),this.changeDetector.markForCheck(),this.activateEvents.emit(this.activated.instance)}}return e.\u0275fac=function(t){return new(t||e)(Eo(Ud),Eo(Hi),Eo(oi),("name",function(e,t){const n=e.attrs;if(n){const e=n.length;let r=0;for(;r<e;){const s=n[r];if(kn(s))break;if(0===s)r+=2;else if("number"==typeof s)for(r++;r<e&&"string"==typeof n[r];)r++;else{if(s===t)return n[r+1];r+=2}}}return null}(qt(),"name")),Eo(Oi))},e.\u0275dir=ft({type:e,selectors:[["router-outlet"]],outputs:{activateEvents:"activate",deactivateEvents:"deactivate"},exportAs:["outlet"]}),e})();class Yd{constructor(e,t,n){this.route=e,this.childContexts=t,this.parent=n}get(e,t){return e===Sh?this.route:e===Ud?this.childContexts:this.parent.get(e,t)}}class Qd{}class Zd{preload(e,t){return Sl(null)}}let Jd=(()=>{class e{constructor(e,t,n,r,s){this.router=e,this.injector=r,this.preloadingStrategy=s,this.loader=new Bd(t,n,t=>e.triggerEvent(new Nc(t)),t=>e.triggerEvent(new $c(t)))}setUpPreloading(){this.subscription=this.router.events.pipe(Xl(e=>e instanceof wc),tc(()=>this.preload())).subscribe(()=>{})}preload(){const e=this.injector.get(zi);return this.processRoutes(e,this.router.config)}ngOnDestroy(){this.subscription&&this.subscription.unsubscribe()}processRoutes(e,t){const n=[];for(const r of t)if(r.loadChildren&&!r.canLoad&&r._loadedConfig){const e=r._loadedConfig;n.push(this.processRoutes(e.module,e.routes))}else r.loadChildren&&!r.canLoad?n.push(this.preloadConfig(e,r)):r.children&&n.push(this.processRoutes(e,r.children));return se(n).pipe(de(),X(e=>{}))}preloadConfig(e,t){return this.preloadingStrategy.preload(t,()=>(t._loadedConfig?Sl(t._loadedConfig):this.loader.load(e.injector,t)).pipe(ue(e=>(t._loadedConfig=e,this.processRoutes(e.module,e.routes)))))}}return e.\u0275fac=function(t){return new(t||e)(mr(Kd),mr(du),mr(Ua),mr(go),mr(Qd))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})(),ep=(()=>{class e{constructor(e,t,n={}){this.router=e,this.viewportScroller=t,this.options=n,this.lastId=0,this.lastSource="imperative",this.restoredId=0,this.store={},n.scrollPositionRestoration=n.scrollPositionRestoration||"disabled",n.anchorScrolling=n.anchorScrolling||"disabled"}init(){"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.setHistoryScrollRestoration("manual"),this.routerEventsSubscription=this.createScrollEvents(),this.scrollEventsSubscription=this.consumeScrollEvents()}createScrollEvents(){return this.router.events.subscribe(e=>{e instanceof vc?(this.store[this.lastId]=this.viewportScroller.getScrollPosition(),this.lastSource=e.navigationTrigger,this.restoredId=e.restoredState?e.restoredState.navigationId:0):e instanceof wc&&(this.lastId=e.id,this.scheduleScrollEvent(e,this.router.parseUrl(e.urlAfterRedirects).fragment))})}consumeScrollEvents(){return this.router.events.subscribe(e=>{e instanceof Dc&&(e.position?"top"===this.options.scrollPositionRestoration?this.viewportScroller.scrollToPosition([0,0]):"enabled"===this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition(e.position):e.anchor&&"enabled"===this.options.anchorScrolling?this.viewportScroller.scrollToAnchor(e.anchor):"disabled"!==this.options.scrollPositionRestoration&&this.viewportScroller.scrollToPosition([0,0]))})}scheduleScrollEvent(e,t){this.router.triggerEvent(new Dc(e,"popstate"===this.lastSource?this.store[this.restoredId]:null,t))}ngOnDestroy(){this.routerEventsSubscription&&this.routerEventsSubscription.unsubscribe(),this.scrollEventsSubscription&&this.scrollEventsSubscription.unsubscribe()}}return e.\u0275fac=function(t){return new(t||e)(mr(Kd),mr(qu),mr(void 0))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();const tp=new Zn("ROUTER_CONFIGURATION"),np=new Zn("ROUTER_FORROOT_GUARD"),rp=[Mu,{provide:rh,useClass:sh},{provide:Kd,useFactory:function(e,t,n,r,s,o,i,a={},u,l){const c=new Kd(null,e,t,n,r,s,o,Wc(i));return u&&(c.urlHandlingStrategy=u),l&&(c.routeReuseStrategy=l),function(e,t){e.errorHandler&&(t.errorHandler=e.errorHandler),e.malformedUriErrorHandler&&(t.malformedUriErrorHandler=e.malformedUriErrorHandler),e.onSameUrlNavigation&&(t.onSameUrlNavigation=e.onSameUrlNavigation),e.paramsInheritanceStrategy&&(t.paramsInheritanceStrategy=e.paramsInheritanceStrategy),e.relativeLinkResolution&&(t.relativeLinkResolution=e.relativeLinkResolution),e.urlUpdateStrategy&&(t.urlUpdateStrategy=e.urlUpdateStrategy)}(a,c),a.enableTracing&&c.events.subscribe(e=>{var t,n;null===(t=console.group)||void 0===t||t.call(console,`Router Event: ${e.constructor.name}`),console.log(e.toString()),console.log(e),null===(n=console.groupEnd)||void 0===n||n.call(console)}),c},deps:[rh,Ud,Mu,go,du,Ua,Ld,tp,[class{},new br],[class{},new br]]},Ud,{provide:Sh,useFactory:function(e){return e.routerState.root},deps:[Kd]},{provide:du,useClass:mu},Jd,Zd,class{preload(e,t){return t().pipe(Zl(()=>Sl(null)))}},{provide:tp,useValue:{enableTracing:!1}}];function sp(){return new ou("Router",Kd)}let op=(()=>{class e{constructor(e,t){}static forRoot(t,n){return{ngModule:e,providers:[rp,lp(t),{provide:np,useFactory:up,deps:[[Kd,new br,new vr]]},{provide:tp,useValue:n||{}},{provide:Au,useFactory:ap,deps:[_u,[new xr(Fu),new br],tp]},{provide:ep,useFactory:ip,deps:[Kd,qu,tp]},{provide:Qd,useExisting:n&&n.preloadingStrategy?n.preloadingStrategy:Zd},{provide:ou,multi:!0,useFactory:sp},[cp,{provide:_a,multi:!0,useFactory:hp,deps:[cp]},{provide:pp,useFactory:dp,deps:[cp]},{provide:$a,multi:!0,useExisting:pp}]]}}static forChild(t){return{ngModule:e,providers:[lp(t)]}}}return e.\u0275fac=function(t){return new(t||e)(mr(np,8),mr(Kd,8))},e.\u0275mod=dt({type:e}),e.\u0275inj=Ae({}),e})();function ip(e,t,n){return n.scrollOffset&&t.setOffset(n.scrollOffset),new ep(e,t,n)}function ap(e,t,n={}){return n.useHash?new Pu(e,t):new Du(e,t)}function up(e){return"guarded"}function lp(e){return[{provide:Jn,multi:!0,useValue:e},{provide:Ld,multi:!0,useValue:e}]}let cp=(()=>{class e{constructor(e){this.injector=e,this.initNavigation=!1,this.destroyed=!1,this.resultOfPreactivationDone=new G}appInitializer(){return this.injector.get(Eu,Promise.resolve(null)).then(()=>{if(this.destroyed)return Promise.resolve(!0);let e=null;const t=new Promise(t=>e=t),n=this.injector.get(Kd),r=this.injector.get(tp);return"disabled"===r.initialNavigation?(n.setUpLocationChangeListener(),e(!0)):"enabled"===r.initialNavigation||"enabledBlocking"===r.initialNavigation?(n.hooks.afterPreactivation=()=>this.initNavigation?Sl(null):(this.initNavigation=!0,e(!0),this.resultOfPreactivationDone),n.initialNavigation()):e(!0),t})}bootstrapListener(e){const t=this.injector.get(tp),n=this.injector.get(Jd),r=this.injector.get(ep),s=this.injector.get(Kd),o=this.injector.get(cu);e===o.components[0]&&("enabledNonBlocking"!==t.initialNavigation&&void 0!==t.initialNavigation||s.initialNavigation(),n.setUpPreloading(),r.init(),s.resetRootComponentType(o.componentTypes[0]),this.resultOfPreactivationDone.next(null),this.resultOfPreactivationDone.complete())}ngOnDestroy(){this.destroyed=!0}}return e.\u0275fac=function(t){return new(t||e)(mr(go))},e.\u0275prov=Re({token:e,factory:e.\u0275fac}),e})();function hp(e){return e.appInitializer.bind(e)}function dp(e){return e.bootstrapListener.bind(e)}const pp=new Zn("Router Initializer");function fp(e,t,n,r,s,o,i){try{var a=e[o](i),u=a.value}catch(l){return void n(l)}a.done?t(u):Promise.resolve(u).then(r,s)}function mp(e){return function(){var t=this,n=arguments;return new Promise(function(r,s){var o=e.apply(t,n);function i(e){fp(o,r,s,i,a,"next",e)}function a(e){fp(o,r,s,i,a,"throw",e)}i(void 0)})}}var gp=n(394);class yp{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class xp{refCount(e){return bp("refCount")}incRef(e){return bp("incRef")}timerAvailable(){return!0}time(e){return bp("time")}read(e){return bp("read")}readSync(e){return bp("readSync")}numDataIds(){return bp("numDataIds")}disposeData(e,t){return bp("disposeData")}write(e,t,n){return bp("write")}move(e,t,n,r,s){return bp("move")}memory(){return bp("memory")}floatPrecision(){return bp("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return bp("dispose")}}function bp(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function vp(e,t,n){return Math.max(e,Math.min(t,n))}function wp(e){return e%2==0?e:e+1}function Cp(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function _p(e,t,n=""){Cp(Tp(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function kp(e){Cp(null!=e,()=>"The input to the tensor constructor must be a non-null value.")}function Ep(e,t=[],n=!1){if(null==t&&(t=[]),Array.isArray(e)||Mp(e)&&!n)for(let r=0;r<e.length;++r)Ep(e[r],t,n);else t.push(e);return t}function Sp(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function Tp(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Ip(e){return e%1==0}function Np(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function $p(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function Rp(e,t=(e=>0),n){return new Promise((r,s)=>{let o=0;const i=()=>{if(e())return void r();o++;const a=t(o);null!=n&&o>=n?s():setTimeout(i,a)};i()})}function Ap(e,t){const n=t.length;return Cp((e=null==e?t.map((e,t)=>t):[].concat(e)).every(e=>e>=-n&&e<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),Cp(e.every(e=>Ip(e)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(e=>e<0?n+e:e)}function Op(e,t){const n=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,o=null==t||s?null:Ap(t,e).sort();let i=0;for(let a=0;a<e.length;++a){if(null!=o){if(o[i]===a&&1!==e[a])throw new Error(`Can't squeeze axis ${a} since its dim '${e[a]}' is not 1`);(null==o[i]||o[i]>a)&&1===e[a]&&(n.push(e[a]),r.push(a)),o[i]<=a&&i++}1!==e[a]&&(n.push(e[a]),r.push(a))}return{newShape:n,keptDims:r}}function Fp(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);n=new Uint8Array(t)}return n}function Dp(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function Pp(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function Mp(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array}function Lp(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function Bp(e){return"string"==typeof e||e instanceof String}function Vp(e){return Array.isArray(e)?Vp(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array?"int32":"number"==typeof e?"float32":Bp(e)?"string":"boolean"==typeof e?"bool":"float32"}function Up(e){return!!(e&&e.constructor&&e.call&&e.apply)}function zp(e,t){for(let n=t;n<e;++n)if(e%n==0)return n;return e}function Wp(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function jp(e,t,n,r=!1){const s=new Array;if(1===t.length){const o=t[0]*(r?2:1);for(let t=0;t<o;t++)s[t]=n[e+t]}else{const o=t[0],i=t.slice(1),a=i.reduce((e,t)=>e*t)*(r?2:1);for(let t=0;t<o;t++)s[t]=jp(e+t*a,i,n,r)}return s}function Hp(e,t,n=!1){if(0===e.length)return t[0];const r=e.reduce((e,t)=>e*t)*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return jp(0,e,t,n)}function Gp(e,t){const n=qp(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function qp(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function Kp(e){e.forEach(t=>{Cp(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function Xp(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=n[s]*e[s];return r}function Yp(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(e/n[s]),e-=r[s]*n[s];return r[r.length-1]=e,r}function Qp(e){return e&&e.then&&"function"==typeof e.then}class Zp{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Jp,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}getAsync(e){var t=this;return mp(function*(){return e in t.flags||(t.flags[e]=yield t.evaluateFlag(e)),t.flags[e]})()}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Qp(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);"tfjsflags"in e&&e.tfjsflags.split(",").forEach(e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}(t,n)})}}function Jp(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...n)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,n[0],n[1]),n.join("="))),t}function ef(){return nf}let tf,nf=null;function rf(){if(null==tf){let e;if("undefined"!=typeof window)e=window;else if("undefined"!=typeof global)e=global;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}tf=e}return tf}function sf(e,t){const n=function(){const e=rf();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const of="Acos",af="Acosh",uf="Add",lf="AddN",cf="ArgMax",hf="ArgMin",df="Asin",pf="Asinh",ff="Atan",mf="Atanh",gf="Atan2",yf="AvgPool",xf="AvgPool3D",bf="BatchMatMul",vf="BatchToSpaceND",wf="Bincount",Cf="Cast",_f="Ceil",kf="ClipByValue",Ef="Complex",Sf="ComplexAbs",Tf="Concat",If="Conv2D",Nf="Conv2DBackpropFilter",$f="Conv2DBackpropInput",Rf="Conv3D",Af="Cosh",Of="Cumsum",Ff="CropAndResize",Df="DenseBincount",Pf="DepthToSpace",Mf="DepthwiseConv2dNative",Lf="DepthwiseConv2dNativeBackpropFilter",Bf="DepthwiseConv2dNativeBackpropInput",Vf="Dilation2D",Uf="RealDiv",zf="Einsum",Wf="Equal",jf="Exp",Hf="ExpandDims",Gf="Expm1",qf="Fill",Kf="FlipLeftRight",Xf="Floor",Yf="FloorDiv",Qf="FusedBatchNorm",Zf="GatherV2",Jf="GatherNd",em="Greater",tm="GreaterEqual",nm="Identity",rm="IFFT",sm="Imag",om="IsNan",im="LeakyRelu",am="Less",um="LessEqual",lm="LinSpace",cm="Log",hm="Log1p",dm="LogicalAnd",pm="LogicalNot",fm="LogicalOr",mm="Maximum",gm="MaxPool",ym="MaxPool3D",xm="MaxPoolWithArgmax",bm="Mean",vm="Minimum",wm="MirrorPad",Cm="Multinomial",_m="Multiply",km="NotEqual",Em="NonMaxSuppressionV3",Sm="NonMaxSuppressionV4",Tm="NonMaxSuppressionV5",Im="OnesLike",Nm="OneHot",$m="Pack",Rm="PadV2",Am="Prelu",Om="Prod",Fm="Range",Dm="Real",Pm="Reciprocal",Mm="Relu",Lm="Reshape",Bm="ResizeNearestNeighbor",Vm="ResizeBilinear",Um="Relu6",zm="Reverse",Wm="Round",jm="Rsqrt",Hm="ScatterNd",Gm="Select",qm="Selu",Km="Slice",Xm="Sinh",Ym="Sign",Qm="Sigmoid",Zm="Softplus",Jm="Sqrt",eg="SpaceToBatchND",tg="SplitV",ng="Softmax",rg="SparseFillEmptyRows",sg="SparseReshape",og="SparseSegmentMean",ig="SparseSegmentSum",ag="SparseToDense",ug="SquaredDifference",lg="StridedSlice",cg="StringNGrams",hg="StringSplit",dg="StringToHashBucketFast",pg="Sub",fg="Tanh",mg="Tile",gg="TopK",yg="Transform",xg="Transpose",bg="Unique",vg="Unpack",wg="ZerosLike",Cg="Step",_g="FromPixels",kg="RotateWithOffset",Eg="_FusedMatMul",Sg="FusedConv2D",Tg="FusedDepthwiseConv2D",Ig=sf("kernelRegistry",()=>new Map),Ng=sf("gradRegistry",()=>new Map);function $g(e,t){const n=Fg(e,t);return Ig.get(n)}function Rg(e){return Ng.get(e)}function Ag(e){const t=Ig.entries(),n=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[o,i]=s,[a]=o.split("_");a===e&&n.push(i)}return n}function Og(e){const{kernelName:t,backendName:n}=e,r=Fg(t,n);Ig.has(r)&&console.warn(`The kernel '${t}' for backend '${n}' is already registered`),Ig.set(r,e)}function Fg(e,t){return`${t}_${e}`}var Dg=n(80);const Pg=n.n(Dg)()||Dg;function Mg(e){return Pg.fromString(e,!0,16)}const Lg=Mg("c3a5c85c97cb3127"),Bg=Mg("b492b66fbe98f273"),Vg=Mg("9ae16a3b2f90404f");function Ug(e){return e.xor(e.shru(47))}function zg(e,t,n){const r=e.slice(t,t+n);return Pg.fromBytes(Array.from(r),!0,!0)}function Wg(e,t){return zg(e,t,8)}function jg(e,t){return zg(e,t,4)}function Hg(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function Gg(e,t,n=Mg("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let s=t.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function qg(e,t,n,r){return function(e,t,n,r,s,o){s=s.add(e),o=Hg(o.add(s).add(r),21);const i=s;return s=(s=s.add(t)).add(n),o=o.add(Hg(s,44)),[s.add(r),o.add(i)]}(Wg(e,t),Wg(e,t+8),Wg(e,t+16),Wg(e,t+24),n,r)}function Kg(e,t=e.length){const n=Pg.fromNumber(81,!0);if(t<=32)return t<=16?function(e,t=e.length){if(t>=8){const n=Vg.add(2*t),r=Wg(e,0).add(Vg),s=Wg(e,t-8);return Gg(Hg(s,37).mul(n).add(r),Hg(r,25).add(s).mul(n),n)}if(t>=4){const n=Vg.add(2*t);return Gg(jg(e,0).shl(3).add(t),jg(e,t-4),n)}if(t>0){const n=t+(e[t-1]<<2);return Ug(Vg.mul(e[0]+(e[t>>1]<<8)).xor(Lg.mul(n))).mul(Vg)}return Vg}(e,t):function(e,t=e.length){const n=Vg.add(2*t),r=Wg(e,0).mul(Bg),s=Wg(e,8),o=Wg(e,t-8).mul(n),i=Wg(e,t-16).mul(Vg);return Gg(Hg(r.add(s),43).add(Hg(o,30)).add(i),r.add(Hg(s.add(Vg),18)).add(o),n)}(e,t);if(t<=64)return function(e,t=e.length){const n=Vg.add(2*t),r=Wg(e,0).mul(Vg),s=Wg(e,8),o=Wg(e,t-8).mul(n),i=Wg(e,t-16).mul(Vg),a=Hg(r.add(s),43).add(Hg(o,30)).add(i),u=Gg(a,r.add(Hg(s.add(Vg),18)).add(o),n),l=Wg(e,16).mul(n),c=Wg(e,24),h=a.add(Wg(e,t-32)).mul(n),d=u.add(Wg(e,t-24)).mul(n);return Gg(Hg(l.add(c),43).add(Hg(h,30)).add(d),l.add(Hg(c.add(r),18)).add(h),n)}(e,t);let r=n,s=n.mul(Bg).add(113),o=Ug(s.mul(Vg).add(113)).mul(Vg),i=[Pg.UZERO,Pg.UZERO],a=[Pg.UZERO,Pg.UZERO];r=r.mul(Vg).add(Wg(e,0));let u=0;const l=64*(t-1>>6),c=l+(t-1&63)-63;do{r=Hg(r.add(s).add(i[0]).add(Wg(e,u+8)),37).mul(Bg),s=Hg(s.add(i[1]).add(Wg(e,u+48)),42).mul(Bg),r=r.xor(a[1]),s=s.add(i[0]).add(Wg(e,u+40)),o=Hg(o.add(a[0]),33).mul(Bg),i=qg(e,u,i[1].mul(Bg),r.add(a[0])),a=qg(e,u+32,o.add(a[1]),s.add(Wg(e,u+16))),[o,r]=[r,o],u+=64}while(u!==l);const h=Bg.add(o.and(255).shl(1));return u=c,a[0]=a[0].add(t-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),r=Hg(r.add(s).add(i[0]).add(Wg(e,u+8)),37).mul(h),s=Hg(s.add(i[1]).add(Wg(e,u+48)),42).mul(h),r=r.xor(a[1].mul(9)),s=s.add(i[0].mul(9).add(Wg(e,u+40))),o=Hg(o.add(a[0]),33).mul(h),i=qg(e,u,i[1].mul(h),r.add(a[0])),a=qg(e,u+32,o.add(a[1]),s.add(Wg(e,u+16))),[o,r]=[r,o],Gg(Gg(i[0],a[0],h).add(Ug(s).mul(Lg)).add(o),Gg(i[1],a[1],h).add(r),h)}function Xg(e,t){return"string"===t?Zg(e):Yg([e],t)}function Yg(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Ep(e)),ef().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function Qg(){return ef().platform.now()}function Zg(e,t="utf-8"){return t=t||"utf-8",ef().platform.encode(e,t)}function Jg(e,t="utf-8"){return t=t||"utf-8",ef().platform.decode(e,t)}class ey{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new ny)}profileKernel(e,t,n){let r;const s=()=>{r=n()};let o;const i=Qg();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(s);else{s();for(const e of r)e.dataSync();o=Promise.resolve({kernelMs:Qg()-i})}if(ef().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let a=0;a<r.length;a++){const t=r[a];t.data().then(n=>{ty(n,t.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:o.then(e=>e.kernelMs),extraInfo:o.then(e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:o}=e;n.forEach(e=>{Promise.all([e.data(),r,o]).then(n=>{this.logger.logKernelProfile(t,e,n[0],n[1],s,n[2])})})}}function ty(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){const t=e[r];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}class ny{logKernelProfile(e,t,n,r,s,o){const i="number"==typeof r?$p(`${r}ms`,9):r.error,a=$p(e,25),u=t.rank,l=t.size,c=$p(t.shape.toString(),14);let h="";for(const d in s){const e=s[d];if(null!=e){const n=e.shape||t.shape,r=n.length;h+=`${d}: ${r}D ${r>0?n:""} `}}console.log(`%c${a}\t%c${i}\t%c${u}D ${c}\t%c${l}\t%c${h}\t%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function ry(e,t,n,r){const s=Wp(t),o=function(e,t,n,r){const s=Sp(t),o=r[r.length-1],i=new Array(o).fill(0),a=t.length,u="complex64"===n?ay(e):e;if(a>1)for(let l=0;l<s/o;l++){const e=l*o;for(let t=0;t<o;t++)i[t]=Math.max(i[t],sy(u[e+t],0,n).length)}return i}(e,t,n,s),i=t.length,a=iy(e,t,n,s,o),u=["Tensor"];return r&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${i}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(a.map(e=>"    "+e).join("\n")),u.join("\n")}function sy(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:Bp(e)?`'${e}'`:"bool"===n?oy(e):parseFloat(e.toFixed(7)).toString(),$p(r,t)}function oy(e){return 0===e?"false":"true"}function iy(e,t,n,r,s,o=!0){const i="complex64"===n?2:1,a=t[0],u=t.length;if(0===u)return"complex64"===n?[sy(ay(e)[0],0,n)]:"bool"===n?[oy(e[0])]:[e[0].toString()];if(1===u){if(a>20){let t=Array.from(e.slice(0,3*i)),r=Array.from(e.slice((a-3)*i,a*i));return"complex64"===n&&(t=ay(t),r=ay(r)),["["+t.map((e,t)=>sy(e,s[t],n)).join(", ")+", ..., "+r.map((e,t)=>sy(e,s[a-3+t],n)).join(", ")+"]"]}return["["+("complex64"===n?ay(e):Array.from(e)).map((e,t)=>sy(e,s[t],n)).join(", ")+"]"]}const l=t.slice(1),c=r.slice(1),h=r[0]*i,d=[];if(a>20){for(let t=0;t<3;t++){const r=t*h;d.push(...iy(e.slice(r,r+h),l,n,c,s,!1))}d.push("...");for(let t=a-3;t<a;t++){const r=t*h;d.push(...iy(e.slice(r,r+h),l,n,c,s,t===a-1))}}else for(let m=0;m<a;m++){const t=m*h;d.push(...iy(e.slice(t,t+h),l,n,c,s,m===a-1))}const p=2===u?",":"";d[0]="["+d[0]+p;for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=",\n";for(let m=2;m<u;m++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(o?"":f),d}function ay(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class uy{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Sp(e),null!=n){const e=n.length;Cp(e===this.size,()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Dp(t,this.size),this.strides=Wp(e)}set(e,...t){0===t.length&&(t=[0]),Cp(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t])throw new Error(`Requested out of range element at ${e}.   Buffer shape=${this.shape}`);t++}let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return ly().makeTensor(this.values,this.shape,this.dtype)}}let ly=null,cy=null,hy=null;class dy{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Sp(e),this.strides=Wp(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var e=this;return mp(function*(){const t=yield e.data();return cy.buffer(e.shape,e.dtype,t)})()}bufferSync(){return cy.buffer(this.shape,this.dtype,this.dataSync())}array(){var e=this;return mp(function*(){const t=yield e.data();return Hp(e.shape,t,"complex64"===e.dtype)})()}arraySync(){return Hp(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var e=this;return mp(function*(){e.throwIfDisposed();const t=ly().read(e.dataId);if("string"===e.dtype){const e=yield t;try{return e.map(e=>Jg(e))}catch(n){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t})()}dataSync(){this.throwIfDisposed();const e=ly().readSync(this.dataId);if("string"===this.dtype)try{return e.map(e=>Jg(e))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}bytes(){var e=this;return mp(function*(){e.throwIfDisposed();const t=yield ly().read(e.dataId);return"string"===e.dtype?t:new Uint8Array(t.buffer)})()}dispose(){this.isDisposed||(ly().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return cy.print(this,e)}clone(){return this.throwIfDisposed(),cy.clone(this)}toString(e=!1){return ry(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),cy.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),ly().makeVariable(this,e,t,n)}}Object.defineProperty(dy,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),sf("Tensor",()=>dy);class py extends dy{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Tp(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);ly().disposeTensor(this),this.dataId=e.dataId,ly().incRef(this,null)}dispose(){ly().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(py,Symbol.hasInstance,{value:e=>e instanceof dy&&null!=e.assign&&e.assign instanceof Function});var fy=(()=>(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(fy||(fy={})),fy))(),my=(()=>(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(my||(my={})),my))(),gy=(()=>(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(gy||(gy={})),gy))(),yy=(()=>(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(yy||(yy={})),yy))();const xy={float32:gy,int32:fy,bool:my,complex64:yy};function by(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return xy[e][t]}function vy(e){return by(e,"int32")}function wy(e,t){if(e.dtype===t.dtype)return[e,t];const n=by(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function Cy(e){const t=[];return _y(e,t,new Set),t}function _y(e,t,n){if(null==e)return;if(e instanceof dy)return void t.push(e);if(r=e,!Array.isArray(r)&&"object"!=typeof r)return;var r;const s=e;for(const o in s){const e=s[o];n.has(e)||(n.add(e),_y(e,t,n))}}function ky(e){return null!=e.kernelName}class Ey{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}let Sy=(()=>{class e{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Ey}ready(){var e=this;return mp(function*(){if(null!=e.pendingBackendInit)return e.pendingBackendInit.then(()=>{});if(null!=e.backendInstance)return;const t=e.getSortedBackends();for(let n=0;n<t.length;n++){const r=t[n];if(yield e.initializeBackend(r).success)return void(yield e.setBackend(r))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(console.warn(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}setBackend(e){var t=this;return mp(function*(){if(null==t.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(t.backendName=e,null==t.registry[e]){t.backendInstance=null;const{success:n,asyncInit:r}=t.initializeBackend(e);if(!(r?yield n:n))return!1}return t.backendInstance=t.registry[e],t.setupRegisteredKernels(),t.profiler=new ey(t.backendInstance),!0})()}setupRegisteredKernels(){Ag(this.backendName).forEach(e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Ag(e).forEach(t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof xp||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then(n=>!(t<this.pendingBackendInitId||(this.registry[e]=n,this.pendingBackendInit=null,0))).catch(n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${e} failed`),console.warn(n.stack||n.message)),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return console.warn(`Initialization of backend ${e} failed`),console.warn(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,s=this.readSync(t),o=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun(()=>this.startScope(r),()=>this.endScope(n),()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(r){throw t(),r}}nextTensorId(){return e.nextTensorId++}nextVariableId(){return e.nextVariableId++}clone(e){const t=Iy.runKernel(nm,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[t],e=>({x:()=>Iy.runKernel(Cf,{x:e},{dtype:"float32"})}),[],{}),t}runKernel(e,t,n){if(null==$g(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let s=0;n.forEach(e=>{s+="complex64"===e.dtype?3:1});const o=r-t-s-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),s=this.state.numBytes,o=this.state.numTensors;let i,a;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const u=ky(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(ky(e)){const{kernelName:t,inputs:s,attrs:o}=e,u=$g(t,this.backendName);Cp(null!=u,()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`),i=()=>{const e=this.backend.numDataIds();a=u.kernelFunc({inputs:s,attrs:o,backend:this.backend});const i=Array.isArray(a)?a:[a];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,i);const l=i.map(e=>{if(null!=e.rank)return e;const{dataId:t,shape:n,dtype:r}=e;return this.makeTensorFromDataId(t,n,r)});if(r){const e=this.getTensorsForGradient(t,s,l);n=this.saveTensorsForBackwardMode(e)}return l}}else{const{forwardFunc:t}=e,s=e=>{r&&(n=e.map(e=>this.keep(this.clone(e))))};i=()=>{const e=this.backend.numDataIds();a=this.tidy(()=>t(this.backend,s));const n=Array.isArray(a)?a:[a];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,e,n),n}}const{inputs:l,attrs:c}=e,h=ky(e)?null:e.backwardsFunc;let d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(u,l,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs):t=i()}),r&&this.addTapeNode(u,l,t,h,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map(e=>null!=l[e]?l[e].shape:null),outputShapes:t.map(e=>e.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(a)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(e=>this.keep(this.clone(e)))}getTensorsForGradient(e,t,n){const r=Rg(e);if(null!=r){const e=r.inputsToSave||[],s=r.outputsToSave||[];let o;r.saveAllInputs?(Cp(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(t).map(e=>t[e])):o=e.map(e=>t[e]);const i=n.filter((e,t)=>s[t]);return o.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");r=r||this.backend;let s=e;"string"===(n=n||"float32")&&Bp(e[0])&&(s=e.map(e=>Zg(e)));const o=r.write(s,t,n),i=new dy(t,n,o,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){const e=this.state.tensorInfo.get(o),t=function(e){if(null==e)return 0;let t=0;return e.forEach(e=>t+=e.length),t}(s);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){const s=new dy(t,n=n||"float32",e,this.nextTensorId());return this.trackTensor(s,r),s}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const s=new py(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*Lp(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof py||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*Lp(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[e])}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){var t=this;return mp(function*(){t.state.profiling=!0;const n=t.state.numBytes,r=t.state.numTensors;t.state.activeProfile.kernels=[],t.state.activeProfile.result=yield e(),t.state.profiling=!1,t.state.activeProfile.peakBytes=Math.max(...t.state.activeProfile.kernels.map(e=>e.totalBytesSnapshot)),t.state.activeProfile.newBytes=t.state.numBytes-n,t.state.activeProfile.newTensors=t.state.numTensors-r;for(const e of t.state.activeProfile.kernels)e.kernelTimeMs=yield e.kernelTimeMs,e.extraInfo=yield e.extraInfo;return t.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,s,o){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},a=Rg(e);null!=a&&(r=a.gradFunc),null!=r&&(i.gradient=e=>(e=e.map((e,t)=>{if(null==e){const e=n[t],r=qp(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e}),r(e.length>1?e:e[0],s,o))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Cy(e),n=new Set(t.map(e=>e.id));for(let s=0;s<this.state.activeScope.track.length;s++){const e=this.state.activeScope.track[s];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(e=>{e.kept||e.scopeId!==r.id||this.track(e)})}gradients(e,t,n,r=!1){if(Cp(t.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));Cp(s instanceof dy,()=>"The result y returned by f() must be a tensor.");const o=function(e,t,n){const r={},s={};for(let u=0;u<t.length;u++)r[t[u].id]=!0;for(let u=0;u<e.length;u++){const n=e[u],o=n.inputs;for(const e in o){const i=o[e];let a=!1;for(let e=0;e<t.length;e++)if(r[i.id]){n.outputs.forEach(e=>r[e.id]=!0),a=!0,s[n.id]=!0;break}if(a)break}}const o={};o[n.id]=!0;const i={};for(let u=e.length-1;u>=0;u--){const t=e[u],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(o[t.outputs[e].id]){for(const e in n)o[n[e].id]=!0,i[t.id]=!0;break}}const a=[];for(let u=0;u<e.length;u++){const t=e[u];if(s[t.id]&&i[t.id]){const e={};for(const s in t.inputs){const n=t.inputs[s];r[n.id]&&(e[s]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,a.push(n)}}return a}(this.state.activeTape,t,s);if(!r&&0===o.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const e={};e[s.id]=null==n?function(e){const t=Gp(Sp(e),"float32");return Iy.makeTensor(t,e,"float32")}(s.shape):n,function(e,t,n,r){for(let s=t.length-1;s>=0;s--){const o=t[s],i=[];if(o.outputs.forEach(t=>{const n=e[t.id];i.push(null!=n?n:null)}),null==o.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const a=o.gradient(i);for(const t in o.inputs){if(!(t in a))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(a)}.`);const s=n(()=>a[t]());if("float32"!==s.dtype)throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${s.dtype}'`);const i=o.inputs[t];if(!Tp(s.shape,i.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${t}' has shape '${s.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=s;else{const t=e[i.id];e[i.id]=r(t,s),t.dispose()}}}}(e,o,e=>this.tidy(e),Ny);const r=t.map(t=>e[t.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(e=>{for(const t of e.saved)t.dispose()}),this.state.activeTape=null),{value:s,grads:r}})}customGrad(e){return Cp(Up(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{let n;Cp(t.every(e=>e instanceof dy),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const r={};return t.forEach((e,t)=>{r[t]=e}),this.runKernelFunc({forwardFunc:(r,s)=>(n=e(...t,s),Cp(n.value instanceof dy,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),Cp(Up(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),backwardsFunc:(e,r)=>{const s=n.gradFunc(e,r),o=Array.isArray(s)?s:[s];Cp(o.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),Cp(o.every(e=>e instanceof dy),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const i={};return o.forEach((e,t)=>{i[t]=()=>e}),i},inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}time(e){var t=this;return mp(function*(){const n=Qg(),r=yield t.backend.time(e);return r.wallMs=Qg()-n,r})()}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Ey;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return e.nextTensorId=0,e.nextVariableId=0,e})();function Ty(){const e=rf();if(null==e._tfengine){const t=new Zp(e);e._tfengine=new Sy(t)}return nf=e._tfengine.ENV,ly=()=>e._tfengine,e._tfengine}const Iy=Ty();function Ny(e,t){return Iy.runKernel(uf,{a:e,b:t})}function $y(e){if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Ry(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const Ay=ef();function Oy(e,t){let n=e;if(Mp(e))return"string"===t?[]:[e.length];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||Mp(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&ef().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Fy(e,r,[]),r}function Fy(e,t,n){if(n=n||[],!Array.isArray(e)&&!Mp(e))return void Cp(0===t.length,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);Cp(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),Cp(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);const r=t.slice(1);for(let s=0;s<e.length;++s)Fy(e[s],r,n.concat(s))}function Dy(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function Py(e,t,n,r="numeric"){if(e instanceof dy)return Dy(r,e.dtype,t,n),e;let s=Vp(e);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),Dy(r,s,t,n),null==e||!Mp(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${null==e?"null":e.constructor.name}'`);const o=Oy(e,s);Mp(e)||Array.isArray(e)||(e=[e]);const i="string"!==s?Yg(e,s):Ep(e,[],!0);return Iy.makeTensor(i,o,s)}function My(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((e,s)=>Py(e,`${t}[${s}]`,n,r))}function Ly(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const s=(...e)=>{Iy.startScope(n);try{const t=r(...e);return Qp(t)&&console.error("Cannot return a Promise inside of tidy."),Iy.endScope(t),t}catch(t){throw Iy.endScope(null),t}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}Ay.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),Ay.registerFlag("IS_BROWSER",()=>Ry()),Ay.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),Ay.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),Ay.registerFlag("PROD",()=>!1),Ay.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Ay.getBool("DEBUG")),Ay.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),Ay.registerFlag("IS_TEST",()=>!1),Ay.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0),Ay.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);const By=Ly({complex_:function(e,t){const n=Py(e,"real","complex"),r=Py(t,"imag","complex");return _p(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`),Iy.runKernel(Ef,{real:n,imag:r})}});function Vy(e,t,n,r){if(null==r&&(r=Vp(e)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Mp(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Kp(t);const e=Sp(t),r=Sp(n);Cp(e===r,()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`);for(let s=0;s<n.length;++s){const e=n[s],r=s!==n.length-1||e!==Sp(t.slice(s));Cp(n[s]===t[s]||!r,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return Mp(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?Yg(e,r):Ep(e,[],!0),Iy.makeTensor(e,t,r)}function Uy(e,t,n){return Vy(e,t,Oy(e,n),n)}const zy={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},Wy="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function jy(e){return Wy?Buffer.byteLength(e):new Blob([e]).size}function Hy(e){if(1===e.length)return e[0];let t=0;e.forEach(e=>{t+=e.byteLength});const n=new Uint8Array(t);let r=0;return e.forEach(e=>{n.set(new Uint8Array(e),r),r+=e.byteLength}),n.buffer}function Gy(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:jy(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:jy(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}function qy(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0==(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{const s=new ArrayBuffer(4*r.length),o=new Uint32Array(s);for(let i=0;i<r.length;i++){const s=r[i];o[i]=e[n[s>>10]+(1023&s)]+t[s>>10]}return new Float32Array(s)}}class Ky{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Ky.instance&&(Ky.instance=new Ky),Ky.instance}static registerSaveRouter(e){Ky.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Ky.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Ky.getHandlers(e,"save")}static getLoadHandlers(e,t){return Ky.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?Ky.getInstance().loadRouters:Ky.getInstance().saveRouters).forEach(t=>{const s=t(e,n);null!==s&&r.push(s)}),r}}const Xy="tensorflowjs",Yy="models_store",Qy="model_info_store";function Zy(){if(!ef().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Jy(e){const t=e.result;t.createObjectStore(Yy,{keyPath:"modelPath"}),t.createObjectStore(Qy,{keyPath:"modelPath"})}let ex=(()=>{class e{constructor(e){if(this.indexedDB=Zy(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){var t=this;return mp(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return t.databaseAction(t.modelPath,e)})()}load(){var e=this;return mp(function*(){return e.databaseAction(e.modelPath)})()}databaseAction(e,t){return new Promise((e,n)=>{const r=this.indexedDB.open(Xy,1);r.onupgradeneeded=()=>Jy(r),r.onsuccess=()=>{const s=r.result;if(null==t){const t=s.transaction(Yy,"readonly"),r=t.objectStore(Yy).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return s.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(s.close(),n(r.error)),t.oncomplete=()=>s.close()}else{const r=Gy(t),o=s.transaction(Qy,"readwrite");let i=o.objectStore(Qy);const a=i.put({modelPath:this.modelPath,modelArtifactsInfo:r});let u;a.onsuccess=()=>{u=s.transaction(Yy,"readwrite");const a=u.objectStore(Yy).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r});a.onsuccess=()=>e({modelArtifactsInfo:r}),a.onerror=e=>{i=o.objectStore(Qy);const t=i.delete(this.modelPath);t.onsuccess=()=>(s.close(),n(a.error)),t.onerror=e=>(s.close(),n(a.error))}},a.onerror=e=>(s.close(),n(a.error)),o.oncomplete=()=>{null==u?s.close():u.oncomplete=()=>s.close()}}},r.onerror=e=>n(r.error)})}}return e.URL_SCHEME="indexeddb://",e})();const tx=e=>{return ef().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(ex.URL_SCHEME)?(t=e.slice(ex.URL_SCHEME.length),new ex(t)):null;var t};Ky.registerSaveRouter(tx),Ky.registerLoadRouter(tx);class nx{constructor(){this.indexedDB=Zy()}listModels(){var e=this;return mp(function*(){return new Promise((t,n)=>{const r=e.indexedDB.open(Xy,1);r.onupgradeneeded=()=>Jy(r),r.onsuccess=()=>{const e=r.result,s=e.transaction(Qy,"readonly"),o=s.objectStore(Qy).getAll();o.onsuccess=()=>{const e={};for(const t of o.result)e[t.modelPath]=t.modelArtifactsInfo;t(e)},o.onerror=t=>(e.close(),n(o.error)),s.oncomplete=()=>e.close()},r.onerror=e=>n(r.error)})})()}removeModel(e){var t=this;return mp(function*(){var n;return e=(n=e).startsWith(ex.URL_SCHEME)?n.slice(ex.URL_SCHEME.length):n,new Promise((n,r)=>{const s=t.indexedDB.open(Xy,1);s.onupgradeneeded=()=>Jy(s),s.onsuccess=()=>{const t=s.result,o=t.transaction(Qy,"readwrite"),i=o.objectStore(Qy),a=i.get(e);let u;a.onsuccess=()=>{if(null==a.result)return t.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const s=i.delete(e),o=()=>{u=t.transaction(Yy,"readwrite");const s=u.objectStore(Yy).delete(e);s.onsuccess=()=>n(a.result.modelArtifactsInfo),s.onerror=e=>r(a.error)};s.onsuccess=o,s.onerror=e=>(o(),t.close(),r(a.error))}},a.onerror=e=>(t.close(),r(a.error)),o.oncomplete=()=>{null==u?t.close():u.oncomplete=()=>t.close()}},s.onerror=e=>r(s.error)})})()}}const rx="/",sx="tensorflowjs_models",ox="info",ix="model_topology",ax="weight_specs",ux="weight_data",lx="model_metadata";function cx(e){return{info:[sx,e,ox].join(rx),topology:[sx,e,ix].join(rx),weightSpecs:[sx,e,ax].join(rx),weightData:[sx,e,ux].join(rx),modelMetadata:[sx,e,lx].join(rx)}}function hx(e){const t=e.split(rx);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(rx)}let dx=(()=>{class e{constructor(e){if(!ef().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=cx(this.modelPath)}save(e){var t=this;return mp(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const r=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),o=Gy(e);try{t.LS.setItem(t.keys.info,JSON.stringify(o)),t.LS.setItem(t.keys.topology,r),t.LS.setItem(t.keys.weightSpecs,s),t.LS.setItem(t.keys.weightData,function(e){if(Wy)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let r=0,s=t.length;r<s;r++)n+=String.fromCharCode(t[r]);return btoa(n)}(e.weightData));const n={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),t.LS.setItem(t.keys.modelMetadata,JSON.stringify(n)),{modelArtifactsInfo:o}}catch(n){throw t.LS.removeItem(t.keys.info),t.LS.removeItem(t.keys.topology),t.LS.removeItem(t.keys.weightSpecs),t.LS.removeItem(t.keys.weightData),t.LS.removeItem(t.keys.modelMetadata),new Error(`Failed to save model '${t.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}})()}load(){var e=this;return mp(function*(){const t=JSON.parse(e.LS.getItem(e.keys.info));if(null==t)throw new Error(`In local storage, there is no model with name '${e.modelPath}'`);if("JSON"!==t.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},r=JSON.parse(e.LS.getItem(e.keys.topology));if(null==r)throw new Error(`In local storage, the topology of model '${e.modelPath}' is missing.`);n.modelTopology=r;const s=JSON.parse(e.LS.getItem(e.keys.weightSpecs));if(null==s)throw new Error(`In local storage, the weight specs of model '${e.modelPath}' are missing.`);n.weightSpecs=s;const o=e.LS.getItem(e.keys.modelMetadata);if(null!=o){const e=JSON.parse(o);n.format=e.format,n.generatedBy=e.generatedBy,n.convertedBy=e.convertedBy,null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer)}const i=e.LS.getItem(e.keys.weightData);if(null==i)throw new Error(`In local storage, the binary weight values of model '${e.modelPath}' are missing.`);return n.weightData=function(e){if(Wy){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}(i),n})()}}return e.URL_SCHEME="localstorage://",e})();const px=e=>{return ef().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(dx.URL_SCHEME)?(t=e.slice(dx.URL_SCHEME.length),new dx(t)):null;var t};Ky.registerSaveRouter(px),Ky.registerLoadRouter(px);class fx{constructor(){Cp(ef().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),Cp("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var e=this;return mp(function*(){const t={},n=sx+rx,r=rx+ox;for(let s=0;s<e.LS.length;++s){const o=e.LS.key(s);o.startsWith(n)&&o.endsWith(r)&&(t[hx(o)]=JSON.parse(e.LS.getItem(o)))}return t})()}removeModel(e){var t=this;return mp(function*(){var n;const r=cx(e=(n=e).startsWith(dx.URL_SCHEME)?n.slice(dx.URL_SCHEME.length):n);if(null==t.LS.getItem(r.info))throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(t.LS.getItem(r.info));return t.LS.removeItem(r.info),t.LS.removeItem(r.topology),t.LS.removeItem(r.weightSpecs),t.LS.removeItem(r.weightData),s})()}}class mx{constructor(){this.managers={}}static getInstance(){return null==mx.instance&&(mx.instance=new mx),mx.instance}static registerManager(e,t){Cp(null!=e,()=>"scheme must not be undefined or null."),e.endsWith("://")&&(e=e.slice(0,e.indexOf("://"))),Cp(e.length>0,()=>"scheme must not be an empty string.");const n=mx.getInstance();Cp(null==n.managers[e],()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){const t=this.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}}class gx{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}}if(ef().get("IS_BROWSER")){ef().setPlatform("browser",new gx);try{mx.registerManager(dx.URL_SCHEME,new fx)}catch(YP){}try{mx.registerManager(ex.URL_SCHEME,new nx)}catch(YP){}}let yx;function xx(e,t="float32",n){return t=t||"float32",Kp(e),new uy(e,t,n)}ef().get("IS_NODE")&&ef().setPlatform("node",new class{constructor(){this.util=n(628),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=ef().global.fetch?ef().global.fetch(e,t):(null==yx&&(yx=n(410)),yx(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}});const bx=Ly({cast_:function(e,t){const n=Py(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");return Iy.runKernel(Cf,{x:n},{dtype:t})}}),vx=Ly({clone_:function(e){const t=Py(e,"x","clone","string_or_numeric");return Iy.runKernel(nm,{x:t})}});function wx(e){return new Promise(e=>setTimeout(e)).then(e)}Ty(),cy={buffer:xx,cast:bx,clone:vx,print:function(e,t=!1){console.log(e.toString(t))}};let Cx=(()=>{class e{constructor(t){if(!ef().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(e.URL_SCHEME)&&(t=t.slice(e.URL_SCHEME.length)),null!=t&&0!==t.length||(t="model"),this.modelTopologyFileName=t+".json",this.weightDataFileName=t+".weights.bin"}save(e){var t=this;return mp(function*(){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:[{paths:["./"+t.weightDataFileName],weights:e.weightSpecs}]};null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer);const s=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),o=null==t.jsonAnchor?document.createElement("a"):t.jsonAnchor;if(o.download=t.modelTopologyFileName,o.href=s,yield wx(()=>o.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const e=null==t.weightDataAnchor?document.createElement("a"):t.weightDataAnchor;e.download=t.weightDataFileName,e.href=n,yield wx(()=>e.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Gy(e)}}})()}}return e.URL_SCHEME="downloads://",e})();function _x(e,t,n,r){!function(e){Cp(null!=e&&Array.isArray(e)&&e.length>0,()=>"promises must be a none empty array")}(e),function(e,t){Cp(e>=0&&e<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`),Cp(t>=0&&t<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`),Cp(t>=e,()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`)}(n=null==n?0:n,r=null==r?1:r);let s=0;return Promise.all(e.map(o=>(o.then(o=>{const i=n+ ++s/e.length*(r-n);return t(i),o}),o)))}function kx(e,t){return Ex.apply(this,arguments)}function Ex(){return(Ex=mp(function*(e,t){null==t&&(t={});const n=null==t.fetchFunc?ef().platform.fetch:t.fetchFunc,r=e.map(e=>n(e,t.requestInit,{isBinary:!0})),s=(null==t.onProgress?yield Promise.all(r):yield _x(r,t.onProgress,0,.5)).map(e=>e.arrayBuffer());return null==t.onProgress?yield Promise.all(s):yield _x(s,t.onProgress,.5,1)})).apply(this,arguments)}Ky.registerSaveRouter(e=>ef().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Cx.URL_SCHEME)?function(e="model"){return new Cx(e)}(e.slice(Cx.URL_SCHEME.length)):null);let Sx=(()=>{class e{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Cp("function"==typeof t.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=ef().platform.fetch,Cp(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&Cp(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}save(e){var t=this;return mp(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:t.DEFAULT_METHOD},t.requestInit);n.body=new FormData;const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:[{paths:["./model.weights.bin"],weights:e.weightSpecs}]};null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),n.body.append("model.json",new Blob([JSON.stringify(r)],{type:"application/json"}),"model.json"),null!=e.weightData&&n.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const s=yield t.fetch(t.path,n);if(s.ok)return{modelArtifactsInfo:Gy(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)})()}load(){var e=this;return mp(function*(){const t=yield e.fetch(e.path,e.requestInit);if(!t.ok)throw new Error(`Request to ${e.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=yield t.json()}catch(f){let t=`Failed to parse model JSON of response from ${e.path}.`;throw e.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const r=n.modelTopology,s=n.weightsManifest,o=n.generatedBy,i=n.convertedBy,a=n.format,u=n.signature,l=n.userDefinedMetadata;if(null==r&&null==s)throw new Error(`The JSON from HTTP path ${e.path} contains neither model topology or manifest for weights.`);let c,h;if(null!=s){const t=yield e.loadWeights(s);[c,h]=t}const d={modelTopology:r,weightSpecs:c,weightData:h,generatedBy:o,convertedBy:i,format:a};null!=u&&(d.signature=u),null!=l&&(d.userDefinedMetadata=l);const p=n.modelInitializer;return p&&(d.modelInitializer=p),d})()}loadWeights(e){var t=this;return mp(function*(){const n=Array.isArray(t.path)?t.path[1]:t.path,[r,s]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?");return[e.substring(0,t)+"/",n>t?e.substring(n):""]}(n),o=t.weightPathPrefix||r,i=[];for(const t of e)i.push(...t.weights);const a=[],u=[];for(const l of e)for(const e of l.paths)null!=t.weightUrlConverter?u.push(t.weightUrlConverter(e)):a.push(o+e+s);return t.weightUrlConverter&&a.push(...yield Promise.all(u)),[i,Hy(yield kx(a,{requestInit:t.requestInit,fetchFunc:t.fetch,onProgress:t.onProgress}))]})()}}return e.URL_SCHEME_REGEX=/^https?:\/\//,e})();function Tx(e){return null!=e.match(Sx.URL_SCHEME_REGEX)}const Ix=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every(e=>Tx(e)):Tx(e),n)return Nx(e,t)}return null};function Nx(e,t){return new Sx(e,t)}function $x(e,t){return Nx(e,t)}let Rx;Ky.registerSaveRouter(Ix),Ky.registerLoadRouter(Ix);const Ax=Ly({fromPixels_:function(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,o=!1,i=!1,a=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)s=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)o=!0;else if(null!=e.getContext)i=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);a=!0}if(s){const t=2;if(s&&e.readyState<t)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(null!=$g(_g,Iy.backendName))return Iy.runKernel(_g,{pixels:e},{numChannels:t});const[u,l]=s?[e.videoWidth,e.videoHeight]:[e.width,e.height];let c,h;if(i?c=e.getContext("2d").getImageData(0,0,u,l).data:r||n?c=e.data:(o||s||a)&&(null==Rx&&(Rx=document.createElement("canvas").getContext("2d")),Rx.canvas.width=u,Rx.canvas.height=l,Rx.drawImage(e,0,0,u,l),c=Rx.getImageData(0,0,u,l).data),4===t)h=new Int32Array(c);else{const e=u*l;h=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)h[n*t+e]=c[4*n+e]}return function(e,t,n){if(kp(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=Oy(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Vy(e,t,r,n)}(h,[l,u,t],"int32")}});function Ox(e,t,n){const r=e.shape.length;Cp(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),Cp(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)Cp(t[s]+n[s]<=e.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`)}function Fx(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function Dx(e,t,n){const r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function Px(e,t,n,r){const s=[...e];for(let o=s.length;o<r.length;o++)s.push(1);for(let o=0;o<n;o++)0===o?s[t]=1:(s.splice(t,0,1),s.pop());return s}function Mx(e,t,n){return n<=e?n:n-(t-1)}function Lx(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function Bx(e,t,n,r,s,o,i,a,u){const l=e.length;let c=new Array(l),h=new Array(l),d=new Array(l);if(t.length&&n>0){const u=t[0],l=n+1;c=Vx(i,u,l,r,e),h=Ux(a,u,l,s,e),d=Px(o,u,l,e)}else for(let p=0;p<l;p++)c[p]=Wx(i,r,o,e,p,u),h[p]=jx(a,s,o,e,p,u),d[p]=zx(o,p,u);return{begin:c,end:h,strides:d}}function Vx(e,t,n,r,s){const o=[...s],i=Lx(n,t);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=0;else{const s=Mx(t,n,a);let i=r[s];e&1<<s&&(i=0),o[a]=i}return o}function Ux(e,t,n,r,s){const o=[...s],i=Lx(n,t);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=Number.MAX_SAFE_INTEGER;else{const s=Mx(t,n,a);let i=r[s];e&1<<s&&(i=Number.MAX_SAFE_INTEGER),o[a]=i}for(let a=0;a<o.length;a++){const e=s[a];o[a]<0&&(o[a]+=e),o[a]=vp(0,o[a],s[a])}return o}function zx(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function Wx(e,t,n,r,s,o){let i=t[s];(e&1<<s||o&1<<s||null==i)&&(i=(n[s]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const a=r[s];return i<0&&(i+=a),i=vp(0,i,a-1),i}function jx(e,t,n,r,s,o){let i=t[s];const a=n[s]||1;(e&1<<s||o&1<<s||null==i)&&(i=a>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const u=r[s];return i<0&&(i+=u),i=a>0?vp(0,i,u):vp(-1,i,u-1),i}function Hx(e,t,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function Gx(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function qx(e,t,n){let r;const s=e.shape.length;let o;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach(e=>{Cp(-1!==e,()=>"slice() does not support negative begin indexing.")}),o=null==n?new Array(s).fill(-1):"number"==typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,o=o.map((t,n)=>t>=0?t:(Cp(-1===t,()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`),e.shape[n]-r[n])),[r,o]}function Kx(e,t,n,r,s,o,i,a,u){let l=t.slice(),c=n.slice(),h=r;null==r&&(h=new Array(l.length));const d=Fx(i);if(d.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(0!==i&&0!==a)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(0!==i&&0!==u)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");const p=e.length-l.length,f=Fx(a),m=e.slice();f.forEach(e=>{l[e]=0,c[e]=1,m.splice(e,0,1)});const{begin:g,end:y,strides:x}=Bx(m,d,p,l,c,h,s,o,i);l=g,c=y,h=x;const b=Fx(u);b.forEach(e=>{c[e]=l[e]+1,h[e]=1});const v=Dx(l,c,h),w=v.filter((e,t)=>-1===b.indexOf(t));return{nonStrided:h.every(e=>1===e),$begin:l,$end:c,$strides:h,size:v,newShape:m,outShape:w}}const Xx=Ly({add_:function(e,t){let n=Py(e,"a","add"),r=Py(t,"b","add");return[n,r]=wy(n,r),Iy.runKernel(uf,{a:n,b:r})}}),Yx=Ly({argMax_:function(e,t=0){const n=Py(e,"x","argMax");return Iy.runKernel(cf,{x:n},{axis:t})}}),Qx=Ly({clipByValue_:function(e,t,n){const r=Py(e,"x","clipByValue");return Cp(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),Iy.runKernel(kf,{x:r},{clipValueMin:t,clipValueMax:n})}}),Zx=Ly({concat_:function(e,t=0){Cp(e.length>=1,()=>"Pass at least one tensor to concat");const n=My(e,"tensors","concat","string_or_numeric");return"complex64"===n[0].dtype&&n.forEach(e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)}),1===n.length?vx(n[0]):Iy.runKernel(Tf,n,{axis:t})}}),Jx=Ly({floorDiv_:function(e,t){let n=Py(e,"a","floorDiv"),r=Py(t,"b","floorDiv");return[n,r]=wy(n,r),Iy.runKernel(Yf,{a:n,b:r})}}),eb=Ly({div_:function(e,t){let n=Py(e,"a","div"),r=Py(t,"b","div");return[n,r]=wy(n,r),"int32"===n.dtype&&"int32"===r.dtype?Jx(n,r):Iy.runKernel(Uf,{a:n,b:r},{})}}),tb=Ly({exp_:function(e){const t=Py(e,"x","exp");return Iy.runKernel(jf,{x:t})}}),nb=Ly({expandDims_:function(e,t=0){const n=Py(e,"x","expandDims","string_or_numeric");return Cp(t<=n.rank,()=>"Axis must be <= rank of the tensor"),Iy.runKernel(Hf,{input:n},{dim:t})}}),rb=Ly({mul_:function(e,t){let n=Py(e,"a","mul"),r=Py(t,"b","mul");return[n,r]=wy(n,r),Iy.runKernel(_m,{a:n,b:r})}}),sb=Ly({reshape_:function(e,t){const n=Py(e,"x","reshape","string_or_numeric");return Iy.runKernel(Lm,{x:n},{shape:t})}});function ob(e,t){if((Mp(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Mp(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Vy(e,[],[],t)}const ib=Ly({sigmoid_:function(e){const t=Py(e,"x","sigmoid");return Iy.runKernel(Qm,{x:t})}}),ab=Ly({slice_:function(e,t,n){const r=Py(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");return Iy.runKernel(Km,{x:r},{begin:t,size:n})}}),ub=Ly({squeeze_:function(e,t){const n=Py(e,"x","squeeze");return sb(n,Op(n.shape,t).newShape)}}),lb=Ly({stack_:function(e,t=0){const n=My(e,"tensors","stack","string_or_numeric");return Cp(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&Cp(t<=n[0].rank,()=>"Axis must be <= rank of the tensor"),Iy.runKernel($m,n,{axis:t})}}),cb=Ly({sub_:function(e,t){let n=Py(e,"a","sub"),r=Py(t,"b","sub");return[n,r]=wy(n,r),Iy.runKernel(pg,{a:n,b:r})}});function hb(e,t){kp(e);const n=Oy(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Vy(e,null,n,t)}function db(e,t,n){if(kp(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Oy(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Vy(e,t,r,n)}const pb=Ly({unstack_:function(e,t=0){const n=Py(e,"x","unstack","string_or_numeric");return Cp(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`),Iy.runKernel(vg,{value:n},{axis:t})}});function fb(e,t="float32"){if("complex64"===t){const t=fb(e,"float32"),n=fb(e,"float32");return By(t,n)}const n=qp(Sp(e),t);return Iy.makeTensor(n,e,t)}const mb=Ly({imag_:function(e){const t=Py(e,"input","imag");return Iy.runKernel(sm,{input:t})}}),gb=Ly({real_:function(e){const t=Py(e,"input","real");return Iy.runKernel(Dm,{input:t})}}),yb=Ly({split_:function(e,t,n=0){const r=Py(e,"x","split");return Iy.runKernel(tg,{x:r},{numOrSizeSplits:t,axis:n})}}),xb=Ly({zerosLike_:function(e){const t=Py(e,"x","zerosLike");return Iy.runKernel(wg,{x:t})}}),bb=Ly({fft_:function(e){return Cp("complex64"===e.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`),Iy.runKernel("FFT",{input:e})}}),vb=Ly({rfft_:function(e,t){Cp("float32"===e.dtype,()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1];const r=e.size/n;let s;if(null!=t&&t<n){const r=e.shape.map(e=>0),o=e.shape.map(e=>e);o[e.shape.length-1]=t,s=ab(e,r,o),n=t}else if(null!=t&&t>n){const r=e.shape.map(e=>e);r[e.shape.length-1]=t-n,s=Zx([e,fb(r)],e.shape.length-1),n=t}else s=e;const o=xb(s),i=sb(By(s,o),[r,n]),a=bb(i),u=Math.floor(n/2)+1,l=gb(a),c=mb(a),h=yb(l,[u,n-u],l.shape.length-1),d=yb(c,[u,n-u],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=u,sb(By(h[0],d[0]),p)}}),wb=Ly({ifft_:function(e){return Cp("complex64"===e.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`),Iy.runKernel(rm,{input:e})}}),Cb=Ly({reverse_:function(e,t){const n=Py(e,"x","reverse");return Iy.runKernel(zm,{x:n},{dims:t})}}),_b=Ly({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const s=sb(e,[n,t]);r=wb(s)}else{const s=[n,2*(t-1)],o=sb(gb(e),[n,t]),i=sb(mb(e),[n,t]),a=Cb(ab(o,[0,1],[n,t-2]),1),u=rb(Cb(ab(i,[0,1],[n,t-2]),1),ob(-1)),l=Zx([o,a],1),c=Zx([i,u],1),h=sb(By(l,c),[s[0],s[1]]);r=wb(h)}if(r=gb(r),3===e.rank&&0!==e.shape[0]){const t=r,n=e.shape[0];r=sb(r,[n,r.shape[0]/n,r.shape[1]]),t.dispose()}return r}});function kb(e,t,n){const r=1-e%2,s=new Float32Array(e);for(let o=0;o<e;++o){const i=2*Math.PI*o/(e+r-1);s[o]=t-n*Math.cos(i)}return hb(s,"float32")}Ly({hammingWindow_:function(e){return kb(e,.54,.46)}});const Eb=Ly({hannWindow_:function(e){return kb(e,.5,.5)}});function Sb(e,t,n){return Iy.runKernel(qf,{},{shape:e,value:t,dtype:n})}const Tb=Ly({frame_:function(e,t,n,r=!1,s=0){let o=0;const i=[];for(;o+t<=e.size;)i.push(ab(e,o,t)),o+=n;if(r)for(;o<e.size;){const r=o+t-e.size,a=Zx([ab(e,o,t-r),Sb([r],s)]);i.push(a),o+=n}return 0===i.length?db([],[0,t]):sb(Zx(i),[i.length,t])}});Ly({stft_:function(e,t,n,r,s=Eb){null==r&&(r=Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2)))));const o=Tb(e,t,n),i=rb(o,s(t));return vb(i,r)}});const Ib=Ly({cropAndResize_:function(e,t,n,r,s="bilinear",o=0){const i=Py(e,"image","cropAndResize"),a=Py(t,"boxes","cropAndResize","float32"),u=Py(n,"boxInd","cropAndResize","int32"),l=a.shape[0];return Cp(4===i.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),Cp(2===a.rank&&4===a.shape[1],()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${a.shape}.`),Cp(1===u.rank&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${a.shape}.`),Cp(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),Cp(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),Cp("bilinear"===s||"nearest"===s,()=>`method must be bilinear or nearest, but was ${s}`),Iy.runKernel(Ff,{image:i,boxes:a,boxInd:u},{method:s,extrapolationValue:o,cropSize:r})}}),Nb=Ly({flipLeftRight_:function(e){const t=Py(e,"image","flipLeftRight","float32");return Cp(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),Iy.runKernel(Kf,{image:t},{})}}),$b=Ly({rotateWithOffset_:function(e,t,n=0,r=.5){const s=Py(e,"image","rotateWithOffset","float32");return Cp(4===s.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`),Iy.runKernel(kg,{image:s},{radians:t,fillValue:n,center:r})}});function Rb(e,t,n,r,s,o){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==o&&(o=0);const i=e.shape[0];return n=Math.min(n,i),Cp(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),Cp(2===e.rank,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),Cp(4===e.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),Cp(1===t.rank,()=>"scores must be a 1D tensor"),Cp(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),Cp(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}const Ab=Ly({nonMaxSuppression_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const o=Py(e,"boxes","nonMaxSuppression"),i=Py(t,"scores","nonMaxSuppression"),a=Rb(o,i,n,r,s);return Iy.runKernel(Em,{boxes:o,scores:i},{maxOutputSize:n=a.maxOutputSize,iouThreshold:r=a.iouThreshold,scoreThreshold:s=a.scoreThreshold})}});function Ob(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,s=e.length,o=0,i=!1;for(;r<s;){o=r+(s-r>>>1);const a=n(t,e[o]);a>0?r=o+1:(s=o,i=!a)}return i?r:-r-1}(e,t,n||Fb)}(e,t,n);e.splice(r<0?-(r+1):r,0,t)}function Fb(e,t){return e>t?1:e<t?-1:0}function Db(e,t,n,r,s){return Lb(e,t,n,r,s,0)}function Pb(e,t,n,r,s,o){return Lb(e,t,n,r,s,0,!1,o,!0)}function Mb(e,t,n,r,s,o){return Lb(e,t,n,r,s,o,!0)}function Lb(e,t,n,r,s,o,i=!1,a=!1,u=!1){const l=[];for(let g=0;g<t.length;g++)t[g]>s&&l.push({score:t[g],boxIndex:g,suppressBeginIndex:0});l.sort(Ub);const c=o>0?-.5/o:0,h=[],d=[];for(;h.length<n&&l.length>0;){const t=l.pop(),{score:n,boxIndex:o,suppressBeginIndex:i}=t;if(n<s)break;let a=!1;for(let u=h.length-1;u>=i;--u){const n=Bb(e,o,h[u]);if(n>=r){a=!0;break}if(t.score=t.score*Vb(r,c,n),t.score<=s)break}t.suppressBeginIndex=h.length,a||(t.score===n?(h.push(o),d.push(t.score)):t.score>s&&Ob(l,t,Ub))}const p=h.length,f=n-p;a&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return i&&(m.selectedScores=d),u&&(m.validOutputs=p),m}function Bb(e,t,n){const r=e.subarray(4*t,4*t+4),s=e.subarray(4*n,4*n+4),o=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),p=(a-o)*(u-i),f=(h-l)*(d-c);if(p<=0||f<=0)return 0;const m=Math.max(o,l),g=Math.max(i,c),y=Math.min(a,h),x=Math.min(u,d),b=Math.max(y-m,0)*Math.max(x-g,0);return b/(p+f-b)}function Vb(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function Ub(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}function zb(){return(zb=mp(function*(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const o=Py(e,"boxes","nonMaxSuppressionAsync"),i=Py(t,"scores","nonMaxSuppressionAsync"),a=Rb(o,i,n,r,s);n=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const u=yield Promise.all([o.data(),i.data()]),l=u[0],c=u[1],{selectedIndices:h}=Db(l,c,n,r,s);return o!==e&&o.dispose(),i!==t&&i.dispose(),hb(h,"int32")})).apply(this,arguments)}const Wb=Ly({nonMaxSuppressionWithScore_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=Py(e,"boxes","nonMaxSuppression"),a=Py(t,"scores","nonMaxSuppression"),u=Rb(i,a,n,r,s,o),l=Iy.runKernel(Tm,{boxes:i,scores:a},{maxOutputSize:n=u.maxOutputSize,iouThreshold:r=u.iouThreshold,scoreThreshold:s=u.scoreThreshold,softNmsSigma:o=u.softNmsSigma});return{selectedIndices:l[0],selectedScores:l[1]}}});function jb(){return(jb=mp(function*(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=Py(e,"boxes","nonMaxSuppressionAsync"),a=Py(t,"scores","nonMaxSuppressionAsync"),u=Rb(i,a,n,r,s,o);n=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,o=u.softNmsSigma;const l=yield Promise.all([i.data(),a.data()]),c=l[0],h=l[1],{selectedIndices:d,selectedScores:p}=Mb(c,h,n,r,s,o);return i!==e&&i.dispose(),a!==t&&a.dispose(),{selectedIndices:hb(d,"int32"),selectedScores:hb(p)}})).apply(this,arguments)}const Hb=Ly({nonMaxSuppressionPadded_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=Py(e,"boxes","nonMaxSuppression"),a=Py(t,"scores","nonMaxSuppression"),u=Rb(i,a,n,r,s,null),l=Iy.runKernel(Sm,{boxes:i,scores:a},{maxOutputSize:u.maxOutputSize,iouThreshold:u.iouThreshold,scoreThreshold:u.scoreThreshold,padToMaxOutputSize:o});return{selectedIndices:l[0],validOutputs:l[1]}}});function Gb(){return(Gb=mp(function*(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=Py(e,"boxes","nonMaxSuppressionAsync"),a=Py(t,"scores","nonMaxSuppressionAsync"),u=Rb(i,a,n,r,s,null),l=u.maxOutputSize,c=u.iouThreshold,h=u.scoreThreshold,[d,p]=yield Promise.all([i.data(),a.data()]),{selectedIndices:f,validOutputs:m}=Pb(d,p,l,c,h,o);return i!==e&&i.dispose(),a!==t&&a.dispose(),{selectedIndices:hb(f,"int32"),validOutputs:ob(m,"int32")}})).apply(this,arguments)}const qb=Ly({resizeBilinear_:function(e,t,n=!1,r=!1){const s=Py(e,"images","resizeBilinear");Cp(3===s.rank||4===s.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),Cp(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),Cp(!1===r||!1===n,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;3===s.rank&&(i=!0,o=sb(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,a=Iy.runKernel(Vm,{images:o},{alignCorners:n,halfPixelCenters:r,size:t});return i?sb(a,[a.shape[1],a.shape[2],a.shape[3]]):a}}),Kb=Ly({resizeNearestNeighbor_:function(e,t,n=!1,r=!1){const s=Py(e,"images","resizeNearestNeighbor");Cp(3===s.rank||4===s.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),Cp(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),Cp("float32"===s.dtype||"int32"===s.dtype,()=>"`images` must have `int32` or `float32` as dtype"),Cp(!1===r||!1===n,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;3===s.rank&&(i=!0,o=sb(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,a=Iy.runKernel(Bm,{images:o},{alignCorners:n,halfPixelCenters:r,size:t});return i?sb(a,[a.shape[1],a.shape[2],a.shape[3]]):a}}),Xb=Ly({bincount_:function(e,t,n){const r=Py(e,"x","bincount"),s=Py(t,"weights","bincount");return Cp("int32"===r.dtype,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),Cp(n>=0,()=>`size must be non-negative, but got ${n}.`),Cp(s.size===r.size||0===s.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`),Iy.runKernel(wf,{x:r,weights:s},{size:n})}});function Yb(e,t){const n=e.length,r=[];for(let s=0;s<n;s++){const o=n-1-s,i=e[o]||1;(t[t.length-1-s]||1)>1&&1===i&&r.unshift(o)}return r}function Qb(e,t){const n=[];for(let r=0;r<t.length;r++){const s=e[e.length-r-1],o=t.length-r-1,i=t[o];(null==s||1===s&&i>1)&&n.unshift(o)}return n}function Zb(e,t){const n=[],r=Math.max(e.length,t.length);for(let s=0;s<r;s++){let r=e[e.length-s-1];null==r&&(r=1);let o=t[t.length-s-1];if(null==o&&(o=1),1===r)n.unshift(o);else if(1===o)n.unshift(r);else{if(r!==o)throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`);n.unshift(r)}}return n}const Jb=Ly({lessEqual_:function(e,t){let n=Py(e,"a","lessEqual","string_or_numeric"),r=Py(t,"b","lessEqual","string_or_numeric");return[n,r]=wy(n,r),Zb(n.shape,r.shape),Iy.runKernel(um,{a:n,b:r})}}),ev=Ly({greater_:function(e,t){let n=Py(e,"a","greater","string_or_numeric"),r=Py(t,"b","greater","string_or_numeric");return[n,r]=wy(n,r),Zb(n.shape,r.shape),Iy.runKernel(em,{a:n,b:r})}}),tv=Ly({sum_:function(e,t=null,n=!1){let r=Py(e,"x","sum");return"bool"===r.dtype&&(r=bx(r,"int32")),Iy.runKernel("Sum",{x:r},{axis:t,keepDims:n})}}),nv=Ly({round_:function(e){const t=Py(e,"x","round");return Iy.runKernel(Wm,{x:t})}}),rv=Ly({broadcastTo_:function(e,t){let n=Py(e,"broadcastTo","x");const r=n.shape;if(t.some(e=>!(e>0)||e%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=sb(n,e)}const s=n.shape,o=Array.from(t);for(let i=t.length-1;i>=0;i--)if(s[i]===t[i])o[i]=1;else if(1!==n.shape[i])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);return 0===o.map((e,t)=>e>1?t:-1).filter(e=>e>=0).length?vx(n):Iy.runKernel(mg,{x:n},{reps:o})}}),sv=Ly({where_:function(e,t,n){const r=Py(t,"a","where"),s=Py(n,"b","where"),o=Py(e,"condition","where","bool"),i=Zb(Zb(o.shape,r.shape),s.shape),a=rv(o,i),u=rv(r,i),l=rv(s,i);return Iy.runKernel(Gm,{condition:a,t:u,e:l})}});function ov(e,t,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");return Iy.runKernel(Fm,{},{start:e,stop:t,step:n,dtype:r})}const iv=Ly({threshold_:function(e,t="binary",n=!1,r=.5){const s=Py(e,"image","threshold"),o=s.shape[0]*s.shape[1];let i,a,u,l,c=rb(hb([r]),255);if(Cp(3===s.rank,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),Cp(3===s.shape[2]||1===s.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),Cp("int32"===s.dtype||"float32"===s.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),Cp("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===s.shape[2]){[i,a,u]=yb(s,[1,1,1],-1);const e=rb(i,.2989),t=rb(a,.587),n=rb(u,.114);l=Xx(Xx(e,t),n)}else l=e;"otsu"===t&&(c=function(e,t){let n,r,s,o,i,a,u=hb([-1]),l=hb([0]),c=hb([0]);for(let h=0;h<e.size-1;h++){n=ab(e,0,h+1),r=ab(e,h+1),i=eb(tv(n),t),a=eb(tv(r),t);const d=tv(rb(n,ov(0,n.size)));s=eb(d,tv(n));const p=Sb(r.shape,n.size),f=Xx(ov(0,r.size),p),m=rb(r,f);o=eb(tv(m),tv(r));const g=cb(s,o),y=cb(s,o),x=rb(i,a);c=rb(rb(x,g),y);const b=ev(c,l);l=sv(b,c,l),u=sv(b,hb([h]),u)}return u}(Xb(bx(nv(l),"int32"),Uy([]),256),o));const h=n?Jb(l,c):ev(l,c);return bx(rb(h,255),"int32")}}),av=Ly({transform_:function(e,t,n="nearest",r="constant",s=0,o){const i=Py(e,"image","transform","float32"),a=Py(t,"transforms","transform","float32");return Cp(4===i.rank,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),Cp(2===a.rank&&(a.shape[0]===i.shape[0]||1===a.shape[0])&&8===a.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),Cp(null==o||2===o.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`),Iy.runKernel(yg,{image:i,transforms:a},{interpolation:n,fillMode:r,fillValue:s,outputShape:o})}}),uv=Ly({greaterEqual_:function(e,t){let n=Py(e,"a","greaterEqual","string_or_numeric"),r=Py(t,"b","greaterEqual","string_or_numeric");return[n,r]=wy(n,r),Zb(n.shape,r.shape),Iy.runKernel(tm,{a:n,b:r})}}),lv=Ly({logicalAnd_:function(e,t){const n=Py(e,"a","logicalAnd","bool"),r=Py(t,"b","logicalAnd","bool");return Zb(n.shape,r.shape),Iy.runKernel(dm,{a:n,b:r})}});Ly({bandPart_:function(e,t,n){Cp(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),Cp(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const r=Py(e,"a","bandPart");Cp(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[o,i]=r.shape.slice(-2);if(!(t<=o))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${o}).`);if(!(n<=i))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`);t<0&&(t=o),n<0&&(n=i);const a=sb(ov(0,o,1,"int32"),[-1,1]),u=ov(0,i,1,"int32"),l=cb(a,u),c=lv(Jb(l,ob(+t,"int32")),uv(l,ob(-n,"int32"))),h=fb([o,i],r.dtype);return sb(lb(pb(sb(r,[-1,o,i])).map(e=>sv(c,e,h))),s)}});const cv=Ly({abs_:function(e){const t=Py(e,"x","abs");return Iy.runKernel("complex64"===t.dtype?Sf:"Abs",{x:t})}});function hv(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function dv(e,t,n){const r=e.length+t.length,s=[];let o=0,i=0;for(let a=0;a<r;a++)-1===n.indexOf(a)?s.push(e[o++]):s.push(t[i++]);return s}function pv(e,t){const n=[],r=e.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&n.push(e[s]);return[n,t.map(t=>e[t])]}function fv(e,t){return dv(e,t.map(e=>1),t)}function mv(e,t,n){Cp(hv(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function gv(e,t){if(hv(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach(e=>n.push(e)),n}function yv(e){return e.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function xv(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}const bv=Ly({max_:function(e,t=null,n=!1){const r=Py(e,"x","max");return Iy.runKernel("Max",{x:r},{reductionIndices:t,keepDims:n})}}),vv=Ly({min_:function(e,t=null,n=!1){const r=Py(e,"x","min");return Iy.runKernel("Min",{x:r},{axis:t,keepDims:n})}}),wv=Ly({pow_:function(e,t){let n=Py(e,"base","pow"),r=Py(t,"exp","pow");return[n,r]=wy(n,r),Iy.runKernel("Pow",{a:n,b:r})}}),Cv=Ly({sqrt_:function(e){const t=Py(e,"x","sqrt");return Iy.runKernel(Jm,{x:t})}}),_v=Ly({square_:function(e){const t=Py(e,"x","square");return Iy.runKernel("Square",{x:t},{})}});function kv(e,t,n=null){if(0===e.rank)return cv(e);if(1!==e.rank&&null===n)return kv(sb(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return tv(cv(e),n);if(t===1/0)return bv(cv(e),n);if(t===-1/0)return vv(cv(e),n);if("euclidean"===t||2===t)return Cv(tv(wv(cv(e),ob(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return bv(tv(cv(e),n[0]),n[1]-1);if(t===1/0)return bv(tv(cv(e),n[1]),n[0]);if(t===-1/0)return vv(tv(cv(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return Cv(tv(_v(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const Ev=Ly({norm_:function(e,t="euclidean",n=null,r=!1){const s=kv(e=Py(e,"x","norm"),t,n);let o=s.shape;if(r){const t=Ap(n,e.shape);o=fv(s.shape,t)}return sb(s,o)}});function Sv(){return Iy}function Tv(e,t){return Iy.tidy(e,t)}function Iv(e){Cy(e).forEach(e=>e.dispose())}function Nv(e){return Iy.keep(e)}Ly({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Cp(null!=e&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const n=e[0].shape[0];for(let t=1;t<e.length;++t)Cp(e[t].shape[0]===n,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`)}else t=!0,e=yb(e,e.shape[0],0).map(e=>ub(e,[0]));Cp(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);const n=[],r=e;for(let s=0;s<e.length;++s)n.push(Iy.tidy(()=>{let e=r[s];if(s>0)for(let t=0;t<s;++t){const r=rb(tv(rb(n[t],e)),n[t]);e=cb(e,r)}return eb(e,Ev(e,"euclidean"))}));return t?lb(n,0):n}}),hy=function(e){ef().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};const $v=Ly({tile_:function(e,t){const n=Py(e,"x","tile","string_or_numeric");return Cp(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`),Iy.runKernel(mg,{x:n},{reps:t})}}),Rv=Ly({eye_:function(e,t,n,r="float32"){null==t&&(t=e);const s=xx([e,t],r),o=e<=t?e:t;for(let a=0;a<o;++a)s.set(1,a,a);const i=sb(s.toTensor(),[e,t]);if(null==n)return i;if(1===n.length)return $v(nb(i,0),[n[0],1,1]);if(2===n.length)return $v(nb(nb(i,0),0),[n[0],n[1],1,1]);if(3===n.length)return $v(nb(nb(nb(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}}),Av=Ly({matMul_:function(e,t,n=!1,r=!1){let s=Py(e,"a","matMul"),o=Py(t,"b","matMul");return[s,o]=wy(s,o),Iy.runKernel(bf,{a:s,b:o},{transposeA:n,transposeB:r})}}),Ov=Ly({neg_:function(e){const t=Py(e,"x","neg");return Iy.runKernel("Neg",{x:t})}}),Fv=Ly({transpose_:function(e,t){const n=Py(e,"x","transpose");return null==t&&(t=n.shape.map((e,t)=>t).reverse()),Cp(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`),t.forEach(e=>{Cp(e>=0&&e<n.rank,()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+` but got ${t}`)}),n.rank<=1?n.clone():Iy.runKernel(xg,{x:n},{perm:t})}});function Dv(e,t=!1){return Iy.tidy(()=>{Cp(2===e.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);const n=e.shape[0],r=e.shape[1];let s=Rv(n),o=vx(e);const i=db([[1]],[1,1]);let a=vx(i);const u=n>=r?r:n;for(let e=0;e<u;++e){const t=o,u=a,l=s;[a,o,s]=Iy.tidy(()=>{const t=ab(o,[e,e],[n-e,1]),u=Ev(t),l=ab(o,[e,e],[1,1]),c=sv(ev(l,0),db([[-1]]),db([[1]])),h=cb(l,rb(c,u)),d=eb(t,h);a=1===d.shape[0]?vx(i):Zx([i,ab(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=Ov(eb(Av(c,h),u)),f=ab(o,[e,0],[n-e,r]),m=rb(p,a),g=Fv(a);if(0===e)o=cb(f,Av(m,Av(g,f)));else{const t=cb(f,Av(m,Av(g,f)));o=Zx([ab(o,[0,0],[e,r]),t],0)}const y=Fv(m),x=ab(s,[0,e],[n,s.shape[1]-e]);if(0===e)s=cb(x,Av(Av(x,a),y));else{const t=cb(x,Av(Av(x,a),y));s=Zx([ab(s,[0,0],[n,e]),t],1)}return[a,o,s]}),Iv([t,u,l])}return!t&&n>r&&(s=ab(s,[0,0],[n,r]),o=ab(o,[0,0],[r,r])),[s,o]})}Ly({qr_:function(e,t=!1){if(Cp(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),2===e.rank)return Dv(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce((e,t)=>e*t),r=pb(sb(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],o=[];return r.forEach(e=>{const[n,r]=Dv(e,t);s.push(n),o.push(r)}),[sb(lb(s,0),e.shape),sb(lb(o,0),e.shape)]}}});var Pv=(()=>(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(Pv||(Pv={})),Pv))();const Mv=Ly({mean_:function(e,t=null,n=!1){const r=Py(e,"x","mean");return Iy.runKernel(bm,{x:r},{axis:t,keepDims:n})}}),Lv=Ly({notEqual_:function(e,t){let n=Py(e,"a","notEqual","string_or_numeric"),r=Py(t,"b","notEqual","string_or_numeric");return[n,r]=wy(n,r),Zb(n.shape,r.shape),Iy.runKernel(km,{a:n,b:r})}});function Bv(e,t="float32"){if("complex64"===t){const t=Bv(e,"float32"),n=fb(e,"float32");return By(t,n)}const n=Gp(Sp(e),t);return Iy.makeTensor(n,e,t)}const Vv=Ly({computeWeightedLoss_:function(e,t,n=Pv.SUM_BY_NONZERO_WEIGHTS){const r=Py(e,"losses","computeWeightedLoss");let s=null;null!=t&&(s=Py(t,"weights","computeWeightedLoss"));const o=null==s?r:rb(r,s);if(n===Pv.NONE)return o;if(n===Pv.SUM)return tv(o);if(n===Pv.MEAN){if(null==s)return Mv(o);{const e=r.size/s.size,t=eb(tv(o),tv(s));return e>1?eb(t,ob(e)):t}}if(n===Pv.SUM_BY_NONZERO_WEIGHTS){if(null==s)return eb(tv(o),ob(r.size));{const e=rb(s,Bv(r.shape)),t=bx(tv(Lv(e,ob(0))),"float32");return eb(tv(o),t)}}throw Error(`Unknown reduction: ${n}`)}});Ly({absoluteDifference_:function(e,t,n,r=Pv.SUM_BY_NONZERO_WEIGHTS){const s=Py(e,"labels","absoluteDifference"),o=Py(t,"predictions","absoluteDifference");let i=null;null!=n&&(i=Py(n,"weights","absoluteDifference")),_p(s.shape,o.shape,"Error in absoluteDifference: ");const a=cv(cb(s,o));return Vv(a,i,r)}}),Ly({cosineDistance_:function(e,t,n,r,s=Pv.SUM_BY_NONZERO_WEIGHTS){const o=Py(e,"labels","cosineDistance"),i=Py(t,"predictions","cosineDistance");let a=null;null!=r&&(a=Py(r,"weights","cosineDistance")),_p(o.shape,i.shape,"Error in cosineDistance: ");const u=ob(1),l=cb(u,tv(rb(o,i),n,!0));return Vv(l,a,s)}});const Uv=Ly({relu_:function(e){const t=Py(e,"x","relu");return Iy.runKernel(Mm,{x:t})}});Ly({hingeLoss_:function(e,t,n,r=Pv.SUM_BY_NONZERO_WEIGHTS){let s=Py(e,"labels","hingeLoss");const o=Py(t,"predictions","hingeLoss");let i=null;null!=n&&(i=Py(n,"weights","hingeLoss")),_p(s.shape,o.shape,"Error in hingeLoss: ");const a=ob(1);s=cb(rb(ob(2),s),a);const u=Uv(cb(a,rb(s,o)));return Vv(u,i,r)}});const zv=Ly({minimum_:function(e,t){let n=Py(e,"a","minimum"),r=Py(t,"b","minimum");return[n,r]=wy(n,r),"bool"===n.dtype&&(n=bx(n,"int32"),r=bx(r,"int32")),Zb(n.shape,r.shape),Iy.runKernel(vm,{a:n,b:r})}});Ly({huberLoss_:function(e,t,n,r=1,s=Pv.SUM_BY_NONZERO_WEIGHTS){const o=Py(e,"labels","huberLoss"),i=Py(t,"predictions","huberLoss");let a=null;null!=n&&(a=Py(n,"weights","huberLoss")),_p(o.shape,i.shape,"Error in huberLoss: ");const u=ob(r),l=cv(cb(i,o)),c=zv(l,u),h=cb(l,c),d=Xx(rb(ob(.5),_v(c)),rb(u,h));return Vv(d,a,s)}});const Wv=Ly({log_:function(e){const t=Py(e,"x","log");return Iy.runKernel(cm,{x:t})}});Ly({logLoss_:function(e,t,n,r=1e-7,s=Pv.SUM_BY_NONZERO_WEIGHTS){const o=Py(e,"labels","logLoss"),i=Py(t,"predictions","logLoss");let a=null;null!=n&&(a=Py(n,"weights","logLoss")),_p(o.shape,i.shape,"Error in logLoss: ");const u=ob(1),l=ob(r),c=Ov(rb(o,Wv(Xx(i,l)))),h=rb(cb(u,o),Wv(Xx(cb(u,i),l))),d=cb(c,h);return Vv(d,a,s)}});const jv=Ly({squaredDifference_:function(e,t){let n=Py(e,"a","squaredDifference"),r=Py(t,"b","squaredDifference");return[n,r]=wy(n,r),Zb(n.shape,r.shape),Iy.runKernel(ug,{a:n,b:r},{})}});Ly({meanSquaredError_:function(e,t,n,r=Pv.SUM_BY_NONZERO_WEIGHTS){const s=Py(e,"labels","meanSquaredError"),o=Py(t,"predictions","meanSquaredError");let i=null;null!=n&&(i=Py(n,"weights","meanSquaredError")),_p(s.shape,o.shape,"Error in meanSquaredError: ");const a=jv(s,o);return Vv(a,i,r)}});const Hv=Ly({log1p_:function(e){const t=Py(e,"x","log1p");return Iy.runKernel(hm,{x:t})}});function Gv(e){return Iy.customGrad(e)}Ly({sigmoidCrossEntropy_:function(e,t,n,r=0,s=Pv.SUM_BY_NONZERO_WEIGHTS){let o=Py(e,"multiClassLabels","sigmoidCrossEntropy");const i=Py(t,"logits","sigmoidCrossEntropy");let a=null;if(null!=n&&(a=Py(n,"weights","sigmoidCrossEntropy")),_p(o.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const e=ob(r),t=ob(1),n=ob(.5);o=Xx(rb(o,cb(t,e)),rb(n,e))}const u=function(e,t){const n=Py(e,"labels","sigmoidCrossEntropyWithLogits"),r=Py(t,"logits","sigmoidCrossEntropyWithLogits");_p(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=Uv(r),o=rb(r,n),i=Hv(tb(Ov(cv(r))));return Xx(cb(s,o),i)}(o,i);return Vv(u,a,s)}});const qv=Ly({logSumExp_:function(e,t=null,n=!1){const r=Py(e,"x","logSumExp"),s=Ap(t,r.shape),o=bv(r,s,!0),i=cb(r,o),a=tb(i),u=tv(a,s),l=Wv(u),c=Xx(sb(o,l.shape),l);if(n){const e=fv(c.shape,s);return sb(c,e)}return c}});Ly({softmaxCrossEntropy_:function(e,t,n,r=0,s=Pv.SUM_BY_NONZERO_WEIGHTS){let o=Py(e,"onehotLabels","softmaxCrossEntropy");const i=Py(t,"logits","softmaxCrossEntropy");let a=null;if(null!=n&&(a=Py(n,"weights","softmaxCrossEntropy")),_p(o.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const e=ob(r),t=ob(1),n=ob(o.shape[1]);o=Xx(rb(o,cb(t,e)),eb(e,n))}const u=function(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return Gv((e,t,r)=>{const s=qv(t,[n],!0),o=cb(bx(t,"float32"),s);r([e,o]);const i=Ov(rb(o,e));return{value:tv(i,[n]),gradFunc:(e,t)=>{const[r,s]=t,o=fv(e.shape,[n]);return[rb(sb(e,o),cb(bx(r,"float32"),tb(s))),rb(sb(e,o),cb(tb(s),bx(r,"float32")))]}}})(e,t)}(o,i);return Vv(u,a,s)}});const Kv=Ly({sparseFillEmptyRows_:function(e,t,n,r){const s=Py(e,"indices","sparseFillEmptyRows"),o=Py(t,"values","sparseFillEmptyRows"),i=Py(n,"denseShape","sparseFillEmptyRows"),a=Py(r,"defaultValue","sparseFillEmptyRows",o.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==o.rank)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==a.rank)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const u=Iy.runKernel(rg,{indices:s,values:o,denseShape:i,defaultValue:a});return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}}),Xv=Ly({sparseReshape_:function(e,t,n){const r=Py(e,"inputIndices","sparseReshape"),s=Py(t,"inputShape","sparseReshape"),o=Py(n,"newShape","sparseReshape");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==o.rank)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const i=Iy.runKernel(sg,{inputIndices:r,inputShape:s,newShape:o});return{outputIndices:i[0],outputShape:i[1]}}}),Yv=Ly({sparseSegmentMean_:function(e,t,n){const r=Py(e,"data","sparseSegmentMean"),s=Py(t,"indices","sparseSegmentMean"),o=Py(n,"segmentIds","sparseSegmentMean");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==o.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${o.shape}`);return Iy.runKernel(og,{data:r,indices:s,segmentIds:o})}}),Qv=Ly({sparseSegmentSum_:function(e,t,n){const r=Py(e,"data","sparseSegmentSum"),s=Py(t,"indices","sparseSegmentSum"),o=Py(n,"segmentIds","sparseSegmentSum");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==o.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${o.shape}`);return Iy.runKernel(ig,{data:r,indices:s,segmentIds:o})}}),Zv=Ly({stringNGrams_:function(e,t,n,r,s,o,i,a){const u=Py(e,"data","stringNGrams","string");if("string"!==u.dtype)throw new Error("Data must be of datatype string");if(1!==u.shape.length)throw new Error(`Data must be a vector, saw: ${u.shape}`);const l=Py(t,"dataSplits","stringNGrams");if("int32"!==l.dtype)throw new Error("Data splits must be of datatype int32");const c=Iy.runKernel(cg,{data:u,dataSplits:l},{separator:n,nGramWidths:r,leftPad:s,rightPad:o,padWidth:i,preserveShortSequences:a});return{nGrams:c[0],nGramsSplits:c[1]}}}),Jv=Ly({stringSplit_:function(e,t,n=!0){const r=Py(e,"input","stringSplit","string"),s=Py(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const o=Iy.runKernel(hg,{input:r,delimiter:s},{skipEmpty:n});return{indices:o[0],values:o[1],shape:o[2]}}}),ew=Ly({stringToHashBucketFast_:function(e,t){const n=Py(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");return Iy.runKernel(dg,{input:n},r)}}),tw={flipLeftRight:Nb,resizeNearestNeighbor:Kb,resizeBilinear:qb,rotateWithOffset:$b,cropAndResize:Ib,nonMaxSuppression:Ab,nonMaxSuppressionAsync:function(e,t,n){return zb.apply(this,arguments)},nonMaxSuppressionWithScore:Wb,nonMaxSuppressionWithScoreAsync:function(e,t,n){return jb.apply(this,arguments)},nonMaxSuppressionPadded:Hb,nonMaxSuppressionPaddedAsync:function(e,t,n){return Gb.apply(this,arguments)},threshold:iv,transform:av},nw={sparseFillEmptyRows:Kv,sparseReshape:Xv,sparseSegmentMean:Yv,sparseSegmentSum:Qv},rw={stringNGrams:Zv,stringSplit:Jv,stringToHashBucketFast:ew};function sw(e,t){const n=e[0].length;e.forEach((e,t)=>{Cp(e.length===n,()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`)}),Cp(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=e[0];e.forEach((e,s)=>{for(let o=0;o<n;o++)Cp(o===t||e[o]===r[o],()=>`Error in concat${n}D: Shape of tensors[${s}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function ow(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}function iw(e,t,n,r,s="NHWC",o){return lw(e,[...t,e[3]],n,o,r,null,null,xw(s))}function aw(e,t,n,r,s,o,i="channelsLast"){const[a,u]=dw(t);let l;if("channelsLast"===i)l=[a,u,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);l=[a,u,e[1],e[1]]}return lw(e,l,n,r,s,o,!1,i)}function uw(e,t,n,r,s,o,i="NDHWC"){const[a,u,l]=pw(t);let c,h;if("NDHWC"===i)h="channelsLast",c=[a,u,l,e[4],e[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);h="channelsFirst",c=[a,u,l,e[1],e[1]]}return cw(e,c,n,r,s,!1,h,o)}function lw(e,t,n,r,s,o,i=!1,a="channelsLast"){let[u,l,c,h]=[-1,-1,-1,-1];if("channelsLast"===a)[u,l,c,h]=e;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[u,h,l,c]=e}const[d,p,,f]=t,[m,g]=dw(n),[y,x]=dw(r),b=fw(d,y),v=fw(p,x),{padInfo:w,outHeight:C,outWidth:_}=function(e,t,n,r,s,o,i,a,u){let l,c,h;if("number"==typeof e){l={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const s=function(e,t,n,r,s){null==r&&(r=hw(e,t,n));const o=e[1];return[mw((e[0]-t+2*r)/n+1,s),mw((o-t+2*r)/n+1,s)]}([t,n],o,r,e,a);c=s[0],h=s[1]}else if("same"===e){c=Math.ceil(t/r),h=Math.ceil(n/s);const e=Math.max(0,(c-1)*r+o-t),a=Math.max(0,(h-1)*s+i-n),u=Math.floor(e/2),d=e-u,p=Math.floor(a/2);l={top:u,bottom:d,left:p,right:a-p,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-o+1)/r),h=Math.ceil((n-i+1)/s);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{const d="channelsLast"===u?e[1][0]:e[2][0],p="channelsLast"===u?e[1][1]:e[2][1],f="channelsLast"===u?e[2][0]:e[3][0],m="channelsLast"===u?e[2][1]:e[3][1];l={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=mw((t-o+d+p)/r+1,a),h=mw((n-i+f+m)/s+1,a)}}return{padInfo:l,outHeight:c,outWidth:h}}(s,l,c,m,g,b,v,o,a),k=i?f*h:f;let E;return"channelsFirst"===a?E=[u,k,C,_]:"channelsLast"===a&&(E=[u,C,_,k]),{batchSize:u,dataFormat:a,inHeight:l,inWidth:c,inChannels:h,outHeight:C,outWidth:_,outChannels:k,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:b,effectiveFilterWidth:v,dilationHeight:y,dilationWidth:x,inShape:e,outShape:E,filterShape:t}}function cw(e,t,n,r,s,o=!1,i="channelsLast",a){let[u,l,c,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[u,l,c,h,d]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[u,d,l,c,h]=e}const[p,f,m,,g]=t,[y,x,b]=pw(n),[v,w,C]=pw(r),_=fw(p,v),k=fw(f,w),E=fw(m,C),{padInfo:S,outDepth:T,outHeight:I,outWidth:N}=function(e,t,n,r,s,o,i,a,u,l,c){let h,d,p,f;if("number"==typeof e){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const o=function(e,t,n,r,s,o){null==s&&(s=hw(e,t,r));const i=e[1],a=e[2];return[mw((e[0]-t+2*s)/r+1,o),mw((i-t+2*s)/r+1,o),mw((a-t+2*s)/r+1,o),1]}([t,n,r,1],a,0,s,e,c);d=o[0],p=o[1],f=o[2]}else if("same"===e){d=Math.ceil(t/s),p=Math.ceil(n/o),f=Math.ceil(r/i);const e=(d-1)*s+a-t,c=(p-1)*o+u-n,m=(f-1)*i+l-r,g=Math.floor(e/2),y=e-g,x=Math.floor(c/2),b=c-x,v=Math.floor(m/2);h={top:x,bottom:b,left:v,right:m-v,front:g,back:y,type:"SAME"}}else{if("valid"!==e)throw Error(`Unknown padding parameter: ${e}`);h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((t-a+1)/s),p=Math.ceil((n-u+1)/o),f=Math.ceil((r-l+1)/i)}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(s,l,c,h,y,x,b,_,k,E,a),$=o?g*d:g;let R;return"channelsFirst"===i?R=[u,$,T,I,N]:"channelsLast"===i&&(R=[u,T,I,N,$]),{batchSize:u,dataFormat:i,inDepth:l,inHeight:c,inWidth:h,inChannels:d,outDepth:T,outHeight:I,outWidth:N,outChannels:$,padInfo:S,strideDepth:y,strideHeight:x,strideWidth:b,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:_,effectiveFilterHeight:k,effectiveFilterWidth:E,dilationDepth:v,dilationHeight:w,dilationWidth:C,inShape:e,outShape:R,filterShape:t}}function hw(e,t,n,r=1){const s=fw(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)}function dw(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function pw(e){return"number"==typeof e?[e,e,e]:e}function fw(e,t){return t<=1?e:e+(e-1)*(t-1)}function mw(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function gw(e){const[t,n,r]=dw(e);return 1===t&&1===n&&1===r}function yw(e,t){return gw(e)||gw(t)}function xw(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}const bw=Ly({elu_:function(e){const t=Py(e,"x","elu");return Iy.runKernel("Elu",{x:t})}}),vw=Ly({leakyRelu_:function(e,t=.2){const n=Py(e,"x","leakyRelu");return Iy.runKernel(im,{x:n},{alpha:t})}}),ww=Ly({prelu_:function(e,t){const n=Py(e,"x","prelu"),r=Py(t,"alpha","prelu");return Iy.runKernel(Am,{x:n,alpha:r})}}),Cw=Ly({relu6_:function(e){const t=Py(e,"x","relu6");return Iy.runKernel(Um,{x:t})}}),_w=Ly({step_:function(e,t=0){const n=Py(e,"x","step");return Iy.runKernel(Cg,{x:n},{alpha:t})}});function kw(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return rb(e,_w(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Ew(e,t){let n=t;const r=Qb(e.shape,t.shape);return r.length>0&&(n=tv(n,r)),sb(n,e.shape)}function Sw(e,t,n,r){if("linear"===t)return e;if("relu"===t)return Uv(e);if("elu"===t)return bw(e);if("relu6"===t)return Cw(e);if("prelu"===t)return ww(e,n);if("leakyrelu"===t)return vw(e,r);if("sigmoid"===t)return ib(e);throw new Error(`Unknown fused activation ${t}.`)}const Tw=(e,t)=>!(e>0)||"linear"===t,Iw=30;function Nw(e){return e<=Iw?e:zp(e,Math.floor(Math.sqrt(e)))}function $w(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function Rw(e,t,n,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)s=s.concat([e[r+1]/t[r],t[r]]);s=s.concat(e.slice(n+1))}return s}function Aw(e,t,n=!0){const r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{const n=[],s=[];for(let r=1;r<e;++r)r>=2*t+1||r%2==1?s.push(r):n.push(r);r.push(...n),r.push(0),r.push(...s)}return r}function Ow(e,t,n,r=!0){const s=[];s.push(r?e[0]/n:e[0]*n);for(let o=1;o<e.length;++o)s.push(o<=t.length?r?t[o-1]*e[o]:e[o]/t[o-1]:e[o]);return s}function Fw(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function Dw(e,t,n){const r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}function Pw(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===Sp(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const s=t.shape,o=s[s.length-1];let i=1;for(let h=0;h<s.length-1;++h)i*=s[h];const a=e.shape,u=s.slice();u.pop();let l=1;for(let h=o;h<n;++h)l*=a[h],u.push(a[h]);const c=[...Wp(e.shape).map(e=>e/l),1].slice(0,o);return[u,i,l,c]}function Mw(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(o+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(o+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(o+" update.rank != "+(s+e.length-r));for(let i=0;i<s;++i)if(n.shape[i]!==t.shape[i])throw new Error(o+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-s;++i)if(n.shape[i+s]!==e[i+r])throw new Error(o+` updates.shape[${i+s}] (${n.shape[i+s]}) != shape[${i+s}] (${e[i+s]})`)}function Lw(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}Mw(n,t,e)}function Bw(e,t,n){const r=t.shape.length,s=r>1?t.shape[r-1]:1,o=n.length;let i=1;for(let u=s;u<o;++u)i*=n[u];const a=s<1?1:s;return{sliceRank:s,numUpdates:Sp(t.shape)/a,sliceSize:i,strides:[...Wp(n.slice(0,s)),1],outputSize:Sp(n)}}const Vw=1.7580993408473768,Uw=1.0507009873554805,zw=.3275911,Ww=.254829592,jw=-.284496736,Hw=1.421413741,Gw=-1.453152027,qw=1.061405429;function Kw(...e){ef().getBool("IS_TEST")||console.warn(...e)}function Xw(...e){ef().getBool("IS_TEST")||console.log(...e)}function Yw(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function Qw(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function Zw(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function Jw(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function eC(e,t){return{real:e[2*t],imag:e[2*t+1]}}function tC(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function nC(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){const o=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(o),r[s]=Math.sin(o)}return{real:n,imag:r}}function rC(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}const sC=/->/g;function oC(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(sC,"").length)/"->".length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("->").');const[r,s]=e.split("->");Cp(-1===r.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');const o=r.split(","),i=o.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let h=0;h<s.length;++h){const e=s[h];if(!o.some(t=>-1!==t.indexOf(e)))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===a.indexOf(e)&&a.push(e)}for(let h=0;h<r.length;++h){const e=r[h];-1===a.indexOf(e)&&","!==e&&a.push(e)}const u=new Array(o.length);for(let h=0;h<i;++h){if(new Set(o[h].split("")).size!==o[h].length)throw new Error(`Found duplicate axes in input component ${o[h]}. Support for duplicate axes in input is not implemented yet.`);u[h]=[];for(let e=0;e<o[h].length;++e)u[h].push(a.indexOf(o[h][e]))}const l=a.length,c=[];for(let h=s.length;h<l;++h)c.push(h);return{allDims:a,summedDims:c,idDims:u}}function iC(e,t){let n=new Array(e);n.fill(-1);for(let s=0;s<t.length;++s)n[t[s]]=s;const r=[];for(let s=0;s<e;++s)-1===n[s]&&r.push(s);return n=n.filter(e=>-1!==e),{permutationIndices:n,expandDims:r}}function aC(e,t,n){const r=new Array(e);for(let s=0;s<n.length;++s){const e=n[s].shape;for(let n=0;n<t[s].length;++n)void 0===r[t[s][n]]?r[t[s][n]]=e[n]:Cp(r[t[s][n]]===e[n],()=>`Expected dimension ${r[t[s][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`)}}function uC(e,t){const n=e,r=[];let s=0;0===e.length&&n.push(-1),s=e.length+1;for(let i=0;i<s;++i)r.push([]);const o=[];for(let i=0;i<n.length;++i){const e=cC(t,n[i]);for(const t of e)-1===o.indexOf(t)&&(r[i].push(t),o.push(t))}return{path:n,steps:r}}function lC(e){return e.every((e,t)=>e===t)}function cC(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function hC(e,t,n=0){let r=[];if("number"==typeof t)Cp(e.shape[n]%t==0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{Cp(t.reduce((e,t)=>(-1===t&&(e+=1),e),0)<=1,()=>"There should be only one negative value in split array.");const s=t.indexOf(-1);if(-1!==s){const r=t.reduce((e,t)=>t>0?e+t:e);t[s]=e.shape[n]-r}Cp(e.shape[n]===t.reduce((e,t)=>e+t),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function dC(e,t){let n,r=!1;for(e<=Iw?(n=e,r=!0):n=zp(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=zp(e,n+1);return n}function pC(e,t,n){const r=[],s=e.length;for(let o=0;o<s;o++)r.push(o!==t?e[o]:n);return r}function fC(e,t,n,r){const s=t.shape.length,o=e.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${o}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let h=0;h<r;++h)if(e.shape[h]!==t.shape[h])throw new Error(`x.shape[${h}]: ${e.shape[h]} should be equal to indices.shape[${h}]: ${t.shape[h]}.`);const i=e.shape[n],a=[];let u=1,l=1,c=1;for(let h=0;h<r;++h)a.push(e.shape[h]),u*=e.shape[h];for(let h=r;h<n;h++)a.push(e.shape[h]),l*=e.shape[h];for(let h=r;h<s;h++)a.push(t.shape[h]);for(let h=n+1;h<o;h++)a.push(e.shape[h]),c*=e.shape[h];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:i,outputShape:a}}function mC(e){try{return e.map(e=>Jg(e))}catch(YP){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${YP}`)}}function gC(e){return e.map(e=>Zg(e))}function yC(e,t){const n=[];for(let o=0;o<t.length;o++)t[o]&&n.push(o);const r=xx(e,"int32"),s=xx([n.length,e.length],"int32");for(let o=0;o<n.length;o++){const t=r.indexToLoc(n[o]);s.values.set(t,o*e.length)}return s.toTensor()}var xC,bC=(()=>(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(bC||(bC={})),bC))();!function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(xC||(xC={}));const vC={};function wC(e){return vC[e]}function CC(e,t,n,r,s){const o=t.inputParams[e];if(o&&void 0!==o.inputIndexStart){const e=o.inputIndexStart,i=0===o.inputIndexEnd?void 0:void 0===o.inputIndexEnd?e+1:o.inputIndexEnd;if("tensor"===o.type)return _C(t.inputNames[o.inputIndexStart],n,r,s);if("tensors"===o.type)return t.inputNames.slice(e,i).map(e=>_C(e,n,r,s));const a=_C(t.inputNames.slice(e)[0],n,r,s),u=a.dataSync();return"number"===o.type?u[0]:Hp(a.shape,u)}const i=t.attrParams[e];return i&&i.value}function _C(e,t,n,r){const[s,o]=SC(e);if(null!=r){const e=r.getHashTableHandleByName(s);if(null!=e)return e}const i=n.currentContextIds.find(e=>!!t[EC(s,e)]);return void 0!==i?t[EC(s,i)][o]:void 0}function kC(e,t){const[n,r,s]=SC(e);return[EC(n,t&&t.currentContextId),r,s]}function EC(e,t){return t?`${e}-${t}`:e}function SC(e){const t=e.split(":");if(1===t.length)return[e,0,void 0];const n=3===t.length?t[1]:void 0;return[t[0],Number(t[t.length-1]),n]}function TC(e,t,n){let r=CC("pad",e,t,n);if("explicit"===r){r=CC("explicitPaddings",e,t,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)s[e][0]=r[2*e],s[e][1]=r[2*e+1];return s}return r}function IC(e){return e.kept?e:vx(e)}const NC=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],$C=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],RC=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],AC=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],OC=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],FC=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],DC=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],PC=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],MC=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],LC=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],BC=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],VC=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],UC=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],zC=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],WC=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],jC=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],HC=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],GC=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],qC=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}];class KC{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[i,a,u,l,c,h,d,p,f,m,g,y,x,b,v,w,C,_,k].map(e=>e.json));this.opMappers=e.reduce((e,t)=>(e[t.tfOpName]=t,e),{})}transformGraph(e,t={}){const n=[],r=[],s=[],o=e.node.reduce((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?n.push(e[t.name]):"Const"===t.op?r.push(e[t.name]):null!=t.input&&0!==t.input.length||s.push(e[t.name]),e),{});let i=[];const a=[];let u={},l={};null!=t&&(u=this.mapSignatureEntries(t.inputs),l=this.mapSignatureEntries(t.outputs));const c=Object.keys(o);c.forEach(e=>{const t=o[e];t.inputNames.forEach((e,n)=>{const[r,,s]=kC(e),i=o[r];if(null!=i.outputs){const e=i.outputs.indexOf(s);-1!==e&&(t.inputNames[n]=`${r}:${e}`)}t.inputs.push(i),i.children.push(t)})}),0===Object.keys(l).length?c.forEach(e=>{const t=o[e];0===t.children.length&&a.push(t)}):Object.keys(l).forEach(e=>{const[t]=kC(e),n=o[t];null!=n&&(n.signatureKey=l[e],a.push(n))}),Object.keys(u).length>0?Object.keys(u).forEach(e=>{const[t]=kC(e),n=o[t];n&&(n.signatureKey=u[e],i.push(n))}):i=n;let h={};null!=e.library&&null!=e.library.function&&(h=e.library.function.reduce((e,t)=>(e[t.signature.name]=this.mapFunction(t),e),{}));const d={nodes:o,inputs:i,outputs:a,weights:r,placeholders:n,signature:t,functions:h};return s.length>0&&(d.initNodes=s),d}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){const t=wC(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(e=>e.startsWith("^")?e.substr(1):e),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce((t,n)=>{const r=n.type;let s;switch(n.type){case"string":s=YC(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=YC(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":s=i_(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=i_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":s=ZC(e.attr,n.tfName,n.defaultValue||0),void 0===s&&n.tfDeprecatedName&&(s=ZC(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":s=o_(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=o_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":s=QC(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=QC(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":s=u_(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=u_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":s=s_(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=s_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":s=a_(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=a_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":s=t_(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=t_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":s=n_(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=n_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":s=e_(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=e_(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:s,type:r},t},{})),n}mapFunction(e){const t=e.nodeDef,n=[];let r={};null!=t&&(r=t.reduce((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e),{}));const s=[],o=[];e.signature.inputArg.forEach(e=>{const[t]=kC(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:JC(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,s.push(n),r[t]=n}),Object.keys(r).forEach(e=>{const t=r[e];t.inputNames.forEach((e,n)=>{const[s,,o]=kC(e),i=r[s];if(null!=i.outputs){const e=i.outputs.indexOf(o);-1!==e&&(t.inputNames[n]=`${s}:${e}`)}t.inputs.push(i),i.children.push(t)})});const i=e.ret;e.signature.outputArg.forEach(e=>{const[t,n]=kC(i[e.name]),s=r[t];null!=s&&(s.defaultOutput=n,o.push(s))});const a=this.mapArgsToSignature(e);return{nodes:r,inputs:s,outputs:o,weights:n,placeholders:[],signature:a}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function XC(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=ef().global;if(void 0!==t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function YC(e,t,n,r=!1){const s=e[t];return null!=s?XC(s.s,r):n}function QC(e,t,n){const r=e[t];return r?r.b:n}function ZC(e,t,n){const r=e[t]||{},s=null!=r.i?r.i:null!=r.f?r.f:n;return"number"==typeof s?s:parseInt(s,10)}function JC(e){switch("string"==typeof e&&(e=bC[e]),e){case bC.DT_FLOAT:return"float32";case bC.DT_INT32:case bC.DT_INT64:case bC.DT_INT8:case bC.DT_UINT8:return"int32";case bC.DT_BOOL:return"bool";case bC.DT_DOUBLE:return"float32";case bC.DT_STRING:return"string";default:return null}}function e_(e,t,n){const r=e[t];return r&&r.func?r.func.name:n}function t_(e,t,n){const r=e[t];return r&&r.type?JC(r.type):n}function n_(e,t,n){const r=e[t];return r&&r.list&&r.list.type?r.list.type.map(e=>JC(e)):n}function r_(e){if(!e.unknownRank)return null!=e.dim?e.dim.map(e=>"number"==typeof e.size?e.size:parseInt(e.size,10)):[]}function s_(e,t,n){const r=e[t];return r&&r.shape?r_(r.shape):n}function o_(e,t,n){const r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(e=>"number"==typeof e?e:parseInt(e,10)):n}function i_(e,t,n,r=!1){const s=e[t];return s&&s.list&&s.list.s?s.list.s.map(e=>XC(e,r)):n}function a_(e,t,n){const r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map(e=>r_(e)):n}function u_(e,t,n){const r=e[t];return r&&r.list&&r.list.b?r.list.b:n}class l_{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(e=>this.getInput(e)),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce((e,t)=>(e[t]=this.getAttr(t),e),{}))}getInput(e){return _C(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return _C(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return ZC(this.node.rawAttrs,e,t);if(null!=n.s)return YC(this.node.rawAttrs,e,t);if(null!=n.b)return QC(this.node.rawAttrs,e,t);if(null!=n.shape)return s_(this.node.rawAttrs,e,t);if(null!=n.type)return t_(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return o_(this.node.rawAttrs,e,t);if(null!=n.list.s)return i_(this.node.rawAttrs,e,t);if(null!=n.list.shape)return a_(this.node.rawAttrs,e,t);if(null!=n.list.b)return u_(this.node.rawAttrs,e,t);if(null!=n.list.type)return n_(this.node.rawAttrs,e,t)}return t}}const c_=Ly({addN_:function(e){Cp(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),Cp(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);const t=e.map((e,t)=>Py(e,`tensors${t}`,"addN")),n=t[0];return t.forEach(e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(e=>{if(!Tp(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),Iy.runKernel(lf,t)}}),h_=Ly({mod_:function(e,t){let n=Py(e,"a","mod"),r=Py(t,"b","mod");return[n,r]=wy(n,r),Iy.runKernel("Mod",{a:n,b:r})}}),d_=Ly({equal_:function(e,t){let n=Py(e,"a","equal","string_or_numeric"),r=Py(t,"b","equal","string_or_numeric");return[n,r]=wy(n,r),Zb(n.shape,r.shape),Iy.runKernel(Wf,{a:n,b:r})}}),p_=Ly({divNoNan_:function(e,t){let n=Py(e,"a","div"),r=Py(t,"b","div");[n,r]=wy(n,r);const s=eb(n,r),o=xb(s),i=d_(r,o);return sv(i,o,s)}}),f_=Ly({maximum_:function(e,t){let n=Py(e,"a","maximum"),r=Py(t,"b","maximum");return[n,r]=wy(n,r),"bool"===n.dtype&&(n=bx(n,"int32"),r=bx(r,"int32")),Zb(n.shape,r.shape),Iy.runKernel(mm,{a:n,b:r})}}),m_=Ly({acos_:function(e){const t=Py(e,"x","acos");return Iy.runKernel(of,{x:t})}}),g_=Ly({acosh_:function(e){const t=Py(e,"x","acosh");return Iy.runKernel(af,{x:t})}}),y_=Ly({asin_:function(e){const t=Py(e,"x","asin");return Iy.runKernel(df,{x:t})}}),x_=Ly({asinh_:function(e){const t=Py(e,"x","asinh");return Iy.runKernel(pf,{x:t})}}),b_=Ly({atan_:function(e){const t=Py(e,"x","atan");return Iy.runKernel(ff,{x:t})}}),v_=Ly({atan2_:function(e,t){let n=Py(e,"a","atan2"),r=Py(t,"b","atan2");return[n,r]=wy(n,r),Iy.runKernel(gf,{a:n,b:r})}}),w_=Ly({atanh_:function(e){const t=Py(e,"x","atanh");return Iy.runKernel(mf,{x:t})}}),C_=Ly({ceil_:function(e){const t=Py(e,"x","ceil");return Iy.runKernel(_f,{x:t})}}),__=Ly({cos_:function(e){const t=Py(e,"x","cos");return Iy.runKernel("Cos",{x:t})}}),k_=Ly({cosh_:function(e){const t=Py(e,"x","cosh");return Iy.runKernel(Af,{x:t})}}),E_=Ly({erf_:function(e){let t=Py(e,"x","erf");return Cp("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=bx(t,"float32")),Iy.runKernel("Erf",{x:t})}}),S_=Ly({expm1_:function(e){const t=Py(e,"x","expm1");return Iy.runKernel(Gf,{x:t})}}),T_=Ly({floor_:function(e){const t=Py(e,"x","floor");return Iy.runKernel(Xf,{x:t})}}),I_=Ly({reciprocal_:function(e){const t=Py(e,"x","reciprocal");return Iy.runKernel(Pm,{x:t})}}),N_=Ly({selu_:function(e){const t=Py(e,"x","selu");return Iy.runKernel(qm,{x:t})}}),$_=Ly({sin_:function(e){const t=Py(e,"x","sin");return Iy.runKernel("Sin",{x:t})}}),R_=Ly({sign_:function(e){const t=Py(e,"x","sign");return Iy.runKernel(Ym,{x:t})}}),A_=Ly({sinh_:function(e){const t=Py(e,"x","sinh");return Iy.runKernel(Xm,{x:t})}}),O_=Ly({softplus_:function(e){const t=Py(e,"x","softplus");return Iy.runKernel(Zm,{x:t})}}),F_=Ly({tanh_:function(e){const t=Py(e,"x","tanh");return Iy.runKernel(fg,{x:t})}}),D_=Ly({tan_:function(e){const t=Py(e,"x","tan");return Iy.runKernel("Tan",{x:t})}}),P_=Ly({rsqrt_:function(e){const t=Py(e,"x","rsqrt");return Iy.runKernel(jm,{x:t})}}),M_=Ly({prod_:function(e,t=null,n=!1){let r=Py(e,"x","prod");return"bool"===r.dtype&&(r=bx(r,"int32")),Iy.runKernel(Om,{x:r},{axis:t,keepDims:n})}}),L_=Ly({isNaN_:function(e){const t=Py(e,"x","isNaN");return Iy.runKernel(om,{x:t})}});function B_(e,t,n=""){if("number"!=typeof e&&"number"!=typeof t){Cp(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let r=0;r<e.length;r++){const s=e[r],o=t[r];Cp(s<0||o<0||s===o,()=>n+` Shapes ${e} and ${t} must match`)}}}function V_(e){return"number"!=typeof e&&!e.some(e=>e<0)}function U_(e,t,n){let r=z_(e,n);const s=!V_(r);if(s&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach(e=>{r=z_(e.shape,r)}),!V_(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function z_(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let r=0;r<e.length;++r){const s=e[r],o=t[r];if(s>=0&&o>=0&&s!==o)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=s>=0?s:o}return n}class W_{constructor(e,t,n,r,s,o,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=s,this.dynamicSize=o,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=ob(0),Nv(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(e=>this.read(e))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),B_(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,Nv(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((e,n)=>this.write(e,t[n]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return Uy([],[0].concat(this.elementShape));const n=this.readMany(e);return B_(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),lb(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return Uy([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const n=this.readMany(t);return B_(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Zx(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,pb(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const r=e.map(e=>(n+=e,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const s=0===n?0:t.size/n,o=[];Tv(()=>{t=sb(t,[1,n,s]);for(let n=0;n<e.length;++n)o[n]=sb(ab(t,[0,0===n?0:r[n-1],0],[1,e[n],s]),this.elementShape);return o});const i=[];for(let a=0;a<e.length;a++)i[a]=a;this.writeMany(i,o)}}class j_{constructor(e,t,n,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach(e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);B_(t,e.shape,"TensorList shape mismatch: "),Nv(e)}),this.idTensor=ob(0),this.maxNumElements=r,Nv(this.idTensor)}get id(){return this.idTensor.id}copy(){return new j_([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.id)||t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);B_(e,this.elementShape,"TensorList shape mismatch: ");const r=U_(this.elementShape,this.tensors,e);return Tv(()=>{const e=this.tensors.map(e=>sb(e,r));return lb(e,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=U_(this.elementShape,this.tensors,e),r=this.tensors.pop();return B_(r.shape,e,"TensorList shape mismatch: "),sb(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(B_(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Nv(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);B_(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=U_(this.elementShape,this.tensors,t);return sb(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);B_(this.elementShape,t.shape,"TensorList shape mismatch: "),Nv(t),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);B_(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=U_(this.elementShape,this.tensors,n);return 0===e.length?Uy([],[0].concat(r)):Tv(()=>{const t=e.map(e=>sb(this.tensors[e],r));return lb(t,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);B_(this.elementShape,t,"TensorList shape mismatch: ");const n=U_(this.elementShape,this.tensors,t);return 0===this.size()?Uy([],[0].concat(n)):Tv(()=>{const e=this.tensors.map(e=>sb(e,n));return Zx(e,0)})}}const H_=function(){var e=mp(function*(e,t,n){switch(e.op){case"If":case"StatelessIf":{const r=CC("thenBranch",e,t,n),s=CC("elseBranch",e,t,n),o=CC("cond",e,t,n),i=CC("args",e,t,n);return(yield o.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=CC("body",e,t,n),s=CC("cond",e,t,n),o=CC("args",e,t,n),i=yield n.functionMap[s].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap),a=o.map(e=>e.id);let u=yield i[0].data();i.forEach(e=>{e.kept||-1!==a.indexOf(e.id)||e.dispose()});let l=o;for(;u[0];){const e=l;l=yield n.functionMap[r].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);const t=l.map(e=>e.id);e.forEach(e=>{e.kept||-1!==a.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()});const o=yield n.functionMap[s].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);u=yield o[0].data(),o.forEach(e=>{e.kept||-1!==a.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()})}return l}case"LoopCond":return[IC(CC("pred",e,t,n))];case"Switch":{const r=CC("pred",e,t,n);let s=CC("data",e,t,n);return s.kept||(s=IC(s)),(yield r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=e.inputNames.find(e=>void 0!==_C(e,t,n));return r?[IC(_C(r,t,n))]:void 0}case"Enter":{const r=CC("frameName",e,t,n),s=CC("tensor",e,t,n);return n.enterFrame(r),[IC(s)]}case"Exit":{const r=CC("tensor",e,t,n);return n.exitFrame(),[IC(r)]}case"NextIteration":{const r=CC("tensor",e,t,n);return n.nextIteration(),[IC(r)]}case"TensorArrayV3":{const r=CC("size",e,t,n),s=CC("dtype",e,t,n),o=CC("elementShape",e,t,n),i=CC("dynamicSize",e,t,n),a=CC("clearAfterRead",e,t,n),u=CC("identicalElementShapes",e,t,n),l=CC("name",e,t,n),c=new W_(l,s,r,o,u,i,a);return n.addTensorArray(c),[c.idTensor,ob(1)]}case"TensorArrayWriteV3":{const r=CC("tensorArrayId",e,t,n),s=CC("index",e,t,n),o=CC("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(s,o),[i.idTensor]}case"TensorArrayReadV3":{const r=CC("tensorArrayId",e,t,n),s=CC("index",e,t,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=CC("tensorArrayId",e,t,n),s=CC("indices",e,t,n),o=CC("dtype",e,t,n);return[n.getTensorArray(r.id).gather(s,o)]}case"TensorArrayScatterV3":{const r=CC("tensorArrayId",e,t,n),s=CC("indices",e,t,n),o=CC("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(s,o),[i.idTensor]}case"TensorArrayConcatV3":{const r=CC("tensorArrayId",e,t,n),s=n.getTensorArray(r.id),o=CC("dtype",e,t,n);return[s.concat(o)]}case"TensorArraySplitV3":{const r=CC("tensorArrayId",e,t,n),s=CC("tensor",e,t,n),o=CC("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(o,s),[i.idTensor]}case"TensorArraySizeV3":{const r=CC("tensorArrayId",e,t,n);return[ob(n.getTensorArray(r.id).size(),"int32")]}case"TensorArrayCloseV3":{const r=CC("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=CC("tensorListId",e,t,n),s=CC("index",e,t,n),o=CC("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(s,o),[i.idTensor]}case"TensorListGetItem":{const r=CC("tensorListId",e,t,n),s=CC("index",e,t,n),o=CC("elementShape",e,t,n),i=CC("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(s,o,i)]}case"TensorListScatterV2":case"TensorListScatter":{const r=CC("indices",e,t,n),s=function(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const s=Math.max(...t);if(null!=r&&-1!==r&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const o=new j_([],n,e.dtype,r),i=pb(e,0);return t.forEach((e,t)=>{o.setItem(e,i[t])}),o}(CC("tensor",e,t,n),r,CC("elementShape",e,t,n),CC("numElements",e,t,n));return n.addTensorList(s),[s.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=CC("elementShape",e,t,n),s=CC("elementDType",e,t,n);let o;o="TensorListReserve"===e.op?"numElements":"maxNumElements";const i=function(e,t,n){return new j_([],e,t,n)}(r,s,CC(o,e,t,n));return n.addTensorList(i),[i.idTensor]}case"TensorListGather":{const r=CC("tensorListId",e,t,n),s=CC("indices",e,t,n),o=CC("elementShape",e,t,n),i=CC("elementDType",e,t,n);return[n.getTensorList(r.id).gather(s,i,o)]}case"TensorListStack":{const r=CC("tensorListId",e,t,n),s=CC("elementShape",e,t,n),o=CC("elementDType",e,t,n),i=CC("numElements",e,t,n);return[n.getTensorList(r.id).stack(s,o,i)]}case"TensorListFromTensor":{const r=function(e,t,n){const r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);B_(e.shape.slice(1),t,"TensorList shape mismatch: ");const s=pb(e);return new j_(s,t,r)}(CC("tensor",e,t,n),CC("elementShape",e,t,n),CC("elementDType",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":{const r=CC("tensorListId",e,t,n),s=n.getTensorList(r.id),o=CC("dtype",e,t,n),i=CC("elementShape",e,t,n);return[s.concat(o,i)]}case"TensorListPushBack":{const r=CC("tensorListId",e,t,n),s=CC("tensor",e,t,n),o=n.getTensorList(r.id);return o.pushBack(s),[o.idTensor]}case"TensorListPopBack":{const r=CC("tensorListId",e,t,n),s=CC("elementShape",e,t,n),o=CC("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(s,o)]}case"TensorListSplit":{const r=CC("tensor",e,t,n),s=CC("elementShape",e,t,n),o=function(e,t,n){let r=0;const s=t.map(e=>(r+=e,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);const o=z_(e.shape.slice(1),n),i=0===r?0:e.size/r,a=Tv(()=>{const n=[];e=sb(e,[1,r,i]);for(let r=0;r<t.length;++r)n[r]=sb(ab(e,[0,0===r?0:s[r-1],0],[1,t[r],i]),o);return e.dispose(),n}),u=new j_([],n,e.dtype,t.length);for(let l=0;l<a.length;l++)u.setItem(l,a[l]);return u}(r,CC("lengths",e,t,n),s);return n.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}});return function(t,n,r){return e.apply(this,arguments)}}(),G_=Ly({conv2d_:function(e,t,n,r,s="NHWC",o=[1,1],i){const a=Py(e,"x","conv2d"),u=Py(t,"filter","conv2d");let l=a,c=!1;3===a.rank&&(c=!0,l=sb(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Cp(4===l.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),Cp(4===u.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),null!=i&&Cp(Ip(r),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`);const h="NHWC"===s?l.shape[3]:l.shape[1];Cp(h===u.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${u.shape[2]}.`),Cp(yw(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);const d=Iy.runKernel(If,{x:l,filter:u},{strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i});return c?sb(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),q_=Ly({conv1d_:function(e,t,n,r,s="NWC",o=1,i){const a=Py(e,"x","conv1d"),u=Py(t,"filter","conv1d");let l=a,c=!1;2===a.rank&&(c=!0,l=sb(a,[1,a.shape[0],a.shape[1]])),Cp(3===l.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),Cp(3===u.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),null!=i&&Cp(Ip(r),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`),Cp(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),Cp(yw(n,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${o}'`),Cp("NWC"===s,()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const h=sb(u,[1,u.shape[0],u.shape[1],u.shape[2]]),d=sb(l,[l.shape[0],1,l.shape[1],l.shape[2]]),p=G_(d,h,[1,n],r,"NHWC",[1,o],i);return sb(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}}),K_=Ly({conv2DBackpropFilter_:function(e,t,n,r,s,o="NHWC",i){let a=e;3===e.rank&&(a=sb(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;3===u.rank&&(u=sb(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Cp(4===a.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),Cp(4===u.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),Cp(4===n.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const l="NHWC"===o?a.shape[3]:a.shape[1],c="NHWC"===o?u.shape[3]:u.shape[1];return Cp(l===n[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${n[2]}.`),Cp(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),null!=i&&Cp(Ip(s),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${i} but got pad ${s}.`),Iy.runKernel(Nf,{x:a,dy:u},{strides:r,pad:s,dataFormat:o,dimRoundingMode:i,filterShape:n})}}),X_=Ly({conv2DBackpropInput_:function(e,t,n,r,s,o="NHWC",i){Cp(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let a=e,u=t,l=!1;3===t.rank&&(l=!0,u=sb(t,[1,t.shape[0],t.shape[1],t.shape[2]]),a=[1,e[0],e[1],e[2]]),Cp(4===a.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),Cp(4===u.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),Cp(4===n.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c="NHWC"===o?a[3]:a[1],h="NHWC"===o?u.shape[3]:u.shape[1];Cp(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),Cp(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),null!=i&&Cp(Ip(s),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${i} but got pad ${s}.`);const d=Iy.runKernel($f,{dy:u,filter:n},{strides:r,pad:s,dataFormat:o,dimRoundingMode:i,inputShape:a});return l?sb(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),Y_=Ly({fusedConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(!1===Tw(Iy.state.gradientDepth,u=u||"linear")){let h=G_(e,t,n,r,s,o,i);return null!=a&&(h=Xx(h,a)),Sw(h,u,l,c)}const h=Py(e,"x","conv2d"),d=Py(t,"filter","conv2d");let p=h,f=!1;3===h.rank&&(f=!0,p=sb(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Cp(4===p.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),Cp(4===d.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),null!=i&&Cp(Ip(r),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`),Cp(p.shape[3]===d.shape[2],()=>`Error in conv2d: depth of input (${p.shape[3]}) must match input depth for filter ${d.shape[2]}.`),Cp(yw(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),Cp("NHWC"===s,()=>`Error in conv2d: got dataFormat of ${s} but only NHWC is currently supported.`);const m=lw(p.shape,d.shape,n,o,r,i);let g,y;null!=a&&(g=Py(a,"bias","fused conv2d"),[g]=wy(g,h),Zb(m.outShape,g.shape)),null!=l&&(y=Py(l,"prelu weights","fused conv2d"));const x=(e,t)=>{const[s,i,a,l]=t,c=kw(e,a,u);Cp(gw(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const h=[X_(i.shape,c,s,n,r),K_(i,c,s.shape,n,r)];if(null!=l){const e=Ew(l,c);h.push(e)}return h},b={x:p,filter:d,bias:g,preluActivationWeights:y},v={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return null==a?Gv((e,t,n)=>{let r=Iy.runKernel(Sg,b,v);return n([t,e,r]),f&&(r=sb(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}})(p,d):Gv((e,t,n,r)=>{let s=Iy.runKernel(Sg,b,v);return r([t,e,s,n]),f&&(s=sb(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:x}})(p,d,g)}}),Q_=Ly({depthwiseConv2d_:function(e,t,n,r,s="NHWC",o=[1,1],i){const a=Py(e,"x","depthwiseConv2d"),u=Py(t,"filter","depthwiseConv2d");let l=a,c=!1;3===a.rank&&(c=!0,l=sb(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Cp(4===l.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),Cp(4===u.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`),Cp(l.shape[3]===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),null!=i&&Cp(Ip(r),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${i} but got pad ${r}.`);const h=Iy.runKernel(Mf,{x:l,filter:u},{strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i});return c?sb(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),Z_=Ly({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,s,o=[1,1],i){let a=e;3===e.rank&&(a=sb(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;return 3===u.rank&&(u=sb(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Iy.runKernel(Lf,{x:a,dy:u},{strides:r,pad:s,dimRoundingMode:i,dilations:o,filterShape:n})}}),J_=Ly({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,s,o=[1,1],i){let a=t,u=!1;3===t.rank&&(u=!0,a=sb(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l=Iy.runKernel(Bf,{dy:a,filter:n},{strides:r,pad:s,dimRoundingMode:i,dilations:o,inputShape:e});return u?sb(l,[l.shape[1],l.shape[2],l.shape[3]]):l}}),ek=Ly({fusedDepthwiseConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(!1===Tw(Iy.state.gradientDepth,u)){let h=Q_(e,t,n,r,s,o,i);return null!=a&&(h=Xx(h,a)),Sw(h,u,l,c)}const h=Py(e,"x","depthwiseConv2d"),d=Py(t,"filter","depthwiseConv2d");let p=h,f=!1;3===h.rank&&(f=!0,p=sb(h,[1,h.shape[0],h.shape[1],h.shape[2]])),Cp(4===p.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),Cp(4===d.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),Cp(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),null==o&&(o=[1,1]),Cp(yw(n,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),null!=i&&Cp(Ip(r),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${i} but got pad ${r}.`);const m=lw(p.shape,d.shape,n,o,r,i,!0);let g,y;null!=a&&(g=Py(a,"bias","fused conv2d"),[g]=wy(g,h),Zb(m.outShape,g.shape)),null!=l&&(y=Py(l,"prelu weights","fused depthwiseConv2d"));const x=(e,t)=>{Cp(gw(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[s,a,l,c]=t,h=kw(e,l,u),d=J_(a.shape,h,s,n,r,o,i),p=Z_(a,h,s.shape,n,r,o,i);return null!=c?[d,p,Ew(g,h)]:[d,p]},b={x:p,filter:d,bias:g,preluActivationWeights:y},v={strides:n,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return null==a?Gv((e,t,n)=>{let r=Iy.runKernel(Tg,b,v);return n([t,e,r]),f&&(r=sb(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}})(p,d):Gv((e,t,n,r)=>{let s=Iy.runKernel(Tg,b,v);return r([t,e,s,n]),f&&(s=sb(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:x}})(p,d,g)}}),tk=Ly({fusedMatMul_:function({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:a}){if(!1===Tw(Iy.state.gradientDepth,o)){let u=Av(e,t,n,r);return null!=s&&(u=Xx(u,s)),Sw(u,o,i,a)}let u=Py(e,"a","fused matMul"),l=Py(t,"b","fused matMul");[u,l]=wy(u,l);const c=n?u.shape[u.rank-2]:u.shape[u.rank-1],h=r?l.shape[l.rank-1]:l.shape[l.rank-2],d=n?u.shape[u.rank-1]:u.shape[u.rank-2],p=r?l.shape[l.rank-2]:l.shape[l.rank-1],f=u.shape.slice(0,-2),m=l.shape.slice(0,-2),g=Sp(f),y=Sp(m);Cp(u.rank>=2&&l.rank>=2&&u.rank===l.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${u.rank} and ${l.rank}.`),Cp(Tp(f,m),()=>`Error in fused matMul: outer dimensions (${f}) and (${m}) of Tensors with shapes ${u.shape} and ${l.shape} must match.`),Cp(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${n} and transposeB=${r} must match.`);const x=u.shape.slice(0,-2).concat([d,p]),b=sb(u,n?[g,c,d]:[g,d,c]),v=sb(l,r?[y,p,h]:[y,h,p]);let w,C;null!=s&&(w=Py(s,"bias","fused matMul"),[w]=wy(w,u),Zb(x,w.shape)),null!=i&&(C=Py(i,"prelu weights","fused matMul"));const _=(e,t)=>{const[i,a,u,l]=t,c=kw(sb(e,u.shape),u,o);let h,d;return n||r?!n&&r?(h=Av(c,a,!1,!1),d=Av(c,i,!0,!1)):n&&!r?(h=Av(a,c,!1,!0),d=Av(i,c,!1,!1)):(h=Av(a,c,!0,!0),d=Av(c,i,!0,!0)):(h=Av(c,a,!1,!0),d=Av(i,c,!0,!1)),null!=s?[h,d,Ew(l,c)]:[h,d]},k={a:b,b:v,bias:w,preluActivationWeights:C},E={transposeA:n,transposeB:r,activation:o,leakyreluAlpha:a};return null==s?Gv((e,t,n)=>{const r=Iy.runKernel(Eg,k,E);return n([e,t,r]),{value:sb(r,x),gradFunc:_}})(b,v):Gv((e,t,n,r)=>{const s=Iy.runKernel(Eg,k,E);return r([e,t,s,n]),{value:sb(s,x),gradFunc:_}})(b,v,w)}}),nk=Ly({conv2dTranspose_:function(e,t,n,r,s,o){const i=Py(e,"x","conv2dTranspose"),a=Py(t,"filter","conv2dTranspose");return X_(n,i,a,r,s,"NHWC",o)}}),rk=Ly({conv3d_:function(e,t,n,r,s="NDHWC",o=[1,1,1]){const i=Py(e,"x","conv3d"),a=Py(t,"filter","conv3d");let u=i,l=!1;4===i.rank&&(l=!0,u=sb(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Cp(5===u.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),Cp(5===a.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),Cp(u.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${a.shape[3]}.`),Cp(yw(n,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),Cp("NDHWC"===s,()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);const c=Iy.runKernel(Rf,{x:u,filter:a},{strides:n,pad:r,dataFormat:s,dilations:o});return l?sb(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}}),sk=Ly({avgPool_:function(e,t,n,r,s){const o=Py(e,"x","avgPool","float32");Cp(yw(n,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`);let i=o,a=!1;3===o.rank&&(a=!0,i=sb(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Cp(4===i.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),null!=s&&Cp(Ip(r),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let u=Iy.runKernel(yf,{x:i},{filterSize:t,strides:n,pad:r,dimRoundingMode:s});return u=bx(u,o.dtype),a?sb(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),ok=Ly({maxPool_:function(e,t,n,r,s){const o=Py(e,"x","maxPool");let i=o,a=!1;3===o.rank&&(a=!0,i=sb(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Cp(4===i.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),Cp(yw(n,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`),null!=s&&Cp(Ip(r),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const u=Iy.runKernel(gm,{x:i},{filterSize:t,strides:n,pad:r,dimRoundingMode:s});return a?sb(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),ik=Ly({maxPoolWithArgmax_:function(e,t,n,r,s=!1){const o=Py(e,"x","maxPoolWithArgmax"),i=Iy.runKernel(xm,{x:o},{filterSize:t,strides:n,pad:r,includeBatchInIndex:s});return{result:i[0],indexes:i[1]}}}),ak=Ly({avgPool3d_:function(e,t,n,r,s,o="NDHWC"){const i=Py(e,"x","avgPool3d","float32");let a=i,u=!1;4===i.rank&&(u=!0,a=sb(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Cp(5===a.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),Cp("NDHWC"===o,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),null!=s&&Cp(Ip(r),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);let l=Iy.runKernel(xf,{x:a},{filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:o});return l=bx(l,a.dtype),u?sb(l,[l.shape[1],l.shape[2],l.shape[3],l.shape[4]]):l}}),uk=Ly({maxPool3d_:function(e,t=[1,1,1],n,r,s,o="NDHWC"){const i=Py(e,"x","maxPool3d");let a=i,u=!1;4===i.rank&&(u=!0,a=sb(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Cp(5===a.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),Cp("NDHWC"===o,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),null!=s&&Cp(Ip(r),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${r}.`);const l=Iy.runKernel(ym,{x:a},{filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:o});return u?sb(l,[l.shape[1],l.shape[2],l.shape[3],l.shape[4]]):l}}),lk=Ly({dilation2d_:function(e,t,n,r,s=[1,1],o="NHWC"){const i=Py(e,"x","dilation2d"),a=Py(t,"filter","dilation2d");Cp(3===i.rank||4===i.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),Cp(3===a.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),Cp("NHWC"===o,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let u=i,l=!1;3===i.rank&&(u=sb(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0);const c=Iy.runKernel(Vf,{x:u,filter:a},{strides:n,pad:r,dilations:s});return l?sb(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});function ck(e,t,n){const[r,s]=CC("fusedOps",e,t,n),o="biasadd"===r,i=!o,a="prelu"===s,u="fusedbatchnorm"===r,l=CC("numArgs",e,t,n);if(o){if(a&&2!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&o&&1!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=CC("strides",e,t,n),h=TC(e,t,n),d=CC("dataFormat",e,t,n).toUpperCase(),p=CC("dilations",e,t,n);let[f,m]=CC("args",e,t,n);return i&&(m=f,f=void 0),{stride:c,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:m,activationFunc:s,leakyreluAlpha:CC("leakyreluAlpha",e,t,n)}}function hk(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");return Iy.runKernel(lm,{},{start:e,stop:t,num:n})}const dk=Ly({multinomial_:function(e,t,n,r=!1){const s=Py(e,"logits","multinomial"),o=s.size,i=s.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const a=1===i?sb(s,[1,-1]):s,u=Iy.runKernel(Cm,{logits:a},{numSamples:t,seed:n,normalized:r});return 1===i?sb(u,[u.size]):u}}),pk=Ly({oneHot_:function(e,t,n=1,r=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const s=Py(e,"indices","oneHot","int32");return Iy.runKernel(Nm,{indices:s},{depth:t,onValue:n,offValue:r})}}),fk=Ly({onesLike_:function(e){const t=Py(e,"x","onesLike");return Iy.runKernel(Im,{x:t})}});var mk=n(176);class gk{constructor(e,t,n,r,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const o=s||Math.random();this.random=mk.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,s,o;do{r=2*this.random()-1,s=2*this.random()-1,o=r*r+s*s}while(o>=1||0===o);const i=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*s*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class yk{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=mk.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const xk=Ly({randomUniform_:function(e,t=0,n=1,r="float32",s){const o=xx(e,r),i=new yk(t,n,null,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}}),bk=Ly({truncatedNormal_:function(e,t=0,n=1,r,s){if(null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const o=new gk(t,n,r,!0,s),i=xx(e,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}});function vk(){return(vk=mp(function*(e){const t=Py(e,"condition","whereAsync","bool"),n=yield t.data(),r=yC(t.shape,n);return e!==t&&t.dispose(),r})).apply(this,arguments)}const wk=function(e){return vk.apply(this,arguments)};function Ck(){return(Ck=mp(function*(e,t){const n=Py(e,"x","setdiff1d"),r=Py(t,"y","setdiff1d");Cp(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),Cp(1===n.rank,()=>`x should be 1D tensor, but got x (${n.shape}).`),Cp(1===r.rank,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=yield n.data(),o=yield r.data(),i=new Set(o);let a=0;for(let c=0;c<s.length;c++)i.has(s[c])||a++;const u=new uy([a],n.dtype),l=new uy([a],"int32");for(let c=0,h=0;c<s.length;c++)i.has(s[c])||(u.values[h]=s[c],l.values[h]=c,h++);return[u.toTensor(),l.toTensor()]})).apply(this,arguments)}function _k(e,t,n){return{boxes:CC("boxes",e,t,n),scores:CC("scores",e,t,n),maxOutputSize:CC("maxOutputSize",e,t,n),iouThreshold:CC("iouThreshold",e,t,n),scoreThreshold:CC("scoreThreshold",e,t,n),softNmsSigma:CC("softNmsSigma",e,t,n)}}const kk=function(){var e=mp(function*(e,t,n){switch(e.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:a,softNmsSigma:u}=_k(e,t,n),l=yield tw.nonMaxSuppressionWithScoreAsync(r,s,o,i,a,u);return[l.selectedIndices,l.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:a}=_k(e,t,n),u=CC("padToMaxOutputSize",e,t,n),l=yield tw.nonMaxSuppressionPaddedAsync(r,s,o,i,a,u);return[l.selectedIndices,l.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:a}=_k(e,t,n);return[yield tw.nonMaxSuppressionAsync(r,s,o,i,a)]}case"Where":{const r=bx(CC("condition",e,t,n),"bool"),s=[yield wk(r)];return r.dispose(),s}case"ListDiff":return function(e,t){return Ck.apply(this,arguments)}(CC("x",e,t,n),CC("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}});return function(t,n,r){return e.apply(this,arguments)}}(),Ek=Ly({topk_:function(e,t=1,n=!0){const r=Py(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const o={x:r},i={k:t,sorted:n},[a,u]=Iy.runKernel(gg,o,i);return{values:a,indices:u}}}),Sk=Ly({unique_:function(e,t=0){const n=Py(e,"x","unique","string_or_numeric");Cp(n.rank>0,()=>"The input tensor must be at least 1D");const r={x:n},s={axis:t},[o,i]=Iy.runKernel(bg,r,s);return{values:o,indices:i}}});class Tk{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=ob(0),this.tensorMap=new Map,Nv(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return ob(this.size(),"int32")}import(e,t){var n=this;return mp(function*(){n.checkKeyAndValueTensor(e,t);const r=yield e.data();return n.tensorMap.forEach(e=>e.dispose()),n.tensorMap.clear(),Tv(()=>{const e=pb(t),s=r.length,o=e.length;Cp(s===o,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${o} elements.`);for(let t=0;t<s;t++){const s=r[t],o=e[t];Nv(o),n.tensorMap.set(s,o)}return n.handle})})()}find(e,t){var n=this;return mp(function*(){n.checkKeyAndValueTensor(e,t);const r=yield e.data();return Tv(()=>{const e=[];for(let s=0;s<r.length;s++){const o=n.findWithDefault(r[s],t);e.push(o)}return lb(e)})})()}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}const Ik=function(){var e=mp(function*(e,t,n,r){switch(e.op){case"HashTable":case"HashTableV2":{const s=CC("keyDType",e,t,n),o=CC("valueDType",e,t,n),i=new Tk(s,o);return r.addHashTable(e.name,i),[i.handle]}case"LookupTableImport":case"LookupTableImportV2":{const s=CC("tableHandle",e,t,n,r),o=CC("keys",e,t,n),i=CC("values",e,t,n),a=r.getHashTableById(s.id);return[yield a.import(o,i)]}case"LookupTableFind":case"LookupTableFindV2":{const s=CC("tableHandle",e,t,n,r),o=CC("keys",e,t,n),i=CC("defaultValue",e,t,n),a=r.getHashTableById(s.id);return[yield a.find(o,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=CC("tableHandle",e,t,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}});return function(t,n,r,s){return e.apply(this,arguments)}}(),Nk=Ly({less_:function(e,t){let n=Py(e,"a","less","string_or_numeric"),r=Py(t,"b","less","string_or_numeric");return[n,r]=wy(n,r),Zb(n.shape,r.shape),Iy.runKernel(am,{a:n,b:r})}}),$k=Ly({logicalNot_:function(e){const t=Py(e,"x","logicalNot","bool");return Iy.runKernel(pm,{x:t})}}),Rk=Ly({logicalOr_:function(e,t){const n=Py(e,"a","logicalOr","bool"),r=Py(t,"b","logicalOr","bool");return Zb(n.shape,r.shape),Iy.runKernel(fm,{a:n,b:r})}}),Ak=Ly({einsum_:function(e,...t){const n=t.map((e,t)=>Py(e,`tensors${t}`,"einsum"));return Iy.runKernel(zf,n,{equation:e})}}),Ok=Ly({batchNorm_:function(e,t,n,r,s,o){null==o&&(o=.001);const i=Py(e,"x","batchNorm"),a=Py(t,"mean","batchNorm"),u=Py(n,"variance","batchNorm");let l,c;null!=s&&(l=Py(s,"scale","batchNorm")),null!=r&&(c=Py(r,"offset","batchNorm")),Cp(a.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Cp(null==c||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Cp(null==l||a.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h=function(e){let t;return t=0===e.rank||1===e.rank?sb(e,[1,1,1,e.size]):2===e.rank?sb(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?sb(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(i),d=Iy.runKernel(Qf,{x:h,scale:l,offset:c,mean:a,variance:u},{varianceEpsilon:o});return sb(d,i.shape)}}),Fk=Ly({localResponseNormalization_:function(e,t=5,n=1,r=1,s=.5){const o=Py(e,"x","localResponseNormalization");Cp(4===o.rank||3===o.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${o.rank}.`),Cp(Ip(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=o,a=!1;3===o.rank&&(a=!0,i=sb(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const u=Iy.runKernel("LRN",{x:i},{depthRadius:t,bias:n,alpha:r,beta:s});return a?sb(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),Dk=Ly({softmax_:function(e,t=-1){const n=Py(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);return Iy.runKernel(ng,{logits:n},{dim:t})}}),Pk=Ly({logSoftmax_:function(e,t=-1){const n=Py(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return Gv((e,n)=>{const r=bv(e,t,!0),s=cb(e,r),o=cb(bx(s,"float32"),Wv(tv(tb(s),t,!0)));return n([o]),{value:o,gradFunc:(e,n)=>{const[r]=n,s=tb(r);return cb(e,rb(tv(e,t,!0),s))}}})(n)}}),Mk=Ly({sparseToDense_:function(e,t,n,r=0){const s=Py(e,"sparseIndices","sparseToDense","int32"),o=Py(t,"sparseValues","sparseToDense"),i=Py(r,"defaultValue","sparseToDense",o.dtype);return function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const s=e.rank>0?e.shape[0]:1,o=e.rank>1?e.shape[1]:1;if(n.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${o}.`);if(0!==t.rank&&(1!==t.rank||t.size!==s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,o,n,i),Iy.runKernel(ag,{sparseIndices:s,sparseValues:o,defaultValue:i},{outputShape:n})}}),Lk=Ly({all_:function(e,t=null,n=!1){const r=Py(e,"x","all","bool");return Iy.runKernel("All",{x:r},{axis:t,keepDims:n})}}),Bk=Ly({any_:function(e,t=null,n=!1){const r=Py(e,"x","any","bool");return Iy.runKernel("Any",{x:r},{axis:t,keepDims:n})}}),Vk=Ly({argMin_:function(e,t=0){const n=Py(e,"x","argMin");return Iy.runKernel(hf,{x:n},{axis:t})}}),Uk=Ly({cumsum_:function(e,t=0,n=!1,r=!1){const s=Py(e,"x","cumsum");return Iy.runKernel(Of,{x:s},{axis:t,exclusive:n,reverse:r})}}),zk=Ly({denseBincount_:function(e,t,n,r=!1){const s=Py(e,"x","denseBincount"),o=Py(t,"weights","denseBincount");return Cp("int32"===s.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),Cp(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),Cp(n>=0,()=>`size must be non-negative, but got ${n}.`),Cp(o.size===s.size||0===o.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${o.shape}.`),Iy.runKernel(Df,{x:s,weights:o},{size:n,binaryOutput:r})}}),Wk=Ly({gather_:function(e,t,n=0,r=0){const s=Py(e,"x","gather"),o=Py(t,"indices","gather","int32");return Iy.runKernel(Zf,{x:s,indices:o},{axis:n,batchDims:r})}}),jk=Ly({stridedSlice_:function(e,t,n,r,s=0,o=0,i=0,a=0,u=0){const l=Py(e,"x","stridedSlice","string_or_numeric");return Iy.runKernel(lg,{x:l},{begin:t,end:n,strides:r,beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u})}}),Hk=Ly({scatterND_:function(e,t,n){const r=Py(e,"indices","scatterND","int32"),s=Py(t,"updates","scatterND");return Lw(s,r,n),Iy.runKernel(Hm,{indices:r,updates:s},{shape:n})}}),Gk=Ly({gatherND_:function(e,t){const n=Py(t,"indices","gatherND","int32"),r=Py(e,"x","gatherND","string_or_numeric");return Iy.runKernel(Jf,{params:r,indices:n})}}),qk=Ly({mirrorPad_:function(e,t,n){Cp("reflect"===n||"symmetric"===n,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const r=Py(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Cp(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);const s="reflect"===n?1:0;for(let o=0;o<r.rank;o++)Cp(2===t[o].length,()=>"Invalid number of paddings. Must be length of 2 each."),Cp(t[o][0]>=0&&t[o][0]<=r.shape[o]-s&&t[o][1]>=0&&t[o][1]<=r.shape[o]-s,()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-s} or less than 0 for input of shape ${r.shape}`);return Iy.runKernel(wm,{x:r},{paddings:t,mode:n})}}),Kk=Ly({pad_:function(e,t,n=0){const r=Py(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return Iy.runKernel(Rm,{x:r},{paddings:t,constantValue:n})}}),Xk=Ly({spaceToBatchND_:function(e,t,n){const r=Py(e,"x","spaceToBatchND");return Cp(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),Cp(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),Cp(r.shape.reduce((e,r,s)=>s>0&&s<=t.length?e&&(r+n[s-1][0]+n[s-1][1])%t[s-1]==0:e,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`),Iy.runKernel(eg,{x:r},{blockShape:t,paddings:n})}}),Yk=Ly({batchToSpaceND_:function(e,t,n){const r=Py(e,"x","batchToSpaceND"),s=t.reduce((e,t)=>e*t);return Cp(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),Cp(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),Cp(r.shape[0]%s==0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`),Iy.runKernel(vf,{x:r},{blockShape:t,crops:n})}}),Qk=Ly({depthToSpace_:function(e,t,n="NHWC"){const r=Py(e,"x","depthToSpace"),s="NHWC"===n?r.shape[1]:r.shape[2],o="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];return Cp(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t}  for depthToSpace with input shape\n    ${r.shape}`),Cp(o*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${o} and ${t} for depthToSpace with input shape\n        ${r.shape}`),Cp(i%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`),Iy.runKernel(Pf,{x:r},{blockSize:t,dataFormat:n})}});function Zk(e,t,n,r){const s=((e,t,n)=>{switch(e.category){case"arithmetic":return Tv(()=>((e,t,n)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[Xx(CC("a",e,t,n),CC("b",e,t,n))];case"AddN":return[c_(CC("tensors",e,t,n))];case"FloorMod":case"Mod":return[h_(CC("a",e,t,n),CC("b",e,t,n))];case"Mul":return[rb(CC("a",e,t,n),CC("b",e,t,n))];case"RealDiv":case"Div":return[eb(CC("a",e,t,n),CC("b",e,t,n))];case"DivNoNan":return[p_(CC("a",e,t,n),CC("b",e,t,n))];case"FloorDiv":return[Jx(CC("a",e,t,n),CC("b",e,t,n))];case"Sub":return[cb(CC("a",e,t,n),CC("b",e,t,n))];case"Minimum":return[zv(CC("a",e,t,n),CC("b",e,t,n))];case"Maximum":return[f_(CC("a",e,t,n),CC("b",e,t,n))];case"Pow":return[wv(CC("a",e,t,n),CC("b",e,t,n))];case"SquaredDifference":return[jv(CC("a",e,t,n),CC("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"basic_math":return Tv(()=>((e,t,n)=>{switch(e.op){case"Abs":case"ComplexAbs":return[cv(CC("x",e,t,n))];case"Acos":return[m_(CC("x",e,t,n))];case"Acosh":return[g_(CC("x",e,t,n))];case"Asin":return[y_(CC("x",e,t,n))];case"Asinh":return[x_(CC("x",e,t,n))];case"Atan":return[b_(CC("x",e,t,n))];case"Atan2":return[v_(CC("x",e,t,n),CC("y",e,t,n))];case"Atanh":return[w_(CC("x",e,t,n))];case"Ceil":return[C_(CC("x",e,t,n))];case"Complex":return[By(CC("real",e,t,n),CC("imag",e,t,n))];case"Cos":return[__(CC("x",e,t,n))];case"Cosh":return[k_(CC("x",e,t,n))];case"Elu":return[bw(CC("x",e,t,n))];case"Erf":return[E_(CC("x",e,t,n))];case"Exp":return[tb(CC("x",e,t,n))];case"Expm1":return[S_(CC("x",e,t,n))];case"Floor":return[T_(CC("x",e,t,n))];case"Log":return[Wv(CC("x",e,t,n))];case"Log1p":return[Hv(CC("x",e,t,n))];case"Imag":return[mb(CC("x",e,t,n))];case"Neg":return[Ov(CC("x",e,t,n))];case"Reciprocal":return[I_(CC("x",e,t,n))];case"Real":return[gb(CC("x",e,t,n))];case"Relu":return[Uv(CC("x",e,t,n))];case"Round":return[nv(CC("x",e,t,n))];case"Selu":return[N_(CC("x",e,t,n))];case"Sigmoid":return[ib(CC("x",e,t,n))];case"Sin":return[$_(CC("x",e,t,n))];case"Sign":return[R_(CC("x",e,t,n))];case"Sinh":return[A_(CC("x",e,t,n))];case"Softplus":return[O_(CC("x",e,t,n))];case"Sqrt":return[Cv(CC("x",e,t,n))];case"Square":return[_v(CC("x",e,t,n))];case"Tanh":return[F_(CC("x",e,t,n))];case"Tan":return[D_(CC("x",e,t,n))];case"ClipByValue":return[Qx(CC("x",e,t,n),CC("clipValueMin",e,t,n),CC("clipValueMax",e,t,n))];case"Relu6":return[Cw(CC("x",e,t,n))];case"Rsqrt":return[P_(_C(e.inputNames[0],t,n))];case"Prod":return[M_(CC("x",e,t,n),CC("axes",e,t,n))];case"LeakyRelu":return[vw(CC("x",e,t,n),CC("alpha",e,t,n))];case"Prelu":return[ww(CC("x",e,t,n),CC("alpha",e,t,n))];case"IsNan":return[L_(_C(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"control":return H_(e,t,n);case"convolution":return Tv(()=>((e,t,n)=>{switch(e.op){case"Conv1D":{const r=CC("stride",e,t,n),s=CC("pad",e,t,n),o=CC("dataFormat",e,t,n).toUpperCase(),i=CC("dilation",e,t,n);return[q_(CC("x",e,t,n),CC("filter",e,t,n),r,s,o,i)]}case"Conv2D":{const r=CC("strides",e,t,n),s=TC(e,t,n),o=CC("dataFormat",e,t,n).toUpperCase(),i=CC("dilations",e,t,n);return[G_(CC("x",e,t,n),CC("filter",e,t,n),[r[1],r[2]],s,o,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:r,pad:s,dataFormat:o,dilations:i,biasArg:a,preluArg:u,activationFunc:l,leakyreluAlpha:c}=ck(e,t,n);return[Y_({x:CC("x",e,t,n),filter:CC("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[i[1],i[2]],bias:a,activation:l,preluActivationWeights:u,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:s,dataFormat:o,dilations:i,biasArg:a,preluArg:u,activationFunc:l,leakyreluAlpha:c}=ck(e,t,n);return[ek({x:CC("x",e,t,n),filter:CC("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[i[1],i[2]],bias:a,activation:l,preluActivationWeights:u,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=CC("outputShape",e,t,n),s=CC("strides",e,t,n),o=TC(e,t,n);return[nk(CC("x",e,t,n),CC("filter",e,t,n),r,[s[1],s[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=CC("strides",e,t,n),s=TC(e,t,n),o=CC("dilations",e,t,n),i=CC("dataFormat",e,t,n).toUpperCase();return[Q_(CC("input",e,t,n),CC("filter",e,t,n),[r[1],r[2]],s,i,[o[1],o[2]])]}case"Conv3D":{const r=CC("strides",e,t,n),s=CC("pad",e,t,n),o=CC("dataFormat",e,t,n).toUpperCase(),i=CC("dilations",e,t,n);return[rk(CC("x",e,t,n),CC("filter",e,t,n),[r[1],r[2],r[3]],s,o,[i[1],i[2],i[3]])]}case"AvgPool":{const r=CC("strides",e,t,n),s=CC("pad",e,t,n),o=CC("kernelSize",e,t,n);return[sk(CC("x",e,t,n),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPool":{const r=CC("strides",e,t,n),s=CC("pad",e,t,n),o=CC("kernelSize",e,t,n);return[ok(CC("x",e,t,n),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPoolWithArgmax":{const r=CC("strides",e,t,n),s=CC("pad",e,t,n),o=CC("kernelSize",e,t,n),i=CC("includeBatchInIndex",e,t,n),{result:a,indexes:u}=ik(CC("x",e,t,n),[o[1],o[2]],[r[1],r[2]],s,i);return[a,u]}case"AvgPool3D":{const r=CC("strides",e,t,n),s=CC("pad",e,t,n),o=CC("kernelSize",e,t,n);return[ak(CC("x",e,t,n),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"MaxPool3D":{const r=CC("strides",e,t,n),s=CC("pad",e,t,n),o=CC("kernelSize",e,t,n);return[uk(CC("x",e,t,n),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"Dilation2D":{const r=CC("strides",e,t,n),s=CC("pad",e,t,n),o=CC("dilations",e,t,n),i=r[1],a=r[2],u=o[1],l=o[2];return[lk(CC("x",e,t,n),CC("filter",e,t,n),[i,a],s,[u,l],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"creation":return Tv(()=>((e,t,n)=>{switch(e.op){case"Fill":{const r=CC("shape",e,t,n),s=CC("dtype",e,t,n);return[Sb(r,CC("value",e,t,n),s)]}case"LinSpace":return[hk(CC("start",e,t,n),CC("stop",e,t,n),CC("num",e,t,n))];case"Multinomial":{const r=CC("logits",e,t,n),s=CC("numSamples",e,t,n),o=CC("seed",e,t,n);return[dk(r,s,o)]}case"OneHot":{const r=CC("indices",e,t,n),s=CC("depth",e,t,n),o=CC("onValue",e,t,n),i=CC("offValue",e,t,n);return[pk(r,s,o,i)]}case"Ones":return[Bv(CC("shape",e,t,n),CC("dtype",e,t,n))];case"OnesLike":return[fk(CC("x",e,t,n))];case"RandomUniform":return[xk(CC("shape",e,t,n),CC("minval",e,t,n),CC("maxval",e,t,n),CC("dtype",e,t,n))];case"Range":return[ov(CC("start",e,t,n),CC("stop",e,t,n),CC("step",e,t,n),CC("dtype",e,t,n))];case"TruncatedNormal":{const r=CC("shape",e,t,n),s=CC("mean",e,t,n),o=CC("stdDev",e,t,n),i=CC("seed",e,t,n);return[bk(r,s,o,CC("dtype",e,t,n),i)]}case"Zeros":return[fb(CC("shape",e,t,n),CC("dtype",e,t,n))];case"ZerosLike":return[xb(CC("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"dynamic":return kk(e,t,n);case"evaluation":return Tv(()=>((e,t,n)=>{switch(e.op){case"TopKV2":{const r=CC("x",e,t,n),s=CC("k",e,t,n),o=CC("sorted",e,t,n),i=Ek(r,s,o);return[i.values,i.indices]}case"Unique":{const r=CC("x",e,t,n),s=Sk(r);return[s.values,s.indices]}case"UniqueV2":{const r=CC("x",e,t,n),s=CC("axis",e,t,n),o=Sk(r,s);return[o.values,o.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"image":return Tv(()=>((e,t,n)=>{switch(e.op){case"ResizeBilinear":{const r=CC("images",e,t,n),s=CC("size",e,t,n),o=CC("alignCorners",e,t,n),i=CC("halfPixelCenters",e,t,n);return[tw.resizeBilinear(r,[s[0],s[1]],o,i)]}case"ResizeNearestNeighbor":{const r=CC("images",e,t,n),s=CC("size",e,t,n),o=CC("alignCorners",e,t,n),i=CC("halfPixelCenters",e,t,n);return[tw.resizeNearestNeighbor(r,[s[0],s[1]],o,i)]}case"CropAndResize":{const r=CC("image",e,t,n),s=CC("boxes",e,t,n),o=CC("boxInd",e,t,n),i=CC("cropSize",e,t,n),a=CC("method",e,t,n),u=CC("extrapolationValue",e,t,n);return[tw.cropAndResize(r,s,o,i,a,u)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"graph":return Tv(()=>((e,t,n)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const r=CC("default",e,t,n);return[_C(e.name,t,n)||r];case"Placeholder":return[_C(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":return[IC(CC("x",e,t,n))];case"IdentityN":return CC("x",e,t,n).map(e=>IC(e));case"Snapshot":return[IC(CC("x",e,t,n))];case"Shape":return[hb(CC("x",e,t,n).shape,"int32")];case"ShapeN":return CC("x",e,t,n).map(e=>hb(e.shape));case"Size":return[ob(CC("x",e,t,n).size,"int32")];case"Rank":return[ob(CC("x",e,t,n).rank,"int32")];case"NoOp":return[ob(1)];case"Print":const s=CC("x",e,t,n),o=CC("data",e,t,n),i=CC("message",e,t,n),a=CC("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(i);for(let e=0;e<o.length;e++)console.log(Array.prototype.slice.call(o[e].dataSync()).slice(0,a));return[s];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"logical":return Tv(()=>((e,t,n)=>{switch(e.op){case"Equal":return[d_(CC("a",e,t,n),CC("b",e,t,n))];case"NotEqual":return[Lv(CC("a",e,t,n),CC("b",e,t,n))];case"Greater":return[ev(CC("a",e,t,n),CC("b",e,t,n))];case"GreaterEqual":return[uv(CC("a",e,t,n),CC("b",e,t,n))];case"Less":return[Nk(CC("a",e,t,n),CC("b",e,t,n))];case"LessEqual":return[Jb(CC("a",e,t,n),CC("b",e,t,n))];case"LogicalAnd":return[lv(CC("a",e,t,n),CC("b",e,t,n))];case"LogicalNot":return[$k(CC("a",e,t,n))];case"LogicalOr":return[Rk(CC("a",e,t,n),CC("b",e,t,n))];case"Select":case"SelectV2":return[sv(CC("condition",e,t,n),CC("a",e,t,n),CC("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"matrices":return Tv(()=>((e,t,n)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[Av(CC("a",e,t,n),CC("b",e,t,n),CC("transposeA",e,t,n),CC("transposeB",e,t,n))];case"Einsum":return[Ak(CC("equation",e,t,n),...CC("tensors",e,t,n))];case"Transpose":return[Fv(CC("x",e,t,n),CC("perm",e,t,n))];case"_FusedMatMul":const[r,s]=CC("fusedOps",e,t,n),o="biasadd"===r,i="prelu"===s,a=CC("numArgs",e,t,n),u=CC("leakyreluAlpha",e,t,n);if(o){if(i&&2!==a)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&1!==a)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[l,c]=CC("args",e,t,n);return[tk({a:CC("a",e,t,n),b:CC("b",e,t,n),transposeA:CC("transposeA",e,t,n),transposeB:CC("transposeB",e,t,n),bias:l,activation:s,preluActivationWeights:c,leakyreluAlpha:u})];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"normalization":return Tv(()=>((e,t,n)=>{switch(e.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[Ok(CC("x",e,t,n),CC("mean",e,t,n),CC("variance",e,t,n),CC("offset",e,t,n),CC("scale",e,t,n),CC("epsilon",e,t,n))];case"LRN":return[Fk(CC("x",e,t,n),CC("radius",e,t,n),CC("bias",e,t,n),CC("alpha",e,t,n),CC("beta",e,t,n))];case"Softmax":return[Dk(CC("x",e,t,n))];case"LogSoftmax":return[Pk(CC("x",e,t,n))];case"SparseToDense":return[Mk(CC("sparseIndices",e,t,n),CC("outputShape",e,t,n),CC("sparseValues",e,t,n),CC("defaultValue",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"reduction":return Tv(()=>((e,t,n)=>{switch(e.op){case"Max":{const r=CC("axis",e,t,n),s=CC("keepDims",e,t,n);return[bv(CC("x",e,t,n),r,s)]}case"Mean":{const r=CC("axis",e,t,n),s=CC("keepDims",e,t,n);return[Mv(CC("x",e,t,n),r,s)]}case"Min":{const r=CC("axis",e,t,n),s=CC("keepDims",e,t,n);return[vv(CC("x",e,t,n),r,s)]}case"Sum":{const r=CC("axis",e,t,n),s=CC("keepDims",e,t,n);return[tv(CC("x",e,t,n),r,s)]}case"All":{const r=CC("axis",e,t,n),s=CC("keepDims",e,t,n);return[Lk(CC("x",e,t,n),r,s)]}case"Any":{const r=CC("axis",e,t,n),s=CC("keepDims",e,t,n);return[Bk(CC("x",e,t,n),r,s)]}case"ArgMax":{const r=CC("axis",e,t,n);return[Yx(CC("x",e,t,n),r)]}case"ArgMin":{const r=CC("axis",e,t,n);return[Vk(CC("x",e,t,n),r)]}case"Prod":{const r=CC("axis",e,t,n),s=CC("keepDims",e,t,n);return[M_(CC("x",e,t,n),r,s)]}case"Cumsum":{const r=CC("axis",e,t,n),s=CC("exclusive",e,t,n),o=CC("reverse",e,t,n);return[Uk(CC("x",e,t,n),r,s,o)]}case"Bincount":const r=CC("x",e,t,n),s=CC("weights",e,t,n),o=CC("size",e,t,n);return[Xb(r,s,o)];case"DenseBincount":{const r=CC("x",e,t,n),s=CC("weights",e,t,n),o=CC("size",e,t,n),i=CC("binaryOutput",e,t,n);return[zk(r,s,o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"slice_join":return Tv(()=>((e,t,n)=>{switch(e.op){case"ConcatV2":case"Concat":{const r=CC("n",e,t,n),s=CC("axis",e,t,n);let o=CC("tensors",e,t,n);return o=o.slice(0,r),[Zx(o,s)]}case"Gather":{const r=CC("x",e,t,n),s=CC("indices",e,t,n);return[Wk(r,bx(s,"int32"),0)]}case"GatherV2":{const r=CC("axis",e,t,n),s=CC("batchDims",e,t,n),o=CC("x",e,t,n),i=CC("indices",e,t,n);return[Wk(o,bx(i,"int32"),r,s)]}case"Reverse":{const r=CC("dims",e,t,n),s=[];for(let e=0;e<r.length;e++)r[e]&&s.push(e);const o=CC("x",e,t,n);return[Cb(o,s)]}case"ReverseV2":{const r=CC("axis",e,t,n),s=CC("x",e,t,n);return[Cb(s,r)]}case"Slice":{const r=CC("begin",e,t,n),s=CC("size",e,t,n);return[ab(CC("x",e,t,n),r,s)]}case"StridedSlice":{const r=CC("begin",e,t,n),s=CC("end",e,t,n),o=CC("strides",e,t,n),i=CC("beginMask",e,t,n),a=CC("endMask",e,t,n),u=CC("ellipsisMask",e,t,n),l=CC("newAxisMask",e,t,n),c=CC("shrinkAxisMask",e,t,n),h=CC("x",e,t,n);return[jk(h,r,s,o,i,a,u,l,c)]}case"Pack":return Tv(()=>{const r=CC("axis",e,t,n),s=CC("tensors",e,t,n),o=s[0].shape,i=ub(s[0]).shape,a=s.map(e=>{const t=Tp(e.shape,o);if(!t&&!Tp(ub(e).shape,i))throw new Error("the input tensors shape does not match");return t?e:sb(e,o)});return[lb(a,r)]});case"Unpack":{const r=CC("axis",e,t,n),s=CC("tensor",e,t,n);return pb(s,r)}case"Tile":{const r=CC("reps",e,t,n);return[$v(CC("x",e,t,n),r)]}case"Split":case"SplitV":{const r=CC("axis",e,t,n),s=CC("numOrSizeSplits",e,t,n),o=CC("x",e,t,n);return yb(o,s,r)}case"ScatterNd":{const r=CC("indices",e,t,n),s=CC("values",e,t,n),o=CC("shape",e,t,n);return[Hk(r,s,o)]}case"GatherNd":{const r=CC("x",e,t,n),s=CC("indices",e,t,n);return[Gk(r,s)]}case"SparseToDense":{const r=CC("sparseIndices",e,t,n),s=CC("outputShape",e,t,n),o=CC("sparseValues",e,t,n),i=CC("defaultValue",e,t,n);return[Mk(r,o,s,o.dtype===i.dtype?i:bx(i,o.dtype))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"sparse":return Tv(()=>((e,t,n)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:s,emptyRowIndicator:o,reverseIndexMap:i}=nw.sparseFillEmptyRows(CC("indices",e,t,n),CC("values",e,t,n),CC("denseShape",e,t,n),CC("defaultValue",e,t,n));return[r,s,o,i]}case"SparseReshape":{const{outputIndices:r,outputShape:s}=nw.sparseReshape(CC("inputIndices",e,t,n),CC("inputShape",e,t,n),CC("newShape",e,t,n));return[r,s]}case"SparseSegmentMean":return[nw.sparseSegmentMean(CC("data",e,t,n),CC("indices",e,t,n),CC("segmentIds",e,t,n))];case"SparseSegmentSum":return[nw.sparseSegmentSum(CC("data",e,t,n),CC("indices",e,t,n),CC("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"spectral":return Tv(()=>((e,t,n)=>{switch(e.op){case"FFT":return[bb(CC("x",e,t,n))];case"IFFT":return[wb(CC("x",e,t,n))];case"RFFT":return[vb(CC("x",e,t,n))];case"IRFFT":return[_b(CC("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"string":return Tv(()=>((e,t,n)=>{switch(e.op){case"StringNGrams":{const{nGrams:r,nGramsSplits:s}=rw.stringNGrams(CC("data",e,t,n),CC("dataSplits",e,t,n),CC("separator",e,t,n),CC("nGramWidths",e,t,n),CC("leftPad",e,t,n),CC("rightPad",e,t,n),CC("padWidth",e,t,n),CC("preserveShortSequences",e,t,n));return[r,s]}case"StringSplit":{const{indices:r,values:s,shape:o}=rw.stringSplit(CC("input",e,t,n),CC("delimiter",e,t,n),CC("skipEmpty",e,t,n));return[r,s,o]}case"StringToHashBucketFast":return[rw.stringToHashBucketFast(CC("input",e,t,n),CC("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"transformation":return Tv(()=>((e,t,n)=>{switch(e.op){case"Cast":return[bx(CC("x",e,t,n),CC("dtype",e,t,n))];case"ExpandDims":{const r=CC("axis",e,t,n);return[nb(CC("x",e,t,n),r)]}case"Squeeze":{const r=CC("axis",e,t,n);return[ub(CC("x",e,t,n),r)]}case"Reshape":return[sb(CC("x",e,t,n),CC("shape",e,t,n))];case"MirrorPad":return[qk(CC("x",e,t,n),CC("padding",e,t,n),CC("mode",e,t,n))];case"PadV2":case"Pad":return[Kk(CC("x",e,t,n),CC("padding",e,t,n),CC("constantValue",e,t,n))];case"SpaceToBatchND":{const r=CC("blockShape",e,t,n),s=CC("paddings",e,t,n);return[Xk(CC("x",e,t,n),r,s)]}case"BatchToSpaceND":{const r=CC("blockShape",e,t,n),s=CC("crops",e,t,n);return[Yk(CC("x",e,t,n),r,s)]}case"DepthToSpace":{const r=CC("blockSize",e,t,n),s=CC("dataFormat",e,t,n).toUpperCase();return[Qk(CC("x",e,t,n),r,s)]}case"BroadcastTo":return[rv(CC("x",e,t,n),CC("shape",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"hash_table":return Ik(e,t,n,r);case"custom":const s=wC(e.op);if(s&&s.customExecutor)return s.customExecutor(new l_(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return Qp(s)?s.then(e=>[].concat(e)):[].concat(s)}class Jk{constructor(e={},t={},n={},r={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function eE(e,t,n,r){const s=new Set,o=[];let i=null,a=null;const u=new Set,l=Object.keys(e).map(e=>SC(e)[0]);let c=[];null!=r&&(c=r.map(e=>SC(e.name)[0]));const h=[...t];for(;h.length>0;){const e=h.pop();(sE(e)||oE(e)||iE(e))&&null==i&&(i=e,a=i.children.map(e=>e.name).filter(e=>s.has(e))),s.add(e.name),null==n[e.name]&&-1===l.indexOf(e.name)&&-1===c.indexOf(e.name)&&(0!==e.inputs.length?e.inputs.forEach(e=>{u.has(e.name)||(u.add(e.name),h.push(e))}):o.push(e.name))}return{inputs:e,outputs:t,usedNodes:s,missingInputs:o,dynamicNode:i,syncInputs:a}}const tE=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],nE=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],rE=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function sE(e){return tE.indexOf(e.op)>=0}function oE(e){return nE.indexOf(e.op)>=0}function iE(e){return rE.indexOf(e.op)>=0}class aE{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach(t=>{this._functionExecutorMap[t]=new aE(e.functions[t],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(t=>e[t].map(e=>e.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){const n=e.map(e=>e.name).sort(),r=t.map(e=>e.name).sort();return n.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(e,t){const n=eE(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:o}=n;if(null!=s)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(r.length>0){const n=t.map(e=>e.name),s=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${s}]. Missing the following inputs: [${r}]`)}return function(e,t,n){const{usedNodes:r,inputs:s}=n,o=[],i=Object.keys(s).map(e=>SC(e)[0]).map(t=>e.nodes[t]),a=e.initNodes;i.forEach(e=>{r.has(e.name)&&o.push(e)}),e.weights.forEach(e=>{r.has(e.name)&&o.push(e)}),null!=a&&a.forEach(e=>{r.has(e.name)&&o.push(e)});const u=new Set,l=[];for(;o.length>0;){const e=o.pop();u.add(e.name),t[e.name]||l.push(e),e.children.forEach(e=>{!u.has(e.name)&&r.has(e.name)&&e.inputs.every(e=>u.has(e.name))&&o.push(e)})}return l}(this.graph,this.weightMap,n)}execute(e,t){e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=n.map(e=>this.graph.nodes[SC(e)[0]]),s=t.map(e=>SC(e)[0]);let o=s.map(e=>this.graph.nodes[e]);0===o.length&&(o=this._outputs);const i=this.getCompilationKey(r,o);let a=this.compiledMap.get(i);null==a&&(a=this.compile(e,o),this.compiledMap.set(i,a));const u={},l={};return Tv(()=>{const n=new Jk(this.weightMap,u,l,this.functionExecutorMap),r=Object.assign({},this.weightMap);Object.keys(e).forEach(t=>{const[n,s]=SC(t),o=[];o[s]=e[t],r[n]=o});const o=this.getFrozenTensorIds(r),i={};for(let e=0;e<a.length;e++){const t=a[e];if(!r[t.name]){const e=Zk(t,r,n,this._resourceManager);if(Qp(e))throw new Error(`The execution of the op '${t.op}' returned a promise. Please use model.executeAsync() instead.`);r[t.name]=e,this.checkTensorForDisposal(t.name,t,r,n,o,s,i)}}return null==this.parent&&n.dispose(o),t.map(e=>_C(e,r,n))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(t=>e[t]).map(e=>e.map(e=>e.id)));return new Set(t)}checkTensorForDisposal(e,t,n,r,s,o,i){"control"!==t.category&&-1===o.indexOf(e)&&(n[e].forEach(e=>{null!=e&&(i[e.id]=(i[e.id]||0)+t.children.length)}),t.inputs.forEach(e=>{if("control"!==e.category){const t=function(e,t,n){return t[EC(e,n.currentContextId)]}(e.name,n,r);null!=t&&t.forEach(e=>{if(e&&!e.kept&&!s.has(e.id)){const t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}})}}))}executeAsync(e,t){var n=this;return mp(function*(){return n._executeAsync(e,t)})()}_executeAsync(e,t,n=!1,r={},s={}){var o=this;return mp(function*(){n||(e=o.mapInputs(e),o.checkInputs(e),o.checkInputShapeAndType(e),t=o.mapOutputs(t),o.checkOutputs(t));const i=new Jk(o.weightMap,r,s,o.functionExecutorMap),a=yield o.executeWithControlFlow(e,i,t,n),u=t.map(e=>_C(e,a,i)),l=u.map(e=>e.id),c=Object.keys(e).map(t=>e[t].id),h=new Set([...l,...c,...o.weightIds]);return Object.keys(a).forEach(e=>{a[e].forEach(e=>{!e||e.kept||e.isDisposed||h.has(e.id)||e.dispose()})}),null==o.parent&&i.dispose(h),u})()}executeFunctionAsync(e,t,n){var r=this;return mp(function*(){const s=e.reduce((e,t,n)=>(e[r.inputs[n].name]=t,e),{});return r._executeAsync(s,r.outputNodes,!0,t,n)})()}executeWithControlFlow(e,t,n,r){var s=this;return mp(function*(){const o=Object.keys(e),i=o.map(e=>s.graph.nodes[SC(e)[0]]),a=n.map(e=>SC(e)[0]);let u=a.map(e=>s.graph.nodes[e]);0===u.length&&(u=s._outputs);const{usedNodes:l,missingInputs:c,dynamicNode:h,syncInputs:d}=eE(e,u,s.weightMap,s._initNodes),p=[...i,...s.graph.weights,...s._initNodes||[]].map(e=>({node:e,contexts:t.currentContext})),f=Object.assign({},s.weightMap);Object.keys(e).forEach(t=>{const[n,r]=SC(t),s=[];s[r]=e[t],f[n]=s});const m={},g=s.getFrozenTensorIds(f),y={};for(;p.length>0;){const e=s.processStack(i,p,t,f,y,g,a,m,l);yield Promise.all(e)}null!=h||r||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const x=u.filter(e=>!sE(e)&&!_C(e.name,f,t)).map(e=>e.name);if(x.length>0){let e="";throw null!=h&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${x}] from the provided inputs [${o}]. Consider providing the following inputs: [${c}]. ${e}`)}return f})()}processStack(e,t,n,r,s,o,i,a,u){const l=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let c="";if("Enter"===e.node.op&&CC("isConstant",e.node,r,n)&&([c]=kC(e.node.name,n)),null==r[e.node.name]){const h=Zk(e.node,r,n,this._resourceManager);c||([c]=kC(e.node.name,n));const d=n.currentContext;Qp(h)?l.push(h.then(l=>(r[c]=l,n.currentContext=d,this.checkTensorForDisposal(c,e.node,r,n,o,i,a),this.processChildNodes(e.node,t,n,r,s,u),l))):(r[c]=h,this.checkTensorForDisposal(c,e.node,r,n,o,i,a),this.processChildNodes(e.node,t,n,r,s,u))}else this.processChildNodes(e.node,t,n,r,s,u)}return l}processChildNodes(e,t,n,r,s,o){e.children.forEach(e=>{const[i]=kC(e.name,n);!s[i]&&o.has(e.name)&&("Merge"===e.op?e.inputNames.some(e=>!!_C(e,r,n))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every(e=>!!_C(e,r,n))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(e=>e.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const n=e[t],[r]=SC(t),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){const e=s.attrParams.shape.value;Cp(e.length===n.shape.length&&n.shape.every((t,n)=>-1===e[n]||e[n]===t),()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&Cp(n.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(e){const t={};for(const n in e)null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[n]?t[this._signature.inputs[n].name]=e[n]:t[n]=e[n];return t}checkInputs(e){const t=Object.keys(e).filter(e=>{const[t]=SC(e);return null==this.graph.nodes[t]});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(e=>null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[e]?this._signature.outputs[e].name:e,{})}checkOutputs(e){e.forEach(e=>{const[t]=SC(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)})}}class uE{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}class lE{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",null==t&&(this.loadOptions={}),this.resourceManager=new uE}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=$x(e,this.loadOptions);else{const t=Ky.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push($x(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){var e=this;return mp(function*(){if(e.findIOHandler(),null==e.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=yield e.handler.load();return e.loadSync(t)})()}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let n;n=null!=this.artifacts.userDefinedMetadata&&null!=this.artifacts.userDefinedMetadata.signature?this.artifacts.userDefinedMetadata.signature:this.artifacts.signature,this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const r=function(e,t){const n={};let r,s=0;for(const o of t){const t=o.name,i=o.dtype,a=o.shape,u=Sp(a);let l;if("quantization"in o){const n=o.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error(`Weight ${o.name} with quantization ${n.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==n.dtype)throw new Error(`Weight ${o.name} has unknown quantization dtype ${n.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==i)throw new Error(`Weight ${o.name} is quantized with ${n.dtype} which only supports weights of type float32 not ${i}.`)}const a=zy[n.dtype],c=e.slice(s,s+u*a),h="uint8"===n.dtype?new Uint8Array(c):new Uint16Array(c);if("float32"===i)if("uint8"===n.dtype||"uint16"===n.dtype){l=new Float32Array(h.length);for(let e=0;e<h.length;e++)l[e]=h[e]*n.scale+n.min}else{if("float16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type float32.`);void 0===r&&(r=qy()),l=r(h)}else{if("int32"!==i)throw new Error(`Unsupported dtype in weight '${t}': ${i}`);if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error(`Unsupported quantization type ${n.dtype} for weight type int32.`);l=new Int32Array(h.length);for(let e=0;e<h.length;e++)l[e]=Math.round(h[e]*n.scale+n.min)}s+=u*a}else if("string"===i){const t=Sp(o.shape);l=[];for(let n=0;n<t;n++){const t=new Uint32Array(e.slice(s,s+4))[0];s+=4;const n=new Uint8Array(e.slice(s,s+t));l.push(n),s+=t}}else{const r=zy[i],o=e.slice(s,s+u*r);if("float32"===i)l=new Float32Array(o);else if("int32"===i)l=new Int32Array(o);else if("bool"===i)l=new Uint8Array(o);else{if("complex64"!==i)throw new Error(`Unsupported dtype in weight '${t}': ${i}`);{l=new Float32Array(o);const e=new Float32Array(l.length/2),r=new Float32Array(l.length/2);for(let t=0;t<e.length;t++)e[t]=l[2*t],r[t]=l[2*t+1];const s=Uy(e,a,"float32"),i=Uy(r,a,"float32");n[t]=By(s,i),s.dispose(),i.dispose()}}s+=u*r}"complex64"!==i&&(n[t]=Uy(l,a,i))}return n}(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new aE(KC.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=KC.Instance.transformGraph(e.modelInitializer);this.initializer=new aE(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}save(e,t){var n=this;return mp(function*(){if("string"==typeof e){const t=Ky.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(n.artifacts)})()}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof dy||Array.isArray(e)))return e;if((e=Array.isArray(e)?e:[e]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,n,r)=>(t[n]=e[r],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}executeAsync(e,t){var n=this;return mp(function*(){e=n.normalizeInputs(e),t=n.normalizeOutputs(t);const r=yield n.executor.executeAsync(e,t);return r.length>1?r:r[0]})()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}function cE(e){return hE.apply(this,arguments)}function hE(){return(hE=mp(function*(e,t={}){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&null==e.load&&(e.endsWith("/")||(e+="/"),e=`${e}model.json?tfjs-format=file`);const n=new lE(e,t);return yield n.load(),n})).apply(this,arguments)}var dE=function(){return(dE=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var s in t=arguments[n])Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s]);return e}).apply(this,arguments)};function pE(e,t,n,r){return new(n||(n=Promise))(function(s,o){function i(e){try{u(r.next(e))}catch(e){o(e)}}function a(e){try{u(r.throw(e))}catch(e){o(e)}}function u(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n(function(e){e(t)})).then(i,a)}u((r=r.apply(e,t||[])).next())})}function fE(e,t){var n,r,s,o,i={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function a(o){return function(a){return function(o){if(n)throw new TypeError("Generator is already executing.");for(;i;)try{if(n=1,r&&(s=2&o[0]?r.return:o[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,o[1])).done)return s;switch(r=0,s&&(o=[2&o[0],s.value]),o[0]){case 0:case 1:s=o;break;case 4:return i.label++,{value:o[1],done:!1};case 5:i.label++,r=o[1],o=[0];continue;case 7:o=i.ops.pop(),i.trys.pop();continue;default:if(!((s=(s=i.trys).length>0&&s[s.length-1])||6!==o[0]&&2!==o[0])){i=0;continue}if(3===o[0]&&(!s||o[1]>s[0]&&o[1]<s[3])){i.label=o[1];break}if(6===o[0]&&i.label<s[1]){i.label=s[1],s=o;break}if(s&&i.label<s[2]){i.label=s[2],i.ops.push(o);break}s[2]&&i.ops.pop(),i.trys.pop();continue}o=t.call(e,i)}catch(e){o=[6,e],r=0}finally{n=s=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,a])}}}var mE=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],gE=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"],yE={left:[1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31],right:[4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32],middle:[0]},xE={left:[1,3,5,7,9,11,13,15],right:[2,4,6,8,10,12,14,16],middle:[0]},bE=[[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[5,11],[6,8],[6,12],[7,9],[8,10],[11,12],[11,13],[12,14],[13,15],[14,16]],vE=[[0,1],[0,4],[1,2],[2,3],[3,7],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[11,23],[12,14],[14,16],[12,24],[13,15],[15,17],[16,18],[16,20],[15,17],[15,19],[15,21],[16,22],[17,19],[18,20],[23,25],[23,24],[24,26],[25,27],[26,28],[27,29],[28,30],[27,31],[28,32],[29,31],[30,32]],wE={runtime:"mediapipe",enableSmoothing:!0,modelType:"full"},CE=function(){function e(e){var t,n=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new gp.Pose({locateFile:function(t,n){return e.solutionPath?e.solutionPath.replace(/\/+$/,"")+"/"+t:n+"/"+t}}),e.modelType){case"lite":t=0;break;case"heavy":t=2;break;case"full":default:t=1}this.poseSolution.setOptions({modelComplexity:t,smoothLandmarks:e.enableSmoothing||!0,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(e){n.height=e.image.height,n.width=e.image.width,n.poses=n.translateOutputs(e)})}return e.prototype.translateOutputs=function(e){var t=this;return null!=e.poseLandmarks?[{keypoints:e.poseLandmarks.map(function(e,n){return{x:e.x*t.width,y:e.y*t.height,z:e.z,score:e.visibility,name:gE[n]}})}]:[]},e.prototype.estimatePoses=function(e,t,n){return pE(this,void 0,void 0,function(){return fE(this,function(r){switch(r.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),[4,this.poseSolution.send({image:e},n)];case 1:return r.sent(),[2,this.poses]}})})},e.prototype.dispose=function(){this.poseSolution.close()},e.prototype.reset=function(){this.poseSolution.reset()},e.prototype.initialize=function(){return this.poseSolution.initialize()},e}();function _E(e){return pE(this,void 0,void 0,function(){var t,n;return fE(this,function(r){switch(r.label){case 0:return t=function(e){if(null==e)return dE({},wE);var t=dE({},e);return t.runtime="mediapipe",null==t.enableSmoothing&&(t.enableSmoothing=wE.enableSmoothing),null==t.modelType&&(t.modelType=wE.modelType),t}(e),[4,(n=new CE(t)).initialize()];case 1:return r.sent(),[2,n]}})})}function kE(e){return e instanceof dy?{height:e.shape[0],width:e.shape[1]}:{height:e.height,width:e.width}}function EE(e){return e-2*Math.PI*Math.floor((e+Math.PI)/(2*Math.PI))}function SE(e){return e instanceof dy?e:Ax(e)}function TE(e,t){Cp(0!==e.width,function(){return t+" width cannot be 0."}),Cp(0!==e.height,function(){return t+" height cannot be 0."})}function IE(e,t,n){var r=t.inputResolution,s=t.keepAspectRatio,o=kE(e),i=function(e,t){return t?{xCenter:t.xCenter*e.width,yCenter:t.yCenter*e.height,width:t.width*e.width,height:t.height*e.height,rotation:t.rotation}:{xCenter:.5*e.width,yCenter:.5*e.height,width:e.width,height:e.height,rotation:0}}(o,n),a=function(e,t,n){if(void 0===n&&(n=!1),!n)return{top:0,left:0,right:0,bottom:0};var r=t.height,s=t.width;TE(t,"targetSize"),TE(e,"roi");var o,i,a=r/s,u=e.height/e.width,l=0,c=0;return a>u?(o=e.width,i=e.width*a,c=(1-u/a)/2):(o=e.height/a,i=e.height,l=(1-a/u)/2),e.width=o,e.height=i,{top:c,left:l,right:l,bottom:c}}(i,r,s);return{imageTensor:Tv(function(){var t=SE(e),n=db(function(e,t,n,r){TE(r,"inputResolution");var s=1/t.width,o=1/t.height,i=e.xCenter,a=e.yCenter,u=Math.cos(e.rotation),l=Math.sin(e.rotation),c=e.width,h=e.height;return[1/r.width*c*u*1*s*t.width,1/r.height*-h*l*s*t.width,(-.5*c*u*1+.5*h*l+i)*s*t.width,1/r.width*c*l*1*o*t.height,1/r.height*h*u*o*t.height,(-.5*h*u-.5*c*l*1+a)*o*t.height,0,0]}(i,o,0,r),[1,8]);return tw.transform(nb(bx(t,"float32")),n,"bilinear","nearest",0,[r.height,r.width])}),padding:a}}function NE(e){return null!=e&&null!=e.currentTime}var $E=function(){function e(e){this.alpha=e,this.initialized=!1}return e.prototype.apply=function(e,t){var n;return this.initialized?n=null==t?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*t*Math.asinh((e-this.storedValue)/t):(n=e,this.initialized=!0),this.rawValue=e,this.storedValue=n,n},e.prototype.applyWithAlpha=function(e,t,n){return this.alpha=t,this.apply(e,n)},e.prototype.hasLastRawValue=function(){return this.initialized},e.prototype.lastRawValue=function(){return this.rawValue},e.prototype.reset=function(){this.initialized=!1},e}(),RE=function(){function e(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new $E(this.getAlpha(this.minCutOff)),this.dx=new $E(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return e.prototype.apply=function(e,t,n){if(null==e)return e;var r=Math.trunc(t);if(this.lastTimestamp>=r)return e;0!==this.lastTimestamp&&0!==r&&(this.frequency=1/(1e-6*(r-this.lastTimestamp))),this.lastTimestamp=r;var s=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*n*this.frequency:0,o=this.dx.applyWithAlpha(s,this.getAlpha(this.derivateCutOff)),i=this.minCutOff+this.beta*Math.abs(o),a=null!=this.thresholdCutOff?this.thresholdCutOff+this.thresholdBeta*Math.abs(o):null;return this.x.applyWithAlpha(e,this.getAlpha(i),a)},e.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},e}(),AE=function(){function e(e){this.config=e}return e.prototype.apply=function(e,t,n){var r=this;if(null==e)return this.reset(),null;this.initializeFiltersIfEmpty(e);var s=1;if(null!=this.config.minAllowedObjectScale){if(n<this.config.minAllowedObjectScale)return e.slice();s=1/n}return e.map(function(e,n){var o=dE({},e,{x:r.xFilters[n].apply(e.x,t,s),y:r.yFilters[n].apply(e.y,t,s)});return null!=e.z&&(o.z=r.zFilters[n].apply(e.z,t,s)),o})},e.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},e.prototype.initializeFiltersIfEmpty=function(e){var t=this;null!=this.xFilters&&this.xFilters.length===e.length||(this.xFilters=e.map(function(e){return new RE(t.config)}),this.yFilters=e.map(function(e){return new RE(t.config)}),this.zFilters=e.map(function(e){return new RE(t.config)}))},e}();function OE(e,t){return e.map(function(e){var n=dE({},e,{x:e.x/t.width,y:e.y/t.height});return null!=e.z&&(e.z=e.z/t.width),n})}var FE=function(){function e(e){this.config=e,this.window=[],this.lowPassFilter=new $E(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return e.prototype.apply=function(e,t,n){if(null==e)return e;var r,s=Math.trunc(t);if(this.lastTimestamp>=s)return e;if(-1===this.lastTimestamp)r=1;else{for(var o=e*n-this.lastValue*this.lastValueScale,i=s-this.lastTimestamp,a=o,u=i,l=(1+this.window.length)*(1e6/30),c=0,h=this.window;c<h.length;c++){var d=h[c];if(u+d.duration>l)break;a+=d.distance,u+=d.duration}r=1-1/(1+this.config.velocityScale*Math.abs(a/(1e-6*u))),this.window.unshift({distance:o,duration:i}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=n,this.lastTimestamp=s,this.lowPassFilter.applyWithAlpha(e,r)},e}(),DE=function(){function e(e){this.config=e}return e.prototype.apply=function(e,t,n){var r=this;if(null==e)return this.reset(),null;var s=1;if(!this.config.disableValueScaling){if(n<this.config.minAllowedObjectScale)return e.slice();s=1/n}return this.initializeFiltersIfEmpty(e),e.map(function(e,n){var o=dE({},e,{x:r.xFilters[n].apply(e.x,t,s),y:r.yFilters[n].apply(e.y,t,s)});return null!=e.z&&(o.z=r.zFilters[n].apply(e.z,t,s)),o})},e.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},e.prototype.initializeFiltersIfEmpty=function(e){var t=this;null!=this.xFilters&&this.xFilters.length===e.length||(this.xFilters=e.map(function(e){return new FE(t.config)}),this.yFilters=e.map(function(e){return new FE(t.config)}),this.zFilters=e.map(function(e){return new FE(t.config)}))},e}();function PE(e,t){return e.map(function(e){var n=dE({},e,{x:e.x*t.width,y:e.y*t.height});return null!=e.z&&(n.z=e.z*t.width),n})}var ME=function(){function e(e){if(null!=e.velocityFilter)this.keypointsFilter=new DE(e.velocityFilter);else{if(null==e.oneEuroFilter)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+e+".");this.keypointsFilter=new AE(e.oneEuroFilter)}}return e.prototype.apply=function(e,t,n,r,s){if(void 0===r&&(r=!1),null==e)return this.keypointsFilter.reset(),null;var o=null!=s?function(e,t){return(e.width*t.width+e.height*t.height)/2}(s,n):1,i=r?PE(e,n):e,a=this.keypointsFilter.apply(i,t,o);return r?OE(a,n):a},e}();function LE(e,t){var n=function(e,t,n,r){var s=(r-n)/255;return{scale:s,offset:n-0*s}}(0,0,t[0],t[1]);return Tv(function(){return Xx(rb(e,n.scale),n.offset)})}function BE(e,t,n){var r=n.rotationVectorStartKeypointIndex,s=n.rotationVectorEndKeypointIndex,o=e.locationData,i=o.relativeKeypoints[r].x*t.width,a=o.relativeKeypoints[r].y*t.height,u=o.relativeKeypoints[s].x*t.width,l=o.relativeKeypoints[s].y*t.height,c=2*Math.sqrt((u-i)*(u-i)+(l-a)*(l-a)),h=function(e,t,n){var r=e.locationData,s=n.rotationVectorStartKeypointIndex,o=n.rotationVectorEndKeypointIndex;return EE((n.rotationVectorTargetAngle?n.rotationVectorTargetAngle:Math.PI*n.rotationVectorTargetAngleDegree/180)-Math.atan2(-(r.relativeKeypoints[o].y*t.height-r.relativeKeypoints[s].y*t.height),r.relativeKeypoints[o].x*t.width-r.relativeKeypoints[s].x*t.width))}(e,t,n);return{xCenter:i/t.width,yCenter:a/t.height,width:c/t.width,height:c/t.height,rotation:h}}function VE(e,t,n,r){return 1===r?.5*(e+t):e+(t-e)*n/(r-1)}function UE(e){for(var t={locationData:{relativeKeypoints:[]}},n=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,s=Number.MAX_SAFE_INTEGER,o=Number.MIN_SAFE_INTEGER,i=0;i<e.length;++i){var a=e[i];n=Math.min(n,a.x),r=Math.max(r,a.x),s=Math.min(s,a.y),o=Math.max(o,a.y),t.locationData.relativeKeypoints.push({x:a.x,y:a.y})}return t.locationData.relativeBoundingBox={xMin:n,yMin:s,xMax:r,yMax:o,width:r-n,height:o-s},t}function zE(e,t,n,r){return pE(this,void 0,void 0,function(){var s,o,i,a,u;return fE(this,function(l){switch(l.label){case 0:return s=db(e.map(function(e){return[e.locationData.relativeBoundingBox.yMin,e.locationData.relativeBoundingBox.xMin,e.locationData.relativeBoundingBox.yMax,e.locationData.relativeBoundingBox.xMax]})),o=hb(e.map(function(e){return e.score[0]})),[4,tw.nonMaxSuppressionAsync(s,o,t,n,r)];case 1:return[4,(i=l.sent()).array()];case 2:return a=l.sent(),u=e.filter(function(e,t){return a.indexOf(t)>-1}),Iv([s,o,i]),[2,u]}})})}function WE(e,t,n){return pE(this,void 0,void 0,function(){var r,s,o,i,a,u,l,c,h,d,p,f,m,g,y,x,b,v,w,C,_,k,E;return fE(this,function(S){switch(S.label){case 0:if(r=ub(t,[0]),o=(s=r.shape)[0],i=s[1],e.length!==(a=s[2]))throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+e.length+", heatmap length: "+a);return u=[],[4,r.buffer()];case 1:for(l=S.sent(),c=0;c<e.length;c++)if(h=dE({},e[c]),u.push(h),d=Math.trunc(h.x*i),p=Math.trunc(h.y*o),!(d<0||d>=i||p<0||d>=o)){for(f=Math.trunc((n.kernelSize-1)/2),m=Math.max(0,d-f),g=Math.min(i,d+f+1),y=Math.max(0,p-f),x=Math.min(o,p+f+1),b=0,v=0,w=0,C=0,_=y;_<x;++_)for(k=m;k<g;++k)E=l.get(_,k,c),b+=E,C=Math.max(C,E),v+=k*E,w+=_*E;C>=n.minConfidenceToRefine&&b>0&&(h.x=v/i/b,h.y=w/o/b)}return r.dispose(),[2,u]}})})}function jE(e,t,n){return pE(this,void 0,void 0,function(){var r,s,o,i;return fE(this,function(a){switch(a.label){case 0:return r=e[0],s=function(e,t,n){return Tv(function(){var r,s,o,i;n.reverseOutputOrder?(s=ub(ab(e,[0,n.boxCoordOffset+0],[-1,1])),r=ub(ab(e,[0,n.boxCoordOffset+1],[-1,1])),i=ub(ab(e,[0,n.boxCoordOffset+2],[-1,1])),o=ub(ab(e,[0,n.boxCoordOffset+3],[-1,1]))):(r=ub(ab(e,[0,n.boxCoordOffset+0],[-1,1])),s=ub(ab(e,[0,n.boxCoordOffset+1],[-1,1])),o=ub(ab(e,[0,n.boxCoordOffset+2],[-1,1])),i=ub(ab(e,[0,n.boxCoordOffset+3],[-1,1]))),s=Xx(rb(eb(s,n.xScale),t.w),t.x),r=Xx(rb(eb(r,n.yScale),t.h),t.y),n.applyExponentialOnBoxSize?(o=rb(tb(eb(o,n.hScale)),t.h),i=rb(tb(eb(i,n.wScale)),t.w)):(o=rb(eb(o,n.hScale),t.h),i=rb(eb(i,n.wScale),t.h));var a=cb(r,eb(o,2)),u=cb(s,eb(i,2)),l=Xx(r,eb(o,2)),c=Xx(s,eb(i,2)),h=Zx([sb(a,[n.numBoxes,1]),sb(u,[n.numBoxes,1]),sb(l,[n.numBoxes,1]),sb(c,[n.numBoxes,1])],1);if(n.numKeypoints)for(var d=0;d<n.numKeypoints;++d){var p=n.keypointCoordOffset+d*n.numValuesPerKeypoint,f=void 0,m=void 0;n.reverseOutputOrder?(f=ub(ab(e,[0,p],[-1,1])),m=ub(ab(e,[0,p+1],[-1,1]))):(m=ub(ab(e,[0,p],[-1,1])),f=ub(ab(e,[0,p+1],[-1,1])));var g=Xx(rb(eb(f,n.xScale),t.w),t.x),y=Xx(rb(eb(m,n.yScale),t.h),t.y);h=Zx([h,sb(g,[n.numBoxes,1]),sb(y,[n.numBoxes,1])],1)}return h})}(e[1],t,n),o=Tv(function(){var e=r;return n.sigmoidScore?(null!=n.scoreClippingThresh&&(e=Qx(r,-n.scoreClippingThresh,n.scoreClippingThresh)),e=ib(e)):e}),[4,HE(s,o,n)];case 1:return i=a.sent(),Iv([s,o]),[2,i]}})})}function HE(e,t,n){return pE(this,void 0,void 0,function(){var r,s,o,i,a,u,l,c,h,d,p;return fE(this,function(f){switch(f.label){case 0:return r=[],[4,e.data()];case 1:return s=f.sent(),[4,t.data()];case 2:for(o=f.sent(),i=0;i<n.numBoxes;++i)if(!(null!=n.minScoreThresh&&o[i]<n.minScoreThresh||(a=i*n.numCoords,u=GE(s[a+0],s[a+1],s[a+2],s[a+3],o[i],n.flipVertically,i),(l=u.locationData.relativeBoundingBox).width<0||l.height<0))){if(n.numKeypoints>0)for((c=u.locationData).relativeKeypoints=[],h=n.numKeypoints*n.numValuesPerKeypoint,d=0;d<h;d+=n.numValuesPerKeypoint)c.relativeKeypoints.push({x:s[(p=a+n.keypointCoordOffset+d)+0],y:n.flipVertically?1-s[p+1]:s[p+1]});r.push(u)}return[2,r]}})})}function GE(e,t,n,r,s,o,i){return{score:[s],ind:i,locationData:{relativeBoundingBox:{xMin:t,yMin:o?1-n:e,xMax:r,yMax:o?1-e:n,width:r-t,height:n-e}}}}function qE(e,t,n,r){return void 0===n&&(n=!1),void 0===r&&(r=!1),pE(this,void 0,void 0,function(){var s,o,i,a,u,l,c;return fE(this,function(h){switch(h.label){case 0:return s=e.size/t.numLandmarks,[4,e.data()];case 1:for(o=h.sent(),i=[],a=0;a<t.numLandmarks;++a)u=a*s,(c={x:0,y:0}).x=n?t.inputImageWidth-o[u]:o[u],s>1&&(c.y=r?t.inputImageHeight-o[u+1]:o[u+1]),s>2&&(c.z=o[u+2]),s>3&&(c.score=1/(1+Math.exp(-o[u+3]))),i.push(c);for(l=0;l<i.length;++l)(c=i[l]).x=c.x/t.inputImageWidth,c.y=c.y/t.inputImageHeight,c.z=c.z/t.inputImageWidth/(t.normalizeZ||1);return[2,i]}})})}function KE(e,t,n){var r=e.width,s=e.height,o=e.rotation;if(null==n.rotation&&null==n.rotationDegree||(o=function(e,t){return null!=t.rotation?e+=t.rotation:null!=t.rotationDegree&&(e+=Math.PI*t.rotationDegree/180),EE(e)}(o,n)),0===o)e.xCenter=e.xCenter+r*n.shiftX,e.yCenter=e.yCenter+s*n.shiftY;else{var i=(t.width*r*n.shiftX*Math.cos(o)-t.height*s*n.shiftY*Math.sin(o))/t.width,a=(t.width*r*n.shiftX*Math.sin(o)+t.height*s*n.shiftY*Math.cos(o))/t.height;e.xCenter=e.xCenter+i,e.yCenter=e.yCenter+a}if(n.squareLong){var u=Math.max(r*t.width,s*t.height);r=u/t.width,s=u/t.height}else if(n.squareShort){var l=Math.min(r*t.width,s*t.height);r=l/t.width,s=l/t.height}return e.width=r*n.scaleX,e.height=s*n.scaleY,e}var XE,YE,QE=function(){function e(e){this.alpha=e.alpha}return e.prototype.apply=function(e){var t=this;if(null==e)return this.visibilityFilters=null,null;null!=this.visibilityFilters&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map(function(e){return new $E(t.alpha)}));for(var n=[],r=0;r<e.length;++r){var s=e[r],o=dE({},s);o.score=this.visibilityFilters[r].apply(s.score),n.push(o)}return n},e}(),ZE={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},JE={runtime:"tfjs",modelType:"full",enableSmoothing:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazeposedetector/1/default/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazeposelandmark_full/1/default/1"},eS={maxPoses:1,flipHorizontal:!1},tS={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},nS={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},rS={inputResolution:{width:224,height:224},keepAspectRatio:!0},sS={inputResolution:{width:256,height:256},keepAspectRatio:!0},oS={numLandmarks:39,inputImageWidth:256,inputImageHeight:256},iS={kernelSize:7,minConfidenceToRefine:.5},aS={alpha:.1},uS={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},lS={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},cS=function(){function e(e,t,n,r){this.detectorModel=e,this.landmarkModel=t,this.enableSmoothing=n,this.modelType=r,this.regionOfInterest=null,this.anchors=function(e){for(var t=[],n=0;n<e.numLayers;){for(var r=[],s=[],o=[],i=[],a=n;a<e.strides.length&&e.strides[a]===e.strides[n];){var u=VE(e.minScale,e.maxScale,a,e.strides.length);if(0===a&&e.reduceBoxesInLowestLayer)o.push(1),o.push(2),o.push(.5),i.push(.1),i.push(u),i.push(u);else{for(var l=0;l<e.aspectRatios.length;++l)o.push(e.aspectRatios[l]),i.push(u);if(e.interpolatedScaleAspectRatio>0){var c=a===e.strides.length-1?1:VE(e.minScale,e.maxScale,a+1,e.strides.length);i.push(Math.sqrt(u*c)),o.push(e.interpolatedScaleAspectRatio)}}a++}for(var h=0;h<o.length;++h){var d=Math.sqrt(o[h]);r.push(i[h]/d),s.push(i[h]*d)}var p=0,f=0;if(e.featureMapHeight.length>0)p=e.featureMapHeight[n],f=e.featureMapWidth[n];else{var m=e.strides[n];p=Math.ceil(e.inputSizeHeight/m),f=Math.ceil(e.inputSizeWidth/m)}for(var g=0;g<p;++g)for(var y=0;y<f;++y)for(var x=0;x<r.length;++x){var b={xCenter:(y+e.anchorOffsetX)/f,yCenter:(g+e.anchorOffsetY)/p,width:0,height:0};e.fixedAnchorSize?(b.width=1,b.height=1):(b.width=s[x],b.height=r[x]),t.push(b)}n=a}return t}(ZE);var s=hb(this.anchors.map(function(e){return e.width})),o=hb(this.anchors.map(function(e){return e.height})),i=hb(this.anchors.map(function(e){return e.xCenter})),a=hb(this.anchors.map(function(e){return e.yCenter}));this.anchorTensor={x:i,y:a,w:s,h:o}}return e.prototype.estimatePoses=function(e,t,n){return pE(this,void 0,void 0,function(){var r,s,o,i,a,u,l,c,h,d,p;return fE(this,function(f){switch(f.label){case 0:return r=function(e){var t;if(null==(t=null==e?eS:dE({},e)).maxPoses&&(t.maxPoses=1),t.maxPoses<=0)throw new Error("Invalid maxPoses "+t.maxPoses+". Should be > 0.");if(t.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return t}(t),null==e?(this.reset(),[2,[]]):(this.maxPoses=r.maxPoses,this.timestamp=null!=n?1e3*n:NE(e)?1e6*e.currentTime:null,s=kE(e),o=Tv(function(){return bx(SE(e),"float32")}),null!=(i=this.regionOfInterest)?[3,2]:[4,this.detectPose(o)]);case 1:if(0===(a=f.sent()).length)return this.reset(),o.dispose(),[2,[]];i=this.poseDetectionToRoi(a[0],s),f.label=2;case 2:return[4,this.poseLandmarksByRoi(i,o)];case 3:return u=f.sent(),o.dispose(),null==u?(this.reset(),[2,[]]):(l=u.poseScore,c=this.poseLandmarkFiltering(u.actualLandmarks,u.auxiliaryLandmarks,s),h=c.actualLandmarksFiltered,d=this.poseLandmarksToRoi(c.auxiliaryLandmarksFiltered,s),this.regionOfInterest=d,null!=(p=null!=h?PE(h,s):null)&&p.forEach(function(e,t){e.name=gE[t]}),[2,[{score:l,keypoints:p}]])}})})},e.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),Iv([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h])},e.prototype.reset=function(){this.regionOfInterest=null,this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},e.prototype.detectPose=function(e){return pE(this,void 0,void 0,function(){var t,n,r,s,o,i,a,u,l;return fE(this,function(c){switch(c.label){case 0:return t=IE(e,rS),r=t.padding,s=LE(n=t.imageTensor,[-1,1]),o=function(e,t){return Tv(function(){var n=function(e){return Tv(function(){var t=ab(e,[0,0,0],[1,-1,1]);return[ib(t),ab(e,[0,0,1],[1,-1,-1])]})}(t.predict(e)),r=n[0];return{boxes:ub(n[1]),scores:ub(r)}})}(s,this.detectorModel),[4,jE([a=o.scores,i=o.boxes],this.anchorTensor,tS)];case 1:return[4,zE(c.sent(),this.maxPoses,.3,-1)];case 2:return u=c.sent(),l=function(e,t){void 0===e&&(e=[]);for(var n=t.left,r=t.top,s=t.left+t.right,o=t.top+t.bottom,i=0;i<e.length;i++){var a=e[i],u=a.locationData.relativeBoundingBox,l=(u.yMin-r)/(1-o),c=u.width/(1-s),h=u.height/(1-o);u.xMin=(u.xMin-n)/(1-s),u.yMin=l,u.width=c,u.height=h;for(var d=0;d<a.locationData.relativeKeypoints.length;++d){var p=a.locationData.relativeKeypoints[d],f=(p.y-r)/(1-o);p.x=(p.x-n)/(1-s),p.y=f}}return e}(u,r),Iv([n,s,a,i]),[2,l]}})})},e.prototype.poseDetectionToRoi=function(e,t){return KE(BE(e,t,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),t,nS)},e.prototype.poseLandmarksByRoi=function(e,t){return pE(this,void 0,void 0,function(){var n,r,s,o,i,a,u,l,c,h,d,p,f,m;return fE(this,function(g){switch(g.label){case 0:switch(n=IE(t,sS,e),s=n.padding,o=LE(r=n.imageTensor,[0,1]),i=this.landmarkModel.predict(o),this.modelType){case"lite":a=i[2],u=i[4],l=i[3];break;case"full":a=i[4],u=i[3],l=i[1];break;case"heavy":a=i[3],u=i[1],l=i[4];break;default:throw new Error("Model type must be one of lite, full or heavy,but got "+this.modelType)}return[4,u.data()];case 1:return(c=g.sent()[0])<.5?(Iv(i),Iv([r,o]),[2,null]):[4,qE(a,oS)];case 2:return[4,WE(g.sent(),l,iS)];case 3:return h=g.sent(),d=function(e,t){var n=t.left,r=t.top,s=t.left+t.right,o=t.top+t.bottom;return e.map(function(e){return dE({},e,{x:(e.x-n)/(1-s),y:(e.y-r)/(1-o),z:e.z/(1-s)})})}(h,s),p=function(e,t,n){void 0===n&&(n={ignoreRotation:!1});for(var r=[],s=0,o=e;s<o.length;s++){var i=o[s],a=i.x-.5,u=i.y-.5,l=n.ignoreRotation?0:t.rotation,c=Math.cos(l)*a-Math.sin(l)*u,h=Math.sin(l)*a+Math.cos(l)*u;c=c*t.width+t.xCenter,h=h*t.height+t.yCenter;var d=i.z*t.width,p=dE({},i);p.x=c,p.y=h,p.z=d,r.push(p)}return r}(d,e),f=p.slice(0,33),m=p.slice(33,35),Iv(i),Iv([r,o]),[2,{actualLandmarks:f,auxiliaryLandmarks:m,poseScore:c}]}})})},e.prototype.poseLandmarksToRoi=function(e,t){return KE(BE(UE(e),t,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),t,nS)},e.prototype.poseLandmarkFiltering=function(e,t,n){var r,s;if(null!=this.timestamp&&this.enableSmoothing){var o=BE(UE(t),n,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});null==this.visibilitySmoothingFilterActual&&(this.visibilitySmoothingFilterActual=new QE(aS)),r=this.visibilitySmoothingFilterActual.apply(e),null==this.visibilitySmoothingFilterAuxiliary&&(this.visibilitySmoothingFilterAuxiliary=new QE(aS)),s=this.visibilitySmoothingFilterAuxiliary.apply(t),null==this.landmarksSmoothingFilterActual&&(this.landmarksSmoothingFilterActual=new ME(uS)),r=this.landmarksSmoothingFilterActual.apply(r,this.timestamp,n,!0,o),null==this.landmarksSmoothingFilterAuxiliary&&(this.landmarksSmoothingFilterAuxiliary=new ME(lS)),s=this.landmarksSmoothingFilterAuxiliary.apply(s,this.timestamp,n,!0,o)}else r=e,s=t;return{actualLandmarksFiltered:r,auxiliaryLandmarksFiltered:s}},e}();function hS(e){return pE(this,void 0,void 0,function(){var t,n,r,s;return fE(this,function(o){switch(o.label){case 0:return t=function(e){var t=dE({},null==e?JE:e);if(null==t.enableSmoothing&&(t.enableSmoothing=JE.enableSmoothing),null==t.modelType&&(t.modelType=JE.modelType),null==t.detectorModelUrl&&(t.detectorModelUrl=JE.detectorModelUrl),null==t.landmarkModelUrl)switch(t.modelType){case"lite":t.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazeposelandmark_lite/1/default/1";break;case"heavy":t.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazeposelandmark_heavy/1/default/1";break;case"full":default:t.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazeposelandmark_full/1/default/1"}return t}(e),n=t.detectorModelUrl.indexOf("https://tfhub.dev")>-1,r=t.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([cE(t.detectorModelUrl,{fromTFHub:n}),cE(t.landmarkModelUrl,{fromTFHub:r})])];case 1:return s=o.sent(),[2,new cS(s[0],s[1],t.enableSmoothing,t.modelType)]}})})}function dS(e){switch(e){case XE.BlazePose:return gE.reduce(function(e,t,n){return e[t]=n,e},{});case XE.PoseNet:case XE.MoveNet:return mE.reduce(function(e,t,n){return e[t]=n,e},{});default:throw new Error("Model "+e+" is not supported.")}}(YE=XE||(XE={})).MoveNet="MoveNet",YE.BlazePose="BlazePose",YE.PoseNet="PoseNet",Object.freeze({__proto__:null,getKeypointIndexBySide:function(e){switch(e){case XE.BlazePose:return yE;case XE.PoseNet:case XE.MoveNet:return xE;default:throw new Error("Model "+e+" is not supported.")}},getAdjacentPairs:function(e){switch(e){case XE.BlazePose:return vE;case XE.PoseNet:case XE.MoveNet:return bE;default:throw new Error("Model "+e+" is not supported.")}},getKeypointIndexByName:dS});var pS=["SinglePose.Lightning","SinglePose.Thunder"],fS={modelType:"SinglePose.Lightning",enableSmoothing:!0},mS={maxPoses:1},gS={frequency:30,minCutOff:6.36,beta:636.61,derivateCutOff:4.77,thresholdCutOff:.5,thresholdBeta:5},yS=function(){function e(e,t){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=dS(XE.MoveNet),this.keypointsFilter=new AE(gS),this.cropRegionFilterYMin=new $E(.9),this.cropRegionFilterXMin=new $E(.9),this.cropRegionFilterYMax=new $E(.9),this.cropRegionFilterXMax=new $E(.9),"SinglePose.Lightning"===t.modelType?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):"SinglePose.Thunder"===t.modelType&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.enableSmoothing=t.enableSmoothing}return e.prototype.detectKeypoints=function(e,t){return void 0===t&&(t=!0),pE(this,void 0,void 0,function(){var n,r,s,o,i;return fE(this,function(a){switch(a.label){case 0:return this.moveNetModel?(n=17,t?(r=this.moveNetModel.execute(e),[3,3]):[3,1]):[2,null];case 1:return[4,this.moveNetModel.executeAsync(e)];case 2:r=a.sent(),a.label=3;case 3:return r&&4===r.shape.length&&1===r.shape[0]&&1===r.shape[1]&&r.shape[2]===n&&3===r.shape[3]?"webgpu"===Iy.backendName?[3,4]:(s=r.dataSync(),[3,6]):(r.dispose(),[2,null]);case 4:return[4,r.data()];case 5:s=a.sent(),a.label=6;case 6:for(r.dispose(),o=[],i=0;i<n;++i)o[i]={y:s[3*i],x:s[3*i+1],score:s[3*i+2]};return[2,o]}})})},e.prototype.estimatePoses=function(e,t,n){return void 0===t&&(t=mS),pE(this,void 0,void 0,function(){var r,s,o,i,a,u,l,c,h,d=this;return fE(this,function(p){switch(p.label){case 0:return t=function(e){var t=null==e?mS:dE({},e);if(t.maxPoses||(t.maxPoses=1),t.maxPoses<=0||t.maxPoses>1)throw new Error("Invalid maxPoses "+t.maxPoses+". Should be 1.");return t}(t),null==e?(this.reset(),[2,[]]):(null==n?NE(e)&&(n=1e6*e.currentTime):n*=1e3,r=SE(e),s=kE(r),o=nb(r,0),e instanceof dy||r.dispose(),this.cropRegion||(this.cropRegion=this.initCropRegion(s.width,s.height)),i=Tv(function(){var e=db([[d.cropRegion.yMin,d.cropRegion.xMin,d.cropRegion.yMax,d.cropRegion.xMax]]),t=fb([1],"int32");return bx(tw.cropAndResize(o,e,t,[d.modelInputResolution.height,d.modelInputResolution.width],"bilinear",0),"int32")}),o.dispose(),[4,this.detectKeypoints(i)]);case 1:if(a=p.sent(),i.dispose(),null==a)return this.reset(),[2,[]];for(h=0;h<a.length;++h)a[h].y=this.cropRegion.yMin+a[h].y*this.cropRegion.height,a[h].x=this.cropRegion.xMin+a[h].x*this.cropRegion.width;for(null!=n&&this.enableSmoothing&&(a=this.keypointsFilter.apply(a,n,1)),u=this.determineCropRegion(a,s.height,s.width),this.cropRegion=this.filterCropRegion(u),l=0,c=0,h=0;h<a.length;++h)a[h].name=mE[h],a[h].y*=s.height,a[h].x*=s.width,a[h].score>.2&&(++l,c+=a[h].score);return l>0?c/=l:this.resetFilters(),[2,[{score:c,keypoints:a}]]}})})},e.prototype.filterCropRegion=function(e){if(e){var t=this.cropRegionFilterYMin.apply(e.yMin),n=this.cropRegionFilterXMin.apply(e.xMin),r=this.cropRegionFilterYMax.apply(e.yMax),s=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:t,xMin:n,yMax:r,xMax:s,height:r-t,width:s-n}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},e.prototype.dispose=function(){this.moveNetModel.dispose()},e.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},e.prototype.resetFilters=function(){this.keypointsFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},e.prototype.torsoVisible=function(e){return(e[this.keypointIndexByName.left_hip].score>.2||e[this.keypointIndexByName.right_hip].score>.2)&&(e[this.keypointIndexByName.left_shoulder].score>.2||e[this.keypointIndexByName.right_shoulder].score>.2)},e.prototype.determineTorsoAndBodyRange=function(e,t,n,r){for(var s=["left_shoulder","right_shoulder","left_hip","right_hip"],o=0,i=0,a=0;a<s.length;a++)(d=Math.abs(n-t[s[a]][0]))>o&&(o=d),(p=Math.abs(r-t[s[a]][1]))>i&&(i=p);for(var u=0,l=0,c=0,h=Object.keys(t);c<h.length;c++){var d,p,f=h[c];e[this.keypointIndexByName[f]].score<.2||((d=Math.abs(n-t[f][0]))>u&&(u=d),(p=Math.abs(r-t[f][1]))>l&&(l=p))}return[o,i,u,l]},e.prototype.determineCropRegion=function(e,t,n){for(var r={},s=0,o=mE;s<o.length;s++){var i=o[s];r[i]=[e[this.keypointIndexByName[i]].y*t,e[this.keypointIndexByName[i]].x*n]}if(this.torsoVisible(e)){var a=(r.left_hip[0]+r.right_hip[0])/2,u=(r.left_hip[1]+r.right_hip[1])/2,l=this.determineTorsoAndBodyRange(e,r,a,u),c=Math.max(1.9*l[1],1.9*l[0],1.2*l[2],1.2*l[3]),h=[a-(c=Math.min(c,Math.max(u,n-u,a,t-a))),u-c];if(c>Math.max(n,t)/2)return this.initCropRegion(t,n);var d=2*c;return{yMin:h[0]/t,xMin:h[1]/n,yMax:(h[0]+d)/t,xMax:(h[1]+d)/n,height:(h[0]+d)/t-h[0]/t,width:(h[1]+d)/n-h[1]/n}}return this.initCropRegion(t,n)},e.prototype.initCropRegion=function(e,t){var n,r,s,o;return this.cropRegion?t>e?(n=t/e,r=1,s=(e/2-t/2)/e,o=0):(n=1,r=e/t,s=0,o=(t/2-e/2)/t):t>e?(n=1,r=e/t,s=0,o=(t/2-e/2)/t):(n=t/e,r=1,s=(e/2-t/2)/e,o=0),{yMin:s,xMin:o,yMax:s+n,xMax:o+r,height:n,width:r}},e}();function xS(e){return void 0===e&&(e=fS),pE(this,void 0,void 0,function(){var t,n,r;return fE(this,function(s){switch(s.label){case 0:return(t=function(e){var t=null==e?fS:dE({},e);if(e.modelType){if(pS.indexOf(t.modelType)<0)throw new Error("Invalid architecture "+t.modelType+". Should be one of "+pS)}else e.modelType="SinglePose.Lightning";return null==t.enableSmoothing&&(t.enableSmoothing=!0),t}(e)).modelUrl?[4,cE(t.modelUrl)]:[3,2];case 1:return n=s.sent(),[3,4];case 2:return r=void 0,"SinglePose.Lightning"===t.modelType?r="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/3":"SinglePose.Thunder"===t.modelType&&(r="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/3"),[4,cE(r,{fromTFHub:!0})];case 3:n=s.sent(),s.label=4;case 4:return[2,new yS(n,t)]}})})}var bS={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},vS=["MobileNetV1","ResNet50"],wS={MobileNetV1:[8,16],ResNet50:[16]},CS=[8,16,32],_S={MobileNetV1:[.5,.75,1],ResNet50:[1]},kS=[1,2,4],ES={maxPoses:1,flipHorizontal:!1},SS={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},TS=[-123.15,-115.9,-103.06];function IS(e){return Math.floor(e/2)}var NS=function(){function e(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return e.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},e.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},e.prototype.empty=function(){return-1===this.numberOfElements},e.prototype.size=function(){return this.numberOfElements+1},e.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},e.prototype.max=function(){return this.priorityQueue[0]},e.prototype.swim=function(e){for(;e>0&&this.less(IS(e),e);)this.exchange(e,IS(e)),e=IS(e)},e.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},e.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},e.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},e.prototype.exchange=function(e,t){var n=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=n},e}();function $S(e,t,n,r,s,o){for(var i=o.shape,a=i[0],u=i[1],l=!0,c=Math.max(n-s,0),h=Math.min(n+s+1,a),d=c;d<h;++d){for(var p=Math.max(r-s,0),f=Math.min(r+s+1,u),m=p;m<f;++m)if(o.get(d,m,e)>t){l=!1;break}if(!l)break}return l}function RS(e){return pE(this,void 0,void 0,function(){return fE(this,function(t){return[2,Promise.all(e.map(function(e){return e.buffer()}))]})})}function AS(e,t,n,r){return{y:r.get(e,t,n),x:r.get(e,t,n+17)}}function OS(e,t,n){var r=AS(e.heatmapY,e.heatmapX,e.id,n);return{x:e.heatmapX*t+r.x,y:e.heatmapY*t+r.y}}function FS(e,t,n,r){var s=n.x,o=n.y;return e.some(function(e){var n,i,a=e.keypoints;return(n=a[r].y-o)*n+(i=a[r].x-s)*i<=t})}var DS=mE.reduce(function(e,t,n){return e[t]=n,e},{}),PS=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(e){return[DS[e[0]],DS[e[1]]]}),MS=PS.map(function(e){return e[1]}),LS=PS.map(function(e){return e[0]});function BS(e,t,n){return e<t?t:e>n?n:e}function VS(e,t,n,r){return{y:BS(Math.round(e.y/t),0,n-1),x:BS(Math.round(e.x/t),0,r-1)}}function US(e,t){return{x:e.x+t.x,y:e.y+t.y}}function zS(e,t,n,r,s,o,i,a){void 0===a&&(a=2);for(var u=r.shape,l=u[0],c=u[1],h={y:t.y,x:t.x},d=US(h,function(e,t,n){var r=n.shape[2]/2;return{y:n.get(t.y,t.x,e),x:n.get(t.y,t.x,r+e)}}(e,VS(h,o,l,c),i)),p=0;p<a;p++){var f=VS(d,o,l,c),m=AS(f.y,f.x,n,s);d=US({x:f.x*o,y:f.y*o},{x:m.x,y:m.y})}var g=VS(d,o,l,c),y=r.get(g.y,g.x,n);return{y:d.y,x:d.x,name:mE[n],score:y}}function WS(e,t,n,r,s,o){var i=MS.length,a=new Array(t.shape[2]),u=e.part,l=e.score,c=OS(u,r,n);a[u.id]={score:l,name:mE[u.id],y:c.y,x:c.x};for(var h=i-1;h>=0;--h){var d=MS[h],p=LS[h];a[d]&&!a[p]&&(a[p]=zS(h,a[d],p,t,n,r,o))}for(h=0;h<i;++h)p=MS[h],a[d=LS[h]]&&!a[p]&&(a[p]=zS(h,a[d],p,t,n,r,s));return a}function jS(e,t,n){return n.reduce(function(n,r,s){var o=r.score;return FS(e,t,{y:r.y,x:r.x},s)||(n+=o),n},0)/n.length}function HS(e,t,n,r,s,o,i,a){return void 0===i&&(i=.5),void 0===a&&(a=20),pE(this,void 0,void 0,function(){var u,l,c,h,d,p,f,m,g,y,x,b;return fE(this,function(v){switch(v.label){case 0:return[4,RS([e,t,n,r])];case 1:for(u=v.sent(),c=u[1],h=u[2],d=u[3],p=[],f=function(e,t,n){for(var r=n.shape,s=r[0],o=r[1],i=r[2],a=new NS(s*o*i,function(e){return e.score}),u=0;u<s;++u)for(var l=0;l<o;++l)for(var c=0;c<i;++c){var h=n.get(u,l,c);h<e||$S(c,h,u,l,1,n)&&a.enqueue({score:h,part:{heatmapY:u,heatmapX:l,id:c}})}return a}(i,0,l=u[0]),m=a*a;p.length<o&&!f.empty();)g=f.dequeue(),y=OS(g.part,s,c),FS(p,m,y,g.part.id)||(x=WS(g,l,c,s,h,d),b=jS(p,m,x),p.push({keypoints:x,score:b}));return[2,p]}})})}function GS(e,t,n){return Tv(function(){var r=function(e,t){for(var n=[],r=0;r<mE.length;r++){var s=qS(e.get(r,0).valueOf(),e.get(r,1).valueOf(),r,t),o=s.x;n.push(s.y),n.push(o)}return db(n,[mE.length,2])}(e,n);return Xx(bx(rb(e.toTensor(),ob(t,"int32")),"float32"),r)})}function qS(e,t,n,r){return{y:r.get(e,t,n),x:r.get(e,t,n+mE.length)}}function KS(e,t,n){return pE(this,void 0,void 0,function(){var r,s,o,i,a,u,l,c,h;return fE(this,function(d){switch(d.label){case 0:return r=0,s=function(e){var t=e.shape,n=t[0],r=t[1],s=t[2];return Tv(function(){var t,o,i=sb(e,[n*r,s]),a=Yx(i,0),u=nb(eb(a,ob(r,"int32")),1),l=nb((t=a,o=r,Tv(function(){var e=eb(t,ob(o,"int32"));return cb(t,rb(e,ob(o,"int32")))})),1);return Zx([u,l],1)})}(e),[4,Promise.all([e.buffer(),t.buffer(),s.buffer()])];case 1:return o=d.sent(),i=o[0],[4,(u=GS(a=o[2],n,o[1])).buffer()];case 2:return l=d.sent(),c=Array.from(function(e,t){for(var n=t.shape[0],r=new Float32Array(n),s=0;s<n;s++){var o=t.get(s,0),i=t.get(s,1);r[s]=e.get(o,i,s)}return r}(i,a)),h=c.map(function(e,t){return r+=e,{y:l.get(t,0),x:l.get(t,1),score:e,name:mE[t]}}),s.dispose(),u.dispose(),[2,{keypoints:h,score:r/h.length}]}})})}function XS(e,t){return(e-1)%t==0}var YS="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",QS="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function ZS(e,t){return function(e,t){return(e-1)%t==0}(e,t)?e:Math.floor(e/t)*t+1}var JS=function(){function e(e,t){this.posenetModel=e;var n=this.posenetModel.inputs[0].shape;Cp(-1===n[1]&&-1===n[2],function(){return"Input shape ["+n[1]+", "+n[2]+"] must both be equal to or -1"});var r,s,o={height:ZS((r=t.inputResolution).height,s=t.outputStride),width:ZS(r.width,s)};!function(e){Cp(CS.indexOf(e)>=0,function(){return"outputStride of "+e+" is invalid. It must be either 8 or 16."})}(t.outputStride),function(e,t){Cp(XS(e.height,t),function(){return"height of "+e.height+" is invalid for output stride "+t+"."}),Cp(XS(e.width,t),function(){return"width of "+e.width+" is invalid for output stride "+t+"."})}(o,t.outputStride),this.inputResolution=o,this.outputStride=t.outputStride,this.architecture=t.architecture}return e.prototype.estimatePoses=function(e,t){return void 0===t&&(t=ES),pE(this,void 0,void 0,function(){var n,r,s,o,i,a,u,l,c,h,d,p,f,m,g;return fE(this,function(y){switch(y.label){case 0:return n=function(e){var t=e;if(null==t.maxPoses&&(t.maxPoses=1),t.maxPoses<=0)throw new Error("Invalid maxPoses "+t.maxPoses+". Should be > 0.");if(t.maxPoses>1){if((t=dE({},SS,t)).scoreThreshold<0||t.scoreThreshold>1)throw new Error("Invalid scoreThreshold "+t.scoreThreshold+". Should be in range [0.0, 1.0]");if(t.nmsRadius<=0)throw new Error("Invalid nmsRadius "+t.nmsRadius+".")}return t}(t),null==e?[2,[]]:(this.maxPoses=n.maxPoses,r=IE(e,{inputResolution:this.inputResolution,keepAspectRatio:!0}),s=r.imageTensor,o=r.padding,i="ResNet50"===this.architecture?Xx(s,TS):LE(s,[-1,1]),a=this.posenetModel.predict(i),"ResNet50"===this.architecture?(u=ub(a[2],[0]),l=ub(a[3],[0]),c=ub(a[0],[0]),h=ub(a[1],[0])):(u=ub(a[0],[0]),l=ub(a[1],[0]),c=ub(a[2],[0]),h=ub(a[3],[0])),d=ib(l),1!==this.maxPoses?[3,2]:[4,KS(d,u,this.outputStride)]);case 1:return f=y.sent(),p=[f],[3,4];case 2:return[4,HS(d,u,c,h,this.outputStride,this.maxPoses,n.scoreThreshold,n.nmsRadius)];case 3:p=y.sent(),y.label=4;case 4:return m=kE(e),g=function(e,t,n,r){var s=t.height/(n.height*(1-r.top-r.bottom)),o=t.width/(n.width*(1-r.left-r.right)),i=-r.top*n.height,a=-r.left*n.width;if(1===o&&1===s&&0===i&&0===a)return e;for(var u=0,l=e;u<l.length;u++)for(var c=0,h=l[u].keypoints;c<h.length;c++){var d=h[c];d.x=(d.x+a)*o,d.y=(d.y+i)*s}return e}(p,m,this.inputResolution,o),n.flipHorizontal&&(g=function(e,t){for(var n=0,r=e;n<r.length;n++)for(var s=0,o=r[n].keypoints;s<o.length;s++){var i=o[s];i.x=t.width-1-i.x}return e}(g,m)),s.dispose(),i.dispose(),Iv(a),u.dispose(),l.dispose(),c.dispose(),h.dispose(),d.dispose(),[2,g]}})})},e.prototype.dispose=function(){this.posenetModel.dispose()},e.prototype.reset=function(){},e}();function eT(e){return void 0===e&&(e=bS),pE(this,void 0,void 0,function(){var t,n,r,s,o;return fE(this,function(i){switch(i.label){case 0:return"ResNet50"!==(t=function(e){var t=e||bS;if(null==t.architecture&&(t.architecture="MobileNetV1"),vS.indexOf(t.architecture)<0)throw new Error("Invalid architecture "+t.architecture+". Should be one of "+vS);if(null==t.inputResolution&&(t.inputResolution={height:257,width:257}),null==t.outputStride&&(t.outputStride=16),wS[t.architecture].indexOf(t.outputStride)<0)throw new Error("Invalid outputStride "+t.outputStride+". Should be one of "+wS[t.architecture]+" for architecture "+t.architecture+".");if(null==t.multiplier&&(t.multiplier=1),_S[t.architecture].indexOf(t.multiplier)<0)throw new Error("Invalid multiplier "+t.multiplier+". Should be one of "+_S[t.architecture]+" for architecture "+t.architecture+".");if(null==t.quantBytes&&(t.quantBytes=4),kS.indexOf(t.quantBytes)<0)throw new Error("Invalid quantBytes "+t.quantBytes+". Should be one of "+kS+" for architecture "+t.architecture+".");if("MobileNetV1"===t.architecture&&32===t.outputStride&&1!==t.multiplier)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return t}(e)).architecture?[3,2]:(u="model-stride"+t.outputStride+".json",n=4===(a=t.quantBytes)?QS+"float/"+u:QS+"quant"+a+"/"+u,[4,cE(t.modelUrl||n)]);case 1:return r=i.sent(),[2,new JS(r,t)];case 2:return s=function(e,t,n){var r={1:"100",.75:"075",.5:"050"},s="model-stride"+e+".json";return 4===n?YS+"float/"+r[t]+"/"+s:YS+"quant"+n+"/"+r[t]+"/"+s}(t.outputStride,t.multiplier,t.quantBytes),[4,cE(t.modelUrl||s)];case 3:return o=i.sent(),[2,new JS(o,t)]}var a,u})})}var tT={keypointsToNormalizedKeypoints:OE};const nT={},rT={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function sT(e){if(!(e in nT)){const t=function(e){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=function(e){if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e);return t.addEventListener("webglcontextlost",t=>{t.preventDefault(),delete nT[e]},!1),1===e?t.getContext("webgl",rT)||t.getContext("experimental-webgl",rT):t.getContext("webgl2",rT)}(e);if(null===t)return console.log("Could not get context for WebGL version",e),null;nT[e]=t}const t=nT[e];return t.isContextLost()?(delete nT[e],sT(e)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),nT[e])}var oT=(()=>(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(oT||(oT={})),oT))(),iT=(()=>(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(iT||(iT={})),iT))(),aT=(()=>(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(aT||(aT={})),aT))();function uT(e,t){return[t,e]}function lT(e){const t=Sp(e);return Np(Math.ceil(t/4))}function cT(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function hT(e,t){const n=e;let r,s,o,i,a,u,l,c,h,d;return 2===ef().getNumber("WEBGL_VERSION")?(r=n.R32F,s=n.R16F,o=n.RGBA16F,i=n.RGBA32F,a=n.RED,l=4,c=1,h=n.HALF_FLOAT,d=n.FLOAT):(r=e.RGBA,s=e.RGBA,o=e.RGBA,i=n.RGBA,a=e.RGBA,l=4,c=4,h=null!=t?t.HALF_FLOAT_OES:null,d=e.FLOAT),u=e.RGBA,{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}function dT(e,t){const n=t();return ef().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),n}function pT(e){return!!(ef().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function fT(e,t){return wT(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}const mT=/ERROR: [0-9]+:([0-9]+):/g;function gT(e,t){if(dT(e,()=>e.validateProgram(t)),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function yT(e,t,n,r,s,o,i){const a=e.getAttribLocation(t,n);return-1!==a&&(dT(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),dT(e,()=>e.vertexAttribPointer(a,s,e.FLOAT,!1,o,i)),dT(e,()=>e.enableVertexAttribArray(a)),!0)}function xT(e,t,n){dT(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),dT(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function bT(e,t){dT(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),dT(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function vT(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function wT(e,t,n){const r=dT(e,()=>t());if(null==r)throw new Error(n);return r}function CT(e,t=2){return Sp(e.slice(0,e.length-t))}function _T(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function kT(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[CT(e),..._T(e)]),t}function ET(e){return e%2==0}function ST(e,t){if(Tp(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e.slice(-1)[0],r=t.slice(-1)[0];if(n===r)return!0;if(ET(n)&&ET(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&ET(e[0])&&ET(t[0])}let TT,IT;function NT(e,t){return null!=e.getExtension(t)}function $T(e){try{if(null!=sT(e))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function RT(e){const t=hT(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),s}function AT(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&Cp("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const OT=ef();function FT(){let e,t,n,r,s,o,i,a,u,l;return 2===ef().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",s="texture",o="outputColor",i="out vec4 outputColor;",a="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",u="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",s="texture2D",o="gl_FragColor",i="",a="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",u="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:o,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:u,defineRound:l}}function DT(e,t,n="index"){const r=Wp(t);return r.map((t,s)=>`int ${e[s]} = ${n} / ${t}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${t}`:`index -= ${e[s]} * ${t}`};`).join("")}function PT(e){const t=Wp(e).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}OT.registerFlag("HAS_WEBGL",()=>OT.getNumber("WEBGL_VERSION")>0),OT.registerFlag("WEBGL_VERSION",()=>$T(2)?2:$T(1)?1:0),OT.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),OT.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===OT.get("WEBGL_VERSION")),OT.registerFlag("WEBGL_CPU_FORWARD",()=>!0),OT.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),OT.registerFlag("WEBGL_PACK",()=>OT.getBool("HAS_WEBGL")),OT.registerFlag("WEBGL_PACK_NORMALIZATION",()=>OT.getBool("WEBGL_PACK")),OT.registerFlag("WEBGL_PACK_CLIP",()=>OT.getBool("WEBGL_PACK")),OT.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>OT.getBool("WEBGL_PACK")),OT.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>OT.getBool("WEBGL_PACK")),OT.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>OT.getBool("WEBGL_PACK")),OT.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>OT.getBool("WEBGL_PACK")),OT.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>OT.getBool("WEBGL_PACK")),OT.registerFlag("WEBGL_PACK_REDUCE",()=>OT.getBool("WEBGL_PACK")),OT.registerFlag("WEBGL_LAZILY_UNPACK",()=>OT.getBool("WEBGL_PACK")),OT.registerFlag("WEBGL_CONV_IM2COL",()=>OT.getBool("WEBGL_PACK")),OT.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function(e){if(null==TT){const t=sT(e);TT=t.getParameter(t.MAX_TEXTURE_SIZE)}return TT}(OT.getNumber("WEBGL_VERSION"))),OT.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function(e){if(null==IT){const t=sT(e);IT=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,IT)}(OT.getNumber("WEBGL_VERSION"))),OT.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const e=OT.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=sT(e);return t=NT(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:NT(n,"EXT_disjoint_timer_query")?1:0,t}(e)}),OT.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>OT.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!$y()),OT.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function(e){if(0===e)return!1;const t=sT(e);if(1===e){if(!NT(t,"OES_texture_float"))return!1}else if(!NT(t,"EXT_color_buffer_float"))return!1;return RT(t)}(OT.getNumber("WEBGL_VERSION"))),OT.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!OT.getBool("WEBGL_FORCE_F16_TEXTURES")&&OT.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),OT.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function(e){if(0===e)return!1;const t=sT(e);if(1!==e){if(NT(t,"EXT_color_buffer_float"))return RT(t);const e="EXT_color_buffer_half_float";if(NT(t,e)){const n=t.getExtension(e);return function(e,t){const n=hT(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(s),o}(t,n)}return!1}return!!NT(t,"OES_texture_float")&&!!NT(t,"WEBGL_color_buffer_float")&&RT(t)}(OT.getNumber("WEBGL_VERSION"))),OT.registerFlag("WEBGL_FENCE_API_ENABLED",()=>{return 2===(e=OT.getNumber("WEBGL_VERSION"))&&null!=sT(e).fenceSync;var e}),OT.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>OT.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),OT.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)}),OT.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>$y()&&OT.getBool("IS_CHROME")?1:-1,e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)}),OT.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);const MT="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";class LT{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=oT.DENSE;const t=lT(e),n=FT();this.outputShape=e,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${DT(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${t[0]}, ${t[1]}));\n        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${n.output} = result;\n      }\n    `}}class BT{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=oT.DENSE;const t=lT(e),n=FT();this.outputShape=e,this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${DT(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(${t[0]}, ${t[1]}));\n        int index = 4 * (resTexRC.x * ${t[1]} + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${n.output} = result;\n      }\n    `}}class VT{constructor(e){this.variableNames=["A"],this.outTexUsage=iT.DOWNLOAD;const t=FT();this.outputShape=e,this.userCode=`\n      ${MT}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class UT{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=iT.DOWNLOAD;const t=FT();this.outputShape=e,this.userCode=`\n      ${MT}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}class zT{constructor(e,t,n=!1){this.variableNames=["A"];const r=FT(),[s,o]=t;this.outputShape=e;let i="result";n&&(i="floor(result * 255. + 0.5)"),this.userCode=`\n      ${PT(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ${o};\n        int c = imod(flatIndex, ${o});\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${o}.0, ${s}.0);\n        vec4 values = ${r.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${r.output} = vec4(${i}, 0., 0., 0.);\n      }\n    `}}class WT{constructor(e,t,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const r=FT(),[s,o]=t;this.outputShape=e;let i="",a="result";n&&(a="floor(result * 255. + 0.5)");for(let u=0;u<=1;u++)for(let t=0;t<=1;t++){const n=2*u+t;i+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${e[2]}) {\n            localCoords[2] += ${t};\n            if(localCoords[1] + ${u} < ${e[1]}) {\n              localCoords[1] += ${u};\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ${o};\n              c = imod(flatIndex, ${o});\n              uv = (vec2(c, r) + halfCR) / vec2(${o}.0, ${s}.0);\n              values = ${r.texture2D}(A, uv);\n\n              if(offset == 0) {\n                result[${n}] = values[0];\n              } else if(offset == 1) {\n                result[${n}] = values[1];\n              } else if(offset == 2) {\n                result[${n}] = values[2];\n              } else {\n                result[${n}] = values[3];\n              }\n            }\n          }\n        `}this.userCode=`\n      ${PT(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ${i}\n\n        ${r.output} = ${a};\n      }\n    `}}function jT(e,t,n,r,s,o){!function(e,t){const n=ef().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(t,n);const i=function(e){return wT(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}(e),a=e.TEXTURE_2D;return dT(e,()=>e.bindTexture(a,i)),dT(e,()=>e.texParameteri(a,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),dT(e,()=>e.texParameteri(a,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),dT(e,()=>e.texParameteri(a,e.TEXTURE_MIN_FILTER,e.NEAREST)),dT(e,()=>e.texParameteri(a,e.TEXTURE_MAG_FILTER,e.NEAREST)),dT(e,()=>e.texImage2D(a,0,r,t,n,0,s,o,null)),dT(e,()=>e.bindTexture(e.TEXTURE_2D,null)),i}function HT(e){return e.internalFormatFloat}function GT(e){return e.internalFormatHalfFloat}function qT(e){return e.downloadTextureFormat}function KT(e){return e.internalFormatPackedFloat}function XT(e){return e.internalFormatPackedHalfFloat}class YT{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=ef().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,function(e,t){nT[e]=t}(t,e)):this.gl=sT(t);let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(1===ef().getNumber("WEBGL_VERSION")){const e="OES_texture_half_float";if(this.textureFloatExtension=fT(this.gl,"OES_texture_float"),NT(this.gl,e))this.textureHalfFloatExtension=fT(this.gl,e);else if(ef().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),NT(this.gl,r))this.colorBufferHalfFloatExtension=fT(this.gl,r);else if(ef().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",NT(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!NT(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=function(e){return function(e,t){const n=wT(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return dT(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),dT(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function(e){return function(e,t){const n=wT(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return dT(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),dT(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}(e,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function(e){return wT(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=hT(this.gl,this.textureHalfFloatExtension)}get debug(){return ef().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;dT(e,()=>e.finish()),dT(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),dT(e,()=>e.deleteFramebuffer(this.framebuffer)),dT(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),dT(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),dT(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,o]=uT(t,n);return jT(e,s,o,HT(r),r.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,o]=uT(t,n);return jT(e,s,o,GT(r),r.textureFormatFloat,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,o]=uT(t,n);return jT(e,s,o,qT(r),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){dT(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?dT(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):dT(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),dT(e,()=>e.bindTexture(e.TEXTURE_2D,null))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),function(e,t,n,r,s,o){let i,a,u;dT(e,()=>e.bindTexture(e.TEXTURE_2D,t)),s instanceof Uint8Array?(i=new Uint8Array(n*r*4),a=e.UNSIGNED_BYTE,u=e.RGBA):(i=new Float32Array(n*r*4),a=e.FLOAT,u=o.internalFormatPackedFloat),i.set(s),dT(e,()=>e.texImage2D(e.TEXTURE_2D,0,u,n,r,0,e.RGBA,a,i)),dT(e,()=>e.bindTexture(e.TEXTURE_2D,null))}(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,o]=cT(t,n);return jT(e,s,o,XT(r),e.RGBA,r.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,r){const[s,o]=cT(t,n);return jT(e,s,o,KT(r),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(bT(this.gl,this.framebuffer),this.outputTexture=null),dT(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>function(e,t,n,r){const[s,o]=uT(t,n),i=new Uint8Array(t*n*4);return dT(e,()=>e.readPixels(0,0,s,o,r.downloadTextureFormat,e.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,s,o){return function(e,t,n,r,s,o,i,a){const u=e,l=new Float32Array(function(e,t){const[n,r]=cT(e,t);return n*r*4}(o,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}(this.gl,e,0,0,0,s,o)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=function(e,t,n,r){const s=e.createBuffer();dT(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,s));const o=16*t*n;return dT(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,o,e.STREAM_READ)),dT(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),dT(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),s}(this.gl,t,n);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(ef().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(s,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=s}else ef().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,ef().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>function(e,t,n){const r=new Float32Array(t*n*4);return dT(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}(this.gl,t,n))}createProgram(e){this.throwIfDisposed();const t=this.gl,n=function(e,t){const n=wT(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(dT(e,()=>e.shaderSource(n,t)),dT(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw function(e,t){const n=mT.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const r=+n[1],s=e.split("\n"),o=s.length.toString().length+2,i=s.map((e,t)=>$p((t+1).toString(),o)+e);let a=0;for(let h=0;h<i.length;h++)a=Math.max(i[h].length,a);const u=i.slice(0,r-1),l=i.slice(r-1,r),c=i.slice(r);console.log(u.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${$p(l[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(t,e);null==this.vertexShader&&(this.vertexShader=function(e){const t=FT();return function(e,t){const n=wT(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(dT(e,()=>e.shaderSource(n,t)),dT(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(t));const r=function(e){return wT(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}(t);return dT(t,()=>t.attachShader(r,this.vertexShader)),dT(t,()=>t.attachShader(r,n)),function(e,t){if(dT(e,()=>e.linkProgram(t)),!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,r),this.debug&&gT(t,r),this.vertexAttrsAreBound||(this.setProgram(r),this.vertexAttrsAreBound=function(e,t,n){return dT(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),yT(e,t,"clipSpacePos",n,3,20,0)&&yT(e,t,"uv",n,2,20,12)}(t,this.program,this.vertexBuffer)),r}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&dT(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&gT(this.gl,this.program),dT(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?function(e,t,n){return wT(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),dT(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),function(e,t,n,r){dT(e,()=>function(e,t,n){(function(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)})(e,n),dT(e,()=>e.activeTexture(e.TEXTURE0+n)),dT(e,()=>e.bindTexture(e.TEXTURE_2D,t))}(e,t,r)),dT(e,()=>e.uniform1i(n,r))}(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,s]=cT(t,n);this.setOutputMatrixTextureDriver(e,r,s)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&gT(this.gl,this.program),vT(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),dT(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),dT(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=fT(this.gl,2===ef().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===ef().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===ef().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(e){var t=this;return mp(function*(){return yield Rp(()=>t.disposed||t.isQueryAvailable(e,ef().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),t.getQueryTime(e,ef().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||Rp(()=>(this.pollItems(),0===this.itemsToPoll.length))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),xT(this.gl,e,this.framebuffer),this.debug&&vT(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(xT(this.gl,this.outputTexture,this.framebuffer),this.debug&&vT(this.gl)):bT(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;xT(r,e,this.framebuffer),this.debug&&vT(r),this.outputTexture=e,dT(r,()=>r.viewport(0,0,t,n)),dT(r,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),dT(this.gl,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{getBroadcastDims:QT}=o;function ZT(e,t,n,r){const s=[];e.forEach(e=>{const t=Sp(e.shapeInfo.logicalShape);e.shapeInfo.isUniform?s.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(s.push(`uniform sampler2D ${e.name};`),s.push(`uniform int offset${e.name};`))});const o=s.join("\n"),i=e.map(e=>function(e,t,n=!1){let r="";return r+=n?eI(e):JT(e),e.shapeInfo.logicalShape.length<=t.logicalShape.length&&(r+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",o=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,a=QT(e.shapeInfo.logicalShape,t.logicalShape),u=aI(i),l=i-o;let c;const h=["x","y","z","w","u","v"];c=0===o?"":i<2&&a.length>=1?"coords = 0;":a.map(e=>`coords.${h[e+l]} = 0;`).join("\n");let d="";d=i<2&&o>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>`coords.${h[t+l]}`).join(", ");let p="return outputValue;";const f=1===Sp(e.shapeInfo.logicalShape),m=1===Sp(t.logicalShape);if(1!==o||f||m){if(f&&!m)p=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(a.length){const e=o-2,t=o-1;a.indexOf(e)>-1&&a.indexOf(t)>-1?p="return vec4(outputValue.x);":a.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${u} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${d});\n      ${p}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",o=e.shapeInfo.logicalShape.length,i=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===i&&null==e.shapeInfo.flatOffset&&Tp(e.shapeInfo.texShape,t.texShape))return`\n      float ${s}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const a=aI(i),u=QT(e.shapeInfo.logicalShape,t.logicalShape),l=i-o;let c;const h=["x","y","z","w","u","v"];c=0===o?"":i<2&&u.length>=1?"coords = 0;":u.map(e=>`coords.${h[e+l]} = 0;`).join("\n");let d="";return d=i<2&&o>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>`coords.${h[t+l]}`).join(", "),`\n    float ${s}() {\n      ${a} coords = getOutputCoords();\n      ${c}\n      return get${r}(${d});\n    }\n  `}(e,t)),r}(e,t,r)).join("\n"),a=t.texShape,u=FT(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(u);let c,h,d=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${tI}\n    ${nI}\n    ${rI}\n  `}(u);return t.isPacked?(c=function(e,t){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===n[0]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);\n    }\n  `}(0,t);case 2:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Tp(e,t))return`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));\n      }\n    `;const r=Math.ceil(e[1]/2);return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t);case 3:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),s=r*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t);default:return function(e,t){const n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),s=r*Math.ceil(e[e.length-2]/2);let o=s,i="",a="b, r, c";for(let u=2;u<e.length-1;u++)o*=e[e.length-u-1],i=`\n      int b${u} = index / ${o};\n      index -= b${u} * ${o};\n    `+i,a=`b${u}, `+a;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      int index = resTexRC.x * ${n[1]} + resTexRC.y;\n\n      ${i}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${e.length}(${a});\n    }\n  `}(e,t)}}(t.logicalShape,a),h=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(u)):(c=function(e,t){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return 1===(n=t)[0]?`\n      int getOutputCoords() {\n        return int(resultUV.x * ${n[1]}.0);\n      }\n    `:1===n[1]?`\n      int getOutputCoords() {\n        return int(resultUV.y * ${n[0]}.0);\n      }\n    `:`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${n[0]}, ${n[1]}));\n      return resTexRC.x * ${n[1]} + resTexRC.y;\n    }\n  `;case 2:return function(e,t){return Tp(e,t)?`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t);case 3:return function(e,t){const n=DT(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${n}\n      return ivec3(r, c, d);\n    }\n  `}(e,t);case 4:return function(e,t){const n=DT(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${n}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t);case 5:return function(e,t){const n=DT(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=DT(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}var n}(t.logicalShape,a),h=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(u)),r&&(d+=sI),[d,l,h,o,c,i,n].join("\n")}function JT(e){const t=e.shapeInfo.logicalShape;switch(t.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`float ${n}() {return ${t};}`;const[r,s]=e.shapeInfo.texShape;if(1===r&&1===s)return`\n      float ${n}() {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const[o,i]=e.shapeInfo.texShape;return`\n    float ${n}() {\n      vec2 uv = uvFromFlat(${o}, ${i}, ${oI(t)});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 1:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${n}(int index) {\n        ${iI(e)}\n      }\n    `;const r=e.shapeInfo.texShape,s=r[0],o=r[1];if(1===o&&1===s)return`\n      float ${n}(int index) {\n        return sampleTexture(${t}, halfCR);\n      }\n    `;const i=oI(t);return 1===o?`\n      float ${n}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${s}.0);\n        return sampleTexture(${t}, uv);\n      }\n    `:1===s?`\n      float ${n}(int index) {\n        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${t}, uv);\n      }\n    `:`\n    float ${n}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${o}, index + ${i});\n      return sampleTexture(${t}, uv);\n    }\n  `}(e);case 2:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape;if(null!=s&&Tp(t,s))return`\n    float ${r}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${s[1]}.0, ${s[0]}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `;const{newShape:o,keptDims:i}=Op(t);if(o.length<t.length){const t=["row","col"];return`\n      ${JT(uI(e,o))}\n      float ${r}(int row, int col) {\n        return ${r}(${lI(t,i)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));\n        ${iI(e)}\n      }\n    `;const a=s[0],u=s[1],l=oI(n);return 1===u?`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${l}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${a}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `:1===a?`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${l}), vec3(${t[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n  float ${r}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${t[1]} + col + ${l};\n    vec2 uv = uvFromFlat(${a}, ${u}, index);\n    return sampleTexture(${n}, uv);\n  }\n`}(e);case 3:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[1]*t[2],o=t[2],{newShape:i,keptDims:a}=Op(t);if(i.length<t.length){const t=["row","col","depth"];return`\n        ${JT(uI(e,i))}\n        float ${r}(int row, int col, int depth) {\n          return ${r}(${lI(t,a)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${o}, 1)));\n        ${iI(e)}\n      }\n    `;const u=e.shapeInfo.texShape,l=u[0],c=u[1],h=e.shapeInfo.flatOffset;return c===s&&null==h?`\n        float ${r}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${o}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${c}.0, ${l}.0);\n          return sampleTexture(${n}, uv);\n        }\n      `:c===o&&null==h?`\n    float ${r}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}.0, ${l}.0);\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n      float ${r}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${o} + depth + ${oI(n)};\n        vec2 uv = uvFromFlat(${l}, ${c}, index);\n        return sampleTexture(${n}, uv);\n      }\n  `}(e);case 4:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[3],o=t[2]*s,i=t[1]*o,{newShape:a,keptDims:u}=Op(t);if(a.length<t.length){const t=["row","col","depth","depth2"];return`\n      ${JT(uI(e,a))}\n      float ${r}(int row, int col, int depth, int depth2) {\n        return ${r}(${lI(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${i}, ${o}, ${s}, 1)));\n        ${iI(e)}\n      }\n    `;const l=e.shapeInfo.flatOffset,c=e.shapeInfo.texShape,h=c[0],d=c[1];return d===i&&null==l?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${d}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:d===s&&null==l?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${t[1]*t[2]}, ${t[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${d}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${o} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${d}, index + ${oI(n)});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],o=t[3]*s,i=t[2]*o,a=t[1]*i,{newShape:u,keptDims:l}=Op(t);if(u.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${JT(uI(e,u))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${lI(t,l)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${a}, ${i}, ${o}, ${s})) +\n          depth3;\n        ${iI(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1];return p===a&&null==c?`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${o}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:p===s&&null==c?`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${a} + col * ${i} + depth * ${o} +\n          depth2 * ${s} + depth3 + ${oI(n)};\n      vec2 uv = uvFromFlat(${d}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:o}=Op(t);if(s.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${JT(uI(e,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${lI(t,o)});\n      }\n    `}const i=t[5],a=t[4]*i,u=t[3]*a,l=t[2]*u,c=t[1]*l;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${l}, ${u}, ${a})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${iI(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],f=d[1];return f===c&&null==h?`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${l}, ${u}, ${a}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:f===i&&null==h?`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${l} + depth * ${u} +\n          depth2 * ${a} + depth3 * ${i} + depth4 + ${oI(n)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function eI(e){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${FT().texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e.shapeInfo.texShape,s=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],o=FT();return`\n    vec4 ${n}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${s[0]}, ${s[1]}, index);\n      return ${o.texture2D}(${t}, uv);\n    }\n  `}(e);case 2:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,o=s[0],i=s[1],a=FT();if(null!=s&&Tp(t,s))return`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${o}.0);\n\n        return ${a.texture2D}(${n}, uv);\n      }\n    `;const u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(t[1]/2)}, ${u[0]}, ${u[1]}, row, col);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(e);case 3:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===t[0]){const n=[1,2],s=["b","row","col"];return`\n        ${eI(uI(e,t.slice(1)))}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${lI(s,n)});\n        }\n      `}const i=o[0],a=o[1],u=Math.ceil(t[2]/2);return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${i}, ${a}, ${u*Math.ceil(t[1]/2)}, ${u}, b, row, col);\n      return ${FT().texture2D}(${n}, uv);\n    }\n  `}(e);default:return function(e){const t=e.shapeInfo.logicalShape,n=t.length,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),o=e.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],a=i[0],u=i[1],l=Math.ceil(t[n-1]/2);let c=l*Math.ceil(t[n-2]/2),h="int b, int row, int col",d=`b * ${c} + (row / 2) * ${l} + (col / 2)`;for(let p=2;p<n-1;p++)h=`int b${p}, `+h,c*=t[n-p-1],d=`b${p} * ${c} + `+d;return`\n    vec4 ${s}(${h}) {\n      int index = ${d};\n      int texR = index / ${u};\n      int texC = index - texR * ${u};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${a});\n      return ${FT().texture2D}(${r}, uv);\n    }\n  `}(e)}}const tI="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",nI="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",rI="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",sI="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function oI(e){return`offset${e}`}function iI(e){const t=e.name,n=Sp(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function aI(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function uI(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function lI(e,t){return t.map(t=>e[t]).join(", ")}function cI(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((e,n)=>{const r=e.logicalShape,s=t[n],o=s.shape;if(!Tp(r,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${o} must match`);if(e.isUniform&&s.isUniform)return;const i=e.texShape,a=s.isUniform?null:s.texData.texShape;if(!Tp(i,a))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${a} must match`)})}function hI(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&Cp("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}function dI(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}function pI(e){return(t,n,r,s,o)=>{const i=Zb(t,n),a=i.length,u=Wp(i),l=Fp(o,Sp(i)),c=t.length,h=n.length,d=Wp(t),p=Wp(n),f=Yb(t,i),m=Yb(n,i);if(f.length+m.length===0)for(let g=0;g<l.length;++g)l[g]=e(r[g%r.length],s[g%s.length]);else for(let g=0;g<l.length;++g){const t=Yp(g,a,u),n=t.slice(-c);f.forEach(e=>n[e]=0);const o=Xp(n,c,d),i=t.slice(-h);m.forEach(e=>i[e]=0);const y=Xp(i,h,p);l[g]=e(r[o],s[y])}return[l,i]}}function fI(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,o=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,a=n.makeTensorInfo(r.shape,"complex64");return n.data.get(a.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",o),imag:n.makeTensorInfo(s.shape,"float32",i)},a}function mI(e,t,n="float32"){if("complex64"===n)return fI({inputs:{real:mI(e,t,"float32"),imag:mI(e,t,"float32")},backend:e});const r=qp(Sp(t),n);return e.makeTensorInfo(t,n,r)}function gI(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function yI(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return gI({inputs:{x:s},backend:n});const e=mI(n,s.shape,s.dtype),t=yI({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),r=fI({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===s.dtype){const e=function(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,o=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,o)}({inputs:{input:s},backend:n}),t=yI({inputs:{x:e},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(e),t}if(!Pp(s.dtype,o)){const e=gI({inputs:{x:s},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:o}}if("int32"===o){const e=n.data.get(s.dataId).values,t=Int32Array.from(e);return n.makeTensorInfo(s.shape,"int32",t)}if("bool"===o){const e=n.data.get(s.dataId).values,t=Yg([0],s.dtype),[r,o]=pI((e,t)=>e!==t?1:0)(s.shape,[],e,t,"bool");return n.makeTensorInfo(o,"bool",r)}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}function xI(e,t,n,r){return null==n?({inputs:n,backend:s})=>{const{a:o,b:i}=n,a=s;hI([o,i],e);const u=a.data.get(o.dataId).values,l=a.data.get(i.dataId).values,c="string"===o.dtype?mC(u):u,h="string"===o.dtype?mC(l):l,d=r||o.dtype,[p,f]=t(o.shape,i.shape,c,h,d);return a.makeTensorInfo(f,d,p)}:({inputs:e,backend:s})=>{const{a:o,b:i}=e,a=s;if("complex64"===o.dtype||"complex64"===i.dtype){const e=yI({inputs:{x:o},backend:a,attrs:{dtype:"complex64"}}),t=a.data.get(e.dataId),r=t.complexTensorInfos.imag,s=a.data.get(t.complexTensorInfos.real.dataId).values,u=a.data.get(r.dataId).values,l=yI({inputs:{x:i},backend:a,attrs:{dtype:"complex64"}}),c=a.data.get(l.dataId),h=c.complexTensorInfos.imag,d=a.data.get(c.complexTensorInfos.real.dataId).values,p=a.data.get(h.dataId).values,[f,m,g]=n(o.shape,i.shape,s,u,d,p),y=a.makeTensorInfo(g,"float32",f),x=a.makeTensorInfo(g,"float32",m),b=fI({inputs:{real:y,imag:x},backend:a});return a.disposeIntermediateTensorInfo(e),a.disposeIntermediateTensorInfo(l),a.disposeIntermediateTensorInfo(y),a.disposeIntermediateTensorInfo(x),b}{const e=a.data.get(o.dataId).values,n=a.data.get(i.dataId).values,s=r||o.dtype,[u,l]=t(o.shape,i.shape,e,n,s);return a.makeTensorInfo(l,s,u)}}}function bI(e){return(t,n,r,s,o,i)=>{const a=Zb(t,n),u=Sp(a),l=a.length,c=Wp(a),h=Fp("float32",u),d=Fp("float32",u),p=Yb(t,a),f=Yb(n,a),m=Yw(r,s),g=Yw(o,i),y=t.length,x=Wp(t),b=n.length,v=Wp(n);if(p.length+f.length===0)for(let w=0;w<h.length;w++){const t=w%m.length,n=w%g.length,r=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);h[w]=r.real,d[w]=r.imag}else for(let w=0;w<h.length;w++){const t=Yp(w,l,c),n=t.slice(-y);p.forEach(e=>n[e]=0);const r=Xp(n,y,x),s=t.slice(-b);f.forEach(e=>s[e]=0);const o=Xp(s,b,v),i=e(m[2*r],m[2*r+1],g[2*o],g[2*o+1]);h[w]=i.real,d[w]=i.imag}return[h,d,a]}}const vI=pI((e,t)=>e+t),wI=bI((e,t,n,r)=>({real:e+n,imag:t+r}));function CI(e,t,n,r,s){const o=Sp(r),i=qp(s,n);for(let a=0;a<e.length;a++){const n=e[a];if(n<0)throw new Error("Input x must be non-negative!");n>=s||(i[n]+=o>0?t[a]:1)}return i}function _I(e,t,n,r=!1){const s=e.shape[0],o=e.shape[1],i=xx([s,n],t.dtype);for(let a=0;a<s;a++)for(let s=0;s<o;s++){const o=e.get(a,s);if(o<0)throw new Error("Input x must be non-negative!");o>=n||i.set(r?1:t.size>0?i.get(a,o)+t.get(a,s):i.get(a,o)+1,a,o)}return i}function kI(e){return(t,n,r)=>{const s=Fp(n,t.length);for(let o=0;o<t.length;++o)s[o]=e(t[o],r);return s}}function EI(e,t,n){return({inputs:r,attrs:s,backend:o})=>{const{x:i}=r;if(hI(i,e),"string"===i.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");const a=o,u=a.data.get(i.dataId).values,l=n||i.dtype,c=t(u,l,s);return a.makeTensorInfo(i.shape,l,c)}}xI(uf,vI,wI);const SI=kI(e=>Math.ceil(e));function TI(e,t,n,r){const s=Dp(n,Sp(t));if(r&&"string"!==n){let t=0;e.forEach(e=>{const n=Sp(e.shape);s.set(e.vals,t),t+=n})}else{let r=0;e.forEach(e=>{const o="string"===n?mC(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const a=n*t[1]+r;for(let t=0;t<e.shape[1];++t)s[a+t]=o[i++]}r+=e.shape[1]})}return s}EI(_f,SI);const II=pI((e,t)=>e===t?1:0),NI=(xI(Wf,II,null,"bool"),kI(e=>Math.exp(e))),$I=(EI(jf,NI),kI(e=>Math.expm1(e))),RI=(EI(Gf,$I),kI(e=>Math.floor(e)));function AI(e,t,n,r,s,o,i,a,u){const l=xx([r,o],n);for(let c=0;c<r;c++){const n=[];let r=0;for(let t=0;t<s;t++){const o=e[c*s+t];r+=o*i[t],n.push(o)}if(r<0||r>=u/o)throw new Error(`Invalid indices: ${n} does not index into ${a}`);for(let e=0;e<o;e++)l.values[c*o+e]=t.get(...t.indexToLoc(r*o+e))}return l}function OI(e,t,n){const r=xx(n,e.dtype);for(let s=0;s<r.size;++s){const n=r.indexToLoc(s).slice(),o=t.locToIndex([n[0],n[2]]);n[2]=t.values[o];const i=e.locToIndex(n);r.values[s]=e.values[i]}return r}EI(Xf,RI);const FI=pI((e,t)=>e>t?1:0),DI=(xI(em,FI,null,"bool"),pI((e,t)=>e>=t?1:0)),PI=(xI(tm,DI,null,"bool"),pI((e,t)=>e<t?1:0)),MI=(xI(am,PI,null,"bool"),pI((e,t)=>e<=t?1:0));function LI(e,t,n){const r=(t-e)/(n-1),s=qp(n,"float32");s[0]=e;for(let o=1;o<s.length;o++)s[o]=s[o-1]+r;return s}xI(um,MI,null,"bool");const BI=kI(e=>Math.log(e));function VI(e,t,n,r){const s=Fp(r,Sp(n));for(let o=0;o<s.length;++o){const n=o*t;let r=e[n];for(let s=0;s<t;++s){const t=e[n+s];(Number.isNaN(t)||t>r)&&(r=t)}s[o]=r}return s}EI(cm,BI);const UI=pI((e,t)=>Math.max(e,t)),zI=(xI(mm,UI),pI((e,t)=>Math.min(e,t))),WI=(xI(vm,zI),pI((e,t)=>e*t)),jI=bI((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}));function HI(e,t,n){const r=Xg(-1,n);return WI([],t,r,e,n)}xI(_m,WI,jI);const GI=pI((e,t)=>e!==t?1:0);function qI(e,t,n,r,s){const o=t.length,i=Sp(t),a=Wp(t),u=Wp(s),l=Fp(n,Sp(s));for(let c=0;c<i;++c){const t=Yp(c,o,a),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];l[Xp(n,o,u)]=e[c]}return l}function KI(e,t,n,r){const[s,o]=pv(e,r),i=by(t,"int32"),a=qp(Sp(s),i),u=Sp(o);for(let l=0;l<a.length;++l){const e=l*u;let t=1;for(let r=0;r<u;++r)t*=n[e+r];a[l]=t}return{outVals:a,outShape:s,outDtype:i}}function XI(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return qp(0,r);const s=qp(Math.abs(Math.ceil((t-e)/n)),r);t<e&&1===n&&(n=-1),s[0]=e;for(let o=1;o<s.length;o++)s[o]=s[o-1]+n;return s}xI(km,GI,null,"bool");const YI=kI(e=>1/Math.sqrt(e));function QI(e,t,n,r,s){const o=Hx(r,t,n),i=Sp(n),a=Wp(r);if(o){const n=Gx(t,a);return"string"===s?e.slice(n,n+i):e.subarray(n,n+i)}const u=xx(r,s,"string"===s?mC(e):e),l=xx(n,s);for(let c=0;c<l.size;++c){const e=l.indexToLoc(c),n=e.map((e,n)=>e+t[n]);l.set(u.get(...n),...e)}return"string"===s?gC(l.values):l.values}function ZI(e,t,n,r,s,o,i){const a=t[0],u=o[0],l=new Array(u),c=new Array(a),h=t[1];if(0===u){if(0!==a)throw new Error(`Received SparseTensor with denseShape[0] = 0 but\n         indices.shape[0] = ${a}`);return[Dp(n,0),[0,h],Dp(s,0),l,c]}let d=!0,p=0;const f=new Array(u).fill(0);for(let g=0;g<a;++g){const t=e[g*h];if(t<0)throw new Error(`indices(${g}, 0) is invalid: ${t} < 0`);if(t>=u)throw new Error(`indices(${g}, 0) is invalid: ${t} >= ${u}`);++f[t],d=d&&t>=p,p=t}let m=!0;for(let g=0;g<u;++g){const e=0===f[g];l[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&d){const t=e,n=r;for(let e=0;e<a;++e)c[e]=e;return[t,[a,h],n,l,c]}{const t=f[u-1],o=Dp(n,t*h),d=Dp(s,t),p=new Array(u).fill(0);for(let n=0;n<a;++n){const t=e[n*h],s=(0===t?0:f[t-1])+p[t];p[t]++;for(let r=0;r<h;++r)o[s*h+r]=e[n*h+r];d[s]=r[n],c[n]=s}for(let e=0;e<u;++e)if(0===p[e]){const t=0===e?0:f[e-1];o[t*h+0]=e;for(let e=1;e<h;++e)o[t*h+e]=0;d[t]=i}return[o,[t,h],d,l,c]}}function JI(e,t,n,r,s){const o=Sp(r),i=t[0],a=s.length,u=[];let l=1,c=-1;for(let g=0;g<a;++g){const e=s[g];if(-1===e){if(-1!==c)throw new Error(`only one output dimension may be -1, not both ${c} and ${g}`);c=g,u.push(1)}else{if(e<0)throw new Error(`size ${g} must be non-negative, not ${e}`);l*=e,u.push(e)}}if(-1!==c){if(l<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(o/l);if(l*e!==o)throw new Error(`Input to reshape is a SparseTensor with ${o}\n          dense values, but the requested shape requires a multiple of ${l}. inputShape=${r} outputShape= ${u}`);u[c]=e}const h=Sp(u);if(h!==o)throw new Error(`Input to reshape is a tensor with ${o} dense values, but the requested shape has ${h}. inputShape=${r} outputShape=${u}`);const d=r.length,p=[];if(d>0){p[d-1]=1;for(let e=d-2;e>=0;--e)p[e]=p[e+1]*r[e+1]}const f=[];if(a>0){f[a-1]=1;for(let e=a-2;e>=0;--e)f[e]=f[e+1]*u[e+1]}const m=Dp(n,i*a);for(let g=0;g<i;++g){let t=0;for(let n=0;n<d;++n)t+=e[g*d+n]*p[n];for(let e=0;e<a;++e)m[g*a+e]=Math.trunc(t/f[e]),t%=f[e]}return[m,[i,a],u]}function eN(e,t,n,r,s,o=!1,i=0){const a=r.length;if(a!==s.length)throw new Error("segmentIds and indices should have same size.");const u=[t[0],e.length/t[0]],l=u[1],c=a>0?s[a-1]+1:0;if(c<0)throw new Error("segment ids must be >= 0");const h=t.slice();h[0]=c;const d=Dp(n,h.reduce((e,t)=>e*t,1));if(0===a)return c>0&&d.fill(i),[d,h];if(c<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,m=0,g=s[p];for(;;){let t=0;if(f<a){if(t=s[f],g===t){++f;continue}if(g>=t)throw new Error("segment ids are not increasing")}if(g<0||g>=c)throw new Error(`Segment id ${g} out of range [0, ${c}), possibly because segmentIds input is not sorted.`);g>m&&d.fill(i,m*l,g*l);for(let n=p;n<f;++n){const t=r[n];if(t<0||t>=u[0])throw new Error(`Bad: indices[${n}] == ${r[n]} out of range [0, ${u[0]})`);for(let n=0;n<l;n++)d[g*l+n]+=e[t*l+n]}if(o)for(let e=0;e<l;e++)d[g*l+e]/=f-p;if(p=f,++f,m=g+1,g=t,f>a)break}return m<c&&d.fill(i,m*l,c*l),[d,h]}EI(jm,YI);const tN=pI((e,t)=>{const n=e-t;return n*n});function nN(e,t,n,r){const s=xx(e,t.dtype);for(let o=0;o<s.size;o++){const e=s.indexToLoc(o),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+r[t];s.set(t.get(...i),...e)}return s}xI(ug,tN);class rN{constructor(e,t,n,r,s,o){this.separator=Zg(e),this.nGramWidths=t,this.leftPad=Zg(n),this.rightPad=Zg(r),this.padWidth=s,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,s,o){for(let i=0;i<s;++i){const a=this.getPadWidth(o),u=Math.max(0,a-i),l=Math.max(0,a-(s-(i+1))),c=o-(u+l),h=t+(u>0?0:i-a);let d=0;d+=u*this.leftPad.length;for(let t=0;t<c;++t)d+=e[h+t].length;d+=l*this.rightPad.length,d+=(u+l+c-1)*this.separator.length,n[r+i]=new Uint8Array(d);const p=n[r+i];let f=0;const m=e=>e.forEach(e=>p[f++]=e);for(let e=0;e<u;++e)m(this.leftPad),m(this.separator);for(let t=0;t<c-1;++t)m(e[h+t]),m(this.separator);if(c>0){m(e[h+c-1]);for(let e=0;e<l;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<l-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let s=1;s<r;++s){let r=t[s]>=e;if(r=r&&t[s]<=n,!r)throw new Error(`Invalid split value ${t[s]}, must be in [${e}, ${n}]`);e=t[s]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const s=r-1,o=Dp("int32",r);if(0===n||0===r){const e=new Array(n);for(let t=0;t<=s;++t)o[t]=0;return[e,o]}o[0]=0;for(let a=1;a<=s;++a){const e=t[a]-t[a-1];let n=0;this.nGramWidths.forEach(t=>{n+=this.getNumNGrams(e,t)}),this.preserveShort&&e>0&&0===n&&(n=1),o[a]=o[a-1]+n}const i=new Array(o[s]);for(let a=0;a<s;++a){const n=t[a];let r=o[a];if(this.nGramWidths.forEach(s=>{const o=this.getNumNGrams(t[a+1]-t[a],s);this.createNGrams(e,n,i,r,o,s),r+=o}),this.preserveShort&&r===o[a]){const s=t[a+1]-t[a];if(0===s)continue;this.createNGrams(e,n,i,r,1,s+2*this.padWidth)}}return[i,o]}}function sN(e,t,n,r,s,o,i,a){return new rN(n,r,s,o,i,a).compute(e,t)}function oN(e,t,n){if(!e.length)return[];if(0===t.length){const t=new Array(e.length);for(let n=0;n<e.length;++n)t[n]=e.subarray(n,n+1);return t}if(1===t.length){const r=t[0],s=[];let o=e.indexOf(r);for(;-1!==o;){const t=e.subarray(0,o);n&&0===t.length||s.push(t),o=(e=e.subarray(o+1)).indexOf(r)}return n&&0===e.length||s.push(e),s}const r=[];let s=0;for(let o=0;o<e.length+1;o++)if(o===e.length||-1!==t.indexOf(e[o])){const t=e.subarray(s,o);n&&0===t.length||r.push(t),s=o+1}return r}function iN(e,t,n){const r=e.length,s=[];let o=0,i=0;const a=new Array(r);for(let d=0;d<r;++d){const r=oN(e[d],t,n),u=r.length;a[d]=u,o+=u,i=Math.max(i,u),s.push(...r)}const u=Dp("int32",2*o),l=new Array(o),c=[r,i];let h=0;for(let d=0;d<r;++d)for(let e=0;e<a[d];++e)u[2*h]=d,u[2*h+1]=e,l[h]=s[h],++h;return[u,l,c]}function aN(e,t){const n=Dp("int32",e.length);for(let r=0;r<e.length;++r)n[r]=Kg(e[r]).modulo(t).getLowBitsUnsigned();return n}const uN=pI((e,t)=>e-t),lN=bI((e,t,n,r)=>({real:e-n,imag:t-r}));function cN(e,t){const n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=e.shape[s]*t[s];const r=xx(n,e.dtype);for(let s=0;s<r.values.length;++s){const t=r.indexToLoc(s),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];const o=e.locToIndex(n);r.values[s]=e.values[o]}return r}function hN(e,t,n,r,s){const o=t[t.length-1],[i,a]=[e.length/o,o],u=Fp(n,i*r),l=Fp("int32",i*r);for(let h=0;h<i;h++){const t=h*a,n=e.subarray(t,t+a),s=[];for(let e=0;e<n.length;e++)s.push({value:n[e],index:e});s.sort((e,t)=>t.value-e.value);const o=h*r,i=u.subarray(o,o+r),c=l.subarray(o,o+r);for(let e=0;e<r;e++)i[e]=s[e].value,c[e]=s[e].index}const c=t.slice();return c[c.length-1]=r,[xx(c,n,u),xx(c,"int32",l)]}function dN(e,t,n,r){const s=Ap(t,n)[0],o=[1,n[0],1];for(let f=0;f<s;f++)o[0]*=n[f];o[1]=n[s];for(let f=s+1;f<n.length;f++)o[2]*=n[f];const i={},a=new Int32Array(n[s]),u=new uy(o,r,e),l=[],c=1===o[0]&&1===o[2];for(let f=0;f<n[s];f++){let t;if(c)t=e[f].toString();else{const e=[];for(let t=0;t<o[0];t++)for(let n=0;n<o[2];n++)e.push(u.get(t,f,n));t=e.join(",")}if(void 0!==i[t])a[f]=i[t];else{const e=Object.keys(i).length;i[t]=e,a[f]=e,l.push(f)}}const h=o.slice();h[1]=Object.keys(i).length;const d=new uy(h,r);l.forEach((e,t)=>{for(let n=0;n<o[0];n++)for(let r=0;r<o[2];r++)d.set(u.get(n,e,r),n,t,r)});const p=n.slice();return p[s]=h[1],{outputValues:d.values,outputShape:p,indices:a}}xI(pg,uN,lN);const{addImpl:pN,bincountImpl:fN,bincountReduceImpl:mN,ceilImpl:gN,concatImpl:yN,equalImpl:xN,expImpl:bN,expm1Impl:vN,floorImpl:wN,gatherNdImpl:CN,gatherV2Impl:_N,greaterImpl:kN,greaterEqualImpl:EN,lessImpl:SN,lessEqualImpl:TN,linSpaceImpl:IN,logImpl:NN,maxImpl:$N,maximumImpl:RN,minimumImpl:AN,multiplyImpl:ON,negImpl:FN,notEqualImpl:DN,prodImpl:PN,rangeImpl:MN,rsqrtImpl:LN,simpleAbsImpl:BN,sliceImpl:VN,sparseFillEmptyRowsImpl:UN,sparseReshapeImpl:zN,sparseSegmentReductionImpl:WN,stridedSliceImpl:jN,stringNGramsImpl:HN,stringSplitImpl:GN,stringToHashBucketFastImpl:qN,subImpl:KN,tileImpl:XN,topKImpl:YN,transposeImpl:QN,uniqueImpl:ZN}=E;function JN(e,t){return["x","y","z","w","u","v"].slice(0,t).map(t=>`${e}.${t}`)}function e$(e,t){return 1===t?[e]:JN(e,t)}class t${constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e;const t=e.length;if(0===t)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const n=e$("rc",t),r=aI(t),s=function(e,t,n){if(1===e)return`rc > ${t[0]}`;let r="";for(let s=e-2;s<e;s++)r+=`${n[s]} >= ${t[s]}`,s<e-1&&(r+="||");return r}(t,e,n),o=function(e,t,n,r){if(1===e)return"";const s=r.slice(-2);return`\n    int r = ${s[0]};\n    int c = ${s[1]};\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ${t};\n    bool rEdge = rp1 >= ${n};\n  `}(t,e[e.length-1],e[e.length-2],n),i=function(e,t){const n=e.length,r=function(e,t){const n=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let o=`${0===r?"r":"rp1"}, ${0===s?"c":"cp1"}`;for(let n=2;n<e;n++)o=`${t[t.length-1-n]},`+o;n.push(o)}return n}(n,t);return 1===n?`getA(rc),\n            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),\n            0, 0`:`getA(${r[0]}),\n          cEdge ? 0. : getA(${r[1]}),\n          rEdge ? 0. : getA(${r[2]}),\n          rEdge || cEdge ? 0. : getA(${r[3]})`}(e,n);this.userCode=`\n        void main() {\n          ${r} rc = getOutputCoords();\n\n          if(${s}) {\n            setOutput(vec4(0));\n          } else {\n            ${o}\n\n            setOutput(vec4(${i}));\n          }\n        }\n      `}}}class n${constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;let n="";for(let s=0;s<4;s++){let e="thisRC = rc;";s%2==1&&(e+="thisRC.z += 1;"),s>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${s}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${s>0?"}":""}\n      `}var r;this.userCode=`\n      ${r=t,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${DT(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${PT(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${e[1]};\n        int cols = ${e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class r${constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){const r=o$(t,n),s=i$(e,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const o=s$(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const e=this.freeTextures[s].shift();return this.usedTextures[s].push(e),e}let i;return r===aT.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===aT.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===aT.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===aT.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===aT.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),i}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const s=o$(n,r),o=i$(t,s,r);o in this.freeTextures||(this.freeTextures[o]=[]);const i=s$(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),a=ef().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==a&&this._numBytesAllocated>a?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=i):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const u=this.usedTextures[o],l=u.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u.splice(l,1),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});for(const e in this.usedTextures)this.usedTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function s$(e,t,n,r,s){const o=function(e,t){switch(e){case aT.PACKED_2X2_FLOAT32:return KT(t);case aT.PACKED_2X2_FLOAT16:return XT(t);case aT.UNPACKED_FLOAT32:return HT(t);case aT.UNPACKED_FLOAT16:return GT(t);case aT.PACKED_4X1_UNSIGNED_BYTE:return qT(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);let i;if(s){const[t,n]=cT(e[0],e[1]);i=t*n}else{const[t,n]=uT(e[0],e[1]);i=t*n}return i*function(e,t){if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===e.RGBA16F)return 8;throw new Error(`Unknown internal format ${t}`)}(n,o)}function o$(e,t){if(e===iT.UPLOAD)return aT.PACKED_2X2_FLOAT32;if(e===iT.RENDER||null==e)return function(e){return ef().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?aT.PACKED_2X2_FLOAT32:aT.UNPACKED_FLOAT32:e?aT.PACKED_2X2_FLOAT16:aT.UNPACKED_FLOAT16}(t);if(e===iT.DOWNLOAD||e===iT.PIXELS)return aT.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function i$(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class a${constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const u$="return abs(x);",l$="return x;";class c${constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class h${constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e;const t=e.length,n=e$("rc",t),r=aI(t),s=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),o=n.slice(-2),i=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}}const d$=yC,p$={},f$=ef().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let m$=(()=>{class e extends xp{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ef().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==e){const e=sT(ef().getNumber("WEBGL_VERSION"));this.binaryCache=((t=ef().getNumber("WEBGL_VERSION"))in p$||(p$[t]={}),p$[t]),this.gpgpu=new YT(e),this.canvas=e.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;var t;this.textureManager=new r$(this.gpgpu),this.numMBBeforeWarning=null==ef().global.screen?1024:ef().global.screen.height*ef().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new yp(this,Sv())}nextDataId(){return e.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if((ef().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ef().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:iT.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,t,n,r,s){if(ef().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:iT.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:s,slice:o,shape:i,isPacked:a}=t;if(null!=o){let t;t=a?new c$(i,l$):new a$(i,l$);const n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),s=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const u=null!=this.activeTimers;let l,c;return u&&(l=Qg()),c="complex64"===r?Yw(this.readSync(s.real.dataId),this.readSync(s.imag.dataId)):this.getValuesFromTexture(e),u&&(this.downloadWaitMs+=Qg()-l),this.convertAndCacheOnCPU(e,c)}read(e){var t=this;return mp(function*(){if(t.pendingRead.has(e)){const n=t.pendingRead.get(e);return new Promise(e=>n.push(e))}const n=t.texData.get(e),{values:r,shape:s,slice:o,dtype:i,complexTensorInfos:a,isPacked:u}=n;if(null!=o){let n;n=u?new c$(s,l$):new a$(s,l$);const r=t.runWebGLProgram(n,[{dataId:e,shape:s,dtype:i}],i),o=t.read(r.dataId);return t.disposeIntermediateTensorInfo(r),o}if(null!=r)return t.convertAndCacheOnCPU(e);if(!ef().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===ef().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,c,h=null;if("complex64"!==i&&ef().get("WEBGL_BUFFER_SUPPORTED")){l=t.decode(e);const n=t.texData.get(l.dataId);h=t.gpgpu.createBufferFromTexture(n.texture,...lT(s))}if(t.pendingRead.set(e,[]),"complex64"!==i&&(yield t.gpgpu.createAndWaitForFence()),"complex64"===i){const e=yield Promise.all([t.read(a.real.dataId),t.read(a.imag.dataId)]);c=Yw(e[0],e[1])}else if(null==h)c=t.getValuesFromTexture(e);else{const e=Sp(s);c=t.gpgpu.downloadFloat32MatrixFromBuffer(h,e)}null!=l&&t.disposeIntermediateTensorInfo(l);const d=t.convertAndCacheOnCPU(e,c),p=t.pendingRead.get(e);return t.pendingRead.delete(e),p.forEach(e=>e(d)),t.pendingDisposal.has(e)&&(t.pendingDisposal.delete(e),t.disposeData(e)&&Sv().removeDataId(e,t),t.pendingDeletes--),d})()}bufferSync(e){const t=this.readSync(e.dataId);let n=t;if("string"===e.dtype)try{n=t.map(e=>Jg(e))}catch(r){throw new Error("Failed to decode encoded string bytes into utf-8")}return xx(e.shape,e.dtype,n)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!pT(n)){if(ef().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),s=Sp(t);if(ef().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),o=this.gpgpu.downloadMatrixFromPackedTexture(r.texture,...lT(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(n),o}const o=ef().getBool("WEBGL_PACK")&&!0===r,i=o?kT(t):t,a=o?new UT(i):new VT(i),u=this.runWebGLProgram(a,[{shape:i,dtype:n,dataId:e}],"float32"),l=this.texData.get(u.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture,l.texShape[0],l.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(u),c}timerAvailable(){return ef().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var t=this;return mp(function*(){const n=t.activeTimers,r=[];let s=!1;null==t.programTimersStack?(t.programTimersStack=r,s=!0):t.activeTimers.push(r),t.activeTimers=r,e();const o=Ep(t.activeTimers.map(e=>e.query)).filter(e=>null!=e),i=Ep(t.activeTimers.map(e=>e.name)).filter(e=>null!=e);t.activeTimers=n,s&&(t.programTimersStack=null);const a={uploadWaitMs:t.uploadWaitMs,downloadWaitMs:t.downloadWaitMs,kernelMs:null,wallMs:null};if(ef().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=yield Promise.all(o);a.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),a.getExtraProfileInfo=()=>e.map((e,t)=>({name:i[t],ms:e})).map(e=>`${e.name}: ${e.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return t.uploadWaitMs=0,t.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ef().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Qg(),endMs:null}}endTimer(e){return ef().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Qg(),e)}getQueryTime(e){var t=this;return mp(function*(){return ef().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?t.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:s,isPacked:o,slice:i}=this.texData.get(e),a=i&&i.origDataId||e,u=this.dataRefCount.get(a);u>1?this.dataRefCount.set(a,u-1):(this.dataRefCount.delete(a),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,s,o)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=f$){return ef().getBool("WEBGL_CPU_FORWARD")&&e.every(e=>null==this.texData.get(e.dataId).texture&&Sp(e.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){Kw("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return d$(e.shape,t)}packedUnaryOp(e,t,n){const r=new c$(e.shape,t),s=this.compileAndRun(r,[e],n);return Sv().makeTensorFromDataId(s.dataId,s.shape,s.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=BN(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(ef().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,u$,e.dtype);const t=new a$(e.shape,u$),n=this.compileAndRun(t,[e]);return Sv().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Bp(n[0])){const s=n.map(e=>Zg(e));r=this.write(s,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){const{dataId:r}=this.makeTensorInfo(e,t,n);return Sv().makeTensorFromDataId(r,e,t,this)}unpackTensor(e){const t=new h$(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new t$(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[CT(e.shape),..._T(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},s=[CT(t),..._T(t)],o=new n$(s,n),i=this.runWebGLProgram(o,[r],e.dtype,null,!0);return{dataId:i.dataId,shape:t,dtype:i.dtype}}decode(e){const t=this.texData.get(e),{isPacked:n,shape:r,dtype:s}=t,o=kT(r);let i;return i=n?new BT(o):new LT(o),{dtype:s,shape:r,dataId:this.runWebGLProgram(i,[{shape:o,dtype:s,dataId:e}],s,null,!0).dataId}}runWebGLProgram(e,t,n,r,s=!1){const o=this.makeTensorInfo(e.outputShape,n),i=this.texData.get(o.dataId);if(e.packedOutput&&(i.isPacked=!0),e.outPackingScheme===oT.DENSE){const t=lT(e.outputShape);i.texShape=t.map(e=>2*e)}if(null!=e.outTexUsage&&(i.usage=e.outTexUsage),0===Sp(o.shape))return i.values=Fp(o.dtype,0),o;const a=[],u=t.map(t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&Sp(t.shape)<=ef().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}else if(!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),a.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!ST(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),a.push(t),n=this.texData.get(t.dataId),e.shape=r}return this.uploadToGPU(t.dataId),{shape:t.shape,texData:n,isUniform:!1}});this.uploadToGPU(o.dataId);const l={shape:o.shape,texData:i,isUniform:!1},c=function(e,t,n){let r="";t.concat(n).forEach(e=>{r+=`${e.shape}_${e.isUniform?"uniform":e.texData.texShape}_${null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0}`});let s=e.constructor.name;return s+="_"+r+"_"+e.userCode,s}(e,u,l),h=this.getAndSaveBinary(c,()=>function(e,t,n,r){const s=t.userCode,o=n.map((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}}),i=o.map(e=>e.shapeInfo),a={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},u=ZT(o,a,s,t.packedInputs),l=e.createProgram(u);let c=null;const h=e.getUniformLocation(l,"NAN",!1);1===ef().getNumber("WEBGL_VERSION")&&(c=e.getUniformLocation(l,"INFINITY",!1));const d={};for(let p=0;p<t.variableNames.length;p++){const n=t.variableNames[p],r=!1;d[n]=e.getUniformLocation(l,n,r),d[`offset${n}`]=e.getUniformLocation(l,`offset${n}`,r)}return{program:t,source:u,webGLProgram:l,uniformLocations:d,inShapeInfos:i,outShapeInfo:a,infLoc:c,nanLoc:h}}(this.gpgpu,e,u,l)),d=null!=this.activeTimers;let p;d&&(p=this.startTimer()),function(e,t,n,r,s){cI(t.inShapeInfos,n),cI([t.outShapeInfo],[r]);const o=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(o,i[0],i[1]):e.setOutputMatrixTexture(o,i[0],i[1]),e.setProgram(t.webGLProgram),1===ef().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach((n,r)=>{const s=t.program.variableNames[r],o=t.uniformLocations[s],i=t.uniformLocations[`offset${s}`];if(null!=o)if(n.isUniform)if(Sp(n.shape)<2)e.gl.uniform1f(o,n.uniformValues[0]);else{let t=n.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(o,t)}else null!=n.texData.slice&&null!=i&&e.gl.uniform1i(i,n.texData.slice.flatOffset),e.setInputMatrixTexture(n.texData.texture,o,r)}),null!=s&&s(e,t.webGLProgram),e.executeProgram()}(this.gpgpu,h,u,l,r),a.forEach(e=>this.disposeIntermediateTensorInfo(e)),d&&(p=this.endTimer(p),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(p)}));const f=ef().get("WEBGL_FLUSH_THRESHOLD");if(f>0){const e=Qg();e-this.lastGlFlushTime>f&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!ef().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&!1===s){const e=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),e}return o}compileAndRun(e,t,n,r,s=!1){return this.runWebGLProgram(e,t,n=n||t[0].dtype,r,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ef().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Tv(()=>{if(!ef().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=ef().getBool("DEBUG");ef().set("DEBUG",!1);const t=this.abs(ob(1e-8)).dataSync()[0];if(ef().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:s,texture:o,usage:i,isPacked:a}=t;if(null!=o)return;const u=null!=this.activeTimers;let l;u&&(l=Qg());let c=t.texShape;if(null==c&&(c=function(e,t=!1){let n=ef().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t&&(n*=2,1===(e=e.map((t,n)=>n>=e.length-2?wp(e[n]):e[n])).length&&(e=[2,e[0]])),2!==e.length){const t=Op(e);e=t.newShape}let r=Sp(e);if(e.length<=1&&r<=n)return[1,r];if(2===e.length&&e[0]<=n&&e[1]<=n)return e;if(3===e.length&&e[0]*e[1]<=n&&e[2]<=n)return[e[0]*e[1],e[2]];if(3===e.length&&e[0]<=n&&e[1]*e[2]<=n)return[e[0],e[1]*e[2]];if(4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n)return[e[0]*e[1]*e[2],e[3]];if(4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n)return[e[0],e[1]*e[2]*e[3]];if(t){const t=CT(e);let n=2,s=2;return e.length&&([n,s]=_T(e)),r=t*(n/2)*(s/2),Np(r).map(e=>2*e)}return Np(r)}(n,a),t.texShape=c),null!=s){const e=kT(n);let o,i=c[1],h=c[0];const d=s instanceof Uint8Array;a?([i,h]=cT(c[0],c[1]),o=new WT(e,[h,i],d)):o=new zT(e,[h,i],d);const p=this.makeTensorInfo([h,i],r);this.texData.get(p.dataId).usage=d?iT.PIXELS:iT.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(p.dataId),i,h,s);const f=this.runWebGLProgram(o,[p],r,null,!0),m=this.texData.get(f.dataId);t.texture=m.texture,t.texShape=m.texShape,t.isPacked=m.isPacked,t.usage=m.usage,this.disposeIntermediateTensorInfo(p),this.texData.delete(f.dataId),t.values=null,u&&(this.uploadWaitMs+=Qg()-l)}else{const e=this.acquireTexture(c,i,r,a);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return this.releaseGPUData(e),null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*Lp(t)}}return e.nextDataId=0,e})();Ry()&&function(e,t,n=1){Iy.registerBackend("webgl",t,n)}(0,()=>new m$,2);class g${constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=Zb(t,n),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}class y${constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Zb(t,n);const s=this.outputShape.length;let o="";if(r)if(0===s||1===Sp(this.outputShape))o="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(o=`\n          ${aI(s)} coords = getOutputCoords();\n        `,1===s)o+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=e$("coords",s);o+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${o}\n\n        setOutput(result);\n      }\n    `}}function x$(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const b$={kernelName:nm,backendName:"webgl",kernelFunc:x$};function v$(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,o=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(o.dataId),a=x$({inputs:{x:r},backend:n}),u=x$({inputs:{x:s},backend:n});return i.complexTensorInfos={real:a,imag:u},o}const w$={kernelName:Ef,backendName:"webgl",kernelFunc:v$},C$="return (a < 0.) ? b * a : a;",_$="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",k$={kernelName:im,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:o}=r,i=n.makeTensorInfo([],"float32",Xg(o,"float32")),a=ef().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new y$(_$,s.shape,i.shape):new g$(C$,s.shape,i.shape),u=n.runWebGLProgram(a,[s,i],s.dtype);return n.disposeIntermediateTensorInfo(i),u}},E$="return (a < 0.) ? b * a : a;",S$="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",T$={kernelName:Am,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t,o=ef().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new y$(S$,r.shape,s.shape):new g$(E$,r.shape,s.shape);return n.runWebGLProgram(o,[r,s],r.dtype)}};function I$({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:o})=>{const{x:i}=s,a=o,u=r||i.dtype;if(a.shouldExecuteOnCPU([i])&&null!=n){const e=a.texData.get(i.dataId),t=n(e.values,u);return a.makeTensorInfo(i.shape,u,t)}let l;return l=ef().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new c$(i.shape,t):new a$(i.shape,e),a.runWebGLProgram(l,[i],u)}}function N$({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:o}){return({inputs:i,backend:a})=>{const{a:u,b:l}=i,c=a;if(r&&"complex64"===u.dtype){const t=c.texData.get(u.dataId),n=c.texData.get(l.dataId),[r,s]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map(t=>{const[n,r]=t,s={dataId:n.dataId,dtype:n.dtype,shape:u.shape},o={dataId:r.dataId,dtype:r.dtype,shape:l.shape},i=new g$(e,u.shape,l.shape);return c.runWebGLProgram(i,[s,o],by(n.dtype,r.dtype))}),o=v$({inputs:{real:r,imag:s},backend:c});return c.disposeIntermediateTensorInfo(r),c.disposeIntermediateTensorInfo(s),o}const h=o||by(u.dtype,l.dtype);if(("string"===u.dtype||"string"===l.dtype||c.shouldExecuteOnCPU([u,l]))&&null!=s){const e=c.texData.get(u.dataId).values,t=c.texData.get(l.dataId).values,n="string"===u.dtype?mC(e):e,r="string"===u.dtype?mC(t):t,[o,i]=s(u.shape,l.shape,n,r,h),a=c.makeTensorInfo(i,h);return c.texData.get(a.dataId).values=o,a}let d;return d=ef().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new y$(t,u.shape,l.shape,n):new g$(e,u.shape,l.shape),c.runWebGLProgram(d,[u,l],h)}}function $$(e,t=!1){if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===e)return t?S$:E$;if("leakyrelu"===e)return t?_$:C$;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class R${constructor(e,t,n,r=!1,s=!1,o=!1,i=null,a=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;const l=Math.ceil((r?e[1]:e[2])/2),c=r?"i * 2, rc.y":"rc.y, i * 2",h=s?"rc.z, i * 2":"i * 2, rc.z",d=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],p=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let f="",m="";i&&(f=a?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:u?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,m="result = activation(result);");const g=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let y="rc.x",x="rc.x";e[0]<t[0]?y=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(x=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`\n      ${f}\n\n      const float sharedDimension = ${l}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${l}; i++) {\n          int batchA = ${y};\n          int batchB = ${x};\n          vec4 a = getMatrixA(batchA, ${c});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${d[0]} * ${p[0]});\n          result += (${d[1]} * ${p[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${g}\n\n        ${m}\n\n        setOutput(result);\n      }\n    `}}class A${constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Zb(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const O$="return a * b;";function F$(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,o=by(r.dtype,s.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),o=new A$("return areal * breal - aimag * bimag;",r.shape,s.shape),i=new A$("return areal * bimag + aimag * breal;",r.shape,s.shape),a=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],u=n.runWebGLProgram(o,a,"float32"),l=n.runWebGLProgram(i,a,"float32"),c=v$({inputs:{real:u,imag:l},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(l),c}if(n.shouldExecuteOnCPU([r,s])){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),[i,a]=ON(r.shape,s.shape,e.values,t.values,o),u=n.makeTensorInfo(a,o);return n.texData.get(u.dataId).values=i,u}let i;return i=ef().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new y$(O$,r.shape,s.shape):new g$(O$,r.shape,s.shape),n.runWebGLProgram(i,[r,s],o)}const D$={kernelName:_m,backendName:"webgl",kernelFunc:F$};function P$(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:o}=r,i=n,a=Sp(s.shape),u=function(e,t){let n=1,r=-1;for(let o=0;o<e.length;++o)if(e[o]>=0)n*=e[o];else if(-1===e[o]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${o}`);r=o}else if(e[o]<0)throw Error(`Shapes can not be < 0. Found ${e[o]} at dim ${o}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const s=e.slice();return s[r]=t/n,s}(o,a),l=Sp(u);Cp(a===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const c=i.texData.get(s.dataId);return!c.isPacked||ST(s.shape,u)||null!==c.texture&&ST(c.shape,u)?(i.incRef(s.dataId),{dataId:s.dataId,shape:u,dtype:s.dtype}):function(e,t,n){const r=[CT(e.shape),..._T(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},o=[CT(t),..._T(t)],i=new n$(o,r),a=n.runWebGLProgram(i,[s],e.dtype,null,!0);return{dataId:a.dataId,shape:t,dtype:a.dtype}}(s,u,i)}const M$={kernelName:Lm,backendName:"webgl",kernelFunc:P$};class L${constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:o}=e;this.outputShape=[r,o];const i=4*Math.floor(n/4),a=n%4;let u="sumValue += dot(values, ones);";if(null!=t){const e=1/t;u=`sumValue += dot(values * ${Ip(e)?e.toPrecision(2):e}, ones);`}let l="";s%n>0&&(l=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${l}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===a}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===a}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===a}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class B${constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:o}=e;this.outputShape=[r,o];let i="0.0",a="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",a="min"):"max"===t&&(i="-1.0 / 1e-20",a="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?u="sumValue":"prod"===t?u="prodValue":"all"===t?u="allValue":"any"===t&&(u="anyValue");const l=4*Math.floor(n/4),c=n%4;let h=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${a}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${a}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,d="vec4";"all"===t?(i="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===t&&(i="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";s%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${l}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${l};\n        if (${1===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${u});\n      }\n    `}}function V$(e,t,n,r){const s=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=Nw(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let o=e;for(let i=0;i<s.length;i++){const{inSize:a,windowSize:u,outSize:l}=s[i];let c,h;c="mean"===n?0===i?new L$({windowSize:u,inSize:a,batchSize:e.shape[0],outSize:l},a):new L$({windowSize:u,inSize:a,batchSize:e.shape[0],outSize:l}):new B$({windowSize:u,inSize:a,batchSize:e.shape[0],outSize:l},n),h=o,o=r.runWebGLProgram(c,[o],t),h.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(h)}return o}class U${constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[t[o]];this.outputShape=n,this.rank=n.length;const r=aI(this.rank),s=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<e.length;s++)r[e[s]]=n[s];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${s}));\n    }\n    `}}class z${constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let l=0;l<n.length;l++)n[l]=e[t[l]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=aI(this.rank),s=JN("rc",this.rank),o=new Array(this.rank);for(let l=0;l<t.length;l++)o[t[l]]=s[l];const i=`vec2(${o.slice(-2).join()})`,a=`++${s[this.rank-1]} < ${n[this.rank-1]}`,u=`getChannel(getA(${o.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${a}) {\n        result[1] = ${u};\n      }\n      --${s[this.rank-1]};\n      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${u};\n        if(${a}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function W$(e,t,n){const r=ef().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new z$(e.shape,t):new U$(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function j$(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:i}=r;return function(e,t,n,r){const s=e.shape.length,o=Ap(t,e.shape);let i=o;const a=gv(i,s),u=null!=a;let l=e;u&&(l=W$(e,a,r),i=xv(i.length,s)),mv("sum",i,s);const[c,h]=pv(l.shape,i);let d=c;n&&(d=fv(c,o));const p=Sp(h),f=P$({inputs:{x:l},attrs:{shape:[Sp(e.shape)/p,p]},backend:r}),m=V$(f,vy(e.dtype),"sum",r),g=P$({inputs:{x:m},attrs:{shape:d},backend:r});return r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(m),u&&r.disposeIntermediateTensorInfo(l),g}(s,o,i,n)}const H$={kernelName:"Sum",backendName:"webgl",kernelFunc:j$};function G$(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:o}=r,i=n,a=new Array(s.shape.length);for(let l=0;l<a.length;l++)a[l]=s.shape[o[l]];let u;if(i.shouldExecuteOnCPU([s])){const e=i.texData.get(s.dataId),t=QN(e.values,s.shape,s.dtype,o,a);u=i.makeTensorInfo(a,s.dtype),i.texData.get(u.dataId).values=t}else u=W$(s,o,i);return u}const q$={kernelName:xg,backendName:"webgl",kernelFunc:G$};function K$({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:u=null}){const l=e.shape.length,c=t.shape.length,h=n?e.shape[l-2]:e.shape[l-1],d=r?t.shape[c-1]:t.shape[c-2],p=n?e.shape[l-1]:e.shape[l-2],f=r?t.shape[c-2]:t.shape[c-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),y=Sp(m),x=Sp(g);Cp(l>=2&&c>=2&&(y===x||1===y||1===x),()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${m}) and (${g}).`);const b=(y>x?e.shape.slice(0,-2):t.shape.slice(0,-2)).concat([p,f]);Cp(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);const v=n?[y,h,p]:[y,p,h],w=r?[x,f,d]:[x,d,f],C=P$({inputs:{x:e},backend:s,attrs:{shape:v}}),_=P$({inputs:{x:t},backend:s,attrs:{shape:w}}),k=[C,_],E=Math.max(y,x),S=n?C.shape[1]:C.shape[2],T=null!=o,I=null!=i,N="leakyrelu"===u,$=null!=u?$$(u,!0):null;let R;if((1===p||1===f)&&S>1e3&&!1===(T||I||N||null!=$)){let e=C,t=_;n&&(e=G$({inputs:{x:C},backend:s,attrs:{perm:[0,2,1]}}),k.push(e)),r&&(t=G$({inputs:{x:_},backend:s,attrs:{perm:[0,2,1]}}),k.push(t));const o=1===f;let i=e;1!==f&&(i=P$({inputs:{x:e},backend:s,attrs:{shape:[E,S,1]}}),k.push(i));const a=1===f?2:1;let u=t;o&&(u=P$({inputs:{x:t},backend:s,attrs:{shape:[E,1,S]}}),k.push(u));const l=F$({inputs:{a:i,b:u},backend:s});R=j$({inputs:{x:l},backend:s,attrs:{axis:a,keepDims:!0}}),k.push(l)}else{const u=by(e.dtype,t.dtype),l=new R$(v,w,[E,p,f],n,r,T,$,I,N),c=[C,_];if(null!=o&&c.push(o),I&&c.push(i),N){const e=s.makeTensorInfo([],"float32",Xg(a,"float32"));c.push(e),k.push(e)}R=s.runWebGLProgram(l,c,u)}const A=P$({inputs:{x:R},backend:s,attrs:{shape:b}});k.push(R);for(const O of k)s.disposeIntermediateTensorInfo(O);return A}const X$={kernelName:Eg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:o,bias:i,preluActivationWeights:a}=t,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:h}=r;return K$({a:s,b:o,transposeA:u,transposeB:l,backend:n,bias:i,preluActivationWeights:a,leakyreluAlpha:h,activation:c})}},Y$="return abs(x);",Q$={kernelName:"Abs",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=BN(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let s;return s=ef().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new c$(r.shape,Y$):new a$(r.shape,Y$),n.runWebGLProgram(s,[r],r.dtype)}},Z$=I$({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),J$={kernelName:of,backendName:"webgl",kernelFunc:Z$},eR=I$({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),tR={kernelName:af,backendName:"webgl",kernelFunc:eR},nR="return a + b;",rR=N$({opSnippet:nR,packedOpSnippet:nR,supportsComplex:!0,cpuKernelImpl:pN}),sR={kernelName:uf,backendName:"webgl",kernelFunc:rR};class oR{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);const n=[];this.variableNames.forEach(e=>{n.push(`float v${e} = get${e}AtOutCoords();`)});const r=this.variableNames.map(e=>`v${e}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class iR{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);const n=[];this.variableNames.forEach(e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)});const r=this.variableNames.map(e=>`v${e}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const aR={kernelName:lf,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,s=n;if(1===s.length)return x$({inputs:{x:s[0]},backend:r});if(s.length>ef().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(s.length/2),n=e({inputs:s.slice(0,t),backend:r}),o=e({inputs:s.slice(t),backend:r});return e({inputs:[n,o],backend:r})}const o=s.map(e=>e.dtype).reduce((e,t)=>by(e,t)),i=s.map(e=>e.shape),a=ef().getBool("WEBGL_PACK")?new iR(s[0].shape,i):new oR(s[0].shape,i);return r.runWebGLProgram(a,s,o)}},uR={kernelName:"All",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:i}=r,a=s.shape.length,u=Ap(o,s.shape);let l=u;const c=gv(l,a);let h=s;null!=c&&(h=G$({inputs:{x:s},backend:n,attrs:{perm:c}}),l=xv(l.length,a)),mv("all",l,a);const[d,p]=pv(h.shape,l),f=P$({inputs:{x:h},backend:n,attrs:{shape:[-1,Sp(p)]}}),m=V$(f,f.dtype,"all",n);let g;return g=P$(i?{inputs:{x:m},backend:n,attrs:{shape:fv(d,u)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}},lR={kernelName:"Any",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:i}=r,a=s.shape.length,u=Ap(o,s.shape);let l=u;const c=gv(l,a);let h=s;null!=c&&(h=G$({inputs:{x:s},backend:n,attrs:{perm:c}}),l=xv(l.length,a)),mv("any",l,a);const[d,p]=pv(h.shape,l),f=P$({inputs:{x:h},backend:n,attrs:{shape:[-1,Sp(p)]}}),m=V$(f,f.dtype,"any",n);let g;return g=P$(i?{inputs:{x:m},backend:n,attrs:{shape:fv(d,u)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}};class cR{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:s,outSize:o}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,o],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===t?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class hR{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Cp(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);const s=Math.ceil(e[e.length-1]/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");const o=this.outputShape,i=o.length,a=aI(i),u=e$("coords",i);let l,c;if(1===s){c=i+1;const e=aI(c);l=`\n        ${e} sourceLocR = ${e}(${u.join()}, 0);\n        ++${u[i-1]};\n        ${e} sourceLocG = ${e}(${u.join()}, 0);\n        ++${u[i-2]};\n        ${e} sourceLocA = ${e}(${u.join()}, 0);\n        --${u[i-1]};\n        ${e} sourceLocB = ${e}(${u.join()}, 0);\n        --${u[i-2]};`}else c=i,l=`\n        ${a} sourceLocR = coords;\n        ++${u[i-1]};\n        ${a} sourceLocG = coords;\n        ++${u[i-2]};\n        ${a} sourceLocA = coords;\n        --${u[i-1]};\n        ${a} sourceLocB = coords;\n        --${u[i-2]};`;const h=["x","y","z","w","u","v"].slice(0,c),d="."+h[c-1],p=h.map(e=>"int "+e),f=e$("sourceLocR",c-1).concat("inIdx.r"),m=e$("sourceLocG",c-1).concat("inIdx.g"),g=e$("sourceLocB",c-1).concat("inIdx.b"),y=e$("sourceLocA",c-1).concat("inIdx.a"),x="max"===n?"greaterThan":"lessThan",b=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${f.join()}),\n                             getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()})));`,v=`vec4(\n            getAChannel(${f.join()}),\n            hasNextCol ? getAChannel(${m.join()}) : 0.,\n            hasNextRow ? getAChannel(${g.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${y.join()}) : 0.)`,w=r?"":`\n      float getBestIndicesAChannel(${p.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${p.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${w}\n      void main() {\n        ${a} coords = getOutputCoords();\n        bool hasNextCol = ${u[i-1]} < ${o[i-1]-1};\n        bool hasNextRow = ${u[i-2]} < ${o[i-2]-1};\n        ${l}\n        ivec4 srcIdx = ivec4(sourceLocR${d}, sourceLocG${d},\n          sourceLocB${d}, sourceLocA${d}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${v};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${b}\n          vec4 candidate = ${v};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function dR(e,t,n,r=null){let s=t.shape[0],o=t.shape[1];null!=r&&(s=r.shape[0],o=r.shape[1]);const i=Nw(o),a={windowSize:i,inSize:o,batchSize:s,outSize:Math.ceil(o/i)},u=new cR(a,n,null==r),l=[t];null!=r&&l.push(r);const c=e.runWebGLProgram(u,l,"int32");if(1===c.shape[1])return c;const h=dR(e,t,n,c);return e.disposeIntermediateTensorInfo(c),h}function pR(e,t,n,r=null){const s=null!=r?r.shape:t.shape,o=Nw(s[s.length-1]),i=new hR(s,o,n,null==r),a=e.runWebGLProgram(i,null==r?[t]:[t,r],"int32");if(a.shape.length===t.shape.length){const r=pR(e,t,n,a);return e.disposeIntermediateTensorInfo(a),r}return a}function fR(e,t,n,r){const s=[n];if(mv("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!ef().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],[o,i]=pv(t.shape,s),a=Sp(i),u=P$({inputs:{x:t},backend:e,attrs:{shape:[-1,a]}});n.push(u);const l=dR(e,u,r);n.push(l);const c=P$({inputs:{x:l},backend:e,attrs:{shape:o}});return n.forEach(t=>e.disposeIntermediateTensorInfo(t)),c}return pR(e,t,r)}const mR={kernelName:cf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o}=r;let i=Ap(o,s.shape);const a=gv(i,s.shape.length);let u=s;const l=[];null!=a&&(u=G$({inputs:{x:s},backend:n,attrs:{perm:a}}),l.push(u),i=xv(i.length,u.shape.length)),mv("argMax",[i[0]],u.shape.length);const c=fR(n,u,i[0],"max");return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}},gR={kernelName:hf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o}=r;let i=Ap(o,s.shape);const a=gv(i,s.shape.length);let u=s;const l=[];null!=a&&(u=G$({inputs:{x:s},backend:n,attrs:{perm:a}}),l.push(u),i=xv(i.length,u.shape.length)),mv("argMin",[i[0]],u.shape.length);const c=fR(n,u,i[0],"min");return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}},yR=I$({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),xR={kernelName:df,backendName:"webgl",kernelFunc:yR},bR=I$({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),vR={kernelName:pf,backendName:"webgl",kernelFunc:bR},wR=I$({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),CR={kernelName:ff,backendName:"webgl",kernelFunc:wR},_R=N$({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),kR={kernelName:gf,backendName:"webgl",kernelFunc:_R},ER=I$({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),SR={kernelName:mf,backendName:"webgl",kernelFunc:ER};class TR{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,i=e.strideHeight,a=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t;let m="0.0";if(f||(m="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${a});\n        const ivec2 pads = ivec2(${d}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${l}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?s?`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`:`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let g=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(g="avgValue / count");const y=4*Math.floor(o/4),x=o%4,b=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${a});\n      const ivec2 pads = ivec2(${d}, ${p});\n      const float initializationValue = ${m};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${m});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${y}; wC += 4) {\n            int xC = xCCorner + wC * ${l};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              getValue(batch, xR, xC + 3 * ${l}, d)\n            );\n\n            ${b}\n          }\n\n          int xC = xCCorner + ${y};\n          if (${1===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${b}\n          } else if (${2===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${b}\n          } else if (${3===x}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${l}, d),\n              getValue(batch, xR, xC + 2 * ${l}, d),\n              initializationValue\n            );\n\n            ${b}\n          }\n        }\n        setOutput(${g});\n      }\n    `}}class IR{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,i=e.strideDepth,a=e.strideHeight,u=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const x="avg"===t;let b="0.0";if(x||(b="-1.0 / 1e-20"),n)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${a}, ${u});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${l}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(v="avgValue / count");const w=4*Math.floor(o/4),C=o%4,_=`\n      if (${x}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${a}, ${u});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${l}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${_}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===C}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${_}\n            } else if (${2===C}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${_}\n            } else if (${3===C}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${_}\n            }\n          }\n          setOutput(${v});\n        }\n      }\n    `}}const NR={kernelName:yf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;AT(s,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:u}=r;Cp(yw(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const l=aw(s.shape,o,i,1,a,u);if(1===l.filterWidth&&1===l.filterHeight&&Tp(l.inShape,l.outShape))return x$({inputs:{x:s},backend:n});const c=new TR(l,"avg",!1);return n.runWebGLProgram(c,[s],"float32")}},$R={kernelName:xf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:o,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=r,c=uw(s.shape,o,i,[1,1,1],a,u,l),h=new IR(c,"avg",!1);return n.runWebGLProgram(h,[s],"float32")}};class RR{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.effectiveFilterHeight,n=e.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n      const float avgMultiplier = float(${1/(e.filterHeight*e.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t};\n            wR += ${e.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n};\n            wC+= ${e.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class AR{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.effectiveFilterDepth,n=e.effectiveFilterHeight,r=e.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${t-1-e.padInfo.front}, ${n-1-e.padInfo.top}, ${r-1-e.padInfo.left});\n      const float avgMultiplier = float(${1/(e.filterDepth*e.filterHeight*e.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${t};\n            wD += ${e.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${e.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${e.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${r};\n                wC += ${e.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const OR={kernelName:"AvgPool3DGrad",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o}=t,i=o,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=r,h=uw(i.shape,a,u,[1,1,1],l,c),d=new AR(h);return n.runWebGLProgram(d,[s],i.dtype)}},FR={kernelName:"AvgPoolGrad",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o}=t,i=o;AT([s,o],"avgPoolGrad");const{filterSize:a,strides:u,pad:l}=r,c=aw(i.shape,a,u,1,l),h=new RR(c);return n.runWebGLProgram(h,[s],i.dtype)}},DR={kernelName:bf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:o}=t,{transposeA:i,transposeB:a}=r;return K$({a:s,b:o,transposeA:i,transposeB:a,backend:n})}};class PR{constructor(e,t,n,r,s,o){this.outputShape=[],this.variableNames=["x","mean","variance"],Zb(e,t),Zb(e,n);let i="0.0";null!=r&&(Zb(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let a="1.0";null!=s&&(Zb(e,s),this.variableNames.push("scale"),a="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${a};\n        float inv = scale * inversesqrt(variance + float(${o}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class MR{constructor(e,t,n,r,s,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Zb(e,t),Zb(e,n);let i="vec4(0.0)";null!=r&&(Zb(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let a="vec4(1.0)";null!=s&&(Zb(e,s),this.variableNames.push("scale"),a="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${a};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${o}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const LR={kernelName:Qf,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,mean:s,variance:o,offset:i,scale:a}=e;Cp(s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Cp(null==i||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Cp(null==a||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=n;null==u&&(u=.001);const l=[r,s,o];let c=null;null!=i&&(c=i.shape,l.push(i));let h=null;null!=a&&(h=a.shape,l.push(a));const d=ef().getBool("WEBGL_PACK_NORMALIZATION")?new MR(r.shape,s.shape,o.shape,c,h,u):new PR(r.shape,s.shape,o.shape,c,h,u);return t.runWebGLProgram(d,l,l[0].dtype)}};class BR{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=aI(this.rank),n=`uniform int start[${this.rank}];`,r=function(e){if(1===e)return"sourceLoc";if(e<=6)return VR.slice(0,e).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let s;s=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map((e,t)=>`sourceLoc.${VR[t]} = start[${t}] + coords.${VR[t]};`).join("\n")}\n      `,this.userCode=`\n      ${n}\n      void main() {\n        ${s}\n        setOutput(getSource(${r}));\n      }\n    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(t,n)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,e)}}}const VR=["x","y","z","w","u","v"];class UR{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length;const t=aI(this.rank),n=e$("coords",this.rank),r=e$("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,o=`getChannel(getSource(${r.join()}), ${s})`,i=`\n      result.x = ${o};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${o};\n        --${r[this.rank-1]};\n      }\n    `,a=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${o};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${o};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map((e,t)=>`start[${t}]`).join()});`:e.map((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`).join("\n");this.userCode=`\n      uniform int start[${this.rank}];\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${i}\n        ${a}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(e){if(e.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${e.length})`);return(t,n)=>{null==this.startLoc&&(this.startLoc=t.getUniformLocationNoThrow(n,"start"),null==this.startLoc)||t.gl.uniform1iv(this.startLoc,e)}}}function zR(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:o,size:i}=r,[a,u]=qx(s,o,i);if(Ox(s,a,u),0===Sp(u))return n.makeTensorInfo(u,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||"string"===s.dtype){const e=n.texData.get(s.dataId),t=VN(e.values,a,u,s.shape,s.dtype);return n.makeTensorInfo(u,s.dtype,t)}const{isPacked:l}=n.texData.get(s.dataId),c=Hx(s.shape,a,u);if(l||!c){const e=ef().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new UR(u):new BR(u),t=e.getCustomSetupFunc(a);return n.runWebGLProgram(e,[s],s.dtype,t)}return n.uploadToGPU(s.dataId),function(e,t,n,r){const s=r.texData.get(e.dataId),o=r.makeTensorInfo(n,e.dtype),i=r.texData.get(o.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=e.dtype;let a=Gx(t,Wp(e.shape));s.slice&&(a+=s.slice.flatOffset),i.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||e.dataId};const u=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,u+1),o}(s,a,u,n)}const WR={kernelName:Km,backendName:"webgl",kernelFunc:zR},jR={kernelName:vf,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:o,crops:i}=r;Cp(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((e,t)=>e*t),u=Rw(s.shape,o,a),l=Aw(u.length,o.length),c=Ow(s.shape,o,a),h=Fw(i,o.length),d=Dw(c,i,o.length),p=[],f=P$({inputs:{x:s},backend:n,attrs:{shape:u}}),m=G$({inputs:{x:f},backend:n,attrs:{perm:l}}),g=P$({inputs:{x:m},backend:n,attrs:{shape:c}}),y=zR({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach(e=>n.disposeIntermediateTensorInfo(e)),y}},HR={kernelName:wf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:o}=t,{size:i}=r,a=n.readSync(s.dataId),u=n.readSync(o.dataId),l=fN(a,u,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,l)}},GR=N$({opSnippet:"return float(a != b);",cpuKernelImpl:DN,dtype:"bool"}),qR={kernelName:km,backendName:"webgl",kernelFunc:GR};function KR(e){const{inputs:t,backend:n}=e,{input:r}=t;return x$({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const XR={kernelName:Dm,backendName:"webgl",kernelFunc:KR},YR={kernelName:Cf,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:s}=t,{x:o}=n,{dtype:i}=s;if("complex64"===i){if("complex64"===o.dtype)return x$({inputs:{x:o},backend:r});const t=fb(o.shape),n=e({inputs:{x:o},backend:r,attrs:{dtype:"float32"}}),s=v$({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),s}if("complex64"===o.dtype){const t=KR({inputs:{input:o},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:i}});return r.disposeIntermediateTensorInfo(t),n}if(!Pp(o.dtype,i)){const e=x$({inputs:{x:o},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if("int32"===i)return function(e,t){const n=new a$(e.shape,"return float(int(x));"),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(o,r);if("bool"===i){const e=r.makeTensorInfo([],"bool",Fp("bool",1)),t=GR({inputs:{a:o,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${i}`)}},QR="return ceil(x);",ZR=I$({opSnippet:QR,packedOpSnippet:QR,cpuKernelImpl:gN}),JR={kernelName:_f,backendName:"webgl",kernelFunc:ZR};class eA{constructor(e){this.variableNames=["A"],this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}getCustomSetupFunc(e,t){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}}class tA{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}getCustomSetupFunc(e,t){return(n,r)=>{null==this.minLoc&&(this.minLoc=n.getUniformLocationNoThrow(r,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(r,"maxVal")),n.gl.uniform1f(this.minLoc,e),n.gl.uniform1f(this.maxLoc,t)}}}const nA={kernelName:kf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:o,clipValueMax:i}=r;let a;a=ef().getBool("WEBGL_PACK_CLIP")?new tA(s.shape):new eA(s.shape);const u=a.getCustomSetupFunc(o,i);return n.runWebGLProgram(a,[s],s.dtype,u)}};class rA{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function sA(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const oA={kernelName:Sf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),o=new rA(r.shape),i=[sA(r,s.complexTensorInfos.real),sA(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(o,i,i[0].dtype)}};class iA{constructor(e){this.outputShape=[],this.outputShape=ow(e,1),this.variableNames=e.map((e,t)=>`T${t}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let r=1;r<t.length;r++)t[r]=t[r-1]+e[r][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let r=1;r<t.length;r++)n.push(`else if (yC < ${t[r]}) setOutput(getT${r}(yR, yC-${t[r-1]}));`);n.push(`else setOutput(getT${t.length}(yR, yC-${t[t.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class aA{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=ow(e,t);const n=this.outputShape,r=n.length,s=aI(r),o=e$("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((e,t)=>`T${t}`);const a=new Array(e.length-1);a[0]=e[0][t];for(let p=1;p<a.length;p++)a[p]=a[p-1]+e[p][t];const u=i[t],l=i.slice(-2),c=i.join();let h=`if (${u} < ${a[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${l.join()}));\n        }`;for(let p=1;p<a.length;p++){const e=a[p-1];h+=`\n        if (${u} < ${a[p]}  && ${u} >= ${a[p-1]}) {\n          return getChannel(\n            getT${p}(${uA(i,u,e)}),\n            vec2(${uA(l,u,e)}));\n        }`}const d=a[a.length-1];h+=`\n        return getChannel(\n          getT${a.length}(${uA(i,u,d)}),\n          vec2(${uA(l,u,d)}));`,this.userCode=`\n      float getValue(${i.map(e=>"int "+e)}) {\n        ${h}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${o}), 0., 0., 0.);\n\n        ${o[r-1]} = ${o[r-1]} + 1;\n        if (${o[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${o});\n        }\n\n        ${o[r-2]} = ${o[r-2]} + 1;\n        if (${o[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${o});\n        }\n\n        ${o[r-1]} = ${o[r-1]} - 1;\n        if (${o[r-2]} < ${n[r-2]} &&\n            ${o[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${o});\n        }\n        setOutput(result);\n      }\n    `}}function uA(e,t,n){const r=e.indexOf(t);return e.map((e,t)=>t===r?`${e} - ${n}`:e).join()}function lA(e){const{inputs:t,backend:n}=e,{input:r}=t;return x$({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const cA={kernelName:sm,backendName:"webgl",kernelFunc:lA};function hA(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map(e=>KR({inputs:{input:e},backend:n})),s=e.map(e=>lA({inputs:{input:e},backend:n})),o=hA(r,t,n),i=hA(s,t,n),a=v$({inputs:{real:o,imag:i},backend:n});return r.forEach(e=>n.disposeIntermediateTensorInfo(e)),s.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),a}let s=n.shouldExecuteOnCPU(e);if("string"===r&&(s=!0),s){const s=e.map(e=>{const r=Sp(e.shape.slice(t));return P$({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})}),o=s.map(e=>({vals:n.readSync(e.dataId),shape:e.shape})),i=ow(s.map(e=>e.shape),1),a=yN(o,i,r,1===s[0].shape[0]),u=ow(e.map(e=>e.shape),t),l=n.makeTensorInfo(u,r,a);return s.forEach(e=>n.disposeIntermediateTensorInfo(e)),l}if(e.length>ef().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const r=Math.floor(e.length/2),s=hA(e.slice(0,r),t,n),o=hA(e.slice(r),t,n),i=hA([s,o],t,n);return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),i}if(ef().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){const s=new aA(e.map(e=>e.shape),t);return n.runWebGLProgram(s,e,r)}const{tensors2D:o,outShape:i}=function(e,t,n){const r=ow(e.map(e=>e.shape),t);return{tensors2D:e.map(e=>P$({inputs:{x:e},attrs:{shape:[-1,Sp(e.shape.slice(t))]},backend:n})),outShape:r}}(e,t,n),a=new iA(o.map(e=>e.shape)),u=n.runWebGLProgram(a,o,r);o.forEach(e=>n.disposeIntermediateTensorInfo(e));const l=P$({inputs:{x:u},attrs:{shape:i},backend:n});return n.disposeIntermediateTensorInfo(u),l}function dA(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,o=Ap(s,t[0].shape)[0],i=ow(t.map(e=>e.shape),o);if(0===Sp(i))return n.makeTensorInfo(i,t[0].dtype,[]);const a=t.filter(e=>Sp(e.shape)>0);return 1===a.length?x$({inputs:{x:a[0]},backend:n}):(sw(a.map(e=>e.shape),o),hA(a,o,n))}const pA={kernelName:Tf,backendName:"webgl",kernelFunc:dA};class fA{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,i=e.padInfo.left,a=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,c=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,x=m?3:1;let b="",v="";n&&(b=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,v="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${b}\n\n      const ivec2 strides = ivec2(${a}, ${u});\n      const ivec2 pads = ivec2(${o}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${x}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${l};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${v}\n        setOutput(result);\n      }\n    `}}class mA{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,s=e.strideDepth,o=e.strideHeight,i=e.strideWidth,a=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,c=e.filterDepth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${s}, ${o}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${a};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${l};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class gA{constructor(e,t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e;const{filterWidth:r,inChannels:s,strideWidth:o,strideHeight:i,padInfo:a,outWidth:u,dilationWidth:l,dilationHeight:c,dataFormat:h}=n,{left:d,top:p}=a,f=s*r,m=FT(),g="channelsLast"===h,y=g?0:1,x=g?1:2;let b="";for(let v=0;v<=1;v++)for(let n=0;n<=1;n++)b+=`\n          blockIndex = rc.y + ${n};\n          pos = rc.x + ${v};\n\n          if(blockIndex < ${e[1]} && pos < ${e[0]}) {\n            offsetY = int(blockIndex / (${u})) * ${i} - ${p};\n            d0 = offsetY + ${c} * (pos / ${f});\n\n            if(d0 < ${t[y]} && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ${u}.) * ${o}. - ${d}.);\n              d1 = offsetX + ${l} * (int(mod(float(pos), ${f}.) / ${s}.));\n\n              if(d1 < ${t[x]} && d1 >= 0) {\n\n                ch = int(mod(float(pos), ${s}.));\n\n                if (${g}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*v+n}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*v+n}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${b}\n\n        ${m.output} = result;\n      }\n    `}}function yA({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const u=e.shape,l=r.texData.get(e.dataId),c="channelsLast"===n.dataFormat;let h;const d=[],p=u[2]%2!=0&&!!l.isPacked;if((1!=u[0]*u[1]*u[2]&&1!==n.outChannels||!(n.inChannels>1e3))&&ef().getBool("WEBGL_LAZILY_UNPACK")&&ef().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&p){const p={dataId:e.dataId,shape:[1,c?u[0]*u[1]*(u[2]+1):u[0]*u[2]*(u[3]+1),n.inChannels],dtype:e.dtype},f=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,Cp(ST(l.shape,p.shape),()=>`packed reshape ${l.shape} to ${p.shape} isn't free`);const m=P$({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});d.push(m);const g=K$({a:p,b:m,backend:r,transposeA:!1,transposeB:!1,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),y=r.texData.get(g.dataId);Cp(y.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=f,y.shape=n.outShape,h=x$({inputs:{x:g},backend:r}),h.shape=n.outShape,d.push(g)}else{const l=P$({inputs:{x:e},backend:r,attrs:{shape:[1,c?u[0]*u[1]*u[2]:u[0]*u[2]*u[3],n.inChannels]}}),p=P$({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),f=K$({a:l,b:p,transposeA:!1,transposeB:!1,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i});h=P$({inputs:{x:f},backend:r,attrs:{shape:n.outShape}}),d.push(l),d.push(p),d.push(f)}for(const f of d)r.disposeIntermediateTensorInfo(f);return h}function xA({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:u,filterHeight:l,inChannels:c,outWidth:h,outHeight:d,dataFormat:p}=n,f="channelsLast"===p,m=u*l*c,g=d*h,y=[m,g],x=[],b=P$({inputs:{x:e},backend:r,attrs:{shape:e.shape.slice(1)}}),v=P$({inputs:{x:t},backend:r,attrs:{shape:[1,m,Sp(t.shape)/m]}});x.push(b),x.push(v);const w=new gA(y,b.shape,n),C=r.runWebGLProgram(w,[b],"float32"),_=P$({inputs:{x:C},backend:r,attrs:{shape:[1,y[0],y[1]]}});x.push(C),x.push(_);const k=null!=s,E=null!=o,S="leakyrelu"===a,T=a?$$(a,!0):null,I=new R$(_.shape,v.shape,[1,g,n.outChannels],!0,!1,k,T,E,S),N=[_,v];if(s&&N.push(s),E&&N.push(o),S){const e=r.makeTensorInfo([],"float32",Xg(i,"float32"));N.push(e),x.push(e)}const $=r.runWebGLProgram(I,N,"float32"),R=P$({inputs:{x:$},backend:r,attrs:{shape:f?[1,d,h,n.outChannels]:[1,n.outChannels,d,h]}});x.push($);for(const A of x)r.disposeIntermediateTensorInfo(A);return R}const bA={kernelName:If,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o}=t,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=r,h=xw(u),d=lw(s.shape,o.shape,i,l,a,c,!1,h);let p;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(ef().getBool("WEBGL_CONV_IM2COL")&&1===s.shape[0])p=xA({x:s,filter:o,convInfo:d,backend:n});else{const e=new fA(d);p=n.runWebGLProgram(e,[s,o],"float32")}else p=yA({x:s,filter:o,convInfo:d,backend:n});const f=P$({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class vA{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${e.strideHeight} - ${e.padInfo.top};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${e.strideWidth} - ${e.padInfo.left};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${"channelsLast"===e.dataFormat}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class wA{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r="channelsLast"===e.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${r?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${r?1:2}], coords[${r?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${r}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class CA{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${e.strideDepth} - ${e.padInfo.front};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${e.strideHeight} - ${e.padInfo.top};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${e.strideWidth} - ${e.padInfo.left};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class _A{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${t-1-e.padInfo.front}, ${n-1-e.padInfo.top}, ${r-1-e.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${e.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const kA={kernelName:Nf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:o}=t,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:c}=r,h=xw(u),d=lw(s.shape,c,i,1,a,l,!1,h),p=new vA(d);return n.runWebGLProgram(p,[s,o],"float32")}},EA={kernelName:$f,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:o}=t,{inputShape:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:c}=r,h=xw(l),d=lw(i,o.shape,a,1,u,c,!1,h),p=new wA(d);return n.runWebGLProgram(p,[s,o],"float32")}},SA={kernelName:Rf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o}=t,{strides:i,pad:a,dilations:u}=r,l=cw(s.shape,o.shape,i,u,a),c=new mA(l);return n.runWebGLProgram(c,[s,o],"float32")}},TA={kernelName:"Conv3DBackpropFilterV2",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:o}=t,{strides:i,pad:a,filterShape:u}=r,l=cw(s.shape,u,i,1,a),c=new CA(l);return n.runWebGLProgram(c,[s,o],"float32")}},IA={kernelName:"Conv3DBackpropInputV2",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:o}=t,{pad:i,strides:a,inputShape:u}=r,l=cw(u,o.shape,a,1,i),c=new _A(l);return n.runWebGLProgram(c,[s,o],"float32")}},NA={kernelName:"Cos",backendName:"webgl",kernelFunc:I$({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"})},$A=I$({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),RA={kernelName:Af,backendName:"webgl",kernelFunc:$A};class AA{constructor(e,t,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,i,a,u]=e,[l]=t,[c,h]=n;this.outputShape=[l,c,h,u];const d="bilinear"===r?1:0,[p,f]=[i-1+".0",a-1+".0"],[m,g,y]=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[x,b,v]=h>1?[""+(a-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${x});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${o}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${b};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${s}));\n          return;\n        }\n        float in_x = ${v};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${s}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const OA={kernelName:Ff,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:o,boxInd:i}=t,{cropSize:a,method:u,extrapolationValue:l}=r,c=new AA(s.shape,o.shape,a,u,l);return n.runWebGLProgram(c,[s,o,i],"float32")}};class FA{constructor(e,t,n){this.variableNames=["x"],this.outputShape=e;const r=e.length,s=t?"0.0":`getX(${DA(r,"coords")})`,o=e[e.length-1];let i="",a="";t?(i=n?"end != "+(o-1):"end != 0",a=n?"end + 1":"end - 1"):(i=n?`end + pow2 < ${o}`:"end >= pow2",a=n?"end + pow2":"end - pow2"),this.userCode=`\n      uniform float index;\n      void main() {\n        ${aI(r)} coords = getOutputCoords();\n        int end = ${PA(r,"coords")};\n        float val = ${s};\n        int pow2 = int(pow(2.0, index));\n        if (${i}) {\n          int idx = ${a};\n          ${PA(r,"coords")} = idx;\n          val += getX(${DA(r,"coords")});\n        }\n        setOutput(val);\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.index&&(this.index=t.getUniformLocation(n,"index")),t.gl.uniform1f(this.index,e)}}}function DA(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}function PA(e,t){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative sum for rank ${e} is not yet supported`)}const MA={kernelName:Of,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,exclusive:i,reverse:a}=r,u=s.shape.length,l=gv([o],u);let c=s;null!=l&&(c=G$({inputs:{x:s},backend:n,attrs:{perm:l}}));const h=xv(1,u)[0];if(h!==u-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${s.shape.length-1} but got axis=${o}`);const d=c.shape[h];let p=x$({inputs:{x:c},backend:n});for(let f=0;f<=Math.ceil(Math.log2(d))-1;f++){const e=new FA(c.shape,!1,a),t=e.getCustomSetupFunc(f),r=p;p=n.runWebGLProgram(e,[p],p.dtype,t),n.disposeIntermediateTensorInfo(r)}if(i){const e=new FA(c.shape,i,a),t=p;p=n.runWebGLProgram(e,[p],p.dtype),n.disposeIntermediateTensorInfo(t)}if(null!=l){const e=G$({inputs:{x:p},backend:n,attrs:{perm:yv(l)}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(c),e}return p}},LA={kernelName:Df,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:o}=t,{size:i,binaryOutput:a}=r;if(1===s.shape.length){const e=n.readSync(s.dataId),t=n.readSync(o.dataId),r=fN(e,t,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,r)}if(2===s.shape.length){const e=n.bufferSync(s),t=n.bufferSync(o),r=mN(e,t,i,a);return n.makeTensorInfo(r.shape,o.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class BA{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const VA={kernelName:Pf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:o,dataFormat:i}=r;Cp(o>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${o}`);const a=s.shape[0],u=("NHWC"===i?s.shape[1]:s.shape[2])*o,l=("NHWC"===i?s.shape[2]:s.shape[3])*o,c=("NHWC"===i?s.shape[3]:s.shape[1])/(o*o),h=new BA("NHWC"===i?[a,u,l,c]:[a,c,u,l],o,i);return n.runWebGLProgram(h,[s],s.dtype)}};class UA{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.inHeight,i=e.inWidth,a=e.padInfo.top,u=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,h=e.dilationHeight,d=e.dilationWidth,p=e.filterHeight,f=e.filterWidth,m=e.outChannels/e.inChannels;let g="",y="";n&&(g=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,y="result = activation(result);");const x=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${g}\n\n      const ivec2 strides = ivec2(${l}, ${c});\n      const ivec2 pads = ivec2(${a}, ${u});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${m};\n        int q = d2 - d1 * ${m};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${p}; wR++) {\n          int xR = xRCorner + wR * ${h};\n\n          if (xR < 0 || xR >= ${o}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${f}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${i}) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${x}\n        ${y}\n        setOutput(result);\n      }\n    `}}class zA{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.outShape;const o=e.outChannels/e.inChannels,i=e.inHeight,a=e.inWidth,u=e.padInfo.top,l=e.padInfo.left,c=e.strideHeight,h=e.strideWidth,d=e.dilationHeight,p=e.dilationWidth,f=e.filterHeight,m=e.filterWidth,g=m;let y="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let w=0;w<m;w++)y+=`\n          vec4 xTexelC${2*w};\n          int xTexelC${2*w}Ready;\n          vec4 xC${w};`;for(let w=0;w<f;w++){for(let e=0;e<m;e++)y+=`\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xC${e} = vec4(0.0);`;y+=`\n        xR = xRCorner + ${w*d};\n        if (xR >=0 && xR < ${i}) {\n      `;for(let e=0;e<(g+1)/2;e++){const t=2*e,n=t*p;if(y+=`\n          xC = xCCorner + ${n};\n          `,1===h){if(t<m&&(l%2==1?(y+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < ${a} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ${a}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n              `,y+=1===p&&n>0?`\n                xC${t} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < ${a}) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ${a}) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${t} = vec4(previous.zw, xTexelC${n}.xy);\n                  } else {\n                    xC${t} = vec4(0.0, 0.0, xTexelC${n}.xy);\n                  }\n                  `):y+=`\n                if (xC >= 0 && xC < ${a} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ${a}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                xC${t} = xTexelC${n};\n                `,n+1<m)){const e=l%2==0?wp(p):p;p%2==0&&l%2==1||p%2!=0&&l%2!=1?(y+=`\n                  xCOffset = xC + ${l%2} + ${e};\n\n                  if (xCOffset >= 0 && xCOffset < ${a} && xTexelC${n+2}Ready == 0) {\n                    xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= ${a}) {\n                      xTexelC${n+2}.zw = vec2(0.0);\n                    }\n                    xTexelC${n+2}Ready = 1;\n                  }\n                  `,p>1&&(y+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < ${a} && xTexelC${n}Ready == 0) {\n                      xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                      xTexelC${n}Ready = 1;\n                    }\n                    `),y+=`\n                  xC${t+1} = vec4(xTexelC${n}.zw, xTexelC${n+2}.xy);\n                  `):y+=1===e?`\n                    xC${t+1} = xTexelC${n};\n                    `:`\n                    xCOffset = xC + ${e};\n\n                    if (xCOffset >= 0 && xCOffset < ${a} && xTexelC${n+2}Ready == 0) {\n                      xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= ${a}) {\n                        xTexelC${n+2}.zw = vec2(0.0);\n                      }\n                      xTexelC${n+2}Ready = 1;\n                    }\n\n                    xC${t+1} = xTexelC${n+2};\n                    `}}else n<m&&(l%2==1?(y+=`\n                xCOffset = xC + 1 - ${h};\n                if(xCOffset >= 0 && xCOffset < ${a} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= ${a}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ${a} && xTexelC${n+2}Ready == 0) {\n                  xTexelC${n+2} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= ${a}) {\n                    xTexelC${n+2}.zw = vec2(0.0);\n                  }\n                  xTexelC${n+2}Ready = 1;\n                }\n\n                xC${t} = vec4(xTexelC${n}.zw, xTexelC${n+2}.zw);\n              `,n+1<m&&(y+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + ${h};\n                  if(xCOffset >= 0 && xCOffset < ${a}) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${t+1} = vec4(xTexelC${n+2}.xy, final.xy);\n                `)):(y+=`\n                if(xC >= 0 && xC < ${a} && xTexelC${n}Ready == 0) {\n                  xTexelC${n} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= ${a}) {\n                    xTexelC${n}.zw = vec2(0.0);\n                  }\n                  xTexelC${n}Ready = 1;\n                }\n\n                xCOffset = xC + ${h};\n                if(xCOffset >= 0 && xCOffset < ${a} && xTexelC${n+2}Ready == 0) {\n                  xTexelC${n+2} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= ${a}) {\n                    xTexelC${n+2}.zw = vec2(0.);\n                  }\n                  xTexelC${n+2}Ready = 1;\n                }\n\n                xC${t} = vec4(\n                  xTexelC${n}.xy, xTexelC${n+2}.xy);\n              `,n+1<m&&(y+=`\n                  xC${t+1} = vec4(xTexelC${n}.zw, xTexelC${n+2}.zw);\n                `)));t<m&&(y+=`\n            wTexel = getW(${w}, ${n}, d1, q);\n            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);\n          `,n+1<m&&(y+=`\n              wTexel = getW(${w}, ${n+1}, d1, q);\n              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}y+="\n        }\n      "}let x="",b="";n&&(x=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,b="result = activation(result);");const v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${x}\n\n      const ivec2 strides = ivec2(${c}, ${h});\n      const ivec2 pads = ivec2(${u}, ${l});\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${y}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${v}\n        ${b}\n        setOutput(result);\n      }\n    `}}const WA={kernelName:Mf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o}=t,{strides:i,pad:a,dilations:u,dimRoundingMode:l}=r;let c=u;null==c&&(c=[1,1]),Cp(yw(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const h=lw(s.shape,o.shape,i,c,a,l,!0);let d;return d=ef().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels==1?new zA(h):new UA(h),n.runWebGLProgram(d,[s,o],"float32")}};class jA{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${e.outChannels/e.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${e.strideHeight} - ${e.padInfo.top};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${e.strideWidth} - ${e.padInfo.left};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class HA{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${r}; dm++) {\n              int d2 = d1 * ${r} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const GA={kernelName:Lf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:o}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,filterShape:c}=r,h=lw(s.shape,c,i,a,u,l,!0),d=new jA(h);return n.runWebGLProgram(d,[s,o],"float32")}},qA={kernelName:Bf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:o}=t,{strides:i,dilations:a,pad:u,dimRoundingMode:l,inputShape:c}=r,h=lw(c,o.shape,i,a,u,l,!0),d=new HA(h);return n.runWebGLProgram(d,[s,o],"float32")}};class KA{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const XA={kernelName:"Diag",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],o=Sp(r.shape),i=P$({inputs:{x:r},backend:n,attrs:{shape:[o]}}),a=new KA(o),u=n.runWebGLProgram(a,[i],i.dtype),l=P$({inputs:{x:u},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),l}};class YA{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:s,strideWidth:o,filterHeight:i,filterWidth:a,dilationHeight:u,dilationWidth:l}=e,{top:c,left:h}=r;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${o});\n      const ivec2 pads = ivec2(${c}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${a}; w++) {\n              int wIn = wBeg + w * ${l};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const QA={kernelName:Vf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o}=t,{strides:i,pad:a,dilations:u}=r,l=iw(s.shape,o.shape,i,a,"NHWC",u);let c;const h=new YA(l);c=n.runWebGLProgram(h,[s,o],"float32");const d=P$({inputs:{x:c},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(c),d}},ZA={kernelName:zf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,o=t,{allDims:i,summedDims:a,idDims:u}=oC(s,o.length);aC(i.length,u,o);const{path:l,steps:c}=uC(a,u),h=c.length;let d=null,p=i.length;const f=[];for(let m=0;m<h;++m){for(const e of c[m]){const{permutationIndices:t,expandDims:r}=iC(p,u[e]);let s;lC(t)?s=o[e]:(s=G$({inputs:{x:o[e]},backend:n,attrs:{perm:t}}),f.push(s));const i=s.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);Tp(s.shape,i)||(s=P$({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===d?d=s:(d=F$({inputs:{a:s,b:d},backend:n}),f.push(d))}m<h-1&&(l[m]>=0&&(d=j$({inputs:{x:d},backend:n,attrs:{axis:l[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}},JA={kernelName:"Elu",backendName:"webgl",kernelFunc:I$({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"})},eO={kernelName:"EluGrad",backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:s}=t,o=ef().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new y$("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new g$("return (b >= 1.0) ? a : a * (b + 1.0);",r.shape,s.shape);return n.runWebGLProgram(o,[r,s],r.dtype)}},tO=N$({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:xN}),nO={kernelName:Wf,backendName:"webgl",kernelFunc:tO},rO={kernelName:"Erf",backendName:"webgl",kernelFunc:I$({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${zw};\n  float a1 = ${Ww};\n  float a2 = ${jw};\n  float a3 = ${Hw};\n  float a4 = ${Gw};\n  float a5 = ${qw};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`})},sO="return exp(x);",oO=I$({opSnippet:sO,packedOpSnippet:sO,cpuKernelImpl:bN}),iO={kernelName:jf,backendName:"webgl",kernelFunc:oO};function aO(e){const{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:o}=t,i=o.shape.length,a=o.shape.slice();let u=s;return s<0&&(Cp(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+s+1),a.splice(u,0,1),P$({inputs:{x:o},backend:r,attrs:{shape:a}})}const uO={kernelName:Hf,backendName:"webgl",kernelFunc:aO},lO="return exp(x) - 1.0;",cO=I$({opSnippet:lO,packedOpSnippet:lO,cpuKernelImpl:vN}),hO={kernelName:Gf,backendName:"webgl",kernelFunc:cO};class dO{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=n?`${r}.0`:"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);i="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${o};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function pO(e,t,n){const r=n.texData.get(e.dataId),s=Sp(e.shape),o=e.shape[e.shape.length-1],i=P$({inputs:{x:e},backend:n,attrs:{shape:[s/o,o]}}),a=i.shape,u=new dO("real",a,t),l=new dO("imag",a,t),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:a},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:a}],h=n.runWebGLProgram(u,c,"float32"),d=n.runWebGLProgram(l,c,"float32"),p=v$({inputs:{real:h,imag:d},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d);const f=P$({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(p),f}const fO={kernelName:"FFT",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return pO(r,!1,n)}};class mO{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}function gO(e){const{backend:t,attrs:n}=e,{shape:r,value:s}=n;let{dtype:o}=n;if(o=o||Vp(s),"string"===o){const e=Dp(o,Sp(r));return e.fill(s),t.makeTensorInfo(r,o,e)}{const e=new mO(r,s),n=e.getCustomSetupFunc(s);return t.runWebGLProgram(e,[],o,n)}}const yO={kernelName:qf,backendName:"webgl",kernelFunc:gO};class xO{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const bO={kernelName:Kf,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,s=new xO(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}},vO="return floor(x);",wO=I$({opSnippet:vO,packedOpSnippet:vO,cpuKernelImpl:wN}),CO={kernelName:Xf,backendName:"webgl",kernelFunc:wO},_O=N$({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),kO={kernelName:Yf,backendName:"webgl",kernelFunc:_O};class EO{constructor(e){this.variableNames=["A"];const t=FT(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class SO{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=FT(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const TO={kernelName:_g,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:s}=t;const{numChannels:o}=r,i="undefined"!=typeof HTMLVideoElement&&s instanceof HTMLVideoElement,a="undefined"!=typeof HTMLImageElement&&s instanceof HTMLImageElement,[u,l]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[l,u],h=[l,u,o];(a||i)&&(null==IO&&(IO=document.createElement("canvas").getContext("2d")),IO.canvas.width=u,IO.canvas.height=l,IO.drawImage(s,0,0,u,l),s=IO.canvas);const d=n.makeTensorInfo(c,"int32");n.texData.get(d.dataId).usage=iT.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),s);const p=ef().getBool("WEBGL_PACK")?new SO(h):new EO(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let IO;const NO={kernelName:Sg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r,m=xw(c),g=lw(s.shape,o.shape,u,h,l,d,!1,m);let y;const x=[];if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(ef().getBool("WEBGL_CONV_IM2COL")&&1===s.shape[0])y=xA({x:s,filter:o,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else{const e=null!=i,t=null!=a,r="leakyrelu"===p,u=p?$$(p,!1):null,l=new fA(g,e,u,t,r),c=[s,o];if(i&&c.push(i),a&&c.push(a),r){const e=n.makeTensorInfo([],"float32",Xg(f,"float32"));c.push(e),x.push(e)}y=n.runWebGLProgram(l,c,"float32")}else y=yA({x:s,filter:o,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:a,leakyreluAlpha:f});const b=P$({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return x.push(y),x.forEach(e=>n.disposeIntermediateTensorInfo(e)),b}},$O={kernelName:Tg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:o,bias:i,preluActivationWeights:a}=t,{strides:u,pad:l,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=r,f=[];let m=c;null==m&&(m=[1,1]),Cp(yw(u,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${m}'`);const g=lw(s.shape,o.shape,u,m,l,h,!0),y=ef().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,x=d?$$(d,y):null,b=[s,o],v=null!=i,w=null!=a,C="leakyrelu"===d;if(v&&b.push(i),w&&b.push(a),C){const e=n.makeTensorInfo([],"float32",Xg(p,"float32"));b.push(e),f.push(e)}let _;_=y?new zA(g,v,x,w,C):new UA(g,v,x,w,C);const k=n.runWebGLProgram(_,b,"float32");return f.forEach(e=>n.disposeIntermediateTensorInfo(e)),k}};class RO{constructor(e,t,n){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=n;const r=aI(t.length),s=aI(n.length);this.userCode=`\n        ${r} strides = ${r}(${this.strides});\n         void main() {\n          ${s} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${this.sliceDim>1?"strides[j]":"strides"};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}}const AO={kernelName:Jf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,o=s.shape,i=o[o.length-1],a=Sp(r.shape),[u,l,c,h]=Pw(r,s),d=P$({inputs:{x:s},backend:n,attrs:{shape:[l,i]}}),p=P$({inputs:{x:r},backend:n,attrs:{shape:[Sp(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const e=n.readSync(s.dataId),t=n.bufferSync(r),o=CN(e,t,r.dtype,l,i,c,h,r.shape,a);return n.makeTensorInfo(u,r.dtype,o.values)}const f=new RO(i,h,[l,c]),m=n.runWebGLProgram(f,[p,d],p.dtype),g=P$({inputs:{x:m},backend:n,attrs:{shape:u}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class OO{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=aI(this.rank),r=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<e.length;s++)r.push(2===s?"int(getIndices(resRC.x, resRC.z))":`${n[s]}`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        setOutput(getA(${r}));\n      }\n    `}}const FO={kernelName:Zf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:o}=t,{axis:i,batchDims:a}=r,u=fC(s,o,Ap(i,s.shape)[0],a),l=Sp(o.shape),c=[],h=P$({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),d=P$({inputs:{x:o},backend:n,attrs:{shape:[u.batchSize,l/u.batchSize]}});c.push(h),c.push(d);const p=[u.batchSize,u.outerSize,l/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([s,o])||"string"===s.dtype){const e=n.bufferSync(d),t=n.bufferSync(h),r=_N(t,e,p);return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}const f=new OO(h.shape,p),m=n.runWebGLProgram(f,[h,d],h.dtype);c.push(m);const g=P$({inputs:{x:m},backend:n,attrs:{shape:u.outputShape}});return c.forEach(e=>n.disposeIntermediateTensorInfo(e)),g}},DO=N$({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:kN,dtype:"bool"}),PO={kernelName:em,backendName:"webgl",kernelFunc:DO},MO=N$({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:EN}),LO={kernelName:tm,backendName:"webgl",kernelFunc:MO},BO={kernelName:rm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return pO(r,!0,n)}},VO={kernelName:"IsFinite",backendName:"webgl",kernelFunc:I$({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"})},UO={kernelName:"IsInf",backendName:"webgl",kernelFunc:I$({opSnippet:"return float(isinf(x));",dtype:"bool"})},zO=I$({opSnippet:"return float(isnan(x));",dtype:"bool"}),WO={kernelName:om,backendName:"webgl",kernelFunc:zO},jO=N$({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:SN,dtype:"bool"}),HO={kernelName:am,backendName:"webgl",kernelFunc:jO},GO=N$({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:TN,dtype:"bool"}),qO={kernelName:um,backendName:"webgl",kernelFunc:GO},KO={kernelName:lm,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:o}=n,i=IN(r,s,o);return t.makeTensorInfo([i.length],"float32",i)}},XO=I$({opSnippet:"if (x < 0.0) return NAN;\n  return log(x);",packedOpSnippet:"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:NN}),YO={kernelName:cm,backendName:"webgl",kernelFunc:XO},QO=I$({opSnippet:"return log(1.0 + x);"}),ZO={kernelName:hm,backendName:"webgl",kernelFunc:QO},JO=N$({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),eF={kernelName:dm,backendName:"webgl",kernelFunc:JO},tF=I$({opSnippet:"return float(!(x >= 1.0));"}),nF={kernelName:pm,backendName:"webgl",kernelFunc:tF},rF=N$({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),sF={kernelName:fm,backendName:"webgl",kernelFunc:rF};class oF{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[];const o=t,i=e[3]-1;let a;this.outputShape=e;const u=`float(${n}) + float(${r}) * sum`;a=.5===s?`inversesqrt(${u})`:1===s?`1.0/(${u})`:`exp(log(${u}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${o}; j <= ${o}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${a};\n        setOutput(val);\n      }\n    `}}class iF{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,i=e[3]-1;let a;this.outputShape=e;const u=`float(${n}) + float(${r}) * sum`;a=.5===s?`inversesqrt(${u})`:1===s?`1.0/(${u})`:`exp(log(${u}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${o};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${o}; j <= ${o}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${a};\n        setOutput(result);\n      }\n    `}}const aF={kernelName:"LRN",backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:o,bias:i,alpha:a,beta:u}=r,l=ef().getBool("WEBGL_PACK_NORMALIZATION")?new iF(s.shape,o,i,a,u):new oF(s.shape,o,i,a,u);return n.runWebGLProgram(l,[s],s.dtype)}};class uF{constructor(e,t,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${s})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${s});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const lF={kernelName:"LRNGrad",backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s,y:o,dy:i}=t,{depthRadius:a,bias:u,alpha:l,beta:c}=r,h=new uF(s.shape,a,u,l,c);return n.runWebGLProgram(h,[s,o,i],s.dtype)}};function cF(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:o,keepDims:i}=r,a=s.shape.length,u=Ap(o,s.shape);let l=u;const c=gv(l,a),h=null!=c,d=n.shouldExecuteOnCPU([s]);let p=s;if(h){if(d){const e=n.texData.get(p.dataId).values,t=new Array(a);for(let n=0;n<t.length;n++)t[n]=s.shape[c[n]];const r=QN(e,s.shape,s.dtype,c,t);p=n.makeTensorInfo(t,s.dtype),n.texData.get(p.dataId).values=r}else p=W$(s,c,n);l=xv(l.length,a)}mv("max",l,a);const[f,m]=pv(p.shape,l);let g,y=f;if(i&&(y=fv(f,u)),d){const e=n.texData.get(p.dataId),t=$N(e.values,Sp(m),y,s.dtype);g=n.makeTensorInfo(y,s.dtype),n.texData.get(g.dataId).values=t}else g=function(e,t,n,r){const s=Sp(t),o=P$({inputs:{x:e},attrs:{shape:[Sp(e.shape)/s,s]},backend:r}),i=V$(o,e.dtype,"max",r),a=P$({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(i),a}(p,m,y,n);return h&&n.disposeIntermediateTensorInfo(p),g}const hF={kernelName:"Max",backendName:"webgl",kernelFunc:cF},dF=N$({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:RN}),pF={kernelName:mm,backendName:"webgl",kernelFunc:dF},fF={kernelName:gm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;AT(s,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:u}=r;Cp(yw(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const l=aw(s.shape,o,i,1,a,u);if(1===l.filterWidth&&1===l.filterHeight&&Tp(l.inShape,l.outShape))return x$({inputs:{x:s},backend:n});const c=new TR(l,"max",!1);return n.runWebGLProgram(c,[s],s.dtype)}},mF={kernelName:ym,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:o,strides:i,pad:a,dataFormat:u,dimRoundingMode:l}=r,c=uw(s.shape,o,i,[1,1,1],a,l,u),h=new IR(c,"max",!1);return n.runWebGLProgram(h,[s],s.dtype)}};class gF{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.effectiveFilterHeight,n=e.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${t-1-e.padInfo.top}, ${n-1-e.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t};\n          wR += ${e.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${t*n-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${n} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class yF{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.effectiveFilterDepth,n=e.effectiveFilterHeight,r=e.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${t-1-e.padInfo.front}, ${n-1-e.padInfo.top}, ${r-1-e.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${t};\n           wD += ${e.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${e.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${n};\n              wR += ${e.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${e.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${r};\n                wC += ${e.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${e.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${t*n*r-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${n} * ${r} +\n                  wR * ${r} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const xF={kernelName:"MaxPool3DGrad",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o}=t,i=o,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=r,h=uw(i.shape,a,u,[1,1,1],l,c),d=new IR(h,"max",!0),p=n.runWebGLProgram(d,[i],i.dtype),f=new yF(h),m=n.runWebGLProgram(f,[s,p],i.dtype);return n.disposeIntermediateTensorInfo(p),m}},bF={kernelName:"MaxPoolGrad",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:o,output:i}=t,a=o;AT([o,i],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:h}=r,d=aw(a.shape,u,l,1,c,h),p=new TR(d,"max",!0),f=n.runWebGLProgram(p,[a],a.dtype),m=new gF(d),g=n.runWebGLProgram(m,[s,f],a.dtype);return n.disposeIntermediateTensorInfo(f),g}},vF={kernelName:xm,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=t,u=n;Cp(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const l=[1,1];Cp(yw(o,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const c=aw(r.shape,s,o,l,i),[h,d]=function(e,t,n,r){let s=new TR(n,"max",!1);const o=r.runWebGLProgram(s,[e],"float32");return s=new TR(n,"max",!0,!0,t),[o,r.runWebGLProgram(s,[e],"float32")]}(r,a,c,u);return[h,d]}},wF={kernelName:bm,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{keepDims:s,axis:o}=t,i=n,a=r.shape.length,u=Ap(o,r.shape);let l=u;const c=gv(l,a),h=null!=c,d=i.shouldExecuteOnCPU([r]),p=[];let f=r;if(h){if(d){const e=i.texData.get(f.dataId).values,t=new Array(a);for(let s=0;s<t.length;s++)t[s]=r.shape[c[s]];const n=QN(e,r.shape,r.dtype,c,t);f=i.makeTensorInfo(t,r.dtype),i.texData.get(f.dataId).values=n}else f=W$(r,c,i);p.push(f),l=xv(l.length,a)}mv("sum",l,a);const[m,g]=pv(f.shape,l);let y=m;s&&(y=fv(m,u));const x=function(e,t,n,r){const s=Sp(t),o=P$({inputs:{x:e},attrs:{shape:[Sp(e.shape)/s,s]},backend:r}),i=V$(o,"float32","mean",r),a=P$({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(i),a}(f,g,y,i);for(const b of p)i.disposeIntermediateTensorInfo(b);return x}},CF={kernelName:"Min",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:i}=r,a=s.shape.length,u=Ap(o,s.shape);let l=u;const c=gv(l,a);let h=s;null!=c&&(h=G$({inputs:{x:s},backend:n,attrs:{perm:c}}),l=xv(l.length,s.shape.length)),mv("min",l,a);const[d,p]=pv(h.shape,l),f=P$({inputs:{x:h},backend:n,attrs:{shape:[-1,Sp(p)]}}),m=V$(f,f.dtype,"min",n);let g;return g=P$(i?{inputs:{x:m},backend:n,attrs:{shape:fv(d,u)}}:{inputs:{x:m},backend:n,attrs:{shape:d}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(h),g}},_F=N$({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:AN}),kF={kernelName:vm,backendName:"webgl",kernelFunc:_F};class EF{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,s=aI(r),o=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),a=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),u="reflect"===n?0:1;this.userCode=1!==r?`\n      ${s} start = ${s}(${o});\n      ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${u};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};\n          }\n        }\n        ${s} coords = outC - start;\n        setOutput(getX(${a}));\n      }\n    `:`\n        int start = ${o};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${u};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${u};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class SF{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,s=aI(r),o=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),a=e$("rc",r),u=e$("source",r),l=`${a[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${u.slice(-2).join()})`,h="reflect"===n?0:1;let d="";if(1===r){const e=`\n        ${s} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;d=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${a[r-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n      `}else{const e=`\n        ${s} source = rc;\n        ${s} lt = ${s}(lessThan(source, start));\n        ${s} gte = ${s}(greaterThanEqual(source, end));\n        ${s} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;d=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${u.join()}), ${c});\n        ${a[r-1]} += 1;\n        if(${l}) {\n          ${e}\n          result[1] = getChannel(getX(${u.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${a[r-2]} += 1;\n        if(${a[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${u.join()}), ${c});\n          ${a[r-1]} += 1;\n          if(${l}) {\n            ${e}\n            result[3] = getChannel(getX(${u.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${s} start = ${s}(${o});\n      const ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}const TF={kernelName:wm,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{paddings:s,mode:o}=n,i=ef().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new SF(r.shape,s,o):new EF(r.shape,s,o);return t.runWebGLProgram(i,[r],r.dtype)}},IF={kernelName:"Mod",backendName:"webgl",kernelFunc:N$({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"})};class NF{constructor(e,t,n){this.variableNames=["probs"],this.outputShape=[e,n],this.userCode=`\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.seedLoc&&(this.seedLoc=t.getUniformLocation(n,"seed")),t.gl.uniform1f(this.seedLoc,e)}}}const $F=N$({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),RF={kernelName:Uf,backendName:"webgl",kernelFunc:$F},AF="return a - b;",OF=N$({opSnippet:AF,packedOpSnippet:AF,supportsComplex:!0,cpuKernelImpl:KN}),FF={kernelName:pg,backendName:"webgl",kernelFunc:OF};function DF(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:o}=r,i=Ap([o],s.shape),a=cF({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),u=fv(a.shape,i),l=P$({inputs:{x:a},backend:n,attrs:{shape:u}}),c=OF({inputs:{a:s,b:l},backend:n}),h=oO({inputs:{x:c},backend:n}),d=j$({inputs:{x:h},backend:n,attrs:{axis:i,keepDims:!1}}),p=P$({inputs:{x:d},backend:n,attrs:{shape:u}}),f=$F({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const PF={kernelName:ng,backendName:"webgl",kernelFunc:DF},MF={kernelName:Cm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:o,seed:i,normalized:a}=r,u=a?s:DF({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),l=new NF(u.shape[0],u.shape[1],o),c=l.getCustomSetupFunc(i),h=n.runWebGLProgram(l,[u],"int32",c);return a||n.disposeIntermediateTensorInfo(u),h}},LF="return -x;",BF={kernelName:"Neg",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,s]=FN(e.values,r.shape,r.dtype);return n.makeTensorInfo(s,r.dtype,t)}let s;return s=ef().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new c$(r.shape,LF):new a$(r.shape,LF),n.runWebGLProgram(s,[r],r.dtype)}},VF=Db,UF={kernelName:Em,backendName:"webgl",kernelFunc:function(e){Kw("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:o}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=r,l=n.readSync(s.dataId),c=n.readSync(o.dataId),{selectedIndices:h}=VF(l,c,i,a,u);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},zF=Pb,WF={kernelName:Sm,backendName:"webgl",kernelFunc:function(e){Kw("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:o}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:l}=r,c=n.readSync(s.dataId),h=n.readSync(o.dataId),{selectedIndices:d,validOutputs:p}=zF(c,h,i,a,u,l);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},jF=Mb,HF={kernelName:Tm,backendName:"webgl",kernelFunc:function(e){Kw("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:o}=t,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=r,c=n.readSync(s.dataId),h=n.readSync(o.dataId),d=i,p=a,f=u,m=l,{selectedIndices:g,selectedScores:y}=jF(c,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class GF{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const qF={kernelName:Nm,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{depth:o,onValue:i,offValue:a}=r,u=Sp(s.shape),l=new GF(u,o,i,a),c=P$({inputs:{x:s},backend:n,attrs:{shape:[u]}}),h=n.runWebGLProgram(l,[c],s.dtype);n.disposeIntermediateTensorInfo(c);const d=P$({inputs:{x:h},backend:n,attrs:{shape:[...s.shape,o]}});return n.disposeIntermediateTensorInfo(h),d}};function KF(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=KR({inputs:{input:r},backend:n}),t=KF({inputs:{x:e},backend:n}),s=lA({inputs:{input:r},backend:n}),o=KF({inputs:{x:s},backend:n}),i=v$({inputs:{real:t,imag:o},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),i}return gO({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const XF={kernelName:wg,backendName:"webgl",kernelFunc:KF},YF={kernelName:Im,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const t=KR({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),o=lA({inputs:{input:s},backend:r}),i=KF({inputs:{x:o},backend:r}),a=v$({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(i),a}return gO({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:r})}},QF={kernelName:$m,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return aO({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const o=t[0].shape,i=t[0].dtype;t.forEach(e=>{_p(o,e.shape,"All tensors passed to stack must have matching shapes"),Cp(i===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=dA({inputs:t.map(e=>{const t=aO({inputs:{input:e},backend:n,attrs:{dim:s}});return a.push(t),t}),backend:n,attrs:{axis:s}});return a.forEach(e=>n.disposeIntermediateTensorInfo(e)),u}};class ZF{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,s=aI(r),o=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),a=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${s} start = ${s}(${o});\n      ${s} end = ${s}(${i});\n      uniform float value;\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${s} coords = outC - start;\n          setOutput(getX(${a}));\n        }\n      }\n    `:`\n        int start = ${o};\n        int end = ${i};\n        uniform float value;\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}class JF{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,s=aI(r),o=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),a=e$("rc",r),u=e$("source",r),l=`${a[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${u.slice(-2).join()})`,h=[`${s} rc = outputLoc;`,`${a[r-1]} += 1;\n       if(${l}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${a[r-2]} += 1;\n       if(${a[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${a[r-1]} += 1;\n         if(${l}) {`],d=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===r?2:4;f<m;f++)p+=`\n        ${h[f]}\n        if (${d}) {\n          result[${f}] = float(value);\n        } else {\n          ${s} source = rc - start;\n          result[${f}] = getChannel(getX(${u.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${s} start = ${s}(${o});\n      const ${s} end = ${s}(${i});\n      uniform float value;\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}getCustomSetupFunc(e){return(t,n)=>{null==this.valueLoc&&(this.valueLoc=t.getUniformLocationNoThrow(n,"value")),t.gl.uniform1f(this.valueLoc,e)}}}const eD=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:o,constantValue:i}=r,a=ef().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new JF(s.shape,o,i):new ZF(s.shape,o,i),u=a.getCustomSetupFunc(i);return n.runWebGLProgram(a,[s],s.dtype,u)},tD={kernelName:Rm,backendName:"webgl",kernelFunc:eD},nD={kernelName:"Pow",backendName:"webgl",kernelFunc:N$({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"})},rD={kernelName:Om,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:o,keepDims:i}=r,a=s.shape.length,u=[],l=Ap(o,s.shape);let c=l;const h=gv(c,a);let d,p=s;if(null!=h&&(p=G$({inputs:{x:s},backend:n,attrs:{perm:h}}),c=xv(c.length,a),u.push(p)),mv("prod",c,a),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:r,outDtype:s}=PN(p.shape,p.dtype,e,c);d=n.makeTensorInfo(r,s,t)}else{const[e,t]=pv(p.shape,c),r=Sp(t),o=P$({inputs:{x:p},backend:n,attrs:{shape:[-1,r]}}),i=V$(o,vy(s.dtype),"prod",n);d=P$({inputs:{x:i},backend:n,attrs:{shape:e}}),u.push(o),u.push(i)}if(i){u.push(d);const e=fv(d.shape,l);d=P$({inputs:{x:d},backend:n,attrs:{shape:e}})}return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),d}},sD=e=>{const{backend:t,attrs:n}=e,{start:r,stop:s,step:o,dtype:i}=n,a=MN(r,s,o,i);return t.makeTensorInfo([a.length],i,a)},oD={kernelName:Fm,backendName:"webgl",kernelFunc:sD},iD=I$({opSnippet:"return 1.0 / x;"}),aD={kernelName:Pm,backendName:"webgl",kernelFunc:iD},uD=I$({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),lD={kernelName:Mm,backendName:"webgl",kernelFunc:uD},cD=I$({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),hD={kernelName:Um,backendName:"webgl",kernelFunc:cD};class dD{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[o,i,a,u]=e;this.outputShape=[o,t,n,u];const l=[r&&t>1?i-1:i,r&&n>1?a-1:a],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${a}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class pD{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,i,a,u]=e;this.outputShape=[o,t,n,u];const l=[r&&t>1?i-1:i,r&&n>1?a-1:a],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${a}.0,\n                                     ${a}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const fD={kernelName:Vm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:o,halfPixelCenters:i,size:a}=r,[u,l]=a,c=ef().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new pD(s.shape,u,l,o,i):new dD(s.shape,u,l,o,i);return n.runWebGLProgram(c,[s],"float32")}};class mD{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,o,i]=e,a=[n&&o>1?r-1:r,n&&i>1?s-1:s],u=[n&&o>1?o-1:o,n&&i>1?i-1:i],l=a[0]/u[0],c=a[1]/u[1],h=1/l,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const gD={kernelName:"ResizeBilinearGrad",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:o}=t,{alignCorners:i}=r,a=new mD(o.shape,s.shape,i);return n.runWebGLProgram(a,[o],o.dtype)}};class yD{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[o,i,a,u]=e;this.outputShape=[o,t,n,u];const l=[r&&t>1?i-1:i,r&&n>1?a-1:a],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${a}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${r?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class xD{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,i,a,u]=e;this.outputShape=[o,t,n,u];const l=[r&&t>1?i-1:i,r&&n>1?a-1:a],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let h;h=s?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${l[0]/c[0]},\n          ${l[1]/c[1]},\n          ${l[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${a}.0,\n                                     ${a}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${r?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const bD={kernelName:Bm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:o,halfPixelCenters:i,size:a}=r,[u,l]=a,c=ef().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new xD(s.shape,u,l,o,i):new yD(s.shape,u,l,o,i);return n.runWebGLProgram(c,[s],s.dtype)}};class vD{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,o,i]=e,a=[n&&o>1?r-1:r,n&&i>1?s-1:s],u=[n&&o>1?o-1:o,n&&i>1?i-1:i],l=a[0]/u[0],c=a[1]/u[1],h=1/l,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${l});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${a[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${a[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const wD={kernelName:"ResizeNearestNeighborGrad",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:o}=t,{alignCorners:i}=r,a=new vD(o.shape,s.shape,i);return n.runWebGLProgram(a,[o],o.dtype)}};class CD{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r)).join(","),s=aI(n);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class _D{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=e$("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,o=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=aI(n);function a(n){const r=e.map((r,s)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(s,n));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${s}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return a(e)}(r.slice())};\n          if(${s}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",a(e)}(r.slice())};\n          }\n          if(${o}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",a(e)}(r.slice())};\n            if(${s}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",a(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const kD={kernelName:zm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:o}=r,i=s.shape.length,a=Ap(o,s.shape);if(0===i)return x$({inputs:{x:s},backend:n});const u=ef().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new _D(s.shape,a):new CD(s.shape,a);return n.runWebGLProgram(u,[s],s.dtype)}};class ED{constructor(e,t){this.variableNames=["Image"],this.outputShape=[];const n=e[1],r=e[2];this.outputShape=e;let s="";s="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        uniform vec4 params;\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${s}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}getCustomSetupFunc(e,t,n,r){return(s,o)=>{null==this.paramsLoc&&(this.paramsLoc=s.getUniformLocationNoThrow(o,"params")),s.gl.uniform4f(this.paramsLoc,e,t,n,r)}}}const SD={kernelName:kg,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:o,center:i}=t,a=n,u=new ED(r.shape,o),[l,c]=$w(i,r.shape[1],r.shape[2]),h=u.getCustomSetupFunc(l,c,Math.sin(s),Math.cos(s));return a.runWebGLProgram(u,[r],r.dtype,h)}},TD=I$({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),ID={kernelName:Wm,backendName:"webgl",kernelFunc:TD},ND=I$({opSnippet:"return inversesqrt(x);",cpuKernelImpl:LN}),$D={kernelName:jm,backendName:"webgl",kernelFunc:ND};class RD{constructor(e,t,n,r,s,o,i=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const a=aI(s.length),u=aI(o.length);let l="";1===n?l="i":2===n&&(l="i, j");let c="";1===r?c="i":2===r&&(c="i, coords[1]"),this.userCode=`\n        ${a} strides = ${a}(${s});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(getIndices(${l}));\n              flattenedIndex += index * ${t>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${c});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}}const AD={kernelName:Hm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:o}=t,{shape:i}=r,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:h}=Bw(0,s,i),d=[h/l,l];if(0===h)return n.makeTensorInfo(i,s.dtype);const p=P$({inputs:{x:s},backend:n,attrs:{shape:[u,a]}}),f=P$({inputs:{x:o},backend:n,attrs:{shape:[u,l]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g=new RD(u,a,p.shape.length,f.shape.length,c,d),y=n.runWebGLProgram(g,[f,p,m],f.dtype),x=P$({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),x}};class OD{constructor(e,t,n){let r,s;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)s="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&o.push(`${n[r]}`);r=o.join(),s=i.join()}const o=aI(n);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${s}));\n        } else {\n          setOutput(getB(${s}));\n        }\n      }\n    `}}const FD={kernelName:Gm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:o}=t,i=new OD(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,o],by(s.dtype,o.dtype))}},DD=I$({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${Vw};\n  float scale = ${Uw};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),PD={kernelName:qm,backendName:"webgl",kernelFunc:DD},MD=I$({opSnippet:"return 1.0 / (1.0 + exp(-1.0 * x));"}),LD={kernelName:Qm,backendName:"webgl",kernelFunc:MD},BD=I$({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),VD={kernelName:Ym,backendName:"webgl",kernelFunc:BD},UD={kernelName:"Sin",backendName:"webgl",kernelFunc:I$({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"})},zD=I$({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),WD={kernelName:Xm,backendName:"webgl",kernelFunc:zD},jD=I$({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),HD={kernelName:Zm,backendName:"webgl",kernelFunc:jD},GD={kernelName:eg,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:o,paddings:i}=r;Cp(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((e,t)=>e*t),u=[[0,0]];u.push(...i);for(let y=1+o.length;y<s.shape.length;++y)u.push([0,0]);const l=[],c=eD({inputs:{x:s},backend:n,attrs:{paddings:u,constantValue:0}}),h=Rw(c.shape,o,a,!1),d=Aw(h.length,o.length,!1),p=Ow(c.shape,o,a,!1),f=P$({inputs:{x:c},backend:n,attrs:{shape:h}}),m=G$({inputs:{x:f},backend:n,attrs:{perm:d}}),g=P$({inputs:{x:m},backend:n,attrs:{shape:p}});return l.push(c),l.push(f),l.push(m),l.forEach(e=>n.disposeIntermediateTensorInfo(e)),g}},qD={kernelName:rg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:o,defaultValue:i}=t;if(1!==o.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${o.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const a=n.readSync(r.dataId),u=n.readSync(s.dataId),l=n.readSync(o.dataId),c=n.readSync(i.dataId)[0],[h,d,p,f,m]=UN(a,r.shape,r.dtype,u,s.dtype,l,c);return[n.makeTensorInfo(d,r.dtype,h),n.makeTensorInfo([d[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}},KD={kernelName:sg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:o}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==o.shape.length)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(n.readSync(s.dataId)),a=n.readSync(r.dataId),u=Array.from(n.readSync(o.dataId)),[l,c,h]=zN(a,r.shape,r.dtype,i,u);return[n.makeTensorInfo(c,r.dtype,l),n.makeTensorInfo([h.length],o.dtype,new Int32Array(h))]}},XD={kernelName:og,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${o.shape}`);const i=n.readSync(r.dataId),a=n.readSync(s.dataId),u=n.readSync(o.dataId),[l,c]=WN(i,r.shape,r.dtype,a,u,!0);return n.makeTensorInfo(c,r.dtype,l)}},YD={kernelName:ig,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:o}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==o.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${o.shape}`);const i=n.readSync(r.dataId),a=n.readSync(s.dataId),u=n.readSync(o.dataId),[l,c]=WN(i,r.shape,r.dtype,a,u);return n.makeTensorInfo(c,r.dtype,l)}},QD={kernelName:ag,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:o,defaultValue:i}=t,{outputShape:a}=r,{sliceRank:u,numUpdates:l,strides:c,outputSize:h}=Bw(0,s,a),d=new RD(l,u,s.shape.length,o.shape.length,c,[h,1],!1),p=n.runWebGLProgram(d,[o,s,i],o.dtype),f=P$({inputs:{x:p},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(p),f}},ZD={kernelName:tg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:o,axis:i}=r,a=Ap(i,s.shape)[0],u=hC(s,o,a),l=new Array(s.shape.length).fill(0),c=s.shape.slice();return u.map(e=>{const t=[...c];t[a]=e;const r=zR({inputs:{x:s},backend:n,attrs:{begin:l,size:t}});return l[a]+=e,r})}},JD=I$({opSnippet:"return sqrt(x);"}),eP={kernelName:Jm,backendName:"webgl",kernelFunc:JD},tP={kernelName:"Square",backendName:"webgl",kernelFunc:I$({opSnippet:"return x * x;"})},nP="return (a - b) * (a - b);",rP=N$({opSnippet:nP,packedOpSnippet:nP}),sP={kernelName:ug,backendName:"webgl",kernelFunc:rP},oP={kernelName:Cg,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:r}=e,s=new a$(r.shape,`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `);return n.runWebGLProgram(s,[r],r.dtype)}};class iP{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,s=aI(n.length),o=aI(n.length);let i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`)).join(",")}this.userCode=`\n      ${s} begin = ${s}(${e});\n      ${s} strides = ${s}(${t});\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}const aP={kernelName:lg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:o,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r,{nonStrided:p,$begin:f,$strides:m,size:g,newShape:y,outShape:x}=Kx(s.shape,o,i,a,u,l,c,h,d),b=P$({inputs:{x:s},backend:n,attrs:{shape:y}});let v;if(p){const e=zR({inputs:{x:b},backend:n,attrs:{begin:f,size:g}});v=P$({inputs:{x:e},backend:n,attrs:{shape:x}}),n.disposeIntermediateTensorInfo(e)}else if(x.some(e=>0===e))v=n.makeTensorInfo(x,s.dtype,[]);else if(n.shouldExecuteOnCPU([b])){const e=n.texData.get(b.dataId),t=xx(b.shape,b.dtype,e.values),r=jN(x,t,m,f);v=n.makeTensorInfo(x,b.dtype,r.values)}else{const e=new iP(f,m,x);v=n.runWebGLProgram(e,[b],b.dtype)}const w=P$({inputs:{x:v},backend:n,attrs:{shape:x}});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(v),w}},uP={kernelName:cg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:l}=r,{data:c,dataSplits:h}=t,d=n.readSync(c.dataId),p=n.readSync(h.dataId),[f,m]=HN(d,p,s,o,i,a,u,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}},lP={kernelName:hg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:o,delimiter:i}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(1!==o.shape.length)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=n.readSync(o.dataId),u=n.readSync(i.dataId)[0],[l,c,h]=GN(a,u,s),d=c.length;return[n.makeTensorInfo([d,2],"int32",l),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}},cP={kernelName:dg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:o}=t;if("string"!==o.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(o.dataId),a=qN(i,s);return n.makeTensorInfo(o.shape,"int32",a)}},hP={kernelName:"Tan",backendName:"webgl",kernelFunc:I$({opSnippet:"return tan(x);"})},dP=I$({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),pP={kernelName:fg,backendName:"webgl",kernelFunc:dP};class fP{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[o]*t[o];this.outputShape=n,this.rank=n.length;const r=aI(this.rank),s=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<e.length;s++)r.push(`imod(${n[s]}, ${e[s]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}function mP(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:o}=r;if("string"===s.dtype||s.shape.length>5){const e=n.readSync(s.dataId),t="string"===s.dtype?e.map(e=>Jg(e)):e,r=xx(s.shape,s.dtype,t),i=XN(r,o);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new fP(s.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}const gP={kernelName:mg,backendName:"webgl",kernelFunc:mP},yP={kernelName:gg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:o,sorted:i}=r,a=n.readSync(s.dataId),[u,l]=YN(a,s.shape,s.dtype,o,i);return[n.makeTensorInfo(u.shape,u.dtype,u.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}};class xP{constructor(e,t,n,r,s,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const i="nearest"===n?1:2;let a;switch(r){case"constant":a=1;break;case"reflect":a=2;break;case"wrap":a=3;break;case"nearest":a=4;break;default:a=1}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${a} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${a} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${a} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${s});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${s});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const bP={kernelName:yg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:o}=t,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=r,[c,h,d,p]=s.shape,[f,m]=null!=l?l:[h,d],g=new xP(h,d,i,a,u,[c,f,m,p]);return n.runWebGLProgram(g,[s,o],"float32")}},vP={kernelName:bg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:o}=t;AT(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(o.dataId),{outputValues:a,outputShape:u,indices:l}=ZN(i,s,o.shape,o.dtype);return[r.makeTensorInfo(u,o.dtype,a),r.makeTensorInfo([l.length],"int32",l)]}},wP={kernelName:vg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s,a=i.shape.length,u=s.shape[o],l=new Array(a-1);let c=0;for(let m=0;m<a;m++)m!==o&&(l[c++]=i.shape[m]);const h=[],d=new Array(a).fill(0),p=i.shape.slice();p[o]=1;const f=new Array(u);for(let m=0;m<f.length;m++){d[o]=m;const e=zR({inputs:{x:i},backend:n,attrs:{begin:d,size:p}}),t=P$({inputs:{x:e},backend:n,attrs:{shape:l}});f[m]=t,h.push(e)}return h.forEach(e=>n.disposeIntermediateTensorInfo(e)),f}};class CP{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,s=e.inSize,o=e.numSegments,i=o*Math.ceil(s/n);this.outputShape=[r,i];const a=4*Math.floor(n/4),u=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let c="";s%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `);let h="";s%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${o})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${o})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${l}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${l}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}const _P=[aF,lF,X$,Q$,J$,tR,sR,aR,uR,lR,mR,gR,xR,vR,kR,CR,SR,$R,NR,OR,FR,DR,LR,jR,HR,YR,JR,nA,oA,w$,pA,kA,EA,bA,TA,IA,SA,NA,RA,OA,MA,LA,VA,GA,qA,WA,XA,QA,ZA,JA,eO,nO,rO,iO,uO,hO,fO,yO,bO,CO,kO,TO,NO,$O,AO,FO,PO,LO,b$,BO,cA,VO,UO,WO,k$,HO,qO,KO,ZO,YO,eF,nF,sF,hF,mF,fF,xF,bF,vF,pF,wF,CF,kF,TF,IF,MF,D$,BF,UF,WF,HF,qR,qF,YF,QF,tD,nD,T$,rD,oD,XR,RF,aD,hD,lD,M$,fD,gD,bD,wD,kD,SD,ID,$D,AD,FD,PD,LD,VD,UD,WD,WR,PF,HD,GD,qD,KD,XD,YD,QD,ZD,eP,tP,sP,oP,aP,uP,lP,cP,FF,H$,hP,pP,gP,yP,bP,q$,vP,wP,{kernelName:"UnsortedSegmentSum",backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:o}=t,{numSegments:i}=r,a=s.shape.length,u=[];let l=0;const c=gv([l],a);let h=s;null!=c&&(h=G$({inputs:{x:s},backend:n,attrs:{perm:c}}),u.push(h),l=xv(1,a)[0]);const d=pC(h.shape,l,i),p=Sp([h.shape[l]]),f=P$({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});u.push(f);const m=vy(s.dtype),g=(e,t,r,s,o)=>{const i=e.shape[0],a=e.shape[1],l=dC(a,o),c=new CP({windowSize:l,inSize:a,batchSize:i,numSegments:o},t),h=n.compileAndRun(c,[e,r],s);if(u.push(h),h.shape[1]===o)return h;const d=sD({backend:n,attrs:{start:0,stop:o,step:1,dtype:"float32"}}),p=mP({inputs:{x:d},backend:n,attrs:{reps:[a/l]}});return u.push(d),u.push(p),g(h,t,p,s,o)},y=P$({inputs:{x:g(f,"unsortedSegmentSum",o,m,i)},backend:n,attrs:{shape:d}});let x=y;if(null!=c){u.push(y);const e=yv(c);x=G$({inputs:{x:x},backend:n,attrs:{perm:e}})}return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),x}},XF];for(const QP of _P)Og(QP);class kP extends F{constructor(e,t){super()}schedule(e,t=0){return this}}let EP=(()=>{class e{constructor(t,n=e.now){this.SchedulerAction=t,this.now=n}schedule(e,t=0,n){return new this.SchedulerAction(this,e).schedule(n,t)}}return e.now=()=>Date.now(),e})();class SP extends EP{constructor(e,t=EP.now){super(e,()=>SP.delegate&&SP.delegate!==this?SP.delegate.now():t()),this.actions=[],this.active=!1,this.scheduled=void 0}schedule(e,t=0,n){return SP.delegate&&SP.delegate!==this?SP.delegate.schedule(e,t,n):super.schedule(e,t,n)}flush(e){const{actions:t}=this;if(this.active)return void t.push(e);let n;this.active=!0;do{if(n=e.execute(e.state,e.delay))break}while(e=t.shift());if(this.active=!1,n){for(;e=t.shift();)e.unsubscribe();throw n}}}const TP=new SP(class extends kP{constructor(e,t){super(e,t),this.scheduler=e,this.work=t,this.pending=!1}schedule(e,t=0){if(this.closed)return this;this.state=e;const n=this.id,r=this.scheduler;return null!=n&&(this.id=this.recycleAsyncId(r,n,t)),this.pending=!0,this.delay=t,this.id=this.id||this.requestAsyncId(r,this.id,t),this}requestAsyncId(e,t,n=0){return setInterval(e.flush.bind(e,this),n)}recycleAsyncId(e,t,n=0){if(null!==n&&this.delay===n&&!1===this.pending)return t;clearInterval(t)}execute(e,t){if(this.closed)return new Error("executing a cancelled action");this.pending=!1;const n=this._execute(e,t);if(n)return n;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(e,t){let n,r=!1;try{this.work(e)}catch(s){r=!0,n=!!s&&s||new Error(s)}if(r)return this.unsubscribe(),n}_unsubscribe(){const e=this.id,t=this.scheduler,n=t.actions,r=n.indexOf(this);this.work=null,this.state=null,this.pending=!1,this.scheduler=null,-1!==r&&n.splice(r,1),null!=e&&(this.id=this.recycleAsyncId(t,e,null)),this.delay=null}});class IP{constructor(e,t,n){this.kind=e,this.value=t,this.error=n,this.hasValue="N"===e}observe(e){switch(this.kind){case"N":return e.next&&e.next(this.value);case"E":return e.error&&e.error(this.error);case"C":return e.complete&&e.complete()}}do(e,t,n){switch(this.kind){case"N":return e&&e(this.value);case"E":return t&&t(this.error);case"C":return n&&n()}}accept(e,t,n){return e&&"function"==typeof e.next?this.observe(e):this.do(e,t,n)}toObservable(){switch(this.kind){case"N":return Sl(this.value);case"E":return e=this.error,new U(t=>t.error(e));case"C":return Ml()}var e;throw new Error("unexpected notification kind value")}static createNext(e){return void 0!==e?new IP("N",e):IP.undefinedValueNotification}static createError(e){return new IP("E",void 0,e)}static createComplete(){return IP.completeNotification}}function NP(e,t=TP){var n;const r=(n=e)instanceof Date&&!isNaN(+n)?+e-t.now():Math.abs(e);return e=>e.lift(new $P(r,t))}IP.completeNotification=new IP("C"),IP.undefinedValueNotification=new IP("N",void 0);class $P{constructor(e,t){this.delay=e,this.scheduler=t}call(e,t){return t.subscribe(new RP(e,this.delay,this.scheduler))}}class RP extends M{constructor(e,t,n){super(e),this.delay=t,this.scheduler=n,this.queue=[],this.active=!1,this.errored=!1}static dispatch(e){const t=e.source,n=t.queue,r=e.scheduler,s=e.destination;for(;n.length>0&&n[0].time-r.now()<=0;)n.shift().notification.observe(s);if(n.length>0){const t=Math.max(0,n[0].time-r.now());this.schedule(e,t)}else this.unsubscribe(),t.active=!1}_schedule(e){this.active=!0,this.destination.add(e.schedule(RP.dispatch,this.delay,{source:this,destination:this.destination,scheduler:e}))}scheduleNotification(e){if(!0===this.errored)return;const t=this.scheduler,n=new AP(t.now()+this.delay,e);this.queue.push(n),!1===this.active&&this._schedule(t)}_next(e){this.scheduleNotification(IP.createNext(e))}_error(e){this.errored=!0,this.queue=[],this.destination.error(e),this.unsubscribe()}_complete(){this.scheduleNotification(IP.createComplete()),this.unsubscribe()}}class AP{constructor(e,t){this.time=e,this.notification=t}}function OP(e=-1){return t=>0===e?Ml():t.lift(new FP(e<0?-1:e-1,t))}class FP{constructor(e,t){this.count=e,this.source=t}call(e,t){return t.subscribe(new DP(e,this.count,this.source))}}class DP extends M{constructor(e,t,n){super(e),this.count=t,this.source=n}complete(){if(!this.isStopped){const{source:e,count:t}=this;if(0===t)return super.complete();t>-1&&(this.count=t-1),e.subscribe(this._unsubscribeAndRecycle())}}}const PP=["webcam"],MP=["canvas"];function LP(e,t){1&e&&(Io(0,"div",11),Io(1,"div",12),Io(2,"span",13),qo(3,"Loading..."),No(),No(),Io(4,"span"),qo(5,"Loading MoveNet ..."),No(),No())}function BP(e,t){if(1&e&&(Io(0,"div"),Io(1,"p"),qo(2),No(),No()),2&e){const e=function(e=1){return function(e){return(Wt.lFrame.contextLView=function(e,t){for(;e>0;)t=t[15],e--;return t}(e,Wt.lFrame.contextLView))[8]}(e)}();ds(2),Ko("Right wrist pose: (",null==e.wristPose||null==e.wristPose.x?null:e.wristPose.x.toFixed(4),",",null==e.wristPose||null==e.wristPose.y?null:e.wristPose.y.toFixed(4),"), score: ",null==e.wristPose||null==e.wristPose.score?null:e.wristPose.score.toFixed(4),"")}}const VP=function(e){return{"visually-hidden":e}},UP=10,zP=3/4*Math.PI,WP=5/4*Math.PI,jP="white";var HP=(()=>(function(e){e[e.COMPUTER=0]="COMPUTER",e[e.HUMAN=1]="HUMAN"}(HP||(HP={})),HP))();const GP=[{path:"",component:(()=>{class e{constructor(){this.pointsComputer=0,this.pointsPlayer=0,this.paddleYComputer=.5,this.ballPosition={x:.5,y:.5},this.ballDirection={x:.46,y:-.89}}ngAfterViewInit(){var e=this;return mp(function*(){e.context=e.canvas.nativeElement.getContext("2d");const t={modelType:"SinglePose.Lightning",enableSmoothing:!0};e.detector=yield function(e,t){return pE(this,void 0,void 0,function(){var n,r;return fE(this,function(s){switch(e){case XE.PoseNet:return[2,eT(t)];case XE.BlazePose:if(r=void 0,null!=(n=t)){if("tfjs"===n.runtime)return[2,hS(t)];if("mediapipe"===n.runtime)return[2,_E(t)];r=n.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' or 'mediapipe', but got "+r);case XE.MoveNet:return[2,xS(t)];default:throw new Error(e+" is not a supported model name.")}})})}(XE.MoveNet,t);const n=e.webcam.nativeElement;if(navigator.mediaDevices.getUserMedia)try{const e=yield navigator.mediaDevices.getUserMedia({video:!0});n.srcObject=e}catch(YP){alert("You should enable access to webcam to use this app.")}else alert("You should have a working webcam to use this app.");n.addEventListener("loadeddata",()=>{const t=Sl({}).pipe(he(e.updatePaddle.bind(e)),NP(30),OP()),n=Sl({}).pipe(he(e.updateGameState.bind(e)),NP(20),OP());t.subscribe(),n.subscribe()})})()}get canvasWidth(){return this.canvas.nativeElement.width}get canvasHeight(){return this.canvas.nativeElement.height}getCanvasPointX(e){return Math.floor(this.canvasWidth*e)}getCanvasPointY(e){return Math.floor(this.canvasHeight*e)}drawBall(e,t){this.context.beginPath(),this.context.arc(this.getCanvasPointX(e),this.getCanvasPointY(t),UP,0,2*Math.PI),this.context.fillStyle="red",this.context.fill()}drawPaddle(e,t){this.context.beginPath(),this.context.fillStyle="white",this.context.fillRect(t==HP.HUMAN?this.canvasWidth-20-10:20,this.getCanvasPointY(e)-35,10,70)}drawScores(){this.context.font="96px VT323",this.context.fillStyle=jP,this.context.textAlign="center",this.context.fillText(this.pointsComputer.toString(),this.canvasWidth/4,75),this.context.fillText(this.pointsPlayer.toString(),this.canvasWidth/4*3,75)}drawHalfLine(){this.context.strokeStyle=jP,this.context.beginPath(),this.context.setLineDash([5,15]),this.context.moveTo(this.canvasWidth/2,0),this.context.lineTo(this.canvasWidth/2,this.canvasHeight),this.context.stroke()}detectRightWristPose(){var e=this;return mp(function*(){const t=e.webcam.nativeElement,n=yield e.detector.estimatePoses(t,{maxPoses:1,flipHorizontal:!1});return tT.keypointsToNormalizedKeypoints(n[0].keypoints,{width:t.videoWidth,height:t.videoHeight}).find(e=>"right_wrist"===e.name)})()}getNormalizedPosition(e){if(e)return e.y=e.y<.25?0:e.y>.98?1:(e.y-.25)/.73,e}moveBall(){this.ballPosition={x:this.ballPosition.x+this.ballDirection.x/30,y:this.ballPosition.y+this.ballDirection.y/30}}rotateVector(e,t){return e.x=Math.cos(t)*e.x-Math.sin(t)*e.y,e.y=Math.sin(t)*e.x+Math.cos(t)*e.y,e}updatePaddle(){var e=this;return mp(function*(){const t=e.getNormalizedPosition(yield e.detectRightWristPose());e.wristPose||(e.wristPose=t);let n=0;t&&e.wristPose&&(n=Math.abs(t.y-e.wristPose.y)),t&&t.score&&t.score>=.275&&n>=.01&&(e.wristPose=t)})()}updateGameState(){var e=this;return mp(function*(){var t;const n=e.getCanvasPointX(e.ballPosition.x),r=e.getCanvasPointY(e.ballPosition.y),s=e.getCanvasPointY(e.paddleYComputer),o=e.getCanvasPointY((null===(t=e.wristPose)||void 0===t?void 0:t.y)||.5),i=e.ballDirection.x<0&&r>=s-35&&r<=s+35&&n-UP<=30;if(i||e.ballDirection.x>0&&r>=o-35&&r<=o+35&&n+UP>=e.canvasWidth-20-10){const t=zP+(r-((i?s:o)-35))/70*(WP-zP);e.ballDirection=e.rotateVector({x:Math.sign(e.ballDirection.x),y:0},i?2*Math.PI-t:t)}e.getCanvasPointX(e.ballPosition.x)<=UP?(e.pointsComputer++,e.ballPosition.x=.5,e.ballPosition.y=.5,e.ballDirection.x=1,e.ballDirection.y=0):e.getCanvasPointX(e.ballPosition.x)>=e.canvasHeight-UP&&(e.pointsPlayer++,e.ballPosition.x=.5,e.ballPosition.y=.5,e.ballDirection.x=-1,e.ballDirection.y=0),(e.getCanvasPointY(e.ballPosition.y)<=UP||e.getCanvasPointY(e.ballPosition.y)>=e.canvasHeight-UP)&&(e.ballDirection.y=-e.ballDirection.y),e.paddleYComputer=e.ballPosition.y,e.clearCanvas(),e.drawHalfLine(),e.drawScores(),e.moveBall(),e.drawBall(e.ballPosition.x,e.ballPosition.y),e.drawPaddle(e.paddleYComputer,HP.COMPUTER),e.wristPose&&e.drawPaddle(e.wristPose.y,HP.HUMAN)})()}clearCanvas(){this.context.clearRect(0,0,this.canvasWidth,this.canvasHeight)}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=ut({type:e,selectors:[["app-pong"]],viewQuery:function(e,t){if(1&e&&(va(PP,5),va(MP,5)),2&e){let e;ba(e=wa())&&(t.webcam=e.first),ba(e=wa())&&(t.canvas=e.first)}},decls:12,vars:6,consts:[[1,"container-fluid","m-2"],[1,"row","text-center"],["class","col-md-12 d-flex align-items-center justify-content-center",4,"ngIf"],[1,"row"],[1,"col-md-6","d-flex","align-items-center","justify-content-center"],["id","pong-field","width","600","height","600"],["canvas",""],[1,"webcam-info"],["autoplay","","playsinline","","muted","","id","webcam","width","300","height","300"],["webcam",""],[4,"ngIf"],[1,"col-md-12","d-flex","align-items-center","justify-content-center"],["role","status",1,"spinner-border","spinner-border-sm","m-2","text-primary"],[1,"visually-hidden"]],template:function(e,t){1&e&&(Io(0,"div",0),Io(1,"div",1),ko(2,LP,6,0,"div",2),No(),Io(3,"div",3),Io(4,"div",4),$o(5,"canvas",5,6),No(),Io(7,"div",4),Io(8,"div",7),$o(9,"video",8,9),ko(11,BP,3,3,"div",10),No(),No(),No(),No()),2&e&&(ds(2),So("ngIf",!t.wristPose),ds(1),function(e,t,n,r){const s=Gt(),o=Jt(2);s.firstUpdatePass&&function(e,t,n,r){const s=e.data;if(null===s[n+1]){const o=s[pn()],i=Vo(e,n);Go(o,r)&&null===t&&!i&&(t=!1),t=function(e,t,n,r){const s=function(e){const t=Wt.lFrame.currentDirectiveIndex;return-1===t?null:e[t]}(e);let o=t.residualClasses;if(null===s)0===t.classBindings&&(n=zo(n=Uo(null,e,t,n,r),t.attrs,r),o=null);else{const i=t.directiveStylingLast;if(-1===i||e[i]!==s)if(n=Uo(s,e,t,n,r),null===o){let n=function(e,t,n){const r=t.classBindings;if(0!==ys(r))return e[ms(r)]}(e,t);void 0!==n&&Array.isArray(n)&&(n=Uo(null,e,t,n[1],r),n=zo(n,t.attrs,r),function(e,t,n,r){e[ms(t.classBindings)]=r}(e,t,0,n))}else o=function(e,t,n){let r;const s=t.directiveEnd;for(let o=1+t.directiveStylingLast;o<s;o++)r=zo(r,e[o].hostAttrs,!0);return zo(r,t.attrs,!0)}(e,t)}return void 0!==o&&(t.residualClasses=o),n}(s,o,t,r),function(e,t,n,r,s,o){let i=t.classBindings,a=ms(i),u=ys(i);e[r]=n;let l,c=!1;if(Array.isArray(n)){const e=n;l=e[1],(null===l||ar(e,l)>0)&&(c=!0)}else l=n;if(s)if(0!==u){const t=ms(e[a+1]);e[r+1]=fs(t,a),0!==t&&(e[t+1]=xs(e[t+1],r)),e[a+1]=131071&e[a+1]|r<<17}else e[r+1]=fs(a,0),0!==a&&(e[a+1]=xs(e[a+1],r)),a=r;else e[r+1]=fs(u,0),0===a?a=r:e[u+1]=xs(e[u+1],r),u=r;c&&(e[r+1]=gs(e[r+1])),Oo(e,l,r,!0),Oo(e,l,r,!1),function(e,t,n,r,s){const o=e.residualClasses;null!=o&&"string"==typeof t&&ar(o,t)>=0&&(n[r+1]=bs(n[r+1]))}(t,l,e,r),i=fs(a,u),t.classBindings=i}(s,o,t,n,i)}}(s,null,o,r);const i=Ht();if(n!==hs&&Co(i,o,n)){const a=s.data[pn()];if(Go(a,r)&&!Vo(s,o)){let e=a.classesWithoutHost;null!==e&&(n=_e(e,n||"")),To(s,a,i,n,r)}else!function(e,t,n,r,s,o,i,a){s===hs&&(s=Je);let u=0,l=0,c=0<s.length?s[0]:null,h=0<o.length?o[0]:null;for(;null!==c||null!==h;){const i=u<s.length?s[u+1]:void 0,d=l<o.length?o[l+1]:void 0;let p,f=null;c===h?(u+=2,l+=2,i!==d&&(f=h,p=d)):null===h||null!==c&&c<h?(u+=2,f=c):(l+=2,f=h,p=d),null!==f&&Wo(e,t,n,r,f,p,!0,a),c=u<s.length?s[u]:null,h=l<o.length?o[l]:null}}(s,a,i,i[11],i[o+1],i[o+1]=function(e,t,n){if(null==n||""===n)return Je;const r=[],s=function(e){return e instanceof class{constructor(e){this.changingThisBreaksApplicationSecurity=e}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`}}?e.changingThisBreaksApplicationSecurity:e}(n);if(Array.isArray(s))for(let o=0;o<s.length;o++)e(r,s[o],!0);else if("object"==typeof s)for(const o in s)s.hasOwnProperty(o)&&e(r,o,s[o]);else"string"==typeof s&&t(r,s);return r}(e,t,n),0,o)}}(or,Bo,function(e,t,n,r){return function(e,t,n,r,s,o){const i=t+n;return Co(e,i,s)?function(e,t,n){return e[t]=n}(e,i+1,o?r.call(o,s):r(s)):function(e,t){const n=e[t];return n===hs?void 0:n}(e,i+1)}(Ht(),function(){const e=Wt.lFrame;let t=e.bindingRootIndex;return-1===t&&(t=e.bindingRootIndex=e.tView.bindingStartIndex),t}(),e,t,n,r)}(4,VP,!t.wristPose),!0),ds(8),So("ngIf",t.wristPose))},directives:[Wu],styles:["#webcam[_ngcontent-%COMP%]{transform:rotateY(180deg);-webkit-transform:rotateY(180deg);-moz-transform:rotateY(180deg)}#pong-field[_ngcontent-%COMP%]{background:#000}"]}),e})()}];let qP=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=dt({type:e}),e.\u0275inj=Ae({imports:[[op.forRoot(GP)],op]}),e})(),KP=(()=>{class e{constructor(){this.title="pong-posenet"}}return e.\u0275fac=function(t){return new(t||e)},e.\u0275cmp=ut({type:e,selectors:[["app-root"]],decls:1,vars:0,template:function(e,t){1&e&&$o(0,"router-outlet")},directives:[Xd],styles:[""]}),e})(),XP=(()=>{class e{}return e.\u0275fac=function(t){return new(t||e)},e.\u0275mod=dt({type:e,bootstrap:[KP]}),e.\u0275inj=Ae({providers:[],imports:[[El,qP]]}),e})();(function(){if(ru)throw new Error("Cannot enable prod mode after platform setup.");nu=!1})(),_l().bootstrapModule(XP).catch(e=>console.error(e))},410:()=>{},628:()=>{},778:()=>{}},e=>{"use strict";e(e.s=339)}]);